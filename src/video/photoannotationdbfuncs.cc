// ==========================================================================
// Photoannotationdbfunc namespace method definitions
// ==========================================================================
// Last modified on 1/18/11
// ==========================================================================

#include <iostream>
#include "astro_geo/Clock.h"
#include "postgres/gis_database.h"
#include "video/photoannotationdbfuncs.h"
#include "general/stringfuncs.h"
#include "math/twovector.h"

using std::cout;
using std::endl;
using std::string;
using std::vector;

namespace photoannotationdbfunc
{

// ==========================================================================
// Manipulation methods for photo annotations table in TOC database
// ==========================================================================

   bool insert_photo_annotation(
      gis_database* gis_database_ptr,int fieldtest_ID,int photo_ID,
      double secs_since_epoch,string username,string label,
      string description,string color,int importance,double U,double V)
   {
      string curr_insert_command=
         photoannotationdbfunc::generate_insert_photo_annotation_SQL_command(
            fieldtest_ID,photo_ID,secs_since_epoch,
            username,label,description,color,importance,U,V);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);
//      cout << "insert_commands.back() = " << insert_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;
      gis_database_ptr->set_SQL_commands(insert_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_insert_photo_annotation_SQL_command() takes in
// metadata associated with a single photo annotation.  It generates
// and returns a string containing a SQL insert command needed to
// populate a row within the photo_annotations table of the
// TOC database.

   string generate_insert_photo_annotation_SQL_command(
      int fieldtest_ID,int photo_ID,double secs_since_epoch,
      string username,string label,string description,string color,
      int importance,double U,double V)
   {
//   cout << "inside photoannotationdbfunc::generate_insert_photo_annotation_SQL_command()" << endl;

      Clock clock;
      clock.convert_elapsed_secs_to_date(secs_since_epoch);
      string date_str=clock.YYYY_MM_DD_H_M_S();
      
      string SQL_command="insert into photo_annotations ";
      SQL_command += "(fieldtest_ID,photo_ID,creation_time,";
      SQL_command += "username,label,description,color,";
      SQL_command += "importance,uv_posn) ";
      SQL_command += "values( ";
      SQL_command += stringfunc::number_to_string(fieldtest_ID)+",";
      SQL_command += stringfunc::number_to_string(photo_ID)+",";
      SQL_command += "'"+date_str+"',";
      SQL_command += "'"+username+"',";
      SQL_command += "'"+label+"',";
      SQL_command += "'"+description+"',";
      SQL_command += "'"+color+"',";
      SQL_command += stringfunc::number_to_string(importance)+",";
      SQL_command += "'SRID=4326; POINT("
         +stringfunc::number_to_string(U,9)
         +" "+stringfunc::number_to_string(V,9)+")'";
      SQL_command += ");";

      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method get_photo_annotation_ID() takes in username, label and
// description fields.  It returns the integer ID automatically
// generated by the photo_annotations table within the TOC database at
// the time the photo annotation was inserted.  If no photo annotation
// matching the input parameters is found, this method returns -1.

   int get_photo_annotation_ID(
      gis_database* gis_database_ptr,
      string username,string label,string description)
   {
//      cout << "inside photoannotationdbfunc::get_photo_annotation_ID()" << endl;
//      cout << "username = " << username
//           << " label = " << label
//           << " description = " << description << endl;

      string SQL_command="select id from photo_annotations ";
      SQL_command += "WHERE username='"+username+"' ";
      SQL_command += "AND label='"+label+"' ";
      SQL_command += "AND description='"+description+"';";
//      cout << "SQL_command = " << SQL_command << endl;

      Genarray<string>* field_array_ptr=
         gis_database_ptr->select_data(SQL_command);
      if (field_array_ptr==NULL) return -1;

//      cout << "*field_array_ptr = " << *field_array_ptr << endl;

      int annotation_ID=stringfunc::string_to_number(
         field_array_ptr->get(0,0));
//      cout << "annotation_ID = "  << annotation_ID << endl;
      return annotation_ID;
   }

// ---------------------------------------------------------------------   
// Method get_particular_photo_annotations() queries the
// photo_annotations table within the TOC database for all annotations
// associated with a particular photo ID.

   void get_particular_photo_annotations(
      gis_database* gis_database_ptr,int photo_ID,
      vector<int>& annotation_IDs,vector<string>& creation_times,
      vector<string>& usernames,vector<string>& labels,
      vector<string>& descriptions,vector<string>& colors,
      vector<int>& importances,vector<twovector>& UVs)
   {
//      cout << "inside photoannotationdbfunc::get_particular_photo_annotation()" << endl;
//      cout << "photo_ID = " << photo_ID << endl;

      string SQL_command="SELECT id,creation_time,username,";
      SQL_command += "label,description,color,importance,";
      SQL_command += "x(uv_posn),y(uv_posn) from photo_annotations ";
      SQL_command += "WHERE photo_ID="+stringfunc::number_to_string(
         photo_ID)+";";
//      cout << "SQL_command = " << SQL_command << endl;

      Genarray<string>* field_array_ptr=
         gis_database_ptr->select_data(SQL_command);
      if (field_array_ptr==NULL) return;

      unsigned int mdim=field_array_ptr->get_mdim();
//      unsigned int ndim=field_array_ptr->get_ndim();
//      cout << "mdim = " << mdim << " ndim = " << ndim << endl;

      for (unsigned int i=0; i<mdim; i++)
      {
         annotation_IDs.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,0)));
         creation_times.push_back(field_array_ptr->get(i,1));
         usernames.push_back(field_array_ptr->get(i,2));
         labels.push_back(field_array_ptr->get(i,3));
         descriptions.push_back(field_array_ptr->get(i,4));
         colors.push_back(field_array_ptr->get(i,5));
         importances.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,6)));
         double U=stringfunc::string_to_number(
            field_array_ptr->get(i,7));
         double V=stringfunc::string_to_number(
            field_array_ptr->get(i,8));
         UVs.push_back(twovector(U,V));

         cout << "annotation_ID = "  << annotation_IDs.back() << endl;
         cout << "creation_time = " << creation_times.back() << endl;
         cout << "username = " << usernames.back() << endl;
         cout << "label = " << labels.back() << endl;
         cout << "description = " << descriptions.back() << endl;
         cout << "color = " << colors.back() << endl;
         cout << "importance = " << importances.back() << endl;
         cout << "U = " << U << " V = " << V << endl;

      } // loop over index i labeling world annotations
   }

// ---------------------------------------------------------------------   
// Method get_all_photo_annotations()

   void get_all_photo_annotations(
      gis_database* gis_database_ptr,int fieldtest_ID,
      vector<int>& annotation_IDs,vector<string>& creation_times,
      vector<string>& usernames,vector<string>& labels,
      vector<string>& descriptions,vector<string>& colors,
      vector<int>& importances,vector<twovector>& UVs)
   {
//      cout << "inside photoannotationdbfunc::get_all_photo_annotations()" << endl;
//      cout << "fieldtest_ID = " << fieldtest_ID << endl;

      string SQL_command="SELECT id,creation_time,username,";
      SQL_command += "label,description,color,importance,";
      SQL_command += "x(uv_posn),y(uv_posn) from photo_annotations ";
      SQL_command += "WHERE fieldtest_ID="+stringfunc::number_to_string(
         fieldtest_ID)+";";
//      cout << "SQL_command = " << SQL_command << endl;

      Genarray<string>* field_array_ptr=
         gis_database_ptr->select_data(SQL_command);
      if (field_array_ptr==NULL) return;

      unsigned int mdim=field_array_ptr->get_mdim();
//      unsigned int ndim=field_array_ptr->get_ndim();
//      cout << "mdim = " << mdim << " ndim = " << ndim << endl;

      for (unsigned int i=0; i<mdim; i++)
      {
         annotation_IDs.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,0)));
         creation_times.push_back(field_array_ptr->get(i,1));
         usernames.push_back(field_array_ptr->get(i,2));
         labels.push_back(field_array_ptr->get(i,3));
         descriptions.push_back(field_array_ptr->get(i,4));
         colors.push_back(field_array_ptr->get(i,5));
         importances.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,6)));
         double U=stringfunc::string_to_number(
            field_array_ptr->get(i,7));
         double V=stringfunc::string_to_number(
            field_array_ptr->get(i,8));
         UVs.push_back(twovector(U,V));

         cout << "annotation_ID = "  << annotation_IDs.back() << endl;
         cout << "creation_time = " << creation_times.back() << endl;
         cout << "username = " << usernames.back() << endl;
         cout << "label = " << labels.back() << endl;
         cout << "description = " << descriptions.back() << endl;
         cout << "color = " << colors.back() << endl;
         cout << "importance = " << importances.back() << endl;
         cout << "U = " << U << " V = " << V << endl;
      } // loop over index i labeling world annotations
   }

// ---------------------------------------------------------------------   
// Method get_fieldtest_photo_annotations()

   void get_fieldtest_photo_annotations(
      gis_database* gis_database_ptr,int fieldtest_ID,
      vector<int>& annotation_IDs,vector<int>& photo_IDs,
      vector<string>& photo_times,
      vector<string>& usernames,vector<string>& labels,
      vector<string>& descriptions,vector<string>& colors,
      vector<int>& importances,vector<twovector>& UVs)
   {
//      cout << "inside photoannotationdbfunc::get_fieldtest_photo_annotations()" << endl;
//      cout << "mission_ID = " << mission_ID << endl;

      string SQL_command="SELECT id,creation_time,username,";
      SQL_command += "label,description,color,importance,";
      SQL_command += "x(uv_posn),y(uv_posn),photo_id from photo_annotations ";
      SQL_command += "WHERE fieldtest_ID="+stringfunc::number_to_string(
         fieldtest_ID)+";";
//      cout << "SQL_command = " << SQL_command << endl;

      Genarray<string>* field_array_ptr=
         gis_database_ptr->select_data(SQL_command);
      if (field_array_ptr==NULL) return;

      unsigned int mdim=field_array_ptr->get_mdim();
//      unsigned int ndim=field_array_ptr->get_ndim();
//      cout << "mdim = " << mdim << " ndim = " << ndim << endl;

      for (unsigned int i=0; i<mdim; i++)
      {
         annotation_IDs.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,0)));
         photo_times.push_back(field_array_ptr->get(i,1));
         usernames.push_back(field_array_ptr->get(i,2));
         labels.push_back(field_array_ptr->get(i,3));
         descriptions.push_back(field_array_ptr->get(i,4));
         colors.push_back(field_array_ptr->get(i,5));
         importances.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,6)));
         double U=stringfunc::string_to_number(
            field_array_ptr->get(i,7));
         double V=stringfunc::string_to_number(
            field_array_ptr->get(i,8));
         UVs.push_back(twovector(U,V));
         photo_IDs.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,9)));

         cout << "annotation_ID = "  << annotation_IDs.back() << endl;
         cout << "photo_time = " << photo_times.back() << endl;
         cout << "username = " << usernames.back() << endl;
         cout << "label = " << labels.back() << endl;
         cout << "description = " << descriptions.back() << endl;
         cout << "color = " << colors.back() << endl;
         cout << "importance = " << importances.back() << endl;
         cout << "U = " << U << " V = " << V << endl;
      } // loop over index i labeling world annotations
   }

// ---------------------------------------------------------------------   
// Method update_photo_annotation() takes in metadata for a single
// annotation which is intended to be tied to a 2D photo point.  It
// update the appropriate entry within *gis_database_ptr.

   bool update_photo_annotation(
      gis_database* gis_database_ptr,
      int annotation_ID,double secs_since_epoch,
      string username,string label,string description,string color,
      int importance,double U,double V)
   {
//   cout << "inside photoannotationdbfunc::update_photo_annotations()" << endl;

      string curr_update_command=
         photoannotationdbfunc::generate_update_photo_annotation_SQL_command(
            annotation_ID,secs_since_epoch,
            username,label,description,color,importance,U,V);
      
      vector<string> update_commands;
      update_commands.push_back(curr_update_command);
//      cout << "update_commands.back() = " << update_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;
      gis_database_ptr->set_SQL_commands(update_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_update_photo_annotation_SQL_command() takes in
// metadata associated with a single photo annotation.  It generates
// and returns a string containing a SQL update command needed to
// alter a row within the photo_annotations table of the
// TOC database.

   string generate_update_photo_annotation_SQL_command(
      int annotation_ID,double secs_since_epoch,
      string username,string label,string description,string color,
      int importance,double U,double V)
   {
//   cout << "inside photoannotationdbfunc::generate_update_photo_annotation_SQL_command()" << endl;

      Clock clock;
      clock.convert_elapsed_secs_to_date(secs_since_epoch);
      string date_str=clock.YYYY_MM_DD_H_M_S();
      
      string SQL_command="UPDATE photo_annotations";
      SQL_command += " SET creation_time='"+date_str+"',";

      if (username.size() > 0)
         SQL_command += "username='"+username+"',";
      if (label.size() > 0)
         SQL_command += "label='"+label+"',";
      if (description.size() > 0)
         SQL_command += "description='"+description+"',";
      if (color.size() > 0)
         SQL_command += "color='"+color+"',";
      if (importance > 0)
         SQL_command += "importance="+stringfunc::number_to_string(
            importance)+",";

      SQL_command += "uv_posn=PointFromText('POINT(' || ";
      SQL_command += stringfunc::number_to_string(U,9)+" || ' ' || ";
      SQL_command += stringfunc::number_to_string(V,9)+" || ')',4326) ";
      
      SQL_command += " WHERE id = "+stringfunc::number_to_string(
         annotation_ID)+";";

      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method delete_photo_annotation() 

   bool delete_photo_annotation(
      gis_database* gis_database_ptr,int annotation_ID)
   {
//   cout << "inside databasefunc::delete_photo_annotation()" << endl;

      string SQL_command="delete from photo_annotations where id=";
      SQL_command += stringfunc::number_to_string(annotation_ID)+";";
      
      vector<string> delete_commands;
      delete_commands.push_back(SQL_command);
//      cout << "delete_commands.back() = " << delete_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;
      gis_database_ptr->set_SQL_commands(delete_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

} // photoannotationdbfunc namespace



