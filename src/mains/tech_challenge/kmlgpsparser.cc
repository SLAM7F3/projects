// ========================================================================
// Program KMLGPSPARSER is a specialized utility program which takes in 
// a KML file generated by a GPS unit.  It calls gpsbabel in order to
// convert the KML output to a human-readable text file.  This program
// then parses the text file and extracts GPS data as a function of
// GPS time.  KMLGPSPARSER generates an output GPS track file whose
// form matches that produced by program GPSDEVICE.

//				kmlgpsparser

// ========================================================================
// Last updated on 8/6/10; 9/7/10; 1/24/14
// ========================================================================

#include <iostream>
#include <unistd.h>
#include <vector>
#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

   string KML_filename;
   cout << "Enter KML file containing GPS data:" << endl;
   cin >> KML_filename;


   string filename_prefix=stringfunc::prefix(KML_filename);
   string text_filename=filename_prefix+".txt";
   string unix_cmd="gpsbabel -i kml -f "+KML_filename+
      " -o text -F "+text_filename;
//   cout << "unix_cmd = " << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   while (!filefunc::fileexist(text_filename))
   {
      sleep(1);
   }
   
   cout << "Input KML file converted to text file " << text_filename << endl;
   filefunc::ReadInfile(text_filename);

   int FixQual=-1;
   int Nsats=-1;
   double HDOP=-1;
   double Vx=0;
   double Vy=0;
   double Vz=0;

   string first_timestamp;
   double longitude,latitude,altitude,speed,heading;
   Clock clock;
   vector<string> output_lines;

   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      int n_substrings=substrings.size();
      if (n_substrings > 2)
      {
//         cout << filefunc::text_line[i] << endl;
         if (stringfunc::first_substring_location(
            substrings[0],"Longitude",0) > 0)
         {
            longitude=stringfunc::string_to_number(substrings[1]);
         }
         else if (stringfunc::first_substring_location(
            substrings[0],"Latitude",0) > 0)
         {
            latitude=stringfunc::string_to_number(substrings[1]);
         }
         else if (stringfunc::first_substring_location(
            substrings[0],"Altitude",0) > 0)
         {
            altitude=stringfunc::string_to_number(substrings[1]);
         }
         else if (stringfunc::first_substring_location(
            substrings[0],"Speed",0) > 0)
         {
            speed=stringfunc::string_to_number(substrings[1]);
         }
         else if (stringfunc::first_substring_location(
            substrings[0],"Heading",0) > 0)
         {
            heading=stringfunc::string_to_number(substrings[1]);
         }
         else if (stringfunc::first_substring_location(
            substrings[0],"Time",0) > 0)
         {
            string timestamp=substrings[1];
            if (first_timestamp.size()==0)
            {
               first_timestamp=timestamp;
            }
            
            bool UTC_flag=true;
            double elapsed_secs=clock.timestamp_string_to_elapsed_secs(
               timestamp,UTC_flag);
            
//            cout.precision(10);
//            cout << endl;
//            cout << "lon = " << longitude
//                 << " lat = " << latitude
//                 << " alt = " << altitude << endl;
//            cout << "speed = " << speed 
//                 << " heading = " << heading
//                 << " timestamp = " << timestamp 
 //                << " elapsed secs = " << elapsed_secs << endl;

            output_lines.push_back(
               stringfunc::number_to_string(elapsed_secs) + " "
               +stringfunc::number_to_string(FixQual) + " "
               +stringfunc::number_to_string(Nsats) + " "
               +stringfunc::number_to_string(HDOP) + " "
               +stringfunc::number_to_string(longitude,8) + " "
               +stringfunc::number_to_string(latitude,8) + " "
               +stringfunc::number_to_string(altitude) + " "
               +stringfunc::number_to_string(Vx) + " "
               +stringfunc::number_to_string(Vy) + " "
               +stringfunc::number_to_string(Vx));
         }
      }
   } // loop over index i labeling lines within text file converted from KML

// Write out GPS track file in same convention as that generated by
// GPSDEVICE program:

   string output_subdir=filefunc::getdirname(text_filename);

//   string output_subdir="/data/tech_challenge/GPS_tracks/";
   string output_filename=output_subdir+
      "KML_gps_track_"+first_timestamp+".dat";

   ofstream outstream;
   filefunc::openfile(output_filename,outstream);
   outstream << "# Time FixQual Nsats HDOP    X	Y	Z	Vx	Vy 	Vz" << endl;
   outstream << endl;
   for (int i=0; i<output_lines.size(); i++)
   {
      outstream << output_lines[i] << endl;
   }
   filefunc::closefile(output_filename,outstream);

   string banner="GPS track data converted to "+output_filename;
   outputfunc::write_big_banner(banner);


}


