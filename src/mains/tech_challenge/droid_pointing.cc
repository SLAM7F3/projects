// ========================================================================
// Program DROID_POINTING parses the pointing log file generated by a
// DROID cell phone.  It extracts instantaneous time stamp, az, pitch and roll
// values.  After alpha-filtering the raw pointing angles,
// this program generates a SQL file containing insert commands so
// that the pointing information can be stored in the expt_metadata database.

//				droid_pointing

// ========================================================================
// Last updated on 6/21/10
// ========================================================================

#include <iostream>
#include "astro_geo/Clock.h"
#include "math/constant_vectors.h"
#include "general/filefuncs.h"
#include "filter/filterfuncs.h"
#include "astro_geo/GPS_datastream.h"
#include "math/mathfuncs.h"
#include "messenger/Messenger.h"
#include "math/statevector.h"
#include "general/sysfuncs.h"
#include "general/stringfuncs.h"
#include "track/tracks_group.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// New TOC database conventions:

   int fieldtest_ID=2;	// Bike ride around LL hill on Tues 7/27 around 4 pm
   int mission_ID=2;	// 
   int platform_ID=2;	// Peter's bike
   int sensor_ID=2;	// Brian's webcam

   string subdir="/data/tech_challenge/droid/GPS_tracks/";
//   string logfilename="june16_droid_gps.txt";
   string logfilename=subdir+
      "20100626_154557_60_1277581557061_location_info_gps.txt";
//   string logfilename="june16_droid_accel.txt";
   cout << "logfilename = " << logfilename << endl;

   if (!filefunc::fileexist(logfilename))
   {
      cout << "Droid log file doesn't exist!" << endl;
      exit(-1);
   }

// ========================================================================

   Clock clock;

   int UTM_zone=19;	// Boston, MA
   clock.compute_UTM_zone_time_offset(UTM_zone);
   cout << "UTM_zone time offset = " << clock.get_UTM_zone_time_offset()
        << endl;

   tracks_group pointing_tracks_group;
   track* pointing_track_ptr=pointing_tracks_group.generate_new_track();

// Instantiate POINTING messenger:

   string broker_URL="tcp://127.0.0.1:61616";
   cout << "ActiveMQ broker_URL = " << broker_URL << endl;

   string POINTING_message_queue_channel_name="POINTING";
   Messenger POINTING_messenger( 
	broker_URL, POINTING_message_queue_channel_name );

// Open droid log file containing POINTING information:

   string subdir=
      "/data/tech_challenge/field_tests/Burlington_Jun16/droid_logs/";
   string logfilename="june16_droid_accel.txt";
   logfilename=subdir+logfilename;
   filefunc::ReadInfile(logfilename);

   int istart=1;
   int i_flying_start=istart;
   double prev_time=-1;
   double prev_filtered_az=0;
   double prev_filtered_pitch=0;
   double prev_filtered_roll=0;
   for (int i=istart; i<filefunc::text_line.size(); i++)
   {
      string curr_line=filefunc::text_line[i];
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(curr_line,",");

// Droid POINTING log occasionally contains spurious metadata.  So make
// sure that log file line has at least 8 entries:

      if (substrings.size() < 10) continue;

      string timestamp=substrings[0];
      vector<string> time_substrings=
         stringfunc::decompose_string_into_substrings(timestamp,"_");
      string ymd=time_substrings[0];
      string hms=time_substrings[1];
      string frac_sec=time_substrings[2];

      int year=stringfunc::string_to_number(ymd.substr(0,4));
      int month=stringfunc::string_to_number(ymd.substr(4,2));
      int day=stringfunc::string_to_number(ymd.substr(6,2));
      int hour=stringfunc::string_to_number(hms.substr(0,2));
      int minute=stringfunc::string_to_number(hms.substr(2,2));
      double second=stringfunc::string_to_number(hms.substr(4,2));
      double fractional_sec=0.001*stringfunc::string_to_number(frac_sec);
      second += fractional_sec;

      clock.set_local_time(year,month,day,hour,minute,second);

      double curr_time=clock.secs_elapsed_since_reference_date(); 
      if (curr_time <= prev_time) continue;
      prev_time=curr_time;

      double magneticX=stringfunc::string_to_number(substrings[1]);
      double magneticY=stringfunc::string_to_number(substrings[2]);
      double magneticZ=stringfunc::string_to_number(substrings[3]);
      double accelX=stringfunc::string_to_number(substrings[4]);
      double accelY=stringfunc::string_to_number(substrings[5]);
      double accelZ=stringfunc::string_to_number(substrings[6]);

      double raw_azimuth=stringfunc::string_to_number(substrings[7]);
      double raw_pitch=stringfunc::string_to_number(substrings[8]);
      double raw_roll=stringfunc::string_to_number(substrings[9]);

      cout.precision(12);
      cout << "iter = " << i << endl;
      cout << "timestamp = " << timestamp 
           << " ymd = " << ymd
           << " hms = " << hms
           << " frac_sec = " << frac_sec << endl;
      cout << "year = " << year
           << " month = " << month 
           << " day = " << day
           << endl;
      cout << "hour = " << hour
           << " minute = " << minute
           << " second = " << second << endl;
      cout << "time = " << clock.YYYY_MM_DD_H_M_S() << endl;
      
      cout << "magneticX = " << magneticX
           << " magneticY = " << magneticY
           << " magneticZ = " << magneticZ << endl;
      cout << "accelX = " << accelX
           << " accelY = " << accelY
           << " accelZ = " << accelZ << endl;
      cout << "azimuth = " << raw_azimuth
           << " pitch = " << raw_pitch
           << " roll = " << raw_roll << endl << endl;

// Smooth noisy POINTING track with simple alpha filter.  But let alpha
// slowly vary from unity down to some fraction less than one.
// Recall alpha=1 implies filtered value = raw noisy input value,
// while alpha=0 implies filtered value = prev filtered value.

      double sigma_iter=5;
      double mu_iter=i_flying_start+7*sigma_iter;
      double arg_iter=(i-mu_iter)/(SQRT_TWO*sigma_iter);
//      cout << "arg_iter = " << arg_iter << endl;
//      cout << "errorfunc::error_function(arg_iter)) = "
//           << mathfunc::error_function(arg_iter) << endl;
      
      double alpha=1.0+(0.85-1.0)*0.5*(
         1+mathfunc::error_function(arg_iter));
//      cout << "alpha = " << alpha << endl;

      double filtered_az=filterfunc::alpha_filter(
         raw_azimuth,prev_filtered_az,alpha);
      double filtered_pitch=filterfunc::alpha_filter(
         raw_pitch,prev_filtered_pitch,alpha);
      double filtered_roll=filterfunc::alpha_filter(
         raw_roll,prev_filtered_roll,alpha);

      prev_filtered_az=filtered_az;
      prev_filtered_pitch=filtered_pitch;
      prev_filtered_roll=filtered_roll;

      threevector apr_posn(filtered_az,filtered_pitch,filtered_roll);
      threevector velocity(0,0,0);
      pointing_track_ptr->set_posn_velocity(curr_time,apr_posn,velocity);

   } // loop over index i labeling lines within droid pointing log file

// Write out SQL insertion commands so that POINTING track can be stored
// within track_pointings table of expt_metadata database:

   int experiment_ID=0;
   string SQL_track_pointings_filename="insert_track_pointings.sql";

   pointing_track_ptr->write_SQL_insert_track_commands(
      experiment_ID,SQL_track_pointings_filename);
}



