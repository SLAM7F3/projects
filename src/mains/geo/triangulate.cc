// Destroy bundle.out link to bundle_trivial.out if it exists before
// overwriting bundle.out at end of this program!


// =======================================================================
// Program TRIANGULATE imports SIFT/ASIFT feature tracks generated by
// program RESTRICTED_ASIFTVID.  It also takes in package files for
// the n video frames which contain hardware-based camera
// parameters.  TRIANGULATE backprojects each 2D feature into a 3D
// ray.  It then computes multi-line intersection points for each
// feature track.  Triangulated 3D points are exported to a
// features_3D.txt file, and correlated 2D/3D feature information is
// written photograph_features.html .  

// TRIANGULATE next exports text file ssba.input containing 2D/3D
// feature information that can be processed via binary executable
// bundle_varying from the SSBA-3.0 package.  After SSBA is called,
// resulting bundle-adjusted output is written to
// bundler_IO_subdir/ssba.output.

// TRIANGULATE exports hardware-based camera parameters and
// triangulated ground points to bundle_raw.out.  BUNDLER is
// subsequently called to perform (re)bundle adjustment with camera
// focal parameters held fixed at their previously calibrated values.
// Bundle-adjusted camera positions are written to an output text
// file.

/*

./triangulate \
--region_filename ./packages/photo_0000.pkg \
--region_filename ./packages/photo_0010.pkg \
--region_filename ./packages/photo_0020.pkg \
--region_filename ./packages/photo_0030.pkg 

*/

// =======================================================================
// Last updated on 7/28/13; 7/30/13; 9/18/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "bundler/bundlerfuncs.h"
#include "video/camerafuncs.h"
#include "osg/osgFeatures/FeaturesGroup.h"
#include "general/filefuncs.h"
#include "geometry/geometry_funcs.h"
#include "geometry/linesegment.h"
#include "math/ltthreevector.h"
#include "messenger/Messenger.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "geometry/plane.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "time/timefuncs.h"

using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::pair;
using std::string;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);

   bool demo_flag=true;
   if (demo_flag)
   {
      string broker_URL = "tcp://127.0.0.1:61616";
      string message_queue_channel_name="127.0.0.1";
      string message_sender_ID="MESSAGE_SENDER";
      bool include_sender_and_timestamp_info_flag=false;
      Messenger m(broker_URL,message_queue_channel_name,message_sender_ID,
                  include_sender_and_timestamp_info_flag);

      string command="DISPLAY_NEXT_FLOW_DIAGRAM";
      m.sendTextMessage(command);
   }
   timefunc::initialize_timeofday_clock();      

// Note added on 3/10/13: We manually generated ~30 tiepoint pairs
// between ALIRT HAFB and 3 low-resolution FLIR frames.  Using program
// FLIR_FOCAL, we found f=-24.58 as a best estimate for the focal
// length corresponding to the "5 degree" FOV FLIR setting:

   double f_five_deg=-24.58;     

   double azimuth_bias=0;
   double elevation_bias=0;
   double roll_bias=0;
//   cout << "Enter azimuth angle bias in degrees:" << endl;
//   cin >> azimuth_bias;
//   cout << "Enter elevation angle bias in degrees:" << endl;
//   cin >> elevation_bias;
//   cout << "Enter roll angle bias in degrees:" << endl;
//   cin >> roll_bias;
   azimuth_bias *= PI/180;
   elevation_bias *= PI/180;
   roll_bias *= PI/180;

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string cropped_bundler_IO_subdir=
      bundler_IO_subdir.substr(2,bundler_IO_subdir.size()-2);
   string full_bundler_IO_path=filefunc::get_pwd()+cropped_bundler_IO_subdir;
//   cout << "full_bundler_IO_path = " << full_bundler_IO_path << endl;
   string images_subdir=bundler_IO_subdir+"images/";
   string all_keys_subdir=full_bundler_IO_path+"all_keys/";

// On 7/13/13, we realized the hard and painful way that we must
// delete any existing outlier.indices file within bundler_IO_subdir
// left over from a previous run of GPSFIT before starting a new round
// of triangulation!

   string outlier_filename=bundler_IO_subdir+"outlier.indices";
   filefunc::deletefile(outlier_filename);

// Create relative softlinks between key files in all_keys_subdir with
// images_subdir:

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("key");
   vector<string> key_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,all_keys_subdir);

   for (unsigned int k=0; k<key_filenames.size(); k++)
   {
//      cout << key_filenames[k] << endl;
      string key_basename=filefunc::getbasename(key_filenames[k]);
      string unix_cmd="ln -s ../all_keys/"+key_basename+" "+images_subdir;
//      cout << "unix_cmd = " << unix_cmd << endl;
      sysfunc::unix_command(unix_cmd);
   }
   
// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group);
   int n_images=photogroup_ptr->get_n_photos();
   cout << "n_images = " << n_images << endl;

   threevector camera_world_COM(Zero_vector);
   vector<double> xdims,ydims;
   vector<camera*> camera_ptrs;
   for (int n=0; n<n_images; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photo_ptr->get_camera_ptr();

// FAKE FAKE:  Sat Mar 9, 2013 at 8:30 pm
// Hardwire best estimate for "5 deg" focal length for FLIR:

//      double f_recorded=camera_ptr->get_fu();
      camera_ptr->set_f(f_five_deg);

      double azimuth_hardware,elevation_hardware,roll_hardware;
      camera_ptr->get_az_el_roll_from_Rcamera(
         azimuth_hardware,elevation_hardware,roll_hardware);
//      cout << "n = " << n 
//           << " elevation_hardware = " << elevation_hardware*180/PI << endl;
      double azimuth=azimuth_hardware+azimuth_bias;
      double elevation=elevation_hardware+elevation_bias;
      double roll=roll_hardware+roll_bias;
      camera_ptr->set_Rcamera(azimuth,elevation,roll);

      camera_ptrs.push_back(camera_ptr);
      xdims.push_back(photo_ptr->get_xdim());
      ydims.push_back(photo_ptr->get_ydim());
      camera_world_COM += camera_ptr->get_world_posn();
   }
   camera_world_COM /= n_images;
//   cout << "In UTM geocoords, camera_world_COM = " << camera_world_COM << endl;

// Subtract off camera_world_COM from camera world positions in order
// to avoid working with numerically large values:

   int n_cameras=camera_ptrs.size();
   for (int n=0; n<n_cameras; n++)
   {
      camera* camera_ptr=camera_ptrs[n];
      threevector camera_world_posn=camera_ptr->get_world_posn();
      camera_world_posn -= camera_world_COM;
      camera_ptr->set_world_posn(camera_world_posn);
      camera_ptr->construct_projection_matrix(true);
//      genmatrix* P_ptr=camera_ptr->get_P_ptr();
//      cout << "n = " << n << " reset P = " << *P_ptr << endl;

   }
//    outputfunc::enter_continue_char();

// --------------------------------------------------------------------------

   int feature_index;
   threevector UVW,XYZ;

   FeaturesGroup* FeaturesGroup_ptr=new FeaturesGroup(
      ndims,passes_group.get_pass_ptr(videopass_ID),NULL);

   string features_subdir=bundler_IO_subdir+"/features/";
   FeaturesGroup_ptr->read_in_photo_features(photogroup_ptr,features_subdir);

   int n_features=FeaturesGroup_ptr->get_n_Graphicals();
   double curr_t=FeaturesGroup_ptr->get_curr_t();
   int max_n_passes=n_images;
//   cout << "n_features = " << n_features << endl;
//   cout << "curr_t = " << curr_t << endl;
//   cout << "max_n_passes = " << max_n_passes << endl;

   string output_filename=features_subdir+"features_3D.txt";
   ofstream outstream;
   filefunc::openfile(output_filename,outstream);
   outstream << "# Time   Feature_ID   Passnumber   X  Y  Z  Score" 
             << endl << endl;

   int n_too_uncertain=0;
   int n_ridiculous=0;
//   double max_intersection_uncertainty=100;	// meters
//   double max_intersection_uncertainty=150;	// meters
   double max_intersection_uncertainty=200;	// meters
//   double max_intersection_uncertainty=250;	// meters
//   double max_intersection_uncertainty=350;	// meters
//   double max_intersection_uncertainty=500;	// meters
//   double max_intersection_uncertainty=750;	// meters
//   double max_intersection_uncertainty=1000;	// meters
   double ridiculous_intersection_uncertainty=5*max_intersection_uncertainty;
//   double ridiculous_intersection_uncertainty=10*max_intersection_uncertainty;
   vector<double> abs_intersection_z,sigma_intersection_distances;
   vector<threevector> V;
   for (int f=0; f<n_features; f++)
   {
      Feature* Feature_ptr=FeaturesGroup_ptr->get_Feature_ptr(f);
      int feature_ID=Feature_ptr->get_ID();

      vector<int> camera_indices;
      vector<linesegment> line_segments;
      for (int p=0; p<n_cameras; p++)
      {
         Feature_ptr->get_index(curr_t,p,feature_index);
         if (feature_index < 0) continue;

         camera* camera_ptr=camera_ptrs[p];
         threevector camera_posn=camera_ptr->get_world_posn();

         Feature_ptr->get_UVW_coords(curr_t,p,UVW);
         double U=UVW.get(0);
         double V=UVW.get(1);

         threevector r_hat=camera_ptr->pixel_ray_direction(U,V);
         line_segments.push_back(
            linesegment(camera_posn,camera_posn+r_hat));
         camera_indices.push_back(p);

//            cout << p << " "
//                 << UV.get(0) << " "
//                 << UV.get(1) << " : "
//                 << r_hat.get(0) << ","
//                 << r_hat.get(1) << ","
//                 << r_hat.get(2) << endl;

      } // loop over index p labeling camera pass

      unsigned int min_line_segments=4;
      if (line_segments.size() < min_line_segments) continue;

/*
      int min_line_segments=3;
      if (line_segments.size() < min_line_segments) 
      {
         int d_camera_index=
            fabs(camera_indices.back()-camera_indices.front());
         if (d_camera_index==1) continue;
      }
*/
  
      double sigma_theta=1*PI/180;
      double sigma_phi=1*PI/180;
      threevector intersection_point,sigma_intersection_point;
      if (!geometry_func::multi_line_intersection_point(
         line_segments,sigma_theta,sigma_phi,
         intersection_point,sigma_intersection_point)) continue;
      
      double curr_sigma_intersection=sigma_intersection_point.magnitude();

      if (curr_sigma_intersection > ridiculous_intersection_uncertainty)
      {
         n_ridiculous++;
         continue;
      }
      
      sigma_intersection_distances.push_back(curr_sigma_intersection);

// As of 5/9/13, we experiment with discarding any raw triangulated
// intersection points whose uncertainties are excessively large:

      if (curr_sigma_intersection > max_intersection_uncertainty)
      {
         n_too_uncertain++;
         continue;
      }

//      intersection_point += camera_world_COM;
      V.push_back(intersection_point);

      threevector abs_intersection_point=intersection_point+camera_world_COM;
//      cout << "abs_intersection_point.get(2) = "
//           << abs_intersection_point.get(2) << endl;
      abs_intersection_z.push_back(abs_intersection_point.get(2));
//      cout << endl;

      const osg::Quat trivial_q(0,0,0,1);
      const threevector trivial_scale(1,1,1);

      Feature_ptr->set_UVW_coords(curr_t,max_n_passes,intersection_point);
      Feature_ptr->set_quaternion(curr_t,max_n_passes,trivial_q);
      Feature_ptr->set_scale(curr_t,max_n_passes,trivial_scale);

      double score=-1;
      outstream << curr_t << "\t"
                << feature_ID << "\t"
                << max_n_passes << "\t"
                << stringfunc::number_to_string(
                   intersection_point.get(0),3) << "\t"
                << stringfunc::number_to_string(
                   intersection_point.get(1),3) << "\t"
                << stringfunc::number_to_string(
                   intersection_point.get(2),3) << "\t"
                << score << endl;

   } // loop over index f labeling feature
   filefunc::closefile(output_filename,outstream);

   cout << "Initial number of feature tracks = " << n_features << endl;
   cout << "Number of raw triangulated points = " << V.size() << endl;
   cout << "n_too_uncertain = " << n_too_uncertain << endl;
   cout << "n_ridiculous = " << n_ridiculous << endl;

   cout << "min sigma_intersection_distance = "
        << mathfunc::minimal_value(sigma_intersection_distances)
        << endl;
   cout << "max sigma_intersection_distance = "
        << mathfunc::maximal_value(sigma_intersection_distances)
        << endl;

   string banner="Triangulated 3D points written to "+output_filename;
   outputfunc::write_big_banner(banner);

/*
   prob_distribution prob_sigma_intersection_distances(
      sigma_intersection_distances,500);
   prob_sigma_intersection_distances.set_xmin(0);
   prob_sigma_intersection_distances.set_xmax(1000);
   prob_sigma_intersection_distances.set_xtic(100);
   prob_sigma_intersection_distances.set_xsubtic(500);
   prob_sigma_intersection_distances.writeprobdists(false);
   cout << "Exported probability distributions for sigma intersection distances" << endl;
//   outputfunc::enter_continue_char();
*/

//   double z_mean=mathfunc::mean(abs_intersection_z);
//   cout << "z_mean = " << z_mean << endl;
//   prob_distribution prob_z(abs_intersection_z,500);
//   prob_z.writeprobdists(false);

// Identify ground plane outliers via RANSAC:

   int n_points=V.size();
   int n_iters=200;
   int max_n_inlier_points=0;
   const double meters_per_story=4;	
   const double max_dist_from_groundplane=4*meters_per_story;	// meters
   plane best_candidate_groundplane;
   for (int iter=0; iter<n_iters; iter++)
   {
//      if (iter%10==0) cout << iter << endl;
      vector<int> point_indices=mathfunc::random_sequence(n_points,3);
      plane candidate_groundplane(
         V[point_indices[0]],V[point_indices[1]],V[point_indices[2]]);

      int n_inlier_points=0;
      for (int n=0; n<n_points; n++)
      {
         double dist=candidate_groundplane.signed_distance_from_plane(V[n]);
         if (fabs(dist) < max_dist_from_groundplane)
         {
            n_inlier_points++;
         }
      }
      if (n_inlier_points > max_n_inlier_points)
      {
         max_n_inlier_points=n_inlier_points;
         best_candidate_groundplane=candidate_groundplane;
//         double frac_inliers=double(max_n_inlier_points)/double(n_points);
//         cout << "n_points = " << n_points 
//              << " max_n_inlier_points = " << max_n_inlier_points 
//              << " frac_inliers = " << frac_inliers << endl;
      }
   } // loop over iter index
   
   vector<threevector> inlier_V;
   typedef map<threevector,int,ltthreevector> INLIER_POINTS_MAP;
   INLIER_POINTS_MAP inlier_points_map;
   INLIER_POINTS_MAP::iterator inlier_points_iter;

   for (int n=0; n<n_points; n++)
   {
      double dist=best_candidate_groundplane.signed_distance_from_plane(V[n]);
      if (fabs(dist) < max_dist_from_groundplane)
      {
         inlier_V.push_back(V[n]);
         inlier_points_map[V[n]]=n;
      }
   }
//   plane groundplane(inlier_V);
//   cout << "groundplane = " << groundplane << endl;

// Export raw triangulated points lying close to ground plane to
// TDP/OSGA files:

   string UTMzone="";
   string tdp_filename=bundler_IO_subdir+"raw_points.tdp";
   tdpfunc::write_relative_xyz_data(tdp_filename,inlier_V);
   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv raw_points.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);

// Delete any features whose 3D world points lie too far from ground plane:

   threevector intersection_point;
   int n_outliers=0;
   typedef map<int,bool> FEATURE_IDS_TO_IGNORE_MAP;
   FEATURE_IDS_TO_IGNORE_MAP feature_ids_to_ignore_map;

   for (int f=0; f<n_features; f++)
   {
      Feature* Feature_ptr=FeaturesGroup_ptr->get_Feature_ptr(f);
      double curr_t=FeaturesGroup_ptr->get_curr_t();
      bool triangulated_flag=
         Feature_ptr->get_UVW_coords(curr_t,max_n_passes,intersection_point);

      inlier_points_iter=inlier_points_map.find(intersection_point);
      if (!triangulated_flag ||
          inlier_points_iter==inlier_points_map.end())
      {
//         cout << "Feature ID = " << Feature_ptr->get_ID() << " is an outlier"
//              << endl;
         feature_ids_to_ignore_map[Feature_ptr->get_ID()]=true;
         n_outliers++;
      }
   }
   double frac_outliers=double(n_outliers)/n_features;
   int n_features_for_bundle_adjustment=
      n_features-feature_ids_to_ignore_map.size();
   cout << "Initial number of feature tracks = " << n_features << endl;
   cout << "frac feature inliers = " << 1-frac_outliers << endl;
   cout << "feature_ids_to_ignore_map.size() = "
        << feature_ids_to_ignore_map.size() << endl;
   cout << "Number of features to be bundle adjusted = "
        << n_features_for_bundle_adjustment << endl;


/*

// Count number of UV image plane measurements:

   int n_UV_coords=0;
   for (int f=0; f<n_features; f++)
   {
      Feature* Feature_ptr=FeaturesGroup_ptr->get_Feature_ptr(f);
      int feature_ID=Feature_ptr->get_ID();

      for (int n=0; n<n_cameras; n++)
      {
         int camera_ID=n;
         
         Feature_ptr->get_index(curr_t,n,feature_index);
         if (feature_index < 0) continue;
         n_UV_coords++;
      } // loop over index n labeling cameras
   } // loop over index f labeling features
   cout << "n_UV_coords = " << n_UV_coords << endl;

// -----------------------------------------------------------------------
// Export text file for SSBA-3.0:

   string gps_posns_filename=bundler_IO_subdir+"GPS_waypoints.txt";
   ofstream gps_posns_stream;
   gps_posns_stream.precision(10);
   filefunc::openfile(gps_posns_filename,gps_posns_stream);

   string ssba_filename=bundler_IO_subdir+"ssba.input";
   ofstream ssba_stream;
   filefunc::openfile(ssba_filename,ssba_stream);
   ssba_stream << n_features << " " << n_cameras << " "
               << n_UV_coords << endl;

// First export intrinsic camera parameters:

   for (int n=0; n<n_cameras; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=camera_ptrs[n];

      double px_center=0.5*xdims[n];
      double py_center=0.5*ydims[n];
      
      double f=camera_ptr->get_fu();
      double f_noah=fabs(f)*ydims[n];
      double skew=0;
      double k1=0;	// radial distortion parameter
      double k2=0;
      double p1=0;	// tangential distortion parameter
      double p2=0;
      ssba_stream << f_noah << " " << skew << " " << px_center << " "
                  << f_noah << " " << py_center << " " 
                  << k1 << " " << k2 << " " << p1 << " " << p2 << endl;
   } // loop over index n labeling cameras

// Second, export 3D point positions:

   for (int f=0; f<n_features; f++)
   {
      Feature* Feature_ptr=FeaturesGroup_ptr->get_Feature_ptr(f);
      int feature_ID=Feature_ptr->get_ID();
      Feature_ptr->get_UVW_coords(curr_t,n_cameras,XYZ);
      ssba_stream << feature_ID << " " 
                  << XYZ.get(0) << " "
                  << XYZ.get(1) << " "
                  << XYZ.get(2) << endl;
   } // loop over index f labeling features

// Third, export 12 entries in its RT matrix: RT = Kinv * P_proj

   double photo_time=0;
   for (int n=0; n<n_cameras; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=camera_ptrs[n];
      threevector camera_posn=camera_ptr->get_world_posn()+camera_world_COM;
      gps_posns_stream 
         << filefunc::getbasename(photo_ptr->get_filename()) << "  "
         << photo_time << "  "
         << camera_posn.get(0) << "  "
         << camera_posn.get(1) << "  "
         << camera_posn.get(2) << "  "
         << endl;
      
      genmatrix* P_ptr=camera_ptr->get_P_ptr();
      genmatrix* Kinv_ptr=camera_ptr->get_Kinv_ptr();
      genmatrix RT(3,4);
      RT=*Kinv_ptr * *P_ptr;
      int camera_ID=n;
      ssba_stream << camera_ID << " ";
      for (int r=0; r<3; r++)
      {
         for (int c=0; c<4; c++)
         {
            ssba_stream << RT.get(r,c) << " ";
         }
      }
      ssba_stream << endl;
   } // loop over index n labeling cameras

// Fourth, export image plane measurements:

   for (int f=0; f<n_features; f++)
   {
      Feature* Feature_ptr=FeaturesGroup_ptr->get_Feature_ptr(f);
      int feature_ID=Feature_ptr->get_ID();

      for (int n=0; n<n_cameras; n++)
      {
         int camera_ID=n;
         
         Feature_ptr->get_index(curr_t,n,feature_index);
         if (feature_index < 0) continue;

         Feature_ptr->get_UVW_coords(curr_t,n,UVW);
         double U=UVW.get(0);
         double V=UVW.get(1);
         double px=U*ydims[n];
         double py=V*ydims[n];
         ssba_stream << camera_ID << " "
                     << feature_ID << " "
                     << px << " " << py << " 1" << endl;
      } // loop over index n labeling cameras
   } // loop over index f labeling features

   filefunc::closefile(gps_posns_filename,gps_posns_stream);
   filefunc::closefile(ssba_filename,ssba_stream);

   banner="Exported "+gps_posns_filename;
   outputfunc::write_big_banner(banner);
   
   banner="Exported "+ssba_filename;
   outputfunc::write_big_banner(banner);
*/

/*
// Call SSBA bundle_varying executable on ssba.input file:

//   unix_cmd="/usr/local/bin/bundle_varying "+ssba_filename+" focal";
   unix_cmd="/usr/local/bin/bundle_varying "+ssba_filename+" metric";
   sysfunc::unix_command(unix_cmd);

   string ssba_output_filename=bundler_IO_subdir+"ssba.output";
   unix_cmd="mv refined.txt "+ssba_output_filename;
   sysfunc::unix_command(unix_cmd);
   banner="Exported ssba.output to "+bundler_IO_subdir;
   outputfunc::write_big_banner(banner);
*/

// -----------------------------------------------------------------------
// Export raw bundle.out file:

   string bundle_raw_filename=bundler_IO_subdir+"bundle_raw.out";
   bundlerfunc::export_bundle_file(
      bundle_raw_filename,photogroup_ptr,FeaturesGroup_ptr,
      &feature_ids_to_ignore_map);

   banner="Exported bundle.out for raw triangulated points to "
      +bundle_raw_filename;
   outputfunc::write_big_banner(banner);

//    outputfunc::enter_continue_char();

   if (demo_flag)
   {
      string broker_URL = "tcp://127.0.0.1:61616";
      string message_queue_channel_name="127.0.0.1";
      string message_sender_ID="MESSAGE_SENDER";
      bool include_sender_and_timestamp_info_flag=false;
      Messenger m(broker_URL,message_queue_channel_name,message_sender_ID,
                  include_sender_and_timestamp_info_flag);

      string command="DISPLAY_NEXT_FLOW_DIAGRAM";
      m.sendTextMessage(command);
   }

// Run bundler to perform simple bundle adjustment with focal length
// parameters held fixed:

// Bundler expects to find key files within bundler_IO_subdir/images/ . 
// Since we're running bundler from src/mains/geo rather than from
// bundler_IO_subdir, image filenames need to be paths relative to
// ./bundler.  So generate modified version of list_tmp.txt file:

   string list_tmp_filename=bundler_IO_subdir+"list_tmp.txt";
   string modified_list_tmp_filename=bundler_IO_subdir+"list_tmp_modified.txt";
   ofstream liststream;
   filefunc::openfile(modified_list_tmp_filename,liststream);

   filefunc::ReadInfile(list_tmp_filename);
   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      string modified_line=bundler_IO_subdir+filefunc::text_line[i];
      liststream << modified_line << endl;
   }
   filefunc::closefile(modified_list_tmp_filename,liststream);

   string bundle_filename=bundler_IO_subdir+"bundle_fixed_focal.out";
   unix_cmd="~/software/bundler-v0.4-source/bin/bundler ";
//   unix_cmd="/usr/local/bin/bundler-v0.4 ";
   unix_cmd += modified_list_tmp_filename;
   unix_cmd += " --bundle "+bundle_raw_filename;
   unix_cmd += " --output "+bundle_filename;
   unix_cmd += " --use_focal_estimate --rerun_bundle";
   cout << "bundler_cmd = " << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

// Overwrite existing bundle.out with new bundle_fixed_focal.out:

   unix_cmd="/bin/rm "+bundler_IO_subdir+"bundle.out";
   sysfunc::unix_command(unix_cmd);
   unix_cmd="cp "+bundle_filename+" "+bundler_IO_subdir+"bundle.out";
   sysfunc::unix_command(unix_cmd);

// Export bundle-adjusted camera positions to output text file:

   string camera_posns_filename=
      bundler_IO_subdir+"reconstructed_camera_posns.dat";
   filefunc::openfile(camera_posns_filename,outstream);
   outstream.precision(12);

   photogroup_ptr->reconstruct_bundler_cameras(bundle_filename);
   for (unsigned int n=0; n<photogroup_ptr->get_n_photos(); n++)
   {
      photograph* photograph_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photograph_ptr->get_camera_ptr();
      threevector camera_posn(camera_ptr->get_world_posn());

      outstream << photograph_ptr->get_ID() << "  "
                << filefunc::getbasename(photograph_ptr->get_filename())
                << "  "
                << camera_posn.get(0) << "  "
                << camera_posn.get(1) << "  "
                << camera_posn.get(2) << endl;
   }
   filefunc::closefile(camera_posns_filename,outstream);

   banner="Bundle adjusted camera positions written to "+
      camera_posns_filename;
   outputfunc::write_big_banner(banner);
   
/*
// -----------------------------------------------------------------------
// Export files for SBA_1.6:

   string points_filename=bundler_IO_subdir+"pts.txt";
   ofstream points_stream;
   filefunc::openfile(points_filename,points_stream);
   points_stream << "# X Y Z nframes  frame0 x0 y0 frame1 x1 y1 ..." << endl;

// Export 3D point positions & their 2D image plane projections.
// Recall zeroth camera defines SBA_1.6 world coordinate system's
// origin and direction vectors!

   threevector Uhat0=camera_ptrs[0]->get_Uhat();
   threevector Vhat0=camera_ptrs[0]->get_Vhat();
   threevector What0=camera_ptrs[0]->get_What();
   threevector origin=camera_ptrs[0]->get_world_posn();

   for (int f=0; f<n_features; f++)
   {
      Feature* Feature_ptr=FeaturesGroup_ptr->get_Feature_ptr(f);
//      int feature_ID=Feature_ptr->get_ID();
      Feature_ptr->get_UVW_coords(curr_t,n_cameras,XYZ);

      threevector rel_XYZ=XYZ-origin;
//      cout << "XYZ = " << XYZ << endl;
//      cout << "origin = " << origin << endl;

      double rel_Xnew=rel_XYZ.dot(Uhat0);
      double rel_Ynew=rel_XYZ.dot(Vhat0);
      double rel_Znew=rel_XYZ.dot(What0);
      points_stream << rel_Xnew << " " << rel_Ynew << " " << rel_Znew << " ";

      int n_imageplanes=0;
      for (int p=0; p<n_cameras; p++)
      {
         int camera_ID=p;

         Feature_ptr->get_index(curr_t,p,feature_index);
         if (feature_index < 0) continue;
         n_imageplanes++;
      }
      points_stream << n_imageplanes << " ";
    
      for (int p=0; p<n_cameras; p++)
      {
         int camera_ID=p;

         Feature_ptr->get_index(curr_t,p,feature_index);
         if (feature_index < 0) continue;

         Feature_ptr->get_UVW_coords(curr_t,p,UVW);
         double U=UVW.get(0);
         double V=UVW.get(1);

         double px=U*ydims[p];
         double py=(1-V)*ydims[p];
         points_stream << p << " "
                       << px << " "
                       << py << " ";
      } // loop over index p labeling cameras
      points_stream << endl;

   } // loop over index f labeling features

   filefunc::closefile(points_filename,points_stream);

   banner="Exported "+points_filename;
   outputfunc::write_big_banner(banner);


   

   string cams_filename=bundler_IO_subdir+"camsvarK.txt";
   ofstream cams_stream;
   filefunc::openfile(cams_filename,cams_stream);
   cams_stream << "# fu, u0, v0, fu/fv , skew, quaternion, translation "
               << endl;

   for (int n=0; n<n_cameras; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=camera_ptrs[n];

      double f=camera_ptr->get_fu();
      double f_noah=fabs(f)*ydims[n];
      rotation* R0camera_ptr=camera_ptrs[0]->get_Rcamera_ptr();
      rotation* Rcamera_ptr=camera_ptr->get_Rcamera_ptr();
      rotation dR=*Rcamera_ptr * R0camera_ptr->transpose();
      fourvector rel_quat=dR.quaternion_corresponding_to_rotation();

      threevector world_posn0=camera_ptrs[0]->get_world_posn();
      threevector world_posn=camera_ptr->get_world_posn();
      threevector rel_trans=world_posn-world_posn0;

      cams_stream << f_noah << " "
                  << 0.5*xdims[n] << " "
                  << 0.5*ydims[n] 
                  << " 1.0 0.0 " 
                  << rel_quat.get(0) << " "
                  << rel_quat.get(1) << " "
                  << rel_quat.get(2) << " "
                  << rel_quat.get(3) << " "
                  << rel_trans.dot(Uhat0) << " "
                  << rel_trans.dot(Vhat0) << " "
                  << rel_trans.dot(What0) 
                  << endl;
   } // loop over index n labeling cameras

   filefunc::closefile(cams_filename,cams_stream);
*/

// -----------------------------------------------------------------------

//   delete FeaturesGroup_ptr;

   cout << "At end of program TRIANGULATE" << endl;
   outputfunc::print_elapsed_time();
}
