// =======================================================================
// Program GROUNDPLANE imports the sparse point cloud generated by
// PARSE_SSBA.  It fits a plane to the cloud and computes the
// distribution of point distances to the fitted plane.  Any point
// that lies more than 5 quartile-widths away from the median distance
// is assumed to be an outlier.  GROUNDPLANE exports a cleaned TDP
// file consisting of just inlier points.
// =======================================================================
// Last updated on 2/3/13; 2/28/13; 3/4/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "bundler/bundlerfuncs.h"
#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "geometry/plane.h"
#include "math/prob_distribution.h"
#include "math/rotation.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "time/timefuncs.h"

using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
//   int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;
   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string packages_subdir=bundler_IO_subdir+"packages/";

// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group);
//   int n_images=photogroup_ptr->get_n_photos();

//   for (int n=0; n<n_images; n++)
//   {
//      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
//      cout << "n = " << n << " *photo_ptr = " << *photo_ptr << endl;
//      camera* camera_ptr=photo_ptr->get_camera_ptr();
//      cout << "n = " << n << " camera = " << *camera_ptr << endl;
//   }

// Import bundle adjusted triangulated world points:

   string tdp_filename=bundler_IO_subdir+"ba_points.tdp";
   vector<double> X,Y,Z;
   tdpfunc::read_XYZ_points_from_tdpfile(tdp_filename,X,Y,Z);

   int n_points=X.size();
   vector<threevector> V;
   for (int n=0; n<n_points; n++)
   {
      V.push_back(threevector(X[n],Y[n],Z[n]));
   }
   
// Identify ground plane outliers via RANSAC:

   int n_iters=200;
   int max_n_inlier_points=0;
   const double max_dist_from_groundplane=15;	// meters
   plane best_candidate_groundplane;
   for (int iter=0; iter<n_iters; iter++)
   {
      if (iter%10==0) cout << iter << endl;
      vector<int> ba_point_indices=mathfunc::random_sequence(n_points,3);
      plane candidate_groundplane(
         V[ba_point_indices[0]],V[ba_point_indices[1]],V[ba_point_indices[2]]);

      int n_inlier_points=0;
      for (int n=0; n<n_points; n++)
      {
         double dist=candidate_groundplane.signed_distance_from_plane(V[n]);
         if (fabs(dist) < max_dist_from_groundplane)
         {
            n_inlier_points++;
         }
      }
      if (n_inlier_points > max_n_inlier_points)
      {
         max_n_inlier_points=n_inlier_points;
         best_candidate_groundplane=candidate_groundplane;
         double frac_inliers=double(max_n_inlier_points)/double(n_points);
         cout << "n_points = " << n_points 
              << " max_n_inlier_points = " << max_n_inlier_points 
              << " frac_inliers = " << frac_inliers << endl;
      }
   } // loop over iter index
   
   vector<threevector> inlier_V;
   for (int n=0; n<n_points; n++)
   {
      double dist=best_candidate_groundplane.signed_distance_from_plane(V[n]);
      if (fabs(dist) < max_dist_from_groundplane)
      {
         inlier_V.push_back(V[n]);
      }
   }
   plane groundplane(inlier_V);

/*
   cout << "Initial groundplane = " << groundplane << endl;

   vector<double> n_planar;
   vector<threevector> Vplanar;
   for (int n=0; n<n_points; n++)
   {
      double dist=groundplane.signed_distance_from_plane(V[n]);
      n_planar.push_back(dist);
   }
   
   prob_distribution prob_alts(n_planar,100);
   prob_alts.writeprobdists(false);
   double median_alt=prob_alts.median();
   double quartile_width=prob_alts.quartile_width();
   cout << "median_alt = " << median_alt 
        << " quartile_width = " << quartile_width << endl;

   X.clear();
   Y.clear();
   Z.clear();
   vector<threevector> V_cleaned;
   for (int n=0; n<n_points; n++)
   {
      double dist=groundplane.signed_distance_from_plane(V[n]);
      double ratio=fabs(dist-median_alt)/quartile_width;
      if (ratio < 5)
      {
         X.push_back(V[n].get(0));
         Y.push_back(V[n].get(1));
         Z.push_back(V[n].get(2));
         V_cleaned.push_back(V[n]);
      }
   }

   cout << "V.size() = " << V.size() << endl;
   cout << "V_cleaned.size() = " << X.size() << endl;
*/

   cout << "Ground plane computed from inlier world points = " 
        << groundplane << endl;
   cout << "origin = " << groundplane.get_origin() << endl;
   threevector n_hat=groundplane.get_nhat();

   if (sgn(n_hat.get(2)) < 0) n_hat=-n_hat;
   cout << "n_hat = " << n_hat << endl;

// Compute cleaned cloud's COM:

   threevector COM(Zero_vector);
   for (unsigned int n=0; n<inlier_V.size(); n++)
   {
      COM += inlier_V[n];
   }
   COM /= inlier_V.size();
   cout << "Cleaned cloud's COM = " << COM << endl;

// Translate groundplane so that it passes through cleaned cloud's COM:

   groundplane=plane(n_hat,COM);
   cout << "Translated cleaned groundplane = " << groundplane << endl;

//   double global_az,global_el,global_roll;
//   global_az=global_el=global_roll=0;
   
/*
// Rotate cleaned cloud about its COM so that ground plane's normal
// aligns with +z_hat:

   rotation R;
   R=R.rotation_taking_u_to_v(n_hat,z_hat);


   R.az_el_roll_from_rotation(global_az,global_el,global_roll);

   for (int n=0; n<inlier_V.size(); n++)
   {
      threevector dV=inlier_V[n]-COM;
      dV=R*dV;
      inlier_V[n]=COM+dV;
   }
*/

   tdp_filename=bundler_IO_subdir+"cleaned_ba_points.tdp";
   tdpfunc::write_relative_xyz_data(tdp_filename,inlier_V);
   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv cleaned_ba_points.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);

   string banner="Exported cleaned bundle adjusted point cloud to "+
      bundler_IO_subdir+"cleaned_ba_points.osga";
   outputfunc::write_big_banner(banner);

/*
   for (int n=0; n<n_images; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photo_ptr->get_camera_ptr();

      camera_ptr->set_georegistered_flag(true);
      camera_ptr->convert_bundler_to_world_coords(
         COM,global_az,global_el,global_roll,1,COM);

      string package_filename=packages_subdir+
         "rotated_fitted_ba_geo_"+stringfunc::number_to_string(n)+".pkg";
      double frustum_sidelength=1000;	// meters
      camera_ptr->write_camera_package_file(
         package_filename,photo_ptr->get_ID(),
         photo_ptr->get_filename(),frustum_sidelength);
   } // loop over index c labeling camera ptrs
*/

// Export bundle.out file:

   string bundle_filename=bundler_IO_subdir+"bundle_ba.out";
   bundlerfunc::export_bundle_file(
      bundle_filename,photogroup_ptr,inlier_V);
}
