// =======================================================================
// Program RECONSTRUCT implements the approach of R. Gherardi and
// A. Fusiello, "Practical Autocalibration" for upgrading a projective
// reconstruction derived from just tiepoint pair matching between 2
// image planes to a Euclidean (metric) reconstruction.  It first
// imports fundamental matrices generated by program ASIFTVID and
// computes a canonical projective camera matrix.  In order to upgrade
// this initial projection to Euclidean form, the "plane at
// infinity" labeled by 3-vector v must be deduced.  

// RECONSTRUCT loops over reasonable ranges for the two cameras' focal
// parameters.  The calibration matrices for both cameras are assumed
// to have the simple form where focal parameter is effectively the
// only variable.  The plane at infinity is then estimated in
// closed-form, and the 4x4 matrix H which maps P_proj H = P_Euclidean
// is derived.  Intrinsic and extrinsic camera parameters are
// subsequently extracted.  

// The optimal focal parameters are taken to be those which yield the
// best intrinsic camera parameters. 

/*

./reconstruct \
--newpass ./bundler/GEO/pass04/images/20110730_110715.193.jpg \
--newpass ./bundler/GEO/pass04/images/20110730_110735.193.jpg 

*/

// =======================================================================
// Last updated on 1/12/13; 1/15/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "video/camerafuncs.h"
#include "general/filefuncs.h"
#include "structmotion/fundamental.h"
#include "numrec/nrfuncs.h"
#include "numerical/param_range.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::pair;
using std::string;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);

   nrfunc::init_time_based_seed();

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
//   int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;

// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group);
   int n_images=photogroup_ptr->get_n_photos();

   vector<string> image_filenames;
   for (int n=0; n<n_images; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
//      cout << "n = " << n << " *photo_ptr = " << *photo_ptr << endl;
      image_filenames.push_back(photo_ptr->get_filename());
      cout << n << " filename = " << image_filenames.back() << endl;
   } // loop over input images

   string fundamental_subdir="./fundamental_matrices/";
   fundamental* fundamental_ptr=new fundamental();
   for (int i=0; i<n_images; i++)
   {
      photograph* curr_photo_ptr=photogroup_ptr->get_photograph_ptr(i);
      string curr_filename=curr_photo_ptr->get_filename();
      camera* curr_camera_ptr=curr_photo_ptr->get_camera_ptr();

      for (int j=i+1; j<n_images; j++)
      {
         photograph* next_photo_ptr=photogroup_ptr->get_photograph_ptr(j);
         string next_filename=next_photo_ptr->get_filename();
         camera* next_camera_ptr=next_photo_ptr->get_camera_ptr();

         string fundamental_filename=fundamental_subdir+"fundamental_____"+
            filefunc::getbasename(curr_filename)+"_____"+
            filefunc::getbasename(next_filename)+".dat";

         genmatrix* F_ptr=mathfunc::import_from_dense_text_format(
            fundamental_filename);
         fundamental_ptr->set_F_values(*F_ptr);
         cout << "rank F = " << F_ptr->rank() << endl;
         cout << "e_XY = " << fundamental_ptr->get_epipole_XY() << endl;
         cout << "e_UV = " << fundamental_ptr->get_epipole_UV() << endl;
         
         delete F_ptr;

         F_ptr=fundamental_ptr->get_F_ptr();
         cout << "F = " << *F_ptr << endl;
         genmatrix* curr_proj_P_ptr=fundamental_ptr->
            compute_trivial_projection_matrix();
         genmatrix* next_proj_P_ptr=fundamental_ptr->
            compute_nontrivial_projection_matrix();
         cout << "curr_proj_P = " << *curr_proj_P_ptr << endl;
         cout << "next_proj_P = " << *next_proj_P_ptr << endl;
         fundamental_ptr->compute_from_projection_matrices(
            *curr_proj_P_ptr,*next_proj_P_ptr);

         threevector next_q;
         genmatrix next_Q(3,3);
         next_proj_P_ptr->get_smaller_matrix(next_Q);
         next_proj_P_ptr->get_column(3,next_q);
         cout << "next_Q = " << next_Q
              << " next_q = " << next_q << endl;

         outputfunc::enter_continue_char();

         param_range curr_f(-27,-23,5);	// geo
         param_range next_f(-27,-23,5);	// geo

//         param_range curr_f(-1.35,-1.35,1);	// kermit
//         param_range next_f(-1.35,-1.35,1);	// kermit


         int n_iters=1;
         for (int iter=0; iter<n_iters; iter++)
         {
            cout << "iter = " << iter << " of " << n_iters << endl;
            
// ========================================================================
// Begin while loop over camera focal parameters
// ========================================================================

            while (curr_f.prepare_next_value())
            {
               curr_camera_ptr->set_u0(
                  0.5*curr_photo_ptr->get_xdim()/curr_photo_ptr->get_ydim());
               curr_camera_ptr->set_v0(0.5);
               curr_camera_ptr->set_f(curr_f.get_value());
               curr_camera_ptr->construct_internal_parameter_K_matrix();
               genmatrix* curr_K_ptr=curr_camera_ptr->get_K_ptr();
               cout << "curr K = " << *curr_K_ptr << endl;
//               genmatrix* curr_Kinv_ptr=curr_camera_ptr->get_Kinv_ptr();
//               cout << "curr_camera = " << *curr_camera_ptr << endl; 
//               cout << "curr: K*Kinv = " << *curr_K_ptr * (*curr_Kinv_ptr)
//                    << endl;

               while (next_f.prepare_next_value())
               {
                  next_camera_ptr->set_u0(
                     0.5*next_photo_ptr->get_xdim()/next_photo_ptr->
                     get_ydim());
                  next_camera_ptr->set_v0(0.5);
                  next_camera_ptr->set_f(next_f.get_value());
                  next_camera_ptr->construct_internal_parameter_K_matrix();  
                  genmatrix* next_K_ptr=next_camera_ptr->get_K_ptr();
                  cout << "next K = " << *next_K_ptr << endl;
                  genmatrix* next_Kinv_ptr=next_camera_ptr->get_Kinv_ptr();
                  cout << "next Kinv = " << *next_Kinv_ptr << endl;
//                  cout << "next_camera = " << *next_camera_ptr << endl;
//                  cout << "next: K*Kinv = " << *next_K_ptr * (*next_Kinv_ptr)
//                       << endl;

                  threevector next_t=*next_Kinv_ptr * next_q;
                  cout << "next_t = " << next_t << endl;
                  threevector next_t_hat=next_t.unitvector();

                  rotation Rstar;
                  Rstar=Rstar.rotation_taking_u_to_v(next_t_hat,x_hat);
                  cout << "Rstar = " << Rstar << endl;
                  cout << "Rstar * Rstar^T = " << Rstar*Rstar.transpose()
                       << endl;
                  cout << "Rstar * next_t = " << Rstar*next_t << endl;

                  genmatrix W(3,3);
                  W=Rstar * (*next_Kinv_ptr) * next_Q * (*curr_K_ptr);
                  cout << "W = " << W << endl;

                  threevector w1,w2,w3;
                  W.get_row(0,w1);
                  W.get_row(1,w2);
                  W.get_row(2,w3);
                  threevector w3_hat=w3.unitvector();
                  threevector v=(w2.cross(w3_hat)-w1)/next_t.magnitude();
                  cout << "v = " << v << endl;

                  genmatrix R2(3,3),RstarRrel(3,3);
                  genmatrix term1(3,3),term2(3,3);
                  term1.clear_values();
                  term2.clear_values();
                  term2.put_row(0,next_t.magnitude()*v);
//                  cout << "term2 = " << term2 << endl;


                  RstarRrel=Rstar * (*next_Kinv_ptr) * next_Q * (*curr_K_ptr) 
                     + term2;
                  RstarRrel /= w3.magnitude();

                  cout << "RstarRrel = " << RstarRrel << endl;
                  cout << "Det(RstarRrel) = "
                       << RstarRrel.determinant() << endl;
                  cout << "RstarRrel*RstarRreltrans = " 
                       << RstarRrel * RstarRrel.transpose() << endl;

                  outputfunc::enter_continue_char();

                  double lambda=1;
                  fourvector v4(v,lambda);

                  genmatrix H(4,4);
                  H.clear_values();
                  H.put_smaller_matrix(*curr_K_ptr);
                  H.put_row(3,v4);
                  cout << "H = " << H << endl;

                  genmatrix curr_P(3,4),next_P(3,4);
                  curr_P=(*curr_proj_P_ptr) * H;
                  next_P=(*next_proj_P_ptr) * H;

                  cout << "curr_P = " << curr_P << endl;
                  cout << "next_P = " << next_P << endl;
                  curr_camera_ptr->set_projection_matrix(curr_P);
                  next_camera_ptr->set_projection_matrix(next_P);

/*
                  genmatrix curr_B(3,3),next_B(3,3);
                  genmatrix curr_K(3,3),curr_R(3,3);
                  genmatrix next_K(3,3),next_R(3,3);
                  
                  curr_P.get_smaller_matrix(curr_B);
                  next_P.get_smaller_matrix(next_B);
                  curr_B.RQ_decomposition(curr_K,curr_R);
                  next_B.RQ_decomposition(next_K,next_R);
                  
                  curr_K /= curr_K.get(2,2);
                  next_K /= next_K.get(2,2);

                  cout << "curr_K = " << curr_K << endl;
                  cout << "next_K = " << next_K << endl;
*/

                  curr_camera_ptr->decompose_projection_matrix();
                  curr_camera_ptr->print_external_and_internal_params();

                  next_camera_ptr->decompose_projection_matrix();
                  next_camera_ptr->print_external_and_internal_params();

                  rotation* curr_Rcamera_ptr=curr_camera_ptr->
                     get_Rcamera_ptr();
                  rotation* next_Rcamera_ptr=next_camera_ptr->
                     get_Rcamera_ptr();

                  cout << "*curr_Rcamera_ptr = " << *curr_Rcamera_ptr << endl;
                  cout << "*next_Rcamera_ptr = " << *next_Rcamera_ptr << endl;

                  double curr_az,curr_el,curr_roll;
                  double next_az,next_el,next_roll;

                  curr_Rcamera_ptr->az_el_roll_from_rotation(
                     curr_az,curr_el,curr_roll);
                  next_Rcamera_ptr->az_el_roll_from_rotation(
                     next_az,next_el,next_roll);

                  cout << "curr_az = " << curr_az*180/PI << endl;
                  cout << "curr_el = " << curr_el*180/PI << endl;
                  cout << "curr_roll = " << curr_roll*180/PI << endl;

                  cout << "next_az = " << next_az*180/PI << endl;
                  cout << "next_el = " << next_el*180/PI << endl;
                  cout << "next_roll = " << next_roll*180/PI << endl;

                  outputfunc::enter_continue_char();

               } // curr_f while loop
            } // next_f while loop
            
         } // iter loop
         


      } // loop over index j labeling next image
   } // loop over index i labeling curr image
   
   delete fundamental_ptr;


}
