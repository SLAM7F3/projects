// =======================================================================
// Program PARSE_SBA imports the refined structure from motion
// parameters file generated by SBA-1.6.  It resets the cameras'
// intrinsic and extrinsic parameters based upon the bundle-adjusted
// results.  It also exports a "sparse 3D cloud" corresponding to
// the bundle-adjusted triangulated points.
// =======================================================================
// Last updated on 2/5/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "video/camerafuncs.h"
#include "osg/osgFeatures/FeaturesGroup.h"
#include "general/filefuncs.h"
#include "geometry/geometry_funcs.h"
#include "geometry/linesegment.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "time/timefuncs.h"

using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::pair;
using std::string;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;
   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group);
   int n_cameras=photogroup_ptr->get_n_photos();

   threevector camera_world_COM(Zero_vector);
   vector<double> xdims,ydims;
   vector<camera*> camera_ptrs;
   for (int n=0; n<n_cameras; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);

//      cout << "n = " << n << " *photo_ptr = " << *photo_ptr << endl;
      camera* camera_ptr=photo_ptr->get_camera_ptr();
      camera_ptrs.push_back(camera_ptr);
      xdims.push_back(photo_ptr->get_ydim());
      ydims.push_back(photo_ptr->get_ydim());
      camera_world_COM += camera_ptr->get_world_posn();
   }
   camera_world_COM /= n_cameras;
   cout << "camera_world_COM = " << camera_world_COM << endl;

   threevector Uhat0=camera_ptrs[0]->get_Uhat();
   threevector Vhat0=camera_ptrs[0]->get_Vhat();
   threevector What0=camera_ptrs[0]->get_What();
   threevector origin=camera_ptrs[0]->get_world_posn();

   cout << "origin = " << origin << endl;
   outputfunc::enter_continue_char();

   string sba1_6_output_filename=bundler_IO_subdir+"sba1.6.out";
   filefunc::ReadInfile(sba1_6_output_filename);

// First, recover bundle adjusted intrinsic camera parameters:

   int line_number=0;
   for (int n=0; n<n_cameras; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photo_ptr->get_camera_ptr();

      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[line_number++]);

      double f_noah=fabs(column_values[0]);
      double f=-f_noah/ydims[n];
      cout << "camera_ID = " << n
           << " f = " << f << endl;
      camera_ptr->set_f(f);
      camera_ptr->construct_internal_parameter_K_matrix();      

      double rel_q0=column_values[5];
      double rel_q1=column_values[6];
      double rel_q2=column_values[7];
      double rel_q3=column_values[8];
      fourvector rel_quat(rel_q0,rel_q1,rel_q2,rel_q3);

      rotation dR;
      dR=dR.rotation_corresponding_to_quaternion(rel_quat);

      rotation R,Rcamera;
      rotation* R0camera_ptr=camera_ptrs[0]->get_Rcamera_ptr();
      Rcamera=dR * (*R0camera_ptr);
      camera_ptr->set_Rcamera(Rcamera);

      double rel_t0=column_values[9];
      double rel_t1=column_values[10];
      double rel_t2=column_values[11];
      threevector rel_trans=
         rel_t0*Uhat0+rel_t1*Vhat0+rel_t2*What0;
      threevector world_posn=origin+rel_trans;
      camera_ptr->set_world_posn(world_posn);

      camera_ptr->construct_projection_matrix(true);
      cout << "n = " << n << " camera = " << *camera_ptr << endl;

/*
      double scale_0 = 1;
      double xtrans_0 = 0;
      double ytrans_0 = 0;
      double ztrans_0 = 0;
      double az_0 = 0;
      double el_0 = 0;
      double roll_0 = 0;
      threevector bundler_COM(0,0,0);

      double global_scalefactor=scale_0;
      threevector world_COM(xtrans_0,ytrans_0,ztrans_0);
      double global_az=az_0*PI/180;
      double global_el=el_0*PI/180;
      double global_roll=roll_0*PI/180;

      camera_ptr->set_georegistered_flag(true);
      camera_ptr->convert_bundler_to_world_coords(
         bundler_COM,
         global_az,global_el,global_roll,
         global_scalefactor,world_COM);
*/
 
      string package_filename=bundler_IO_subdir+"packages/fitted_ba_geo_"
         +stringfunc::number_to_string(n)+".pkg";
      double frustum_sidelength=1000;	// meters
      camera_ptr->write_camera_package_file(
         package_filename,photo_ptr->get_ID(),
         photo_ptr->get_filename(),frustum_sidelength);
   } // loop over index n labeling cameras
   
// Second, recover bundle-adjusted world points:

   string adjusted_features_filename=bundler_IO_subdir+"sba_features_3D.txt";
   ofstream features_stream;
   features_stream.precision(12);
   filefunc::openfile(adjusted_features_filename,features_stream);
   features_stream << "# Time   Feature_ID   Passnumber   X  Y  Z  Score"
                   << endl;
   features_stream << endl;

   int feature_ID=0;
   int pass_number=n_cameras+1;
   double curr_time=0;
   double score=-1;
   vector<double> X,Y,Z;
   while (line_number < filefunc::text_line.size())
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[line_number++]);

      double rel_Unew=column_values[0];
      double rel_Vnew=column_values[1];
      double rel_Wnew=column_values[2];
      threevector rel_XYZnew=rel_Unew*Uhat0+rel_Vnew*Vhat0+rel_Wnew*What0;
      threevector XYZnew=origin+rel_XYZnew;
      threevector new_world_camera_posn=XYZnew;

      double world_X=new_world_camera_posn.get(0);
      double world_Y=new_world_camera_posn.get(1);
      double world_Z=new_world_camera_posn.get(2);
      X.push_back(world_X);
      Y.push_back(world_Y);
      Z.push_back(world_Z);

      features_stream << curr_time << "\t"
                      << feature_ID++ << "\t"
                      << pass_number << "\t"
                      << world_X << "\t"
                      << world_Y << "\t"
                      << world_Z << "\t"
                      << score << endl;
   }
   filefunc::closefile(adjusted_features_filename,features_stream);
   
   string UTMzone="";
   string tdp_filename=bundler_IO_subdir+"sba_points.tdp";
   tdpfunc::write_xyz_data(UTMzone,tdp_filename,X,Y,Z);
   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv sba_points.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
}
