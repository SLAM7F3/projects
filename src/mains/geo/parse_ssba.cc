// =======================================================================
// Program PARSE_SSBA imports the refined structure from motion
// parameters file generated by SSBA-3.0.  It resets the cameras'
// intrinsic and extrinsic parameters based upon the bundle-adjusted
// results.  It also exports a "sparse 3D cloud" corresponding to
// the bundle-adjusted triangulated points.
// =======================================================================
// Last updated on 2/8/13; 2/27/13; 2/28/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "video/camerafuncs.h"
#include "osg/osgFeatures/FeaturesGroup.h"
#include "general/filefuncs.h"
#include "geometry/geometry_funcs.h"
#include "geometry/linesegment.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "time/timefuncs.h"

using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::pair;
using std::string;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
//   int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;
   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group);
   int n_images=photogroup_ptr->get_n_photos();

   threevector camera_world_COM(Zero_vector);
   vector<double> xdims,ydims;
   vector<camera*> camera_ptrs;
   for (int n=0; n<n_images; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);

//      cout << "n = " << n << " *photo_ptr = " << *photo_ptr << endl;
      camera* camera_ptr=photo_ptr->get_camera_ptr();
      camera_ptrs.push_back(camera_ptr);
      xdims.push_back(photo_ptr->get_ydim());
      ydims.push_back(photo_ptr->get_ydim());
      camera_world_COM += camera_ptr->get_world_posn();
   }
   camera_world_COM /= n_images;
   cout << "camera_world_COM = " << camera_world_COM << endl;

   string refined_ssba_filename=bundler_IO_subdir+"/ssba.output";
   filefunc::ReadInfile(refined_ssba_filename);

   int line_number=0;
   vector<double> column_values=stringfunc::string_to_numbers(
      filefunc::text_line[line_number++]);
   int n_features=column_values[0];
   int n_cameras=column_values[1];
   int n_UV_features=column_values[2];
   
   cout << "n_features = " << n_features
        << " n_cameras = " << n_cameras
        << " n_UV_features = " << n_UV_features << endl;

// First, recover bundle adjusted intrinsic camera parameters:

   for (int n=0; n<n_cameras; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photo_ptr->get_camera_ptr();

      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[line_number++]);

      double f_noah=fabs(column_values[0]);
      double f=-f_noah/ydims[n];

      cout << "camera_ID = " << n
           << " f = " << f << endl;
      camera_ptr->set_f(f);
      camera_ptr->construct_internal_parameter_K_matrix();      

   } // loop over index n labeling cameras
   
// Second, recover bundle-adjusted world points:

   string adjusted_features_filename=bundler_IO_subdir+"ba_features_3D.txt";
   ofstream features_stream;
   features_stream.precision(12);
   filefunc::openfile(adjusted_features_filename,features_stream);
   features_stream << "# Time   Feature_ID   Passnumber   X  Y  Z  Score"
                   << endl;
   features_stream << endl;

   double curr_time=0;
   double score=-1;
   vector<double> X,Y,Z;
   for (int f=0; f<n_features; f++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[line_number++]);

      int feature_ID=column_values[0];
      int pass_number=n_cameras+1;

      double world_X=column_values[1]+camera_world_COM.get(0);
      double world_Y=column_values[2]+camera_world_COM.get(1);
      double world_Z=column_values[3]+camera_world_COM.get(2);
      X.push_back(world_X);
      Y.push_back(world_Y);
      Z.push_back(world_Z);

      int n_skip=10;
      if (f%n_skip != 0) continue;

      features_stream << curr_time << "\t"
                      << feature_ID << "\t"
                      << pass_number << "\t"
                      << world_X << "\t"
                      << world_Y << "\t"
                      << world_Z << "\t"
                      << score << endl;
   }

   filefunc::closefile(adjusted_features_filename,features_stream);
   
   string UTMzone="";
   string tdp_filename=bundler_IO_subdir+"ba_points.tdp";
   tdpfunc::write_xyz_data(tdp_filename,&X,&Y,&Z);
   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv ba_points.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
   
// Third, recover bundle-adjusted extrinsic camera parameters.  Export
// bundle-adjusted camera posns to output text file:

   string cameraposns_filename=
      bundler_IO_subdir+"unfitted_reconstructed_camera_posns.dat";
   ofstream cameraposns_stream;
   cameraposns_stream.precision(10);
   filefunc::openfile(cameraposns_filename,cameraposns_stream);

   genmatrix RT(3,4),P(3,4);
   for (int n=0; n<n_cameras; n++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[line_number++]);
      fourvector row0(
         column_values[1],column_values[2],column_values[3],column_values[4]);
      fourvector row1(
         column_values[5],column_values[6],column_values[7],column_values[8]);
      fourvector row2(
         column_values[9],column_values[10],column_values[11],
         column_values[12]);
      RT.put_row(0,row0);
      RT.put_row(1,row1);
      RT.put_row(2,row2);

      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photo_ptr->get_camera_ptr();
      genmatrix* K_ptr=camera_ptr->get_K_ptr();

      P=*K_ptr * RT;
      camera_ptr->set_projection_matrix(P);

      threevector camera_world_posn=camera_ptr->get_world_posn();

// FAKE FAKE:  Fri Jan 18, 2013 at 3 pm

//       camera_world_COM=Zero_vector;
      
      camera_world_posn += camera_world_COM;
      camera_ptr->set_world_posn(camera_world_posn);
      camera_ptr->construct_projection_matrix(false);

      cout << "n = " << n << " camera = " << *camera_ptr << endl;

// Convert from raw "bundler" bundle-adjusted coordinates to "GPS
// georegistered" world coordinates:

/*
      double global_scalefactor=1.052979853;
      threevector world_COM(314444.0623 , 4700049.1 , 2713.5);
      double global_az=-0.2487279036*PI/180;
      double global_el=-3.793763499*PI/180;
      double global_roll=12.69756108*PI/180;
      threevector bundler_COM(104.0291525 , 22.5964775 , 1.6360275);
*/

/*
// Convert from raw "bundler" bundle-adjusted coordinates to "ALIRT
// georegistered" world coords:

      double global_scalefactor = 0.8616945584;
      threevector world_COM(
         311665.3423 , 4703563.833 , 16.31179977);
      double global_az = 3.021678089*PI/180;
      double global_el = -6.642653843 * PI/180;
      double global_roll = -0.2673540243 * PI/180;
      threevector bundler_COM( -2868.85, 3487.565, -2678.050625 ); 
*/

/*
      double scale_0 = 0.9913657045;
      double xtrans_0 = 312221.0863;
      double ytrans_0 = 4702860.887;
      double ztrans_0 = 555.7494398;
      double az_0 = 0.279611991;
      double el_0 = 3.878330425;
      double roll_0 = 2.406226176;
      threevector bundler_COM( -2274.274169, 2794.571295, -2142.113295 ); 
*/

      double scale_0 = 1;
      double xtrans_0 = 0;
      double ytrans_0 = 0;
      double ztrans_0 = 0;
      double az_0 = 0;
      double el_0 = 0;
      double roll_0 = 0;
      threevector bundler_COM(0,0,0);

      double global_scalefactor=scale_0;
      threevector world_COM(xtrans_0,ytrans_0,ztrans_0);
      double global_az=az_0*PI/180;
      double global_el=el_0*PI/180;
      double global_roll=roll_0*PI/180;

      camera_ptr->set_georegistered_flag(true);
      camera_ptr->convert_bundler_to_world_coords(
         bundler_COM,
         global_az,global_el,global_roll,
         global_scalefactor,world_COM);

      string package_filename=bundler_IO_subdir+"packages/fitted_ba_geo_"
         +stringfunc::integer_to_string(n,3)+".pkg";
      double frustum_sidelength=1000;	// meters
      camera_ptr->write_camera_package_file(
         package_filename,photo_ptr->get_ID(),
         photo_ptr->get_filename(),frustum_sidelength);

      threevector camera_posn=camera_ptr->get_world_posn();
      cameraposns_stream 
         << n << "  "
         << filefunc::getbasename(photo_ptr->get_filename()) << "  "
         << camera_posn.get(0) << "  "
         << camera_posn.get(1) << "  "
         << camera_posn.get(2) 
         << endl;

   } // loop over index n labeling cameras

   filefunc::closefile(cameraposns_filename,cameraposns_stream);

   string banner="Exported bundle adjusted point cloud to "+
      bundler_IO_subdir+"ba_points.osga";
   outputfunc::write_big_banner(banner);
   banner="Exported bundle adjusted package files to "+
      bundler_IO_subdir+"packages/";
   outputfunc::write_big_banner(banner);
   banner="Exported bundle adjusted camera positions to "+
      cameraposns_filename;
   outputfunc::write_big_banner(banner);
}
