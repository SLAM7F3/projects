// ========================================================================
// Program WRITE_BUNDLEOUT is a specialized utility which reads in
// measured camera parameters for a GEO flight from summer 2011 around
// HAFB from image package files.  The package files are generated by
// mains/aerosynth/VISUALIZE_FLIR_METADATA.  It exports a "bundle.out"
// file corresponding to measured camera parameters for a GEO flight
// from summer 2011 around HAFB.
// ========================================================================
// Last updated on 1/7/12; 1/10/12; 1/18/12
// ========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <osgDB/FileUtils>

#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

#include "general/outputfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string image_sizes_filename=passes_group.get_image_sizes_filename();
   cout << "image_sizes_filename = " << image_sizes_filename << endl;

// Read photographs from input low-defn pass:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group,image_sizes_filename);
   int n_photos=photogroup_ptr->get_n_photos();
   cout << "n_photos = " << n_photos << endl;

   ofstream bundlestream;
   bundlestream.precision(10);
   string bundle_filename="junk_bundle_measured.out";
   filefunc::openfile(bundle_filename,bundlestream);
   bundlestream <<  "# Bundle file v0.3" << endl;
   bundlestream << n_photos << "  0 " << endl;

// As of 1/7/2012, we suspect that the very large order of magnitude
// differences between easthing and northing coordinates vs altitude
// values can signficantly corrupt 3D reconstruction.  So compute the
// flightpath's COM.  Remove the COM's easting and northing from all
// camera positions written to bundle_measured.out:

   threevector world_posn_COM(Zero_vector);
   for (int n=0; n<n_photos; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photo_ptr->get_camera_ptr();
//      cout << "n = " << n
//           << " camera = " << *camera_ptr << endl;
      threevector camera_world_posn=camera_ptr->get_world_posn();
      world_posn_COM += camera_world_posn;
   }
   world_posn_COM /= n_photos;
   cout << "world_posn_COM = " << world_posn_COM << endl;

// For GEO orbit around flight facility on Jan 5, 2012 with 5 deg FOV,
// world_posn_COM = 

//	 312827.375
//	4705407.279
//	    720.7393939

// For GEO flyby pass of flight facility on Jan 5, 2012 with 5 deg FOV,
// world_posn_COM = 

//   314843.6358
//  4703596.685
//      713.0111732

// For GEO pass on July 28 with 5 deg FOV, world_posn_COM = 

//	 313440.3949
// 	4705909.974
// 	   2347.180602

// For GEO pass 04 with 5 deg FOV, world_posn_COM = 

//   313875.9924
//  4704551.411
//     2704.825806

// For GEO pass 15 with 5 deg FOV, world_posn_COM = 

//    312448.1034
//   4702421.792
//       802.3381643

   for (int n=0; n<n_photos; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photo_ptr->get_camera_ptr();
//      cout << "n = " << n
//           << " camera = " << *camera_ptr << endl;

//      unsigned int width=photo_ptr->get_xdim();
      unsigned int height=photo_ptr->get_ydim();
      double f_noah=fabs(camera_ptr->get_fu())*height;
//      double k2=camera_ptr->get_kappa2();
//      double k4=camera_ptr->get_kappa4();
      
//      cout << f_noah << "  "  << k2 << "  " << k4 << endl;
      bundlestream << f_noah << " 0.0 0.0" << endl;

      rotation* Rcamera_ptr=camera_ptr->get_Rcamera_ptr();
//      cout << "*Rcamera_ptr = " << *Rcamera_ptr << endl;

      for (int i=0; i<3; i++)
      {
         for (int j=0; j<3; j++)
         {
            bundlestream << Rcamera_ptr->get(i,j) << " ";
         }
         bundlestream << endl;
      }
      
      threevector camera_world_posn=camera_ptr->get_world_posn();
      threevector rel_camera_world_posn=camera_world_posn-world_posn_COM;
      threevector trans_noah=-(*Rcamera_ptr)*rel_camera_world_posn;

//      cout << "n = " << n 
//           << " camera_X = " << camera_world_posn.get(0)
//           << " camera_Y = " << camera_world_posn.get(1)
//           << " camera_Z = " << camera_world_posn.get(2)
//           << endl;
      
//      cout << "trans_noah = " << trans_noah << endl;
      bundlestream << trans_noah.get(0) << " "
                   << trans_noah.get(1) << " "
                   << trans_noah.get(2) << endl;

   } // loop over index n labeling input photos

   filefunc::closefile(bundle_filename,bundlestream);

   string banner="Wrote "+bundle_filename;
   outputfunc::write_big_banner(banner);

}
