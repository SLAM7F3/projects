// ==========================================================================
// Program GENERATE_EDGELIST imports image basenames from
// bundler_IO_subdir/image_list.dat .  It next recovers coarse image
// matching scores generated by program COLOR_BOW_IMAGE_COMPARISONS.
// After querying the user to enter a minimum graph edge weight
// threshold, GENERATE_EDGELIST exports an edge list which can be used
// to form an image search network.
// ==========================================================================
// Last updated on 12/15/13; 1/1/14; 1/9/14
// ==========================================================================

#include  <iostream>
#include  <map>
#include  <string>
#include  <vector>

#include "general/filefuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(12);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string image_list_filename=passes_group.get_image_list_filename();
   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";
   filefunc::dircreate(graphs_subdir);

// Import basic HOG BoW processing parameters:

   string gist_subdir="../gist/";
   string BoW_params_filename=gist_subdir+"BoW_params.dat";
   filefunc::ReadInfile(BoW_params_filename);

   bool video_frames_input_flag=
      stringfunc::string_to_boolean(filefunc::text_line[8]);
   cout << "video_frames_input_flag = " << video_frames_input_flag << endl;

   string JAV_subdir;
   if (video_frames_input_flag)
   {
      string ImageEngine_subdir="/data/ImageEngine/";
      string BostonBombing_subdir=ImageEngine_subdir+"BostonBombing/";

      cout << "1: early September 2013 NewsWraps" << endl;
      cout << "2: October 2013 NewsWraps with transcripts" << endl;
      cout << "3: Boston Bombing YouTube clips 1 - 25" << endl;

      int video_corpus_ID;
      cout << "Enter video corpus ID:" << endl;
      cin >> video_corpus_ID;
   
      if (video_corpus_ID==1)
      {
         JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
      }
      else if (video_corpus_ID==2)
      {
         JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
      }
      else if (video_corpus_ID==3)
      {
         JAV_subdir=BostonBombing_subdir+"clips_1_thru_25/";
      }
      else
      {
         exit(-1);
      }
   }
   else
   {
      JAV_subdir="./bundler/tidmarsh/";
   } // video_frames_input_flag conditional
   cout << "JAV_subdir = " << JAV_subdir << endl;

   string root_subdir=JAV_subdir;
   string matching_BoW_subdir=root_subdir+"matching_images_BoW/";

// First import image basenames into STL map image_basename_map:

   typedef map<string,int> IMAGE_BASENAME_MAP;
   IMAGE_BASENAME_MAP image_basename_map;
   IMAGE_BASENAME_MAP::iterator iter;
   
   filefunc::ReadInfile(image_list_filename);
   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      string basename=filefunc::getbasename(filefunc::text_line[i]);
      image_basename_map[basename]=i;
//      cout << "image_basename = " << basename << " i = " << i << endl;
   }
   cout << "image_basename_map.size() = " << image_basename_map.size()
        << endl;

// Open output coarse image matching edge list file:

   double weight_threshold;
   cout << "Enter minimum edge weight threshold:" << endl;
   cin >> weight_threshold;

   string edgelist_filename=graphs_subdir+"new_coarse_matching_edgelist.dat";
   ofstream edgelist_stream;
   filefunc::openfile(edgelist_filename,edgelist_stream);
   edgelist_stream << "# Edge weight threshold = " << weight_threshold << endl;
   edgelist_stream << "# NodeID  NodeID'  Edge weight" << endl << endl;

// Next import coarse image matching scores as functions of image
// basenames:

   string scores_filename=matching_BoW_subdir+"scores.dat";
//   cout << "scores_filename = " << scores_filename << endl;

   vector<vector<string> > RowSubstrings=filefunc::
      ReadInSubstrings(scores_filename);
   for (unsigned int r=0; r<RowSubstrings.size(); r++)
   {
      double match_prob=stringfunc::string_to_number(RowSubstrings[r].at(0));
      double weight=100*match_prob;
      if (weight < weight_threshold) continue;

      string image_basename1=RowSubstrings[r].at(1)+".jpg";
      iter=image_basename_map.find(image_basename1);
      if (iter==image_basename_map.end()) continue;
      int image_ID1=iter->second;

//      cout << "image_basename1 = " << image_basename1
//           << " image_ID1 = " << image_ID1 << endl;

      string image_basename2=RowSubstrings[r].at(2)+".jpg";
      iter=image_basename_map.find(image_basename2);
      if (iter==image_basename_map.end()) continue;
      int image_ID2=iter->second;

      edgelist_stream  << image_ID1 << "   " << image_ID2 << "   " 
                       << weight << endl;
      
   } // loop over index r labeling rows in scores_filename

   filefunc::closefile(edgelist_filename,edgelist_stream);
   
   string banner="Exported edge list to "+edgelist_filename;
   outputfunc::write_banner(banner);

   banner="At end of program GENERATE_EDGELIST";
   outputfunc::write_big_banner(banner);
}

