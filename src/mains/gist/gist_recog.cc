// ==========================================================================
// Program GIST_RECOG imports gist descriptors for 8 outdoor scenes.
// It classifies each descriptor as belonging or not to each of the 8
// categories based upon their thresholded probability values.

//				gist_recog

// ==========================================================================
// Last updated on 3/31/13; 4/6/13
// ==========================================================================

#include  <iostream>
#include  <map>
#include  <set>
#include  <string>
#include  <vector>
#include "dlib/svm.h"

#include "image/compositefuncs.h"
#include "video/connected_components.h"
#include "general/filefuncs.h"
#include "image/graphicsfuncs.h"
#include "image/imagefuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/RGB_analyzer.h"
#include "classification/signrecogfuncs.h"
#include "classification/text_detector.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::ios;
using std::map;
using std::pair;
using std::string;
using std::vector;


int main(int argc, char* argv[])
{
   cout.precision(12);

   string outdoor_categories_subdir="./all_images/combined_image_links/";

   std::vector<string> scene;
   scene.push_back("coast");
   scene.push_back("forest");
   scene.push_back("highway");
   scene.push_back("insidecity");
   scene.push_back("mountain");
   scene.push_back("opencountry");
   scene.push_back("street");
   scene.push_back("tallbldg");
   int n_scenes=scene.size();

// Import probabilistic decision functions generated by an SVM with a
// linear kernel on N scene and N' non-scene GIST descriptors:

   const int K=3*512;

   typedef dlib::matrix<double, K, 1> Ng_sample_type;
   typedef dlib::linear_kernel<Ng_sample_type> Ng_kernel_type;
   Ng_sample_type Ng_sample;

   typedef dlib::probabilistic_decision_function<Ng_kernel_type> 
      Ng_probabilistic_funct_type;  
   typedef dlib::normalized_function<Ng_probabilistic_funct_type> 
      Ng_pfunct_type;
   Ng_pfunct_type Ng_pfunct;
   vector<Ng_pfunct_type> Ng_pfuncts;

   for (unsigned int scene_index=0; scene_index < scene.size(); scene_index++)
   {
      cout << "--------------------------------------------------------------" 
           << endl;
      cout << "s = " << scene_index
           << " scene label = " << scene[scene_index]
           << endl;

      string learned_funcs_subdir="./learned_functions/"+scene[scene_index]
         +"/";
      string learned_Ng_pfunct_filename=learned_funcs_subdir;
      learned_Ng_pfunct_filename += "symbols_Ng_pfunct.dat";
      cout << "learned_Ng_pfunct_filename = "
           << learned_Ng_pfunct_filename << endl;
      ifstream fin6(learned_Ng_pfunct_filename.c_str(),ios::binary);
      deserialize(Ng_pfunct, fin6);
      Ng_pfuncts.push_back(Ng_pfunct);
   } // loop over scene_index
   
// Import GIST descriptors for test images:

   double scene_gist_threshold=0.90;
   cout << "Enter scene gist threshold:" << endl;
   cin >> scene_gist_threshold;

   for (unsigned int scene_index=0; scene_index < scene.size(); scene_index++)
   {
      cout << "--------------------------------------------------------------" 
           << endl;
      cout << "s = " << scene_index
           << " scene label = " << scene[scene_index]
           << endl;

      string curr_image_subdir=outdoor_categories_subdir+scene[scene_index]
         +"/";
      string gist_subdir=curr_image_subdir+"gist_files/";

      flann::Matrix<float> scene_descriptors;

// Import scene GIST descriptors:

      cout << "Loading scene descriptors" << endl;
      string scene_descriptors_hdf5_filename=gist_subdir+
         "scene_gist_descriptors.hdf5";
      cout << "scene_descrips_filename = "
           << scene_descriptors_hdf5_filename << endl;

      flann::load_from_file(
         scene_descriptors,scene_descriptors_hdf5_filename.c_str(),
         "gist_descriptors");

      cout << "scene_descriptors.rows = " << scene_descriptors.rows << endl;
      cout << "scene_descriptors.cols = " << scene_descriptors.cols << endl;
      int N_images=scene_descriptors.rows;

// Loop over individual video frames starts here:

      int n_rejections=0;
      int n_acceptances=0;
      int n_correct_acceptances=0;
      int n_wrong_acceptances=0;

      int i_start=400;
      int i_stop=N_images;

      vector<double> classification_probabilities;
      int n_samples=(i_stop-i_start);
      for (int i=i_start; i<i_stop; i++)
      {
         for (int k=0; k<K; k++)
         {
            Ng_sample(k)=scene_descriptors[i][k];
         } // loop over index k labeling gist descriptors

// Looping over all decision functions, evaluate classification
// probabilities.  Ignore any probability which falls below
// scene_gist_threshold.  Classify image based upon maximal surviving
// probability:

         int max_s=-1;
         double max_classification_prob=-1;
         for (int s=0; s<n_scenes; s++)
         {
            double classification_prob=Ng_pfuncts[s](Ng_sample);
            if (classification_prob > max_classification_prob)
            {
               max_classification_prob=classification_prob;
               max_s=s;
            }
         } // loop over index s labeling scenes

         if (max_classification_prob < scene_gist_threshold)
         {
            n_rejections++;
         }
         else
         {
            n_acceptances++;
            if (max_s==int(scene_index))
            {
               n_correct_acceptances++;
            }
            else
            {
               n_wrong_acceptances++;
            }
         }
         classification_probabilities.push_back(max_classification_prob);
//         cout << "i = " << i << " Ng probability = " << classification_prob << endl;

      } // loop over index i labeling image filenames

/*
      double mu_classification_prob=mathfunc::mean(
         classification_probabilities);
      double sigma_classification_prob=mathfunc::std_dev(
         classification_probabilities);
      double median_classification_prob,quartile_width;
      mathfunc::median_value_and_quartile_width(
         classification_probabilities,median_classification_prob,
         quartile_width);
      cout << "classification_prob = " << mu_classification_prob 
           << " +/- " << sigma_classification_prob
           << endl;
      cout << "median = " << median_classification_prob
           << " quartile_width = " << quartile_width << endl;
*/

      double rejections_frac=double(n_rejections)/double(n_samples);
      double wrong_acceptances_frac=double(n_wrong_acceptances)/
         double(n_samples);
      double correct_acceptances_frac=double(n_correct_acceptances)/
         double(n_samples);
      double total_good_frac=(1-rejections_frac)*
         (1-wrong_acceptances_frac)*(correct_acceptances_frac);

      cout << "n_samples = " << n_samples << endl;
      cout << "n_rejections = " << n_rejections << endl;
      cout << "n_wrong_acceptances = " << n_wrong_acceptances << endl;
      cout << "n_correct_acceptances = " << n_correct_acceptances << endl;

      cout << "rejections_frac = " << rejections_frac << endl;
      cout << "wrong_acceptances_frac = " << wrong_acceptances_frac
           << endl;
      cout << "correct_acceptances_frac = " << correct_acceptances_frac
           << endl;
      cout << "total_good_frac = " << total_good_frac << endl;

//      outputfunc::enter_continue_char();

   } // loop of scene_index 
   

}
