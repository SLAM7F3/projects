// ==========================================================================
// Program COMPARE_COLOR_HISTOGRAMS imports a set of color
// histograms generated by program COMPUTE_COLOR_HISTOGRAMS.
// Looping over all imported histograms, it calculates dotproducts
// between successive pairs.  If the compared color
// histograms do not correspond to temporally adjacent video frames,
// the dotproducts are sorted in descending order.  Dotproducts
// exceeding a specified threshold value are exported to an output
// text file with the corresponding pair's image filenames.

//		      ./compare_color_histograms

// ==========================================================================
// Last updated on 11/8/13; 12/12/13; 12/21/13
// ==========================================================================

#include <cstdlib>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "math/ltduple.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "video/RGB_analyzer.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   bool keyframes_flag=true;
   bool different_clips_flag=false;
   bool adjacent_frames_flag=false;

   string input_char;
   cout << "Enter 'k' to process just video keyframes:" << endl;
   cin >> input_char;
   if (input_char != "k")
   {
      keyframes_flag=false;
   }
   cout << "Enter 'w' to compare histograms within and not between clips:"
        << endl;
   cin >> input_char;
   if (input_char != "w")
   {
      different_clips_flag=true;
   }

/*
   cout << "Enter 'a' to compare histograms between temporal neighbor video frames:" << endl;
   cin >> input_char;
   if (input_char=="a")
   {
      adjacent_frames_flag=true;
   }
*/

   string ImageEngine_subdir="/data/ImageEngine/";
   string BostonBombing_subdir=ImageEngine_subdir+"BostonBombing/";
   string JAV_subdir=BostonBombing_subdir+"clips_1_thru_25/";
   string root_subdir=JAV_subdir;
   string images_subdir=root_subdir+"jpg_frames/";
   string keyframes_subdir=images_subdir+"keyframes/";
   double min_dotproduct=0.0;

/*
//   string JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
   string JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
//   string JAV_subdir="/data/video/JAV/UIUC_Broadcast_News/";
   string root_subdir=JAV_subdir;
   string images_subdir=root_subdir+"jpg_frames/";
   string keyframes_subdir=images_subdir+"keyframes/";
//   double min_dotproduct=0.5156;	// NewsWraps
//   double min_dotproduct=0.2;	// NewsWraps
   double min_dotproduct=0.05;	// NewsWraps
*/

//   if (!different_clips_flag) min_dotproduct=0.76;
   if (!different_clips_flag) min_dotproduct=0.75;	// OK for keyframe ID
//   if (!different_clips_flag) min_dotproduct=0.74;

// Report all color matching scores when we're comparing keyframes
// within same video clips:

   if (keyframes_flag && !different_clips_flag && !adjacent_frames_flag)
      min_dotproduct=0;

// Report all color matching scores when we're comparing just
// temporally adjacent video frames:

   if (adjacent_frames_flag) min_dotproduct=0; 

//   string images_subdir=ImageEngine_subdir+"/tidmarsh/";
//   string images_subdir=tidmarsh_subdir;
//   string root_subdir=tidmarsh_subdir;
//   double min_dotproduct=0.53;	// Tidmarsh

// Store keyframes' clip and frame IDs within STL map keyframes_map:

   typedef map<DUPLE,string> KEYFRAMES_MAP;
   KEYFRAMES_MAP keyframes_map;

// independent DUPLE holds video image clip and frame ID
// dependent string holds video image's filename

   if (keyframes_flag)
   {
      vector<string> keyframe_filenames=filefunc::image_files_in_subdir(
         keyframes_subdir);

      for (int i=0; i<keyframe_filenames.size(); i++)
      {
         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
               filefunc::getbasename(keyframe_filenames[i])," _-");
//         for (int s=0; s<substrings.size(); s++)
//         {
//            cout << "i = " << i << " s = " << s << " substring[s] = " 
//                 << substrings[s] << endl;
//         }

// If input filename has form clip_0000_frame-00001.jpg, record clip's
// ID within STL vector:

         int clip_ID=-1;
         int frame_ID=-1;
         if (substrings.size()==4)
         {
            if (substrings[0]=="clip")
            {
               clip_ID=stringfunc::string_to_number(substrings[1]);
               frame_ID=stringfunc::string_to_number(substrings[3]);
               keyframes_map[DUPLE(clip_ID,frame_ID)]=keyframe_filenames[i];
            }
         }
      } // loop over index i labeling keyframe filenames
      
   } // keyframes_flag conditional
   cout << "keyframes_map.size() = " << keyframes_map.size() << endl;

   bool global_color_histogram_flag=true;
   cout << "Enter 'g' to compare global rather than local color histograms"
        << endl;
   cin >> input_char;
   if (input_char != "g")
   {
      global_color_histogram_flag=false;
   }

   string color_histograms_subdir=root_subdir+"global_color_histograms/";
   if (!global_color_histogram_flag)
      color_histograms_subdir=root_subdir+"color_histograms/";

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("color_hist");
   vector<string> histogram_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,color_histograms_subdir);

   timefunc::initialize_timeofday_clock();      

   int n_rows=1;
   int n_columns=1;
   if (!global_color_histogram_flag)
   {
      n_rows=3;
      n_columns=3;
   }
   
   RGB_analyzer* RGB_analyzer_ptr=new RGB_analyzer();
   int n_colors=n_rows*n_columns*RGB_analyzer_ptr->get_n_color_indices();
       // 33*n_rows_n_columns
   delete RGB_analyzer_ptr;

   int n_bins=n_colors;
   cout << "n_histogram_bins = " << n_bins << endl;

// Import color histograms generated by program COMPUTE_COLOR_HISTS:

   string banner="Importing color histograms from text files:";
   outputfunc::write_banner(banner);

   vector<string> hist_filenames;
   vector<float*> histogram_ptrs;
   for (int i=0; i<histogram_filenames.size(); i++)
   {
      outputfunc::update_progress_fraction(i,100,histogram_filenames.size());
//      cout << "i = " << i << " histogram_filename = " 
//           << histogram_filenames[i] << endl;

      if (keyframes_flag && keyframes_map.size() > 0)
      {
         string basename=filefunc::getbasename(histogram_filenames[i]);
         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
               stringfunc::prefix(basename)," _-");
//         for (int s=0; s<substrings.size(); s++)
//         {
//            cout << " s = " << s << " substring[s] = " 
//                 << substrings[s] << endl;
//         }

// If input filename has form clip_0000_frame-00001, record clip's
// ID within STL vector:

         int clip_ID=-1;
         int frame_ID=-1;
         if (substrings.size()==4)
         {
            if (substrings[0]=="clip")
            {
               clip_ID=stringfunc::string_to_number(substrings[1]);
               frame_ID=stringfunc::string_to_number(substrings[3]);
               KEYFRAMES_MAP::iterator keyframe_iter=keyframes_map.find(
                  DUPLE(clip_ID,frame_ID));
               if (keyframe_iter==keyframes_map.end())
               {
                  continue;
               }
//               else
//               {
//                  cout << "clip_ID = " << clip_ID << " frame_ID = " << frame_//ID
//                       << " is a keyframe" << endl;
//               }
            }
         } // substrings.size() conditional
      } // keyframes_flag conditional

      vector<double> curr_bin_values=filefunc::ReadInNumbers(
         histogram_filenames[i]);
      float* curr_histogram_ptr=new float[n_bins];
      histogram_ptrs.push_back(curr_histogram_ptr);
      hist_filenames.push_back(histogram_filenames[i]);

      for (int j=0; j<curr_bin_values.size(); j++)
      {
         (curr_histogram_ptr)[j]=curr_bin_values[j];
      }
   } // loop over index i labeling input histogram files
   int n_histograms=histogram_ptrs.size();
   cout << "n_histograms = " << n_histograms << endl;


   cout << endl;
   cout << "Computing color histogram matching scores:" << endl;
   cout << endl;

//   bool conventional_dotproduct_flag=true;
   bool conventional_dotproduct_flag=false;
   int i_max=n_histograms;
   int j_max=i_max;
   vector<float> dotproducts,color_dotproducts;
   vector<string> image_pair_names;

   for (int i=0; i<i_max-1; i++)
   {
      outputfunc::update_progress_fraction(i,1000,n_histograms);
      float* curr_histogram_ptr=histogram_ptrs[i];

      float curr_norm=0;
      if (conventional_dotproduct_flag)
      {
         for (int b=0; b<n_bins; b++)
         {
            curr_norm += sqr(curr_histogram_ptr[b]);
         }
         curr_norm=sqrt(curr_norm);
      }

      if (adjacent_frames_flag) j_max=basic_math::min(i+2,i_max);

      for (int j=i+1; j<j_max; j++)
      {
         float* next_histogram_ptr=histogram_ptrs[j];

         float dotproduct=0;
         if (conventional_dotproduct_flag)
         {
            float next_norm=0;
            for (int b=0; b<n_bins; b++)
            {
               dotproduct += curr_histogram_ptr[b]*next_histogram_ptr[b];
               next_norm += sqr(next_histogram_ptr[b]);
            }
            next_norm=sqrt(next_norm);
            dotproduct /= (curr_norm*next_norm);
         }
         else
         {

// Nonparametric dissimilarity measure:

            for (int b=0; b<n_bins; b++)
            {
               double numer=fabs(next_histogram_ptr[b]-curr_histogram_ptr[b]);
               double denom=fabs(next_histogram_ptr[b]+curr_histogram_ptr[b]);

               if (nearly_equal(numer,0) || nearly_equal(denom,0)) continue;
               dotproduct += numer/denom;
            }
            dotproduct /= n_bins;

// Transform "dotproduct" so that unity [zero] value indicates
// similarity [dissimilarity]"

            dotproduct=1-dotproduct;

//            cout << "Nonparameteric dissimilarity measure = " 
// 		   << dotproduct << endl;
         }
         dotproducts.push_back(dotproduct);

         if (dotproduct < min_dotproduct) continue;

         color_dotproducts.push_back(dotproduct);

         string basename_i=filefunc::getbasename(hist_filenames[i]);
         string basename_j=filefunc::getbasename(hist_filenames[j]);
//         string basename_i=filefunc::getbasename(histogram_filenames[i]);
//         string basename_j=filefunc::getbasename(histogram_filenames[j]);
//         cout << "basename_i = " << basename_i << endl;
//         cout << "basename_j = " << basename_j << endl;
         
         image_pair_names.push_back(
            stringfunc::prefix(basename_i)+"  "+
            stringfunc::prefix(basename_j) );
//         cout << "image_pair_names = " << image_pair_names.back() << endl;

      } // loop over index j 
      delete [] curr_histogram_ptr;
   } // loop over index i 
   cout << endl;

   cout << "dotproducts.size() = " << dotproducts.size() << endl;
   cout << "n_dotproducts exceeding min threshold = " 
        << color_dotproducts.size() << endl;

   prob_distribution prob(dotproducts,100,0);
   prob.set_densityfilenamestr(
      color_histograms_subdir+"color_matches_density.meta");
   prob.set_cumulativefilenamestr(
      color_histograms_subdir+"color_matches_cum.meta");
   prob.writeprobdists(false);

   if (!adjacent_frames_flag)
      templatefunc::Quicksort_descending(color_dotproducts,image_pair_names);

   string output_filename=color_histograms_subdir;
   if (global_color_histogram_flag)
   {
      if (different_clips_flag)
      {
         output_filename += "image_global_colors.comparison";
      }
      else if (adjacent_frames_flag)
      {
         output_filename += "image_global_colors_adjacent_frames.comparison";
      }
      else
      {
         output_filename += "image_global_colors_sameclips.comparison";
      }
   }
   else
   {
      if (!global_color_histogram_flag)
      {
         if (different_clips_flag)
         {
            output_filename += "image_colors.comparison";
         }
         else if (adjacent_frames_flag)
         {
            output_filename += "image_colors_adjacent_frames.comparison";
         }
         else
         {
            output_filename += "image_colors_sameclips.comparison";
         }
      }
   } // global_color_histogram_flag conditional
      
   if (keyframes_flag)
   {
      output_filename += ".keyframes";
   }

   ofstream outstream;
   filefunc::openfile(output_filename,outstream);
   outstream << "# Dotproduct    Image_prefix   Image'_prefix   " 
             << endl << endl;
   outstream << "# min_dotproduct = " << min_dotproduct << endl << endl;

   cout << "color_dotproducts.size() = " << color_dotproducts.size() << endl;
   for (int i=0; i<color_dotproducts.size(); i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         image_pair_names[i]," _-");
//      for (int s=0; s<substrings.size(); s++)
//      {
//         cout << "s = " << s << " substring[s] = " << substrings[s] << endl;
//      }

// If input histogram's basename has form
// clip_0000_frame-00001.color_hist, record clip's ID within STL
// vector:

      int clip_ID_i=-1;
      int clip_ID_j=-2;
      int frame_ID_i,frame_ID_j;
      if (substrings.size()==8)
      {
         if (substrings[0]=="clip")
         {
            clip_ID_i=stringfunc::string_to_number(substrings[1]);
            frame_ID_i=stringfunc::string_to_number(substrings[3]);
            clip_ID_j=stringfunc::string_to_number(substrings[5]);
            frame_ID_j=stringfunc::string_to_number(substrings[7]);
//            cout << "clip_ID_i = " << clip_ID_i
//                 << " clip_ID_j = " << clip_ID_j
//                 << endl;
         }
      }
      else if (substrings.size()==4)
      {
         if (substrings[0]=="frame")    // July 2011 NewsWrap 
         {
            clip_ID_i=0;
            frame_ID_i=stringfunc::string_to_number(substrings[1]);
            clip_ID_j=0;
            frame_ID_j=stringfunc::string_to_number(substrings[3]);
         }
      } 
      else if (substrings.size()==10)
      {
         if (substrings[0]=="clip")    // Boston bombing YouTube
         {
            clip_ID_i=stringfunc::string_to_number(substrings[1]);
            frame_ID_i=stringfunc::string_to_number(substrings[3]);
            clip_ID_j=stringfunc::string_to_number(substrings[6]);
            frame_ID_j=stringfunc::string_to_number(substrings[8]);
         }
         else if (substrings[0]=="transcripted") // transcripted NL clip
         {
            clip_ID_i=stringfunc::string_to_number(substrings[2]);
            frame_ID_i=stringfunc::string_to_number(substrings[4]);
            clip_ID_j=stringfunc::string_to_number(substrings[7]);
            frame_ID_j=stringfunc::string_to_number(substrings[9]);
         }
      } // substrings.size() conditional

//      cout << "clip_ID_i = " << clip_ID_i << endl;
//      cout << "clip_ID_j = " << clip_ID_j << endl;
//      cout << "frame_ID_i = " << frame_ID_i << endl;
//      cout << "frame_ID_j = " << frame_ID_j << endl;
//      cout << "different_clips_flag = " << different_clips_flag << endl;

      if ( ((clip_ID_i != clip_ID_j) && different_clips_flag) ||
      ((clip_ID_i==clip_ID_j) && !different_clips_flag) )
      {
         if ( (adjacent_frames_flag && (frame_ID_j==frame_ID_i+1)) ||
              !adjacent_frames_flag)
         {
            outstream << color_dotproducts[i] << "   "
                      << image_pair_names[i] << endl;
         }
      }
   } // loop over index i labeling color dotproducts

   filefunc::closefile(output_filename,outstream);

//   prob_distribution colors_prob(color_dotproducts,100,0);
//   colors_prob.writeprobdists();

   banner="Exported image color histogram comparison to "+output_filename;
   outputfunc::write_big_banner(banner);

   cout << "At end of program COMPARE_COLOR_HISTOGRAMS" << endl;
   outputfunc::print_elapsed_time();
}
