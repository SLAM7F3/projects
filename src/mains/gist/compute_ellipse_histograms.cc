// =======================================================================
// Program COMPUTE_ELLIPSE_HISTOGRAMS imports ellipse parameters
// extracted by program PLOT_AFFINE_ELLIPSES from a set of input jpg
// images.  For each image, 1D probability distributions are
// calculated for the ellipses' fractional areas, number density and
// center separation distances.  Probability densities and cumulative
// functions are exported to metafile subdirectories of the input
// ellipses directories.

// 			./compute_ellipse_histograms

// =======================================================================
// Last updated on 10/21/13; 10/22/13; 10/23/13; 11/8/13
// =======================================================================

#include <algorithm>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "geometry/contour.h"
#include "image/drawfuncs.h"
#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "geometry/geometry_funcs.h"
#include "math/lttwovector.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"
#include "math/twovector.h"
#include "geometry/triangles_group.h"
#include "geometry/vertex.h"
#include "video/videofuncs.h"

using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();      

/*
   string root_subdir="./jpg_files/";
   string images_subdir=root_subdir;
   string ellipses_subdir=root_subdir+"ellipses/";
   string ellipse_metafiles_subdir=ellipses_subdir+"metafiles/";
   filefunc::dircreate(ellipse_metafiles_subdir);
*/


//   string JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
   string JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
//   string JAV_subdir="/data/video/JAV/UIUC_Broadcast_News/";
   string images_subdir=JAV_subdir+"jpg_frames/";
   string root_subdir=JAV_subdir;
   string ellipses_subdir=root_subdir+"ellipses/";
   string ellipse_metafiles_subdir=ellipses_subdir+"metafiles/";
   filefunc::dircreate(ellipse_metafiles_subdir);

/*
   string ImageEngine_subdir="/data/ImageEngine/";
   string tidmarsh_subdir=ImageEngine_subdir+"tidmarsh/";
   string images_subdir=tidmarsh_subdir;
   string root_subdir=tidmarsh_subdir;
   string ellipses_subdir=root_subdir+"ellipses/";
   string ellipse_metafiles_subdir=ellipses_subdir+"metafiles/";
   filefunc::dircreate(ellipse_metafiles_subdir);
*/

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("ellipse_params");

   vector<string> ellipse_params_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,ellipses_subdir);
   cout << "ellipse_params_filenames.size() = "
        << ellipse_params_filenames.size() << endl;

   int jstart=0;
//   cout << "Enter jstart:" << endl;
//   cin >> jstart;
   int jstop=ellipse_params_filenames.size()-1;
//   cout << "Enter jstop:" << endl;
//   cin >> jstop;
   
   for (int j=jstart; j<=jstop; j++)
   {
      double progress_frac=outputfunc::update_progress_fraction(j,100,jstop);
      outputfunc::print_elapsed_and_remaining_time(progress_frac);
      
      cout << "j = " << j 
           << " ellipse_params_filename = " 
           << filefunc::getbasename(ellipse_params_filenames[j])
           << endl;

      string param_filename=ellipse_params_filenames[j];
      string basename=filefunc::getbasename(param_filename);
      string prefix=stringfunc::prefix(basename);
      basename=prefix+".jpg";
      string jpg_filename=images_subdir+basename;

      texture_rectangle* texture_rectangle_ptr=new texture_rectangle(
         jpg_filename,NULL);
      double width=texture_rectangle_ptr->getWidth();
      double height=texture_rectangle_ptr->getHeight();
      double image_area=width*height;

      twoDarray* ptwoDarray_ptr=
         texture_rectangle_ptr->refresh_ptwoDarray_ptr();
      ptwoDarray_ptr->init_coord_system(0,width/height,0,1);
      ptwoDarray_ptr->clear_values();

// Import ellipse parameters from text files generated by program
// PLOT_AFFINE_ELLIPSES.  Discard any repeated lines wtihin input
// parameter file:
      
      filefunc::ReadInfile(param_filename);
//      cout << "filefunc::text_line.size() = "
//           << filefunc::text_line.size() << endl;
      
      typedef map<string,int> FILELINES_MAP;
      FILELINES_MAP filelines_map;

// independent string = filefunc::text_line
// dependent int = multiplicity

      vector<vector<double> > row_numbers;
      for (int i=0; i<filefunc::text_line.size(); i++)
      {
         string curr_line=filefunc::text_line[i];
         FILELINES_MAP::iterator iter=filelines_map.find(curr_line);
         if (iter==filelines_map.end())
         {
            filelines_map[curr_line]=1;
            vector<double> curr_row_numbers=
               stringfunc::string_to_numbers(filefunc::text_line[i]);
            row_numbers.push_back(curr_row_numbers);
         }
         else
         {
            iter->second=iter->second+1;
         }
      }

      int n_ellipses=row_numbers.size();
      cout << "n_ellipses = " << n_ellipses << endl;

      const int min_n_ellipses=3;
      if (n_ellipses < min_n_ellipses) continue;

      vector<double> frac_areas;
      triangles_group* delaunay_triangles_group_ptr=new triangles_group();

      for (int i=0; i<n_ellipses; i++)
      {
//         cout << "i = " << i << endl;
         double px_center=row_numbers[i].at(0);
         double py_center=row_numbers[i].at(1);         

         vertex curr_vertex(threevector(px_center,py_center),i);
         delaunay_triangles_group_ptr->update_triangle_vertices(curr_vertex);

         double a=row_numbers[i].at(2);
         double b=row_numbers[i].at(3);
         double c=row_numbers[i].at(4);
         double major_axis=row_numbers[i].at(5);
         double minor_axis=row_numbers[i].at(6);
         double frac_area=row_numbers[i].at(7);
         frac_areas.push_back(frac_area);

         polygon ellipse=videofunc::generate_ellipse_polygon(
            a,b,c,px_center,py_center,texture_rectangle_ptr);
//         cout << "polygon ellipse = " << ellipse << endl;
         contour ellipse_contour(&ellipse);

         triangles_group* triangles_group_ptr=
            ellipse_contour.generate_interior_triangles();

         for (int t=0; t<triangles_group_ptr->get_n_triangles(); t++)
         {
//            cout << "t = " << t << endl;
            triangle* triangle_ptr=triangles_group_ptr->get_triangle_ptr(t);
            polygon* triangle_poly_ptr=triangle_ptr->generate_polygon();
            
            double value=1;
            bool accumulate_flag=true;
            drawfunc::color_triangle_interior(
               *triangle_poly_ptr,value,ptwoDarray_ptr,accumulate_flag);

            triangle_ptr->delete_triangle_poly_ptr();
         } // loop over index t labeling triangles

      } // loop over index i labeling extracted ellipses

// Compute probability distribution for fractional ellipse areas:

      prob_distribution ellipse_area_prob(frac_areas,100,0);
      ellipse_area_prob.set_xlabel("Ellipse fractional image area");
      ellipse_area_prob.set_densityfilenamestr(
         ellipse_metafiles_subdir+prefix+"_ellipse_area_density.meta");
      ellipse_area_prob.set_cumulativefilenamestr(
         ellipse_metafiles_subdir+prefix+"_ellipse_area_cum.meta");
      ellipse_area_prob.writeprobdists(false,false);

//      string unix_cmd="mv prob_density.meta "+
//         ellipse_metafiles_subdir+prefix+"_ellipse_area_density.meta";
//      sysfunc::unix_command(unix_cmd);
//      unix_cmd="mv prob_cum.meta "+
//         ellipse_metafiles_subdir+prefix+"_ellipse_area_cum.meta";
//      sysfunc::unix_command(unix_cmd);

      cout << "Exported prob distribution for ellipses areas:" << endl;

// Recolor pixels within *texture_rectangle_ptr which correspond to
// nonzero entries in *ptwoDarray_ptr:

      vector<double> n_ellipses_per_image_pixel;
      for (int py=0; py<height; py++)
      {
         for (int px=0; px<width; px++)
         {
            int n_fills=ptwoDarray_ptr->get(px,py);
            n_ellipses_per_image_pixel.push_back(n_fills);
         } // loop over px index
      } // loop over py index
      
//      string ellipse_image_filename=ellipses_subdir+"ellipse_"+basename;
//      texture_rectangle_ptr->write_curr_frame(ellipse_image_filename);

// Compute probability distribution for n_ellipses_per_pixel:

      prob_distribution ellipse_number_density(
         n_ellipses_per_image_pixel,100,0);
      ellipse_number_density.set_xlabel("Number ellipses per image pixel");
      ellipse_number_density.set_densityfilenamestr(
         ellipse_metafiles_subdir+prefix+"_ellipse_numberdens_density.meta");
      ellipse_number_density.set_cumulativefilenamestr(
         ellipse_metafiles_subdir+prefix+"_ellipse_numberdens_cum.meta");
      ellipse_number_density.writeprobdists(false,false);

//      unix_cmd="mv prob_density.meta "+
//         ellipse_metafiles_subdir+prefix+"_ellipse_numberdens_density.meta";
//      sysfunc::unix_command(unix_cmd);
//      unix_cmd="mv prob_cum.meta "+
//         ellipse_metafiles_subdir+prefix+"_ellipse_numberdens_cum.meta";
//      sysfunc::unix_command(unix_cmd);

      cout << "Exported prob distribution for n_ellipses_per_pixel:" << endl;
//      outputfunc::enter_continue_char();

// Compute Delaunay triangulation of ellipse centers: 

      delaunay_triangles_group_ptr->delaunay_triangulate_vertices();

// Compute Delaunay triangle edges measured in pixels:

      vector<double> edge_lengths=delaunay_triangles_group_ptr->
         triangle_edge_lengths();

// Renormalize triangle edge lengths in UV coordinates:

      for (int e=0; e<edge_lengths.size(); e++)
      {
         edge_lengths[e]=edge_lengths[e]/width;
      }
      
// Compute probability distribution for renormalized Delaunay triangle
// edge lengths:

      prob_distribution ellipse_center_separation(edge_lengths,100,0);
      ellipse_center_separation.set_xlabel("Distance between ellipse centers");
      ellipse_center_separation.set_densityfilenamestr(
         ellipse_metafiles_subdir+prefix+"_ellipse_separation_density.meta");
      ellipse_center_separation.set_cumulativefilenamestr(
         ellipse_metafiles_subdir+prefix+"_ellipse_separation_cum.meta");
      ellipse_center_separation.writeprobdists(false,false);

//      unix_cmd="mv prob_density.meta "+
//         ellipse_metafiles_subdir+prefix+"_ellipse_separation_density.meta";
//      sysfunc::unix_command(unix_cmd);
//      unix_cmd="mv prob_cum.meta "+
//         ellipse_metafiles_subdir+prefix+"_ellipse_separation_cum.meta";
//      sysfunc::unix_command(unix_cmd);

      cout << "Exported prob distribution for ellipse center separation:" 
           << endl;
//      outputfunc::enter_continue_char();

      delete delaunay_triangles_group_ptr;

      delete texture_rectangle_ptr;
      
   } // loop over index j effectively labeling jpg images

   cout << "At end of program COMPUTE_ELLIPSE_HISTOGRAMS" << endl;
   outputfunc::print_elapsed_time();
}


