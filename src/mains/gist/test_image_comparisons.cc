// ==========================================================================
// Program TEST_IMAGE_COMPARISONS imports a probabilistic binary
// classifier decision function generated via SVM_GLOBAL_DESCRIPTORS.  
// It also imports color histogram, GIST descriptor and texture
// histogram dotproducts for pairs of images.  If the decision
// function operating on an image pair's global descriptor dotproducts
// exceeds some user-specified threshold, the image pair is declared
// to represent a match.  A montage for the pair of matching images is
// then generated, displayed and stored within matches_subdir.

//			   ./test_image_comparisons

// ==========================================================================
// Last updated on 11/26/13; 12/12/13; 12/13/13
// ==========================================================================

#include  <iostream>
#include  <map>
#include  <string>
#include  <vector>
#include "dlib/svm.h"

#include "general/filefuncs.h"
#include "video/descriptorfuncs.h"
#include "image/imagefuncs.h"
#include "math/ltduple.h"
#include "math/ltquadruple.h"
#include "math/mathfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/outputfuncs.h"
#include "image/pngfuncs.h"
#include "math/prob_distribution.h"
#include "datastructures/Quadruple.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(12);

   timefunc::initialize_timeofday_clock();      
   nrfunc::init_time_based_seed();

   double maximum_matching_prob=1.001;
   cout << "Enter maximum matching probability threshold:" << endl;
//   cin >> maximum_matching_prob;

   double minimum_matching_prob=0.1;
   cout << "Enter minimum matching probability threshold:" << endl;
   cin >> minimum_matching_prob;

//   const int K=3;
//   const int K=4;
//   const int K=5;
//   const int K=6;
//   const int K=7;
   const int K=11;
//   const int K=11+1024;
   int n_descriptors=K;

   typedef std::map<quadruple,genvector*,ltquadruple> 
      GLOBAL_DESCRIPTOR_SCORES_MAP;
   GLOBAL_DESCRIPTOR_SCORES_MAP global_descriptor_scores_map;
   GLOBAL_DESCRIPTOR_SCORES_MAP::iterator iter,iter_start;

//   string JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
   string JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
   string root_subdir=JAV_subdir;
   string images_subdir=root_subdir+"jpg_frames/";
   bool video_clip_data_flag=true;

   bool keyframes_flag=true;
   bool different_clips_flag=false;

   string input_char;
   cout << "Enter 'k' to process just video keyframes:" << endl;
   cin >> input_char;
   if (input_char != "k")
   {
      keyframes_flag=false;
   }
   cout << "Enter 'w' to compare histograms within and not between clips:"
        << endl;
   cin >> input_char;
   if (input_char != "w")
   {
      different_clips_flag=true;
   }

/*
   string ImageEngine_subdir="/data/ImageEngine/";
   string tidmarsh_subdir=ImageEngine_subdir+"tidmarsh/";
   string images_subdir=tidmarsh_subdir;
   string root_subdir=tidmarsh_subdir;
   bool video_clip_data_flag=false;
*/

   string global_color_histograms_subdir=
      root_subdir+"global_color_histograms/";
   string gist_histograms_subdir=root_subdir+"gist_files/";
   string texture_histograms_subdir=root_subdir+"texture_histograms/";
   string SURF_histograms_subdir=root_subdir+"SURF_keys/";
   string LBP_histograms_subdir=root_subdir+"LBP_histograms/";
   string segmentation_histograms_subdir=root_subdir+"segmentation/metafiles/";

   string SURF_scale_histograms_subdir=SURF_histograms_subdir+
      "metafiles/scale/cumulative/";
   string SURF_angle_histograms_subdir=SURF_histograms_subdir+
      "metafiles/angle/cumulative/";
   string SURF_separation_histograms_subdir=SURF_histograms_subdir+
      "metafiles/separation/cumulative/";

   string segmentation_histograms_frac_area_subdir=
      segmentation_histograms_subdir+"frac_area/";
   string segmentation_histograms_Iuu_subdir=
      segmentation_histograms_subdir+"Iuu/";
   string segmentation_histograms_Iuv_subdir=
      segmentation_histograms_subdir+"Iuv/";
   string segmentation_histograms_Ivv_subdir=
      segmentation_histograms_subdir+"Ivv/";

   string matches_subdir=root_subdir+"matching_images"
      +stringfunc::number_to_string(minimum_matching_prob,2)+"/";   
   filefunc::dircreate(matches_subdir);

// Import probabilistic decision function generated by an SVM with a
// linear kernel on matching and nonmatching images:

   typedef dlib::matrix<double, K, 1> sample_type;
   typedef dlib::linear_kernel<sample_type> kernel_type;
   sample_type sample;

   typedef dlib::probabilistic_decision_function<kernel_type> 
      probabilistic_funct_type;  
   typedef dlib::normalized_function<probabilistic_funct_type> pfunct_type;
   pfunct_type pfunct;

   string learned_funcs_subdir=root_subdir+"learned_functions/";
   string learned_pfunct_filename=learned_funcs_subdir+"pfunct.dat";

   ifstream fin6(learned_pfunct_filename.c_str(),ios::binary);
   dlib::deserialize(pfunct, fin6);

   cout << endl;
   cout << "Importing global image descriptors:" << endl;
   cout << endl;

   string global_color_comparison_filename=global_color_histograms_subdir+
      "image_global_colors";
   string gist_comparison_filename=gist_histograms_subdir+"image_gists";
   string texture_comparison_filename=texture_histograms_subdir+
      "image_textures";
   string LBP_comparison_filename=LBP_histograms_subdir+"image_LBPs";
   string SURF_scale_comparison_filename=SURF_scale_histograms_subdir+
      "image_SURFs";
   string SURF_angle_comparison_filename=
      SURF_angle_histograms_subdir+"image_SURFs";
   string SURF_separation_comparison_filename=
      SURF_separation_histograms_subdir+"image_SURFs";
   string segment_area_comparison_filename=
      segmentation_histograms_frac_area_subdir+"image_segments";
   string segment_Iuu_comparison_filename=
      segmentation_histograms_Iuu_subdir+"image_segments";
   string segment_Iuv_comparison_filename=
      segmentation_histograms_Iuv_subdir+"image_segments";
   string segment_Ivv_comparison_filename=
      segmentation_histograms_Ivv_subdir+"image_segments";

   if (!different_clips_flag)
   {
      global_color_comparison_filename += "_sameclips";
      gist_comparison_filename += "_sameclips";
      texture_comparison_filename += "_sameclips";
      LBP_comparison_filename += "_sameclips";
      SURF_scale_comparison_filename += "_sameclips";
      SURF_angle_comparison_filename += "_sameclips";
      SURF_separation_comparison_filename += "_sameclips";
      segment_area_comparison_filename += "_sameclips";
      segment_Iuu_comparison_filename += "_sameclips";
      segment_Iuv_comparison_filename += "_sameclips";
      segment_Ivv_comparison_filename += "_sameclips";
   }

   global_color_comparison_filename += ".comparison";
   gist_comparison_filename += ".comparison";
   texture_comparison_filename += ".comparison";
   LBP_comparison_filename += ".comparison";
   SURF_scale_comparison_filename += ".comparison";
   SURF_angle_comparison_filename += ".comparison";
   SURF_separation_comparison_filename += ".comparison";
   segment_area_comparison_filename += ".comparison";
   segment_Iuu_comparison_filename += ".comparison";
   segment_Iuv_comparison_filename += ".comparison";
   segment_Ivv_comparison_filename += ".comparison";

   if (keyframes_flag)
   {
      global_color_comparison_filename += ".keyframes";
      gist_comparison_filename += ".keyframes";
      texture_comparison_filename += ".keyframes";
      LBP_comparison_filename += ".keyframes";
      SURF_scale_comparison_filename += ".keyframes";
      SURF_angle_comparison_filename += ".keyframes";
      SURF_separation_comparison_filename += ".keyframes";
      segment_area_comparison_filename += ".keyframes";
      segment_Iuu_comparison_filename += ".keyframes";
      segment_Iuv_comparison_filename += ".keyframes";
      segment_Ivv_comparison_filename += ".keyframes";
   }

   vector<vector<string> > substrings;

   int descriptor_start=0;
   int descriptor_stop=n_descriptors-1;
   for (int descriptor=descriptor_start; descriptor<=descriptor_stop; 
        descriptor++)
   {
      cout << endl;
      outputfunc::print_elapsed_time();

// FAKE FAKE:  Thurs Dec 12, 2013 at 9 am
// Eliminate SURF separation descriptor by replacing it with dummy
// copy of global color descriptor:

      cout << "Descriptor = " << descriptor << endl;
      if (descriptor==0 || descriptor==5)
      {
         filefunc::ReadInSubstrings(
            global_color_comparison_filename,substrings);
      }
      else if (descriptor==1)
      {
         filefunc::ReadInSubstrings(gist_comparison_filename,substrings);
      }
      else if (descriptor==2)
      {
         filefunc::ReadInSubstrings(texture_comparison_filename,substrings);
      }
      else if (descriptor==3)
      {
         filefunc::ReadInSubstrings(
            SURF_scale_comparison_filename,substrings);
      }
      else if (descriptor==4)
      {
         filefunc::ReadInSubstrings(
            SURF_angle_comparison_filename,substrings);
      }
/*
      else if (descriptor==5)
      {
         filefunc::ReadInSubstrings(
            SURF_separation_comparison_filename,substrings);
      }
*/
      else if (descriptor==6)
      {
         filefunc::ReadInSubstrings(LBP_comparison_filename,substrings);
      }
      else if (descriptor==7)
      {
         filefunc::ReadInSubstrings(
            segment_area_comparison_filename,substrings);
      }
      else if (descriptor==8)
      {
         filefunc::ReadInSubstrings(
            segment_Iuu_comparison_filename,substrings);
      }
      else if (descriptor==9)
      {
         filefunc::ReadInSubstrings(
            segment_Iuv_comparison_filename,substrings);
      }
      else if (descriptor==10)
      {
         filefunc::ReadInSubstrings(
            segment_Ivv_comparison_filename,substrings);
      }
      cout << "substrings.size() = " << substrings.size() << endl;
    

      string separator_chars=" _-";
      int i_max=substrings.size();
      for (int i=0; i<i_max; i++)
      {
         outputfunc::update_progress_fraction(
            i,substrings.size()/100,substrings.size());
         double score=stringfunc::string_to_number(substrings[i].at(0));

         int first_clip_ID=0;
         int second_clip_ID=0;
         int first_frame_ID,second_frame_ID;
         if (video_clip_data_flag)
         {
            vector<string> subsubstrings=
               stringfunc::decompose_string_into_substrings(
                  substrings[i].at(1),separator_chars);
            first_clip_ID=stringfunc::string_to_number(subsubstrings[1]);
            first_frame_ID=stringfunc::string_to_number(subsubstrings[3]);
         }
         else
         {
            string curr_substr=substrings[i].at(1);
            first_frame_ID=stringfunc::string_to_number(
               curr_substr.substr(3,curr_substr.size()-3));
         }

         if (video_clip_data_flag)
         {
            vector<string> subsubstrings=
               stringfunc::decompose_string_into_substrings(
                  substrings[i].at(2),separator_chars);
            second_clip_ID=stringfunc::string_to_number(subsubstrings[1]);
            second_frame_ID=stringfunc::string_to_number(subsubstrings[3]);
         }
         else
         {
            string curr_substr=substrings[i].at(2);
            second_frame_ID=stringfunc::string_to_number(
               curr_substr.substr(3,curr_substr.size()-3));
         }

         quadruple curr_q(
            first_clip_ID,first_frame_ID,second_clip_ID,second_frame_ID);

         iter=global_descriptor_scores_map.find(curr_q);
         if (iter==global_descriptor_scores_map.end())
         {
            genvector* descriptor_score_ptr=new genvector(n_descriptors);
            for (int d=0; d<n_descriptors; d++)
            {
               descriptor_score_ptr->put(d,-1);
            }

            descriptor_score_ptr->put(descriptor,score);
            global_descriptor_scores_map[curr_q]=descriptor_score_ptr;
         }
         else
         {
            iter->second->put(descriptor,score);
         }
      }
      substrings.clear();
   } // loop over descriptor index

   cout << endl;

// Loop over pairs of images.  If their color, GIST and texture
// scores could plausibly allow for a match, evaluate probabilistic
// decision function generated via program SVM_GLOBAL_DESCRIPS.
// Output matching probability along with color, GIST and texture
// scores to text file.  And pop open displays of image pairs for
// human evaluation:

   string scores_filename=matches_subdir+"scores.dat";
   ofstream scores_stream;
   filefunc::openfile(scores_filename,scores_stream);

   scores_stream << "# matching_score global_color GIST texture SURF_scale SURF_angle SURF_separation LBP segment_area segment_Iuu segment_Iuv segment_Ivv image1_filename image2_filename matching_score" 
                 << endl << endl;

   scores_stream << "# Maximum matching probability threshold = "
                 << maximum_matching_prob << endl;
   scores_stream << "# Minimum matching probability threshold = "
                 << minimum_matching_prob << endl << endl;

   int counter_start=0;
//   int counter_start=86712+4270+2140+24848;
   int counter=0;
   iter_start=global_descriptor_scores_map.begin(); 
   while (counter < counter_start)
   {
      iter_start++;
      counter++;
   }

   int n_global_descriptor_pairs=global_descriptor_scores_map.size();
   cout << "n_global_descriptor_pairs = " << n_global_descriptor_pairs << endl;
   for (iter=iter_start; iter != global_descriptor_scores_map.end(); iter++)
   {
      counter++;

      double global_color_score,gist_score,texture_score;
      double SURF_scale_score,SURF_angle_score,SURF_separation_score;
      double LBP_score;
      double segment_area_score,segment_Iuu_score,segment_Iuv_score,
         segment_Ivv_score;
      
      global_color_score=iter->second->get(0);
      gist_score=iter->second->get(1);
      texture_score=iter->second->get(2);

      if (global_color_score < 0) continue;
      if (gist_score < 0) continue;
      if (texture_score < 0) continue;

      sample(0)=global_color_score;
      sample(1)=gist_score;
      sample(2)=texture_score;

      if (K >= 4)
      {
         SURF_scale_score=iter->second->get(3);
         if (SURF_scale_score < 0) continue;
         sample(3)=SURF_scale_score;
      }
      if (K >= 5)
      {
         SURF_angle_score=iter->second->get(4);
         if (SURF_angle_score < 0) continue;
         sample(4)=SURF_angle_score;
      }
      if (K >= 6)
      {
         SURF_separation_score=iter->second->get(5);
         if (SURF_separation_score < 0) continue;
         sample(5)=SURF_separation_score;
      }
      if (K >= 7)
      {
         LBP_score=iter->second->get(6);
         if (LBP_score < 0) continue;
         sample(6)=LBP_score;
      }
      if (K >= 8)
      {
         segment_area_score=iter->second->get(7);
         if (segment_area_score < 0) continue;
         sample(7)=segment_area_score;
      }
      if (K >= 9)
      {
         segment_Iuu_score=iter->second->get(8);
         if (segment_Iuu_score < 0) continue;
         sample(8)=segment_Iuu_score;
      }
      if (K >= 10)
      {
         segment_Iuv_score=iter->second->get(9);
         if (segment_Iuv_score < 0) continue;
         sample(9)=segment_Iuv_score;
      }
      if (K >= 11)
      {
         segment_Ivv_score=iter->second->get(10);
         if (segment_Ivv_score < 0) continue;
         sample(10)=segment_Ivv_score;
      }

      double match_prob=pfunct(sample);
//      cout << "match_prob = " << match_prob << endl;

      if (match_prob > maximum_matching_prob) continue;
      if (match_prob < minimum_matching_prob) continue;

      int first_clip_ID=iter->first.first;
      int first_frame_ID=iter->first.second;
      int second_clip_ID=iter->first.third;
      int second_frame_ID=iter->first.fourth;

      string first_image_filename,second_image_filename;
      if (video_clip_data_flag)
      {
         first_image_filename=images_subdir+
            "clip_"+stringfunc::integer_to_string(first_clip_ID,4)+"_frame-"+
            stringfunc::integer_to_string(first_frame_ID,5)+".jpg";
         second_image_filename=images_subdir+
            "clip_"+stringfunc::integer_to_string(second_clip_ID,4)+"_frame-"+
            stringfunc::integer_to_string(second_frame_ID,5)+".jpg";
      }
      else
      {
         first_image_filename=images_subdir+
            "pic"+stringfunc::integer_to_string(first_frame_ID,5)+".jpg";
         second_image_filename=images_subdir+
            "pic"+stringfunc::integer_to_string(second_frame_ID,5)+".jpg";
      }

//      cout << "first_image_filename = " 
//           << filefunc::getbasename(first_image_filename) << endl;
//      cout << "second_image_filename = " 
//           << filefunc::getbasename(second_image_filename) << endl;

/*
      cout 
         << global_color_score << " "
         << gist_score << " "
         << texture_score << " "
         << SURF_scale_score << " "
         << SURF_angle_score << " "
         << SURF_separation_score << " "
         << LBP_score 
         << segment_area_score << " "
         << segment_Iuu_score << " "
         << segment_Iuv_score << " "
         << segment_Ivv_score << " "
         << endl;
*/

      double counter_frac=double(counter-counter_start)/
         (n_global_descriptor_pairs-counter_start);
      cout << "counter-counter_start = " << counter-counter_start
           << " n_global_descriptor_pairs-counter_start = " 
           << n_global_descriptor_pairs-counter_start
           << " counter_frac = " << counter_frac 
           << endl;
      cout << "image matching probability = " << match_prob << endl;
      outputfunc::print_elapsed_and_remaining_time(counter_frac);

      string unix_cmd="montageview "+first_image_filename+" "+
         second_image_filename+" NO_DISPLAY";
      sysfunc::unix_command(unix_cmd);
      string prob_str=stringfunc::number_to_string(match_prob,2);

      string montage_jpg_filename=
         "montage_"+filefunc::getprefix(first_image_filename)+"___"+
         filefunc::getbasename(second_image_filename);
      string montage_w_score_jpg_filename=
         "montage_"+filefunc::getprefix(first_image_filename)+"___"+
         filefunc::getprefix(second_image_filename)+"__"+prob_str+".jpg";

      scores_stream << match_prob << " "
                    << global_color_score << " "
                    << gist_score << " "
                    << texture_score << " "
                    << LBP_score << " "
                    << SURF_scale_score << " "
                    << SURF_angle_score << " "
                    << SURF_separation_score << " "
                    << segment_area_score << " "
                    << segment_Iuu_score << " "
                    << segment_Iuv_score << " "
                    << segment_Ivv_score << " "
                    << stringfunc::prefix(
                       filefunc::getbasename(first_image_filename)) << " "
                    << stringfunc::prefix(
                       filefunc::getbasename(second_image_filename)) 
                    << endl;

      double trunc_prob=0.1*basic_math::mytruncate(match_prob/0.1);
      prob_str=stringfunc::number_to_string(trunc_prob,1);
      string prob_subdir=matches_subdir+prob_str+"/";
      filefunc::dircreate(prob_subdir);

// Annotate montage with color, GIST, texture, LBP, etc scores along
// with matching probability score:

//      bool annotate_montage_w_scores_flag=true;
      bool annotate_montage_w_scores_flag=false;
      
      if (!annotate_montage_w_scores_flag)
      {
         unix_cmd="mv "+montage_jpg_filename+" "+
            prob_subdir+montage_w_score_jpg_filename;
         sysfunc::unix_command(unix_cmd);
      }
      else      
      {
         string montage_png_filename=
            montage_jpg_filename.substr(0,montage_jpg_filename.size()-3)+"png";
//      cout << "montage_png_filename = " << montage_png_filename << endl;
         unix_cmd="convert "+montage_jpg_filename+" "+montage_png_filename;
//      cout << "unix_cmd = " << unix_cmd << endl;
         sysfunc::unix_command(unix_cmd);

         unsigned int montage_width,montage_height;
         imagefunc::get_image_width_height(
            montage_png_filename,montage_width,montage_height);
//      cout << "montage_width = " << montage_width
//           << " montage_height = " << montage_height << endl;

         string dirname=filefunc::getdirname(montage_png_filename);
         string basename=filefunc::getbasename(montage_png_filename);
         string annotated_montage_png_filename=dirname+"annotated_"+basename;
//      cout << "annotated_montage_png_filename = "
//           << annotated_montage_png_filename << endl;

         int fontsize=20;
         vector<string> text_lines;
         vector<twovector> xy_start;
         vector<colorfunc::RGB> text_RGB;

         text_lines.push_back("c="+stringfunc::number_to_string(
                                 global_color_score,3));
         text_lines.push_back("G="+stringfunc::number_to_string(gist_score,3));
         text_lines.push_back("T="+stringfunc::number_to_string(
                                 texture_score,3));
         text_lines.push_back("L="+stringfunc::number_to_string(LBP_score,3));
         text_lines.push_back("sc="+stringfunc::number_to_string(
                                 SURF_scale_score,3));
         text_lines.push_back("an="+stringfunc::number_to_string(
                                 SURF_angle_score,3));
         text_lines.push_back("se="+stringfunc::number_to_string(
                                 SURF_separation_score,3));

         text_lines.push_back("sa="+stringfunc::number_to_string(
                                 segment_area_score,3));
         text_lines.push_back("Iuu="+stringfunc::number_to_string(
                                 segment_Iuu_score,3));
         text_lines.push_back("Iuv="+stringfunc::number_to_string(
                                 segment_Iuv_score,3));
         text_lines.push_back("Ivv="+stringfunc::number_to_string(
                                 segment_Ivv_score,3));
         text_lines.push_back("P="+stringfunc::number_to_string(match_prob,3));

         xy_start.push_back(twovector(0.0*montage_width,40));
         xy_start.push_back(twovector(0.2*montage_width,40));
         xy_start.push_back(twovector(0.4*montage_width,40));
         xy_start.push_back(twovector(0.6*montage_width,40));
         xy_start.push_back(twovector(0.0*montage_width,70));
         xy_start.push_back(twovector(0.2*montage_width,70));
         xy_start.push_back(twovector(0.4*montage_width,70));
         xy_start.push_back(twovector(0.0*montage_width,100));
         xy_start.push_back(twovector(0.2*montage_width,100));
         xy_start.push_back(twovector(0.4*montage_width,100));
         xy_start.push_back(twovector(0.6*montage_width,100));
         xy_start.push_back(twovector(0.8*montage_width,100));

         for (int l=0; l<K+1; l++)
         {
            text_RGB.push_back(colorfunc::get_RGB_values(colorfunc::purple));
         }
      
         pngfunc::add_text_to_PNG_image(
            montage_png_filename,annotated_montage_png_filename,
            fontsize,text_lines,xy_start,text_RGB);

         unix_cmd="mv "+annotated_montage_png_filename+" "+prob_subdir;
         sysfunc::unix_command(unix_cmd);
         unix_cmd="/bin/rm "+montage_png_filename;
         sysfunc::unix_command(unix_cmd);
         unix_cmd="/bin/rm "+montage_jpg_filename;
         sysfunc::unix_command(unix_cmd);

      } // annotate_montage_w_scores_flag conditional

   } // loop over global_descriptor_scores_map iterator

   filefunc::closefile(scores_filename,scores_stream);

   cout << "Maximum matching probability threshold = "
        << maximum_matching_prob << endl;
   cout << "Minimum matching probability threshold = "
        << minimum_matching_prob << endl;
   
   cout << "At end of program TEST_IMAGE_COMPARISONS" << endl;
   outputfunc::print_elapsed_time();
}

