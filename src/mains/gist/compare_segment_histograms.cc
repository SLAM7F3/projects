// ==========================================================================
// Program COMPARE_SEGMENT_HISTOGRAMS imports sets of cumulative
// probability distribution functions generated by program
// mains/JAV/SEGMENT_VIDEO_FRAMES.  Looping over all imported
// cumulative distributions, it computes the maximum difference
// between pairs.  The similarity between two cumulative
// distributions is taken to equal 1 - their maximum difference.  The
// similarity scores are sorted in descending order and exported to an
// output text file with the corresponding pair's image filenames.

//		       ./compare_segment_histograms

// ==========================================================================
// Last updated on 11/20/13
// ==========================================================================

#include <cstdlib>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "math/ltduple.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "filter/piecewise_linear.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();      

   bool keyframes_flag=true;
   bool different_clips_flag=false;

   string input_char;
   cout << "Enter 'k' to process just video keyframes:" << endl;
   cin >> input_char;
   if (input_char != "k")
   {
      keyframes_flag=false;
   }
   cout << "Enter 'w' to compare histograms within and not between clips:"
        << endl;
   cin >> input_char;
   if (input_char != "w")
   {
      different_clips_flag=true;
   }

//   string JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
   string JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
//   string JAV_subdir="/data/video/JAV/UIUC_Broadcast_News/";
   string root_subdir=JAV_subdir;
   string images_subdir=root_subdir+"jpg_frames/";
   string keyframes_subdir=images_subdir+"keyframes/";

   string segmentation_subdir=root_subdir+"segmentation/";
   string segmentation_metafiles_subdir=segmentation_subdir+"metafiles/";
   string segmentation_metafiles_frac_area_subdir=
      segmentation_metafiles_subdir+"frac_area/";
   string segmentation_metafiles_Iuu_subdir=
      segmentation_metafiles_subdir+"Iuu/";
   string segmentation_metafiles_Iuv_subdir=
      segmentation_metafiles_subdir+"Iuv/";
   string segmentation_metafiles_Ivv_subdir=
      segmentation_metafiles_subdir+"Ivv/";

   double min_segment_area_score=0.01;
   double min_segment_Iuu_score=0.01;
   double min_segment_Iuv_score=0.01;
   double min_segment_Ivv_score=0.01;

/*
   string ImageEngine_subdir="/data/ImageEngine/";
   string tidmarsh_subdir=ImageEngine_subdir+"tidmarsh/";
   string images_subdir=tidmarsh_subdir;
   string root_subdir=tidmarsh_subdir;
   string SURFs_subdir=root_subdir+"SURFs/";
   string SURF_histograms_subdir=SURFs_subdir+"metafiles/";
   double min_segment_scale_score=0.94;
   double min_segment_angle_score=0.95;
   double min_segment_separation_score=0.94;
*/

// Report all SURF matching scores when we're comparing keyframes
// within same video clips:

   if (keyframes_flag && !different_clips_flag)
   {
      min_segment_area_score=min_segment_Iuu_score=
         min_segment_Iuv_score=min_segment_Ivv_score=0;
   }

   vector<double> min_segment_scores;
   min_segment_scores.push_back(min_segment_area_score);
   min_segment_scores.push_back(min_segment_Iuu_score);
   min_segment_scores.push_back(min_segment_Iuv_score);
   min_segment_scores.push_back(min_segment_Ivv_score);

// Store keyframes' clip and frame IDs within STL map keyframes_map:

   typedef map<DUPLE,string> KEYFRAMES_MAP;
   KEYFRAMES_MAP keyframes_map;

// independent DUPLE holds video image clip and frame ID
// dependent string holds video image's filename

   if (keyframes_flag)
   {
      vector<string> keyframe_filenames=filefunc::image_files_in_subdir(
         keyframes_subdir);

      for (int i=0; i<keyframe_filenames.size(); i++)
      {
         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
               filefunc::getbasename(keyframe_filenames[i])," _-");
//         for (int s=0; s<substrings.size(); s++)
//         {
//            cout << "i = " << i << " s = " << s << " substring[s] = " 
//                 << substrings[s] << endl;
//         }

// If input filename has form clip_0000_frame-00001.jpg, record clip's
// ID within STL vector:

         int clip_ID=-1;
         int frame_ID=-1;
         if (substrings.size()==4)
         {
            if (substrings[0]=="clip")
            {
               clip_ID=stringfunc::string_to_number(substrings[1]);
               frame_ID=stringfunc::string_to_number(substrings[3]);
               keyframes_map[DUPLE(clip_ID,frame_ID)]=keyframe_filenames[i];
            }
         }
      } // loop over index i labeling keyframe filenames
      
   } // keyframes_flag conditional
   cout << "keyframes_map.size() = " << keyframes_map.size() << endl;

   outputfunc::enter_continue_char();
   
   vector<string> segmentation_cum_subdirs;
   segmentation_cum_subdirs.push_back(segmentation_metafiles_frac_area_subdir);
   segmentation_cum_subdirs.push_back(segmentation_metafiles_Iuu_subdir);
   segmentation_cum_subdirs.push_back(segmentation_metafiles_Iuv_subdir);
   segmentation_cum_subdirs.push_back(segmentation_metafiles_Ivv_subdir);

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("meta");

// Loop over index e labeling segment feature type starts here:

   string cum_meta_substring="_cum.meta";
   for (int e=0; e<segmentation_cum_subdirs.size(); e++)
   {
      outputfunc::print_elapsed_time();
      vector<string> meta_filenames=
         filefunc::files_in_subdir_matching_substring(
            segmentation_cum_subdirs[e],cum_meta_substring);
      int n_metafiles=meta_filenames.size();

      cout << "e = " << e
           << " segmentation_cum_subdirs[e] = " 
           << segmentation_cum_subdirs[e] << endl;
      cout << "n_metafiles = " << n_metafiles << endl;      

// Import cumulative distributions generated by program
// mains/JAV/SEGMENT_VIDEO_FRAMES:

      string banner="Importing segment metafiles from "
         +segmentation_cum_subdirs[e];
      outputfunc::write_banner(banner);

      typedef pair< vector<double> , vector<double> > CUM_DISTRIBUTION;
      vector<CUM_DISTRIBUTION> cum_distributions;

      vector<short unsigned int> basename_i_indices,basename_j_indices;
      vector<float> segment_scores;
      basename_i_indices.reserve(0.5*sqr(n_metafiles));
      basename_j_indices.reserve(0.5*sqr(n_metafiles));
      segment_scores.reserve(0.5*sqr(n_metafiles));

      vector<string> hist_filenames;
      for (int i=0; i<n_metafiles; i++)
      {
         outputfunc::update_progress_fraction(i,100,n_metafiles);
          
         if (keyframes_flag && keyframes_map.size() > 0)
         {
            string basename=filefunc::getbasename(meta_filenames[i]);
            vector<string> substrings=
               stringfunc::decompose_string_into_substrings(
                  stringfunc::prefix(basename)," _-");
//            for (int s=0; s<substrings.size(); s++)
//            {
//               cout << " s = " << s << " substring[s] = " 
//                    << substrings[s] << endl;
//            }

// If input filename has form clip_0000_frame-00001, record clip's
// ID within STL vector:

            int clip_ID=-1;
            int frame_ID=-1;
            if (substrings.size()==5)
            {
               if (substrings[0]=="clip")
               {
                  clip_ID=stringfunc::string_to_number(substrings[1]);
                  frame_ID=stringfunc::string_to_number(substrings[3]);
                  KEYFRAMES_MAP::iterator keyframe_iter=keyframes_map.find(
                     DUPLE(clip_ID,frame_ID));
                  if (keyframe_iter==keyframes_map.end())
                  {
                     continue;
                  }
//               else
//               {
//                  cout << "clip_ID = " << clip_ID << " frame_ID = " << frame_//ID
//                       << " is a keyframe" << endl;
//               }
               }
            } // substrings.size() conditional
         } // keyframes_flag conditional

         filefunc::ReadInfile(meta_filenames[i]);

// Explicitly check for NANs in input probability cumulative
// distributions.  If present, reject entire metafile input:

         bool NAN_encountered_flag=false;
         CUM_DISTRIBUTION curr_cum_distribution;
         for (int linenumber=17; linenumber < filefunc::text_line.size(); 
              linenumber++)
         {
            vector<string> substrings=
               stringfunc::decompose_string_into_substrings(
                  filefunc::text_line[linenumber]);
            if (!stringfunc::is_number(substrings[1]))
            {
               NAN_encountered_flag=true;
               break;
            }
            
            vector<double> column_values=stringfunc::string_to_numbers(
               filefunc::text_line[linenumber]);
//         cout << column_values[0] << "  " << column_values[1] << endl;
            curr_cum_distribution.first.push_back(
               stringfunc::string_to_number(substrings[0]));
            curr_cum_distribution.second.push_back(
               stringfunc::string_to_number(substrings[1]));
         }

         if (!NAN_encountered_flag && 
             curr_cum_distribution.first.size() > 0)
         {
            cum_distributions.push_back(curr_cum_distribution);
            hist_filenames.push_back(meta_filenames[i]);
         }
      } // loop over index i labeling input metafiles
      cout << endl;

      cout << "cum_distributions.size() = "
           << cum_distributions.size() << endl;

      cout << endl;
      cout << "Computing segment cumulative distribution scores:" << endl;
      cout << endl;

      outputfunc::print_elapsed_time();

      int i_max=cum_distributions.size();
      int j_max=i_max;
      for (int i=0; i<i_max-1; i++)
      {
         outputfunc::update_progress_fraction(i,10,n_metafiles);
         CUM_DISTRIBUTION* curr_cum_distribution_ptr=
            &(cum_distributions[i]);
//         cout << "i = " << i << " i_max = " << i_max << endl;
//         cout << "curr_cum_distrition_ptr->first.size() = "
//              << curr_cum_distribution_ptr->first.size() << endl;
//         cout << "curr_cum_distrition_ptr->second.size() = "
//              << curr_cum_distribution_ptr->second.size() << endl;

         piecewise_linear pl(curr_cum_distribution_ptr->first,
                             curr_cum_distribution_ptr->second);
      
//         if (!different_clips_flag) j_max=basic_math::min(i+2,i_max);

         for (int j=i+1; j<j_max; j++)
         {
            CUM_DISTRIBUTION* next_cum_distribution_ptr=
               &(cum_distributions[j]);
            
// Search for maximum discrepancy between curr_cum_distribution and
// next_cum_distribution:

            double max_cum_difference=-1;
            for (int b=0; b<next_cum_distribution_ptr->first.size(); b++)
            {
               double next_x=next_cum_distribution_ptr->first[b];
               double next_cum=next_cum_distribution_ptr->second[b];
               double curr_cum=pl.value(next_x);
               max_cum_difference=basic_math::max(
                  max_cum_difference,fabs(next_cum-curr_cum));
            }

//         cout << "i = " << i << " j = " << j << " max_cum_difference = "
//              << max_cum_difference << endl;

            segment_scores.push_back(1-max_cum_difference);
            basename_i_indices.push_back(i);
            basename_j_indices.push_back(j);

         } // loop over index j 
      
      } // loop over index i labeling input metafiles

      prob_distribution prob(segment_scores,100,0);
      prob.set_densityfilenamestr(
         segmentation_cum_subdirs[e]+"segment_density_scores.meta");
      prob.set_cumulativefilenamestr(
         segmentation_cum_subdirs[e]+"segmentation_cum_scores.meta");
      prob.writeprobdists(false);

      templatefunc::Quicksort_descending(
         segment_scores,basename_i_indices,basename_j_indices);

      string output_filename=segmentation_cum_subdirs[e];
      if (different_clips_flag)
      {
         output_filename += "image_segments.comparison";
      }
      else
      {
         output_filename += "image_segments_sameclips.comparison";
      }

      if (keyframes_flag)
      {
         output_filename += ".keyframes";
      }

      ofstream outstream;
      filefunc::openfile(output_filename,outstream);
      outstream << "# Score    Image_prefix   Image'_prefix   " 
                << endl << endl;

      for (int t=0; t<segment_scores.size(); t++)
      {
         if (segment_scores[t] < min_segment_scores[e]) continue;

         string basename_i=filefunc::getbasename(
            hist_filenames[basename_i_indices[t]]);
         string basename_j=filefunc::getbasename(
            hist_filenames[basename_j_indices[t]]);
//         cout << "basename_i = " << basename_i
//              << " basename_j = " << basename_j << endl;

         int posn=stringfunc::first_substring_location(
            basename_i,"_segment");
         basename_i=basename_i.substr(0,posn);
         posn=stringfunc::first_substring_location(
            basename_j,"_segment");
         basename_j=basename_j.substr(0,posn);

//         cout << "basename_i = " << basename_i
//              << " basename_j = " << basename_j << endl;

         string image_pair_names=
            stringfunc::prefix(basename_i)+"  "+
            stringfunc::prefix(basename_j);
//      cout << "t = " << t
//           << " image_pair_names = " << image_pair_names << endl;


         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
               image_pair_names," _-");

         int clip_ID_i=-1;
         int clip_ID_j=-2;
         int frame_ID_i,frame_ID_j;
         if (substrings.size()==8)
         {
            if (substrings[0]=="clip")
            {
               clip_ID_i=stringfunc::string_to_number(substrings[1]);
               frame_ID_i=stringfunc::string_to_number(substrings[3]);
               clip_ID_j=stringfunc::string_to_number(substrings[5]);
               frame_ID_j=stringfunc::string_to_number(substrings[7]);
//            cout << "clip_ID_i = " << clip_ID_i
//                 << " clip_ID_j = " << clip_ID_j
//                 << endl;
            }
         } // substrings.size()==8 conditional

         if ( ((clip_ID_i != clip_ID_j) && different_clips_flag) ||
         ((clip_ID_i==clip_ID_j) && 
//          (frame_ID_j==frame_ID_i+1) && 
         !different_clips_flag) )
         {
            outstream << segment_scores[t] << "   "
                      << image_pair_names << endl;
         }
      } // loop over index t labeling segment scores

      filefunc::closefile(output_filename,outstream);
      banner="Exported image segment comparison to "+output_filename;
      outputfunc::write_big_banner(banner);

   } // loop over index e labeling segment cumulative subdirectories

   cout << "At end of program COMPARE_SEGMENT_HISTOGRAMS" << endl;
   outputfunc::print_elapsed_time();
}

