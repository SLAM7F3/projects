// =======================================================================
// Program COMPUTE_SURF_HISTOGRAMS imports SURF features
// extracted by program EXTRACT_SURF_FEATURES from a set of input jpg
// images.  For each image, 1D probability distributions are
// calculated for SURF interest points' scales, angles and separation 
// distances.  Probability densities and cumulative functions are
// exported to metafile subdirectories of the input SURF keys
// directory.

// 			./compute_SURF_histograms

// =======================================================================
// Last updated on 11/11/13
// =======================================================================

#include <algorithm>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "geometry/contour.h"
#include "image/drawfuncs.h"
#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "geometry/geometry_funcs.h"
#include "math/lttwovector.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "video/sift_detector.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"
#include "math/twovector.h"
#include "geometry/triangles_group.h"
#include "geometry/vertex.h"
#include "video/videofuncs.h"

using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();      

/*
   string root_subdir="./jpg_files/";
   string images_subdir=root_subdir;
   string ellipses_subdir=root_subdir+"ellipses/";
   string ellipse_metafiles_subdir=ellipses_subdir+"metafiles/";
   filefunc::dircreate(ellipse_metafiles_subdir);
*/


   string JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
//   string JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
//   string JAV_subdir="/data/video/JAV/UIUC_Broadcast_News/";
   string images_subdir=JAV_subdir+"jpg_frames/";
   string root_subdir=JAV_subdir;
   string SURF_keys_subdir=root_subdir+"SURF_keys/";
   cout << "SURF_keys_subdir = " << SURF_keys_subdir << endl;
   string SURF_histograms_subdir=SURF_keys_subdir+"metafiles/";
   filefunc::dircreate(SURF_histograms_subdir);


   bool FLANN_flag=true;
   sift_detector* sift_detector_ptr=new sift_detector(NULL,FLANN_flag);

/*
   string ImageEngine_subdir="/data/ImageEngine/";
   string tidmarsh_subdir=ImageEngine_subdir+"tidmarsh/";
   string images_subdir=tidmarsh_subdir;
   string root_subdir=tidmarsh_subdir;
   string ellipses_subdir=root_subdir+"ellipses/";
   string SURF_histograms_subdir=ellipses_subdir+"metafiles/";
   filefunc::dircreate(SURF_histograms_subdir);
*/

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("surf_features");

   vector<string> SURF_key_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,SURF_keys_subdir);
   cout << "SURF_key_filenames.size() = "
        << SURF_key_filenames.size() << endl;

   int jstart=0;
//   cout << "Enter jstart:" << endl;
//   cin >> jstart;
   int jstop=SURF_key_filenames.size()-1;
//   cout << "Enter jstop:" << endl;
//   cin >> jstop;
   
   for (int j=jstart; j<=jstop; j++)
   {
      double progress_frac=outputfunc::update_progress_fraction(j,100,jstop);
      outputfunc::print_elapsed_and_remaining_time(progress_frac);
      
      cout << "j = " << j 
           << " SURF_key_filename = " 
           << filefunc::getbasename(SURF_key_filenames[j])
           << endl;

      string basename=filefunc::getbasename(SURF_key_filenames[j]);
      string prefix=stringfunc::prefix(basename);
      basename=prefix+".jpg";
      string jpg_filename=images_subdir+basename;

// Import SURF features from serialized binary files generated by
// program EXTRACT_SURF_FEATURES:

      vector<sift_detector::feature_pair> currimage_feature_info;
      sift_detector_ptr->import_SURF_features(
         SURF_keys_subdir,jpg_filename,currimage_feature_info);

      int n_features=currimage_feature_info.size();
      cout << "n_features = " << n_features << endl;
      const int min_n_features=3;
      if (n_features < min_n_features) continue;

      vector<double> SURF_scales,SURF_angles;
      triangles_group* delaunay_triangles_group_ptr=new triangles_group();
      for (int i=0; i<n_features; i++)
      {
//         cout << "i = " << i << endl;

         descriptor* F_ptr=currimage_feature_info[i].first;
         double U=F_ptr->get(1);
         double V=F_ptr->get(2);
         double scale=F_ptr->get(3);
         double angle=basic_math::phase_to_canonical_interval(
            F_ptr->get(4),0,2*PI);
         SURF_scales.push_back(scale);
         SURF_angles.push_back(angle);

         vertex curr_vertex(threevector(U,V),i);
         delaunay_triangles_group_ptr->update_triangle_vertices(curr_vertex);

      } // loop over index i labeling SURF features

      cout << "SURF_scales.size() = " << SURF_scales.size() << endl;
      cout << "SURF_angles.size() = " << SURF_angles.size() << endl;

// Compute probability distribution for SURF scales:

      prob_distribution SURF_scale_prob(SURF_scales,100,0);
      SURF_scale_prob.set_xlabel("SURF scale");
      SURF_scale_prob.set_densityfilenamestr(
         SURF_histograms_subdir+prefix+"_SURF_scales_density.meta");
      SURF_scale_prob.set_cumulativefilenamestr(
         SURF_histograms_subdir+prefix+"_SURF_scales_cum.meta");
      SURF_scale_prob.writeprobdists(false,false);
      cout << "Exported prob distribution for SURF scales:" << endl;

// Compute probability distribution for SURF angles:

      prob_distribution SURF_angle_prob(SURF_angles,100,0);
      SURF_angle_prob.set_xmin(0);
      SURF_angle_prob.set_xmax(2*PI);
      SURF_angle_prob.set_xlabel("SURF angle");
      SURF_angle_prob.set_densityfilenamestr(
         SURF_histograms_subdir+prefix+"_SURF_angles_density.meta");
      SURF_angle_prob.set_cumulativefilenamestr(
         SURF_histograms_subdir+prefix+"_SURF_angles_cum.meta");
      SURF_angle_prob.writeprobdists(false,false);
      cout << "Exported prob distribution for SURF angles:" << endl;

// Compute Delaunay triangulation of SURF interest points:

      delaunay_triangles_group_ptr->delaunay_triangulate_vertices();

// Compute Delaunay triangle edges measured in UV coordinates:

      vector<double> edge_lengths=delaunay_triangles_group_ptr->
         triangle_edge_lengths();
      
// Compute probability distribution for renormalized Delaunay triangle
// edge lengths:

      prob_distribution SURF_feature_separation(edge_lengths,100,0);
      SURF_feature_separation.set_xlabel("Distance between ellipse centers");
      SURF_feature_separation.set_densityfilenamestr(
         SURF_histograms_subdir+prefix+"_separation_density.meta");
      SURF_feature_separation.set_cumulativefilenamestr(
         SURF_histograms_subdir+prefix+"_separation_cum.meta");
      SURF_feature_separation.writeprobdists(false,false);
      cout << "Exported prob distribution for feature separation:" << endl;
//      outputfunc::enter_continue_char();

      delete delaunay_triangles_group_ptr;
      
   } // loop over index j effectively labeling jpg images

   delete sift_detector_ptr;

   cout << "At end of program COMPUTE_SURF_HISTOGRAMS" << endl;
   outputfunc::print_elapsed_time();
}


