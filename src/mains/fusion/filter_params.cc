// ==========================================================================
// Program FILTER_PARAMS reads in best chisq-fit internal camera
// parameter information derived by program BUNDLE/WANDER.  This
// program instantiates a gaussian filter which is used to temporally
// smooth each of the sets of internal parameters.  The filtered
// values are written to output text file "filtered_params.txt".
// ==========================================================================
// Last updated on 10/4/05; 12/4/10
// ==========================================================================

#include <iostream>
#include <set>
#include <string>
#include "math/constants.h"
#include "general/filefuncs.h"
#include "filter/filterfuncs.h"
#include "math/Genarray.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::ofstream;
   using std::setw;
   using std::string;

// Open ascii file to hold temporally filtered sequence of camera
// intrinsic and extrinsic parameters:

   string filtered_params_filename="filtered_params.txt";
   ofstream filtered_params_stream;
   filefunc::deletefile(filtered_params_filename);
   filefunc::openfile(filtered_params_filename,filtered_params_stream);

// Read in and parse camera parameters determined from chisq
// minimization by program BUNDLE:

   outputfunc::newline();
   string subdir="./KLT_camera_params/";
   string input_params_filename;
   outputfunc::newline();
   cout << "Enter file in subdir "+subdir << endl;
   cout << "containing unfiltered intrinsic params" << endl;
   cout << "generated by program BUNDLE/WANDER:" << endl;
   cin >> input_params_filename;
   input_params_filename=subdir+input_params_filename;
   filefunc::ReadInfile(input_params_filename);

   const unsigned int n_entries=filefunc::text_line.size();
   const unsigned int n_params=10;
   double X[n_params];
   genarray data(n_entries,n_params);
   for (unsigned int n=0; n<n_entries; n++)
   {
      stringfunc::string_to_n_numbers(n_params,filefunc::text_line[n],X);
      for (unsigned int v=0; v<n_params; v++)
      {
         data.put(n,v,X[v]);
      }
   } // loop over index n labeling tiepoint camera information 

// Initialize gaussian filter to be used for temporal smoothing:

   const double dt=1.0;
   const int max_n_sigma=1;
   const double max_sigma=max_n_sigma*dt;
   const double e_folding_distance=3;
   int max_n_size=filterfunc::gaussian_filter_size(
      max_sigma,dt,e_folding_distance);
   double *filter=new double[max_n_size];

   genarray filtered_data(n_entries,10);

   int prev_n_size=-1;
   for (unsigned int n=0; n<n_entries; n++)
   {
      for (unsigned int v=1; v<n_params; v++)
      {

// To avoid divizion-by-zero problems, do not filter the first and
// last few parameter entries:

         if (n < 2 || n > n_entries-1-2)
         {
            filtered_data.put(n,v,data.get(n,v));
         }
         else
         {
            double sigma=basic_math::min(
               max_sigma,(n-1)*dt/(e_folding_distance*SQRT_TWO),
               (n_entries-n-1)*dt/(e_folding_distance*SQRT_TWO));
            int n_size=filterfunc::gaussian_filter_size(
               sigma,dt,e_folding_distance);

// Don't waste time recomputing gaussian filter unless its width has
// changed:

            if (n_size != prev_n_size)
            {
               filterfunc::gaussian_filter(n_size,0,sigma,dt,filter);
               prev_n_size=n_size;
            }
               
//         cout << "image = " << n
//              << " n_size=" << n_size 
//              << " max_n_size=" << max_n_size
//              << " sigma=" << sigma
//              << " max_sigma=" << max_sigma
//              << endl;

            int w=n_size/2;
            double filter_sum=0;
            double param=0;
            for (int i=0; i<n_size; i++)
            {
               int j=n-w+i;
               if (j >= 0 && j < int(n_entries))
               {
                  param += data.get(j,v)*filter[i]*dt;
                  filter_sum += filter[i]*dt;
               }
            } 
            param /= filter_sum;
            filtered_data.put(n,v,param);

         } // n < max_n_sigma || n > n_entries-1-max_n_sigma
         //  conditional
         
      } // loop over v index
   } // loop over n index

   int column_width=12;
   filtered_params_stream.precision(5);
   for (unsigned int n=0; n<n_entries; n++)
   {
      filtered_params_stream << setw(4) << data.get(n,0);
      for (unsigned int v=1; v<n_params; v++)
      {
         filtered_params_stream << setw(column_width) 
                                << filtered_data.get(n,v);
      }
      filtered_params_stream << endl;
   }

   filefunc::closefile(filtered_params_filename,filtered_params_stream);
   
   delete [] filter;
}
