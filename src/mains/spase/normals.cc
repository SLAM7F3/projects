// ==========================================================================
// Program NORMALS is a specialized program hacked together to
// generate an XYZP file containing SPASE face normal information.  It
// retrieves SPASE planar surface information from an output file
// generated by specialized methods within FeaturesGroup (as of
// 3/3/06).  It then computes the distance of every XYZ point to these
// planes and associates one plane to each point based upon its
// minimal distance.  The closest plane normals are written to an out
// XYZP file in the same order as the points themselves.
// ==========================================================================
// Last updated on 3/5/06
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "geometry/plane.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "threeDgraphics/xyzpfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::ofstream;
using std::ostream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   vector<plane*> plane_ptrs;

   string plane_filename="./spase_planes.txt";
   filefunc::ReadInfile(plane_filename);
   for (int l=0; l<filefunc::text_line.size(); l++)
   {
      vector<double> X=stringfunc::string_to_numbers(filefunc::text_line[l]);
      int p=X[0];
      fourvector pi(X[1],X[2],X[3],X[4]);
      plane* curr_plane_ptr=new plane(pi);
      plane_ptrs.push_back(curr_plane_ptr);

      cout << "p = " << p << " pi = " << curr_plane_ptr->get_pi()
           << endl;
      cout << "nhat = " << curr_plane_ptr->get_nhat() << endl;
      
   } // loop over index l labeling lines in spase planes text file

//   string shading_filename="./shading_factors.p";
//   vector<float>* shading_ptr=xyzpfunc::read_float_data(shading_filename);

   string xyzp_filename="./XYZP/null_probs.xyzp";
   cout << "Enter XYZP filename:" << endl;
   cin >> xyzp_filename;
   vector<fourvector>* XYZP_ptr=xyzpfunc::read_xyzp_float_data(xyzp_filename);
   vector<fourvector>* normal_ptr=new vector<fourvector>;
   
   for (int i=0; i<XYZP_ptr->size(); i++)
   {
      fourvector xyzp=(*XYZP_ptr)[i];
      threevector xyz(xyzp.get(0),xyzp.get(1),xyzp.get(2));

      int closest_p=-1;
      double min_dist=POSITIVEINFINITY;
      for (int p=0; p<plane_ptrs.size(); p++)
      {
         double curr_dist=fabs(
            plane_ptrs[p]->signed_distance_from_plane(xyz));
         if (curr_dist < min_dist)
         {
            min_dist=curr_dist;
            closest_p=p;
         }
      } // loop over index p labeling planar surfaces

// Reset probability value to indicate closest planar surface:

// For reasons we do not understand, all of the SPASE side face
// normals are coming out with the wrong sign as of Friday, Mar 3.  We
// introduce a compensating minus sign as an ugly hack:

      if (closest_p<=5)
      {
         normal_ptr->push_back(fourvector(
            -plane_ptrs[closest_p]->get_nhat(),0));
      }
      else
      {
         normal_ptr->push_back(fourvector(
            plane_ptrs[closest_p]->get_nhat(),0));
      }

//      double curr_shade=max(0.0f,(*shading_ptr)[i]);
//      (*XYZP_ptr)[i].put(3,curr_shade);

//      (*XYZP_ptr)[i].put(3,0.125*closest_p);
//      (*XYZP_ptr)[i].put(3,normal_ptr->back().get(0));
//      (*XYZP_ptr)[i].put(3,normal_ptr->back().get(1));
//      (*XYZP_ptr)[i].put(3,normal_ptr->back().get(2));
   } // loop over index i labeling points inside cloud
   
//   string normals_filename="normals.xyz";
   string normals_filename="normals.xyzp";
   filefunc::deletefile(normals_filename);
//   xyzpfunc::write_xyz_data(normals_filename,normal_ptr,false);
   xyzpfunc::write_xyzp_data(normals_filename,normal_ptr,false);

   string junk_filename="junk.xyzp";
   filefunc::deletefile(junk_filename);
   xyzpfunc::write_xyzp_data(junk_filename,XYZP_ptr,false);

   delete XYZP_ptr;
   delete normal_ptr;
//   delete shading_ptr;
}
