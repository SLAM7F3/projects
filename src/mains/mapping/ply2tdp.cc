// ==========================================================================
// Program PLY2TDP reads in reads in a PLY file generated by Noah's
// Bundler codes.  It extracts X,Y,Z,R,G,B information and generates
// an output TDP file.

// 				ply2tdp 

// ==========================================================================
// Last updated on 6/27/12; 6/29/12; 9/11/13; 12/3/13
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"

#include "math/prob_distribution.h"

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   string ply_filename;
   vector<string> param;
   if (filefunc::parameter_input(argc,argv,param))
   {
      ply_filename=param.back();
   }
   else
   {
      cout << "Enter input PLY filename:" << endl;
      cin >> ply_filename;
   }
   
   filefunc::ReadInfile(ply_filename);
   cout << "filefunc::text_line.size() = "
        << filefunc::text_line.size() << endl;

   vector<double> X,Y,Z;
   vector<int> R,G,B;

   string banner="Parsing input PLY file:";
   outputfunc::write_banner(banner);

//   int i_max=1000;
   int i_max=filefunc::text_line.size();
   for (int i=0; i<i_max; i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);

// For lazerkart ply file, substrings.size()=3:

      if (substrings.size()==3)
      {
         double x=stringfunc::string_to_number(substrings[0]);
         double y=stringfunc::string_to_number(substrings[1]);
         double z=stringfunc::string_to_number(substrings[2]);
         X.push_back(x);
         Y.push_back(y);
         Z.push_back(z);
      }
      else if (substrings.size()==6 || substrings.size()>=9)
      {
         double x=stringfunc::string_to_number(substrings[0]);
         double y=stringfunc::string_to_number(substrings[1]);
         double z=stringfunc::string_to_number(substrings[2]);

// Recall Noah's initial coordinate system needs to be grossly
// manipulated so that ground scenes lie approximately in XY plane:

// 	X_Peter = -X_Noah
// 	Y_Peter= Z_Noah
// 	Z_Peter = Y_Noah

         bool gross_rotate_bundler_coords_flag=true; // bundler
//         bool gross_rotate_bundler_coords_flag=false;  
         if (gross_rotate_bundler_coords_flag)
         {
            X.push_back(-x);
            Y.push_back(z);
            Z.push_back(y);
         }
         else
         {
            X.push_back(x);
            Y.push_back(y);
            Z.push_back(z);
         }

         int r,g,b;
         if (substrings.size()==6)
         {
            r=stringfunc::string_to_number(substrings[3]);
            g=stringfunc::string_to_number(substrings[4]);
            b=stringfunc::string_to_number(substrings[5]);
         }
         else if (substrings.size()>=9)
         {
            r=stringfunc::string_to_number(substrings[6]);
            g=stringfunc::string_to_number(substrings[7]);
            b=stringfunc::string_to_number(substrings[8]);
         }
         R.push_back(r);
         G.push_back(g);
         B.push_back(b);
      }
   }

   cout << "X.size() = " << X.size() << endl;
   cout << "Y.size() = " << Y.size() << endl;
   cout << "Z.size() = " << Z.size() << endl;
   cout << "R.size() = " << R.size() << endl;
   cout << "G.size() = " << G.size() << endl;
   cout << "B.size() = " << B.size() << endl;

/*
   int n_output_bins=10000;
   prob_distribution prob_X(X,n_output_bins);
   prob_distribution prob_Y(Y,n_output_bins);
   prob_distribution prob_Z(Z,n_output_bins);
   
   prob_X.set_densityfilenamestr("X.meta");
   prob_Y.set_densityfilenamestr("Y.meta");
   prob_Z.set_densityfilenamestr("Z.meta");
   prob_X.writeprobdists(false);
   prob_Y.writeprobdists(false);
   prob_Z.writeprobdists(false);
*/

   string UTMzone="";
   string tdp_filename=stringfunc::prefix(ply_filename)+".tdp";
   tdpfunc::write_relative_xyzrgba_data(
      UTMzone,tdp_filename,X,Y,Z,R,G,B);




/*
// This next section was added in late June 2012 in order to georegister
// Nick Armstrong-Crews' lazerkart point cloud to the 3D MIT building
// models:

// Scan through X,Y,Z vectors and eliminate any point which lie
// outside reasonable intervals:

   banner="Eliminating outlier points:";
   outputfunc::write_banner(banner);

   double xmin=327881;
   double xmax=328373;

   double ymin=4690774;
   double ymax=4692651;

   double zmin=-10;
   double zmax=50;

   vector<double> X_reduced,Y_reduced,Z_reduced;
   for (int i=0; i<X.size(); i++)
   {
      if (X[i] > xmin && X[i] < xmax) X_reduced.push_back(X[i]);
      if (Y[i] > ymin && Y[i] < ymax) Y_reduced.push_back(Y[i]);
      if (Z[i] > zmin && Z[i] < zmax) Z_reduced.push_back(Z[i]);
   }

   banner="Transforming inlier points:";
   outputfunc::write_banner(banner);

   const threevector rotation_origin(328192,4692011,0);
//   double az=0;
//   double az= -2.36471 * PI/180;	// best global fit 6/29/2012
//   double az= -3.0453 * PI/180;	// just Carleton St fit 7/6/2012
   double az= -2.27079 * PI/180;	// just Rebecca bldgs fit 7/6/2012
   double el=0;
   double roll=0;

   rotation Rot;   
   Rot=Rot.rotation_from_az_el_roll(az,el,roll);

   double scalefactor= 1;

//   double x_trans=0;
//   double y_trans=0;
//   double x_trans = 3.08188;		// best global fit 6/29/2012
//   double y_trans = -3.00164;		// best global fit 6/29/2012
//   double x_trans=3.64261;		// just Carleton St fit 7/6/2012
//   double y_trans=-3.00413;		// just Carleton St fit 7/6/2012
   double x_trans=3.41057;		// just Rebecca bldgs fit 7/6/2012
   double y_trans=1.32599;		// just Rebecca bldgs fit 7/6/2012

   double z_trans=2.53;			// best global fit 6/29/2012
   threevector trans(x_trans,y_trans,z_trans);

   vector<double> X_transformed,Y_transformed,Z_transformed;
   for (int i=0; i<X_reduced.size(); i++)
   {
      threevector XYZ(X_reduced[i],Y_reduced[i],Z_reduced[i]);
      vertex V(XYZ);
      V.translate(-rotation_origin);
      V.rotate(Rot);
      V.scale(rotation_origin,scalefactor);
      V.translate(rotation_origin);
      V.translate(trans);
      XYZ=V.get_posn();
      X_transformed.push_back(XYZ.get(0));
      Y_transformed.push_back(XYZ.get(1));
      Z_transformed.push_back(XYZ.get(2));
   }

   cout << "X.size() = " << X.size()
        << " X_reduced.size() = " << X_reduced.size() 
        << " X_transformed.size() = " << X_transformed.size() 
        << endl;

   banner="Exporting TDP file:";
   outputfunc::write_banner(banner);
   
   string UTMzone="";
//   string tdp_filename=stringfunc::prefix(ply_filename)+"_ztrans.tdp";
   string tdp_filename=stringfunc::prefix(ply_filename)+"_reg.tdp";
//   tdpfunc::write_xyz_data(tdp_filename,&X_reduced,&Y_reduced,&Z_reduced);
   tdpfunc::write_xyz_data(
      tdp_filename,&X_transformed,&Y_transformed,&Z_transformed);

*/


}
