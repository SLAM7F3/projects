// ==========================================================================
// Program EOTIF2TDP takes in a registered geotiff EO satellite image
// and generates a corresponding point cloud in TDP output format.

// 				eotif2tdp
// or

//			eotif2tdp Baghdad_2006_R1C4_0_0.tif 

// We wrote this specialized utility program in August 2008 when we
// discovered that the .osga files generated by osgdem for the Baghdad
// data set failed on the classified touch2y disks.  We believe that
// the classified touchy2 disks are flawed and not the programs nor
// the osgdem files (which both seem to work fine on other computers).
// So we had to resort to generating point cloud .osga files which
// hopefully will work on touchy2 in time for the Sept RCO sponsor review.

// We also empirically determined that this program can handle
// 4000x4000 subtiles.  Tiles larger than this size lead to
// out-of-memory errors.

// ==========================================================================
// Last updated on 3/21/09; 4/22/09; 4/24/09; 8/27/09
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "gdal_priv.h"
#include "image/raster_parser.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "image/TwoDarray.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::string;
using std::vector;

// ==========================================================================
int main (int argc, char * argv[])
{
   std::set_new_handler(sysfunc::out_of_memory);
//   cout << "argc = " << argc << endl;
//   cout << "argv[0] = " << argv[0] << endl;
//   cout << "argv[1] = " << argv[1] << endl;

   raster_parser RasterParser;

   string image_filename;
   if (argc==2)
   {
      image_filename=argv[1];
   }
   else
   {
      cout << "Enter input EO geotiff file name:" << endl;
      cin >> image_filename;
   }
   cout << "image_filename = " << image_filename << endl;

//   string image_filename="bb_r1c3.tif";
//   string image_filename="copley.jpg";
//   image_filename="baghdad37.tif";
//   string image_filename="cats.jp2";
//   string image_filename="clewiston.jp2";

   string filename_prefix=stringfunc::prefix(image_filename);
   RasterParser.open_image_file(image_filename);

   twoDarray *ztwoDarray_ptr,*RtwoDarray_ptr,*GtwoDarray_ptr,*BtwoDarray_ptr;
   ztwoDarray_ptr=NULL;
   RtwoDarray_ptr=NULL;
   GtwoDarray_ptr=NULL;
   BtwoDarray_ptr=NULL;
   
   int n_channels=RasterParser.get_n_channels();
   cout << "n_channels = " << n_channels << endl;

   for (int channel_ID=0; channel_ID<n_channels; channel_ID++)
   {
      RasterParser.fetch_raster_band(channel_ID);

      if (n_channels==1)
      {
         ztwoDarray_ptr=RasterParser.get_ztwoDarray_ptr();
         RasterParser.read_raster_data(ztwoDarray_ptr);
      }
      else if (n_channels==3)
      {
         cout << "channel_ID = " << channel_ID << endl;
         if (channel_ID==0)
         {
            RtwoDarray_ptr=RasterParser.get_RtwoDarray_ptr();
            cout << "*RtwoDarray_ptr = " << *RtwoDarray_ptr << endl;
            RasterParser.read_raster_data(RtwoDarray_ptr);
         }
         else if (channel_ID==1)
         {
            GtwoDarray_ptr=RasterParser.get_GtwoDarray_ptr();
//            cout << "GtwoDarray_ptr = " << GtwoDarray_ptr << endl;
            RasterParser.read_raster_data(GtwoDarray_ptr);
         }
         else if (channel_ID==2)
         {
            BtwoDarray_ptr=RasterParser.get_BtwoDarray_ptr();
//            cout << "BtwoDarray_ptr = " << BtwoDarray_ptr << endl;
            RasterParser.read_raster_data(BtwoDarray_ptr);
         }
      } // n_channels conditional
   } // loop over channel_ID labeling RGB channels

// Write out TDP file:

   string tdp_filename=filename_prefix+".tdp";
   cout << "Output tdp_filename = " << tdp_filename << endl;
   string UTMzone="19";		// Boston & Lowell
//   string UTMzone="38T";
//   string UTMzone="42";	// Afghanistan

   int nodata_value=0;
   tdpfunc::write_relative_xyzrgba_data(
      tdp_filename,UTMzone,RtwoDarray_ptr,GtwoDarray_ptr,BtwoDarray_ptr,
      nodata_value);
} 

