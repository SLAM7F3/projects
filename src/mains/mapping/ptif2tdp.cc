// ==========================================================================
// Program PTIF2TDP is a specialized variant of TIF2TDP which we
// hacked together in Nov 2009.  It takes in a ZP tile generated by
// Ross Anderson for his draping of Boston EO imagery onto an ALIRT
// height surface.  This program outputs a P-map in both TIF and TDP
// file formats.  

// 			     ptif2tdp input_PZ_file.tiff

// ==========================================================================
// Last updated on 11/28/09; 11/30/09; 12/4/10
// ==========================================================================

#include <iostream>
#include <string>
#include "gdal_priv.h"
#include "astro_geo/geopoint.h"
#include "passes/PassesGroup.h"
#include "image/raster_parser.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "image/TwoDarray.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::string;

// ==========================================================================
int main (int argc, char * argv[])
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:
   
   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   Pass* pass_ptr=passes_group.get_pass_ptr(0);
   string image_filename=pass_ptr->get_first_filename();
   cout << "image_filename = " << image_filename << endl;
   string filename_prefix=stringfunc::prefix(image_filename);

   raster_parser RasterParser;
   RasterParser.open_image_file(image_filename);

   int channel_ID=1;
   RasterParser.fetch_raster_band(channel_ID);

   twoDarray* ztwoDarray_ptr=RasterParser.get_ztwoDarray_ptr();
   cout << "ztwoDarray_ptr = " << ztwoDarray_ptr << endl;
   RasterParser.read_raster_data(ztwoDarray_ptr);

// Compute geocoordinates for raster image's four corners:

   geopoint lower_left_corner(
      RasterParser.get_northern_hemisphere_flag(),
      RasterParser.get_specified_UTM_zonenumber(),
      ztwoDarray_ptr->get_xlo(),ztwoDarray_ptr->get_ylo());

   cout << "lower_left_corner = " << lower_left_corner << endl;

   geopoint upper_left_corner(
      RasterParser.get_northern_hemisphere_flag(),
      RasterParser.get_specified_UTM_zonenumber(),
      ztwoDarray_ptr->get_xlo(),ztwoDarray_ptr->get_yhi());
   
   geopoint lower_right_corner(
      RasterParser.get_northern_hemisphere_flag(),
      RasterParser.get_specified_UTM_zonenumber(),
      ztwoDarray_ptr->get_xhi(),ztwoDarray_ptr->get_ylo());

   geopoint upper_right_corner(
      RasterParser.get_northern_hemisphere_flag(),
      RasterParser.get_specified_UTM_zonenumber(),
      ztwoDarray_ptr->get_xhi(),ztwoDarray_ptr->get_yhi());

   cout << "lower_left_corner = " << lower_left_corner << endl;
   cout << "upper_left_corner = " << upper_left_corner << endl;
   cout << "lower_right_corner = " << lower_right_corner << endl;
   cout << "upper_right_corner = " << upper_right_corner << endl;
   


   int mdim=ztwoDarray_ptr->get_mdim();
   int ndim=ztwoDarray_ptr->get_ndim();
   cout << "mdim = " << mdim << " ndim = " << ndim << endl;

   double x,y;
   double min_p=POSITIVEINFINITY;
   double max_p=NEGATIVEINFINITY;
   osg::Vec3 XYZ;
   osg::Vec3Array* vertices_ptr=new osg::Vec3Array;
   vertices_ptr->reserve(mdim*ndim);
   for (int px=0; px<mdim; px++)
   {
      if (px%100==0) cout << px << " " << flush;
      for (int py=0; py<ndim; py++)
      {
         ztwoDarray_ptr->pixel_to_point(px,py,x,y);
         XYZ[0]=x;
         XYZ[1]=y;
         double prob=ztwoDarray_ptr->get(px,py)/65535;
         min_p=basic_math::min(min_p,prob);
         max_p=basic_math::max(max_p,prob);

         ztwoDarray_ptr->put(px,py,prob);

         XYZ[2]=prob;
         vertices_ptr->push_back(XYZ);
      }
   }
   cout << endl;

   cout << "min_p = " << min_p << " max_p = " << max_p << endl;

   int output_UTM_zonenumber=19;	// Boston/Lowell
   bool output_northern_hemisphere_flag=true;

// Write out TIFF file containing just P values:

   string prob_filename="prob.tiff";
   bool output_floats_flag=false;
   RasterParser.write_raster_data(
      output_floats_flag,prob_filename,
      output_UTM_zonenumber,output_northern_hemisphere_flag,
      ztwoDarray_ptr , 0.0 , 1.0 );

// Write out TDP file containing just P values:

   string tdp_filename="prob_"+filename_prefix+".tdp";
   cout << "Output tdp_filename = " << tdp_filename << endl;
   string UTMzone="19";		// Boston/Lowell
   tdpfunc::write_relative_xyz_data(tdp_filename,UTMzone,vertices_ptr);

}

