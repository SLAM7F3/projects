// ==========================================================================
// Program GEOREGISTER_VIDEO reads in a set of manually selected
// (easting,northing) and (U,V) tiepoints from two feature text files
// generated by programs TESTCITIES & VIDEO.  It performs a least
// squares minimization of a chisq function that quantifies the
// discrepancy between the (easting,northing) and (U,V) feature
// coordinates.  We determine the linear transformation of the
// relative X and Y coordinates of the manually selected 2D features
// of the form UV = M XY + T where M is a 2x2 matrix close to the
// identity, T is the translation 2-vector, XY holds the
// (easting,northing) coordinates, and UV holds the (U,V) video
// feature coordinates.  We evaluate the closed-form solution for the
// 4 parameters in M and the 2 translations in T.

// GEOREGISTER_VIDEO performs two rounds of rubber sheeting.  After
// the first one, it can discard some number of tiepoint pairs.  It
// then performs a 2nd round with a reduced set of feature inputs.
// Once the final linear transformation parameters are determined,
// this program uses the inverse transformation to compute the
// geocoordinates for the four video corners.  

// ==========================================================================
// Last updated on 2/22/08; 9/14/08; 8/20/11; 9/7/11
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "astro_geo/geopoint.h"
#include "math/mypolynomial.h"
#include "general/outputfuncs.h"
#include "math/rubbersheet.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "templates/mytemplates.h"
#include "math/threevector.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::ofstream;
using std::ostream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   const int PRECISION=15;
   cout.precision(PRECISION);

   bool northern_hemisphere_flag=true;		
//   int UTM_zonenumber=14;			// Lubbock, TX	
   int UTM_zonenumber=19;			// Boston, MA

   cout << "northern_hemisphere_flag = " << northern_hemisphere_flag << endl;
   cout << "UTM_zonenumber = " << UTM_zonenumber << endl;
//   outputfunc::enter_continue_char();

// Read in (easting,northing) geographic coordinates for tiepoint
// features:

   string EN_features_filename="features_3D_full.txt";
   cout << "Enter full path for filename containing 2D features in Easting-Northing geocoordinates:" << endl;
   cin >> EN_features_filename;
   filefunc::ReadInfile(EN_features_filename);

   vector<double> X,Y;
   vector<threevector> XYID;
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<string> substring=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      int feature_ID=stringfunc::string_to_number(substring[1]);
      double curr_X=stringfunc::string_to_number(substring[3]);
      double curr_Y=stringfunc::string_to_number(substring[4]);
      X.push_back(curr_X);
      Y.push_back(curr_Y);
      XYID.push_back(threevector(curr_X,curr_Y,feature_ID));
      cout << "i = " << i 
           << " ID = " << XYID.back().get(2)
           << " X = " << XYID.back().get(0)
           << " Y = " << XYID.back().get(1)
           << endl;
   }

// Read in (U,V) video coordinates for tiepoint features:

//   string EO_subdir="/media/LACIE/Bluegrass/eo/aerial/utm/";
//   string EO_features_filename=EO_subdir+"features_new_2D_ar1.txt";
   string UV_features_filename="features_2D_full.txt";
   cout << "Enter full path for filename containing 2D features in image plane UV coordinates:" << endl;
   cin >> UV_features_filename;
   filefunc::ReadInfile(UV_features_filename);
   
   vector<double> U,V;
   vector<twovector> UV;
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
//      cout << filefunc::text_line[i] << endl;
      vector<string> substring=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      
      double curr_U=stringfunc::string_to_number(substring[3]);
      double curr_V=stringfunc::string_to_number(substring[4]);
      U.push_back(curr_U);
      V.push_back(curr_V);
      UV.push_back(twovector(curr_U,curr_V));
      cout << "i = " << i << " UV = " << UV.back() << endl;
   }
   
   mypolynomial U2X(1);
   mypolynomial V2Y(1);
   double chisqUX,chisqVY;
//   U2X.fit_coeffs(U,X,chisqUX);
//   V2Y.fit_coeffs(V,Y,chisqVY);
   U2X.fit_coeffs_using_residuals(U,X,chisqUX);
   V2Y.fit_coeffs_using_residuals(V,Y,chisqVY);
   vector<double> residual_UX=U2X.compute_residuals(U,X);
   vector<double> residual_VY=V2Y.compute_residuals(V,Y);

   cout << "chisqUX = " << chisqUX << endl;
   cout << "chisqVY = " << chisqVY << endl;

   for (int i=0; i<U.size(); i++)
   {
      double fitted_X=U2X.value(U[i]);
      double fitted_Y=V2Y.value(V[i]);
      double dx=fitted_X-X[i];
      double dy=fitted_Y-Y[i];
      double ds=sqrt(sqr(dx)+sqr(dy));
      cout << "i = " << i << " dx = " << dx << " dy = " << dy 
           << " ds = " << ds << endl;
//      cout << "residual_UX = " << residual_UX[i]
//           << " residual_VY = " << residual_VY[i] << endl;
   }

// Use linear transformation parameters to compute easting-northing
// coordinates corresponding to UV image plane corners:

   double minU=0;
   double minV=0;
   double maxU=0.907645; // Ft Devens 10 A horseshoe image snapped from GE
   double maxV=1;
//   cout << "Enter min_U:" << endl;
//   cin >> minU;
//   cout << "Enter max_U:" << endl;
//   cin >> maxU;

   double minX=U2X.value(minU);
   double maxX=U2X.value(maxU);
   double minY=V2Y.value(minV);
   double maxY=V2Y.value(maxV);
   
   cout << "minX = " << minX << " maxX = " << maxX << endl;
   cout << "minY = " << minY << " maxY = " << maxY << endl;

/*
   outputfunc::enter_continue_char();

// Instantiate rubber sheet object which locally transforms (easting,
// northing) pairs into (U,V) coordinates:

   rubbersheet RubberSheet;

   RubberSheet.copy_XYID(XYID);
   RubberSheet.copy_UV(UV);

// Perform first round of rubber sheeting:

   vector<bool> retained_feature_flag;
   for (int i=0; i<RubberSheet.get_n_features(); i++)
   {
      retained_feature_flag.push_back(true);
   }
   RubberSheet.fit_linear_warp(retained_feature_flag);

// Use residuals to identify worst feature match in least squares fit:

//   int npoints_to_discard=0;
   int npoints_to_discard=1;
   RubberSheet.compare_measured_and_linearly_transformed_UVs(
      npoints_to_discard,retained_feature_flag);

// Perform second round of rubber sheeting with worst feature not
// included into least squares fit:

   RubberSheet.fit_linear_warp(retained_feature_flag);

   npoints_to_discard=0;
   RubberSheet.compare_measured_and_linearly_transformed_UVs(
      npoints_to_discard,retained_feature_flag);

   genmatrix* M_ptr=RubberSheet.get_M_ptr();
   genmatrix* Minv_ptr=RubberSheet.get_Minv_ptr();
   twovector trans=RubberSheet.get_trans();
      
   cout << "*M_ptr = " << *M_ptr << endl;
   cout << "*Minv_ptr = " << *Minv_ptr << endl;
   cout << "trans = " << trans << endl;

// UV = M XY + T 

   twovector screen_lower_left(minU,minV);
   twovector screen_lower_right(maxU,minV);
   twovector screen_upper_right(maxU,maxV);
   twovector screen_upper_left(minU,maxV);

   twovector geo_lower_left=(*Minv_ptr)*(screen_lower_left-trans);
   twovector geo_lower_right=(*Minv_ptr)*(screen_lower_right-trans);
   twovector geo_upper_right=(*Minv_ptr)*(screen_upper_right-trans);
   twovector geo_upper_left=(*Minv_ptr)*(screen_upper_left-trans);
   
   cout << "geo_lower_left = " << geo_lower_left << endl;
   cout << "geo_lower_right = " << geo_lower_right << endl;
   cout << "geo_upper_right = " << geo_upper_right << endl;
   cout << "geo_upper_left = " << geo_upper_left << endl;

   outputfunc::enter_continue_char();

   geopoint lower_left_corner(
      northern_hemisphere_flag,UTM_zonenumber,
      geo_lower_left.get(0),geo_lower_left.get(1));
   geopoint lower_right_corner(
      northern_hemisphere_flag,UTM_zonenumber,
      geo_lower_right.get(0),geo_lower_right.get(1));
   geopoint upper_right_corner(
      northern_hemisphere_flag,UTM_zonenumber,
      geo_upper_right.get(0),geo_upper_right.get(1));
   geopoint upper_left_corner(
      northern_hemisphere_flag,UTM_zonenumber,
      geo_upper_left.get(0),geo_upper_left.get(1));

   cout << "lower_left_corner = " << lower_left_corner << endl;
   cout << "lower_right_corner = " << lower_right_corner << endl;
   cout << "upper_right_corner = " << upper_right_corner << endl;
   cout << "upper_left_corner = " << upper_left_corner << endl;
*/

// Write out ground control point arguments to gdal_translate in order
// to incorporate tiepoints into an aerial image:

   int Nx,Ny;
   cout << "Enter aerial image width in pixels:" << endl;
//   cin >> Nx;
   cout << "Enter aerial image height in pixels:" << endl;
//   cin >> Ny;


   Nx=1488;	// LL Pavilion image snapped from GE
   Ny=1335;	// LL Pavilion image snapped from GE

//   Nx=1199;	// Ft Devens 10 A horseshoe image snapped from GE
//   Ny=1321;	// Ft Devens 10 A horseshoe image snapped from GE
   
//   Nx=1886;
//   Ny=1245;

   for (int i=0; i<UV.size(); i++)
   {
      double curr_U=UV[i].get(0);
      double curr_V=UV[i].get(1);
      int px=curr_U*Ny;
      int py=(1-curr_V)*Ny;

//      twovector curr_geopoint=(*Minv_ptr)*(UV[i]-trans);
//      double easting=curr_geopoint.get_UTM_easting();
//      double northing=curr_geopoint.get_UTM_northing();

      double easting=U2X.value(curr_U);
      double northing=V2Y.value(curr_V);

// Note: -gcp = ground control point for gdal_translate

      cout << "-gcp " << px << " " << py << " "
           << easting << " "
           << northing << endl;
   } // loop over index i labeling tiepoint pairs
   
   
}
