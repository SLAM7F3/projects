// ==========================================================================
// Program BUNDLER_CONVERT is a quick-and-dirty utility to parse and
// transform Noah Snavely's BUNDLER program ascii output into an XYZP
// file.  We hardwire global scaling, translation and rotation
// information into this program generated by program
// BUNDLER_GEORGEGISTER which georegisters raw bundler XYZ points.

// 			bundler_convert

// ==========================================================================
// Last updated on 6/23/09; 6/24/09; 9/13/09; 12/4/10
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <osg/Array>
#include "color/colorfuncs.h"
#include "general/filefuncs.h"
#include "math/prob_distribution.h"
#include "math/rotation.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "math/threevector.h"
#include "threeDgraphics/xyzpfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(15);

//   string input_filename="bundler_points.dat";
//   string input_filename="Manhattan_1012_points.dat";
//   string input_filename="boston_skyline_points.ply";
   string input_filename="MIT_592.dat";
   string suffix=stringfunc::suffix(input_filename);

   filefunc::ReadInfile(input_filename);
   int n_lines=filefunc::text_line.size();
   cout << "n_lines = " << n_lines << endl;
   
   vector<threevector> xyz_pnts;
   vector<double> X_pnts,Y_pnts,Z_pnts,P_pnts;

   double x_min=POSITIVEINFINITY;
   double y_min=POSITIVEINFINITY;
   double z_min=POSITIVEINFINITY;

   double x_max=NEGATIVEINFINITY;
   double y_max=NEGATIVEINFINITY;
   double z_max=NEGATIVEINFINITY;

   osg::Vec4ubArray* colors_ptr=new osg::Vec4ubArray;
   const unsigned char alpha_byte=
      static_cast<unsigned char>(stringfunc::ascii_integer_to_char(255));

   int line_skip=3;
   if (suffix=="ply") line_skip=1;
   
   for (int i=0; i<n_lines; i++)
   {
      if (i%line_skip==0)
      {
//         cout << "line " << i << endl;
//         cout << filefunc::text_line[i] << endl;
         threevector curr_xyz;
         colorfunc::RGB curr_RGB;

         if (suffix=="ply")
         {
            vector<double> curr_sextet=stringfunc::string_to_numbers(
               filefunc::text_line[i]);
            curr_xyz=threevector(curr_sextet[0],curr_sextet[1],
                                 curr_sextet[2]);
            curr_RGB=colorfunc::RGB(
               curr_sextet[3],curr_sextet[4],curr_sextet[5]);
//            cout << "r = " << curr_RGB.first
//                 << " g = " << curr_RGB.second
//                 << " b = " << curr_RGB.third << endl;
         }
         else
         {
            vector<double> curr_triple=stringfunc::string_to_numbers(
               filefunc::text_line[i]);
            vector<double> unrenormalized_colors=
               stringfunc::string_to_numbers(filefunc::text_line[i+1]);
            
            curr_xyz=threevector(
               -curr_triple[0],curr_triple[2],curr_triple[1]);
            curr_RGB=colorfunc::RGB(unrenormalized_colors[0],
                                    unrenormalized_colors[1],
                                    unrenormalized_colors[2]);
         } // suffix=="ply" conditional

         bool normalized_input_RGB_values=false;
         colorfunc::RGB_bytes curr_RGB_bytes=
            colorfunc::RGB_to_bytes(curr_RGB,normalized_input_RGB_values);
         colors_ptr->push_back(
            osg::Vec4ub(curr_RGB_bytes.first,curr_RGB_bytes.second,
                        curr_RGB_bytes.third,alpha_byte));

//         cout << curr_xyz.get(0) << " "
//              << curr_xyz.get(1) << " "
//              << curr_xyz.get(2) << endl;
         xyz_pnts.push_back(curr_xyz);

         X_pnts.push_back(curr_xyz.get(0));
         Y_pnts.push_back(curr_xyz.get(1));
         Z_pnts.push_back(curr_xyz.get(2));

         x_min=basic_math::min(x_min,curr_xyz.get(0));
         x_max=basic_math::max(x_max,curr_xyz.get(0));

         y_min=basic_math::min(y_min,curr_xyz.get(1));
         y_max=basic_math::max(y_max,curr_xyz.get(1));

         z_min=basic_math::min(z_min,curr_xyz.get(2));
         z_max=basic_math::max(z_max,curr_xyz.get(2));

      }
   } // loop over index i 

   cout << "x_min = " << x_min << " x_max = " << x_max << endl;
   cout << "y_min = " << y_min << " y_max = " << y_max << endl;
   cout << "z_min = " << z_min << " z_max = " << z_max << endl;
   int n_output_bins=100;

   prob_distribution X_prob(X_pnts,n_output_bins,x_min);
   prob_distribution Y_prob(Y_pnts,n_output_bins,y_min);
   prob_distribution Z_prob(Z_pnts,n_output_bins,z_min);

   double cumprob=0.05;
//   cout << "Enter cumulative z probability:" << endl;
//   cin >> cumprob;
   double z_cum=Z_prob.find_x_corresponding_to_pcum(cumprob);
   cout << "z_cum = " << z_cum << endl;

   double eps_x=0.001;
   double x_lo_cum=X_prob.find_x_corresponding_to_pcum(eps_x);
   double x_hi_cum=X_prob.find_x_corresponding_to_pcum(1-eps_x);
   x_hi_cum=x_max;

   double eps_y=0.001;
   double y_lo_cum=Y_prob.find_x_corresponding_to_pcum(eps_y);
   double y_hi_cum=Y_prob.find_x_corresponding_to_pcum(1-eps_y);

   threevector thresholded_xyz_COM;
   vector<threevector> thresholded_xyz_pnts;
   for (int i=0; i<xyz_pnts.size(); i++)
   {
      threevector curr_xyz=xyz_pnts[i];
      if (curr_xyz.get(0) > x_lo_cum && curr_xyz.get(0) < x_hi_cum &&
          curr_xyz.get(1) > y_lo_cum && curr_xyz.get(1) < y_hi_cum &&
          curr_xyz.get(2) > z_cum)
      {
         thresholded_xyz_pnts.push_back(curr_xyz);
         P_pnts.push_back(0);
         thresholded_xyz_COM += curr_xyz;
      }
   }
   thresholded_xyz_COM /= thresholded_xyz_pnts.size();
   cout << "xyz_pnts.size() = " << xyz_pnts.size() << endl;
   cout << "thresholded_xyz_pnts.size() = " << thresholded_xyz_pnts.size() 
        << endl;
   cout << "thresholded_xyz_COM = " << thresholded_xyz_COM << endl;

// Apply fitted scale, translation and rotation to bundler XYZ points
// in order to georegister them with NYC ladar map:

   osg::Vec3Array* vertices_ptr=new osg::Vec3Array;

//      double fitted_nyc_to_bundler_distance_ratio = 465.107262286;
//      threevector fitted_bundler_trans( 
//         583554.894526, 4508719.49732, 135.21422601);
//      double global_az = 108.99283146*PI/180;
//      double global_el= -1.01519976041*PI/180;
//      double global_roll = -0.458266485503*PI/180;

// "Best fit" georegistration parameters calculated via program
// LADARSYNTH for 1012 NYC photos reconstructed by Noah in June 2009:
 
//   double fitted_nyc_to_bundler_distance_ratio= 16.5752865695;
   double fitted_nyc_to_bundler_distance_ratio= 1000;
   threevector fitted_bundler_trans(
      583887.298309 , 4509465.89982  ,508.234588843);
   if (suffix=="ply")
   {
      fitted_bundler_trans=thresholded_xyz_COM;
   }

// On 9/13/09, we empirically found that az=el=0, roll=90 yields a
// quasi-reasonable XYZ orientation for Noah's preliminary Boston
// skyline reconstruction

   double global_az=0;
   cout << "Enter global_az" << endl;
   cin >> global_az;
   global_az *= PI/180;

   double global_el=0;
   cout << "Enter global_el" << endl;
   cin >> global_el;
   global_el *= PI/180;

   double global_roll=0;
   cout << "Enter global_roll" << endl;
   cin >> global_roll;
   global_roll *= PI/180;

//   double global_az = 135.170030088*PI/180;
//   double global_el = 2.24855835965*PI/180;
//   double global_roll = -9.77460748613*PI/180;

   rotation global_R;
   global_R=global_R.rotation_from_az_el_roll(
      global_az,global_el,global_roll);
   cout << "global_R = " << global_R << endl;

   threevector fitted_bundler_feature_COM(
      583299.091845454,4506309.89236364,101.864543137272);

   vector<threevector> fitted_xyz_pnts;
   for (int i=0; i<thresholded_xyz_pnts.size(); i++)
   {
      threevector bundler_xyz=thresholded_xyz_pnts[i];
      bundler_xyz *= fitted_nyc_to_bundler_distance_ratio;
      bundler_xyz += fitted_bundler_trans;

      threevector rel_bundler_xyz=bundler_xyz-fitted_bundler_feature_COM;
      rel_bundler_xyz = global_R * rel_bundler_xyz;
      bundler_xyz=rel_bundler_xyz+fitted_bundler_feature_COM;

      fitted_xyz_pnts.push_back(bundler_xyz);
//      fitted_xyz_pnts.push_back(thresholded_xyz_pnts[i]);

      vertices_ptr->push_back(osg::Vec3(bundler_xyz.get(0),
                                        bundler_xyz.get(1),
                                        bundler_xyz.get(2)));

//      cout << vertices_ptr->back().x() << " , "
//           << vertices_ptr->back().y() << " , "
//           << vertices_ptr->back().z() << endl;

   } // loop over index i labeling XYZ points

   string xyzp_filename="bundler.xyzp";
   bool p_represents_genuine_prob=true;
   xyzpfunc::write_xyzp_data(
//      thresholded_xyz_pnts,P_pnts,xyzp_filename,p_represents_genuine_prob);
      fitted_xyz_pnts,P_pnts,xyzp_filename,p_represents_genuine_prob);

   string tdp_filename="bundler.tdp";
   string UTMzone="18";
   tdpfunc::write_relative_xyzrgba_data(
      tdp_filename,UTMzone,vertices_ptr,colors_ptr);
}

