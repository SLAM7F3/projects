// ========================================================================
// Program LADARSYNTH performs a brute-force search over a
// 7-dimensional parameter space to find the scale factor, global
// translation and global rotation needed to georegister Noah
// Snavely's relatively registered photo set generated by his BUNDLER
// program.  We hardwire reasonable initial guesses for all these
// parameters within this program.  Looping over all the parameters,
// LADARSYNTH computes the squared projection error between 3D
// features manually selected in the NYC point cloud and 2D tiepoint
// counterparts also manually selected in some number of Noah's
// photos.  After multiple iterations of this looping are performed,
// LADARSYNTH returns a decent estimate for the 7 global parameter
// values.

//				ladarsynth

// ========================================================================
// Last updated on 4/20/09; 5/29/09; 6/23/09
// ========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <osgUtil/Optimizer>
#include <osgDB/ReadFile>
#include <osgDB/WriteFile>

#include "video/camera.h"
#include "math/constant_vectors.h"
#include "osg/osgOrganization/Decorations.h"
#include "osg/osgFeatures/FeaturesGroup.h"
#include "general/filefuncs.h"
#include "osg/ModeController.h"
#include "templates/mytemplates.h"
#include "osg/osgOperations/Operations.h"
#include "optimum/optimizer.h"
#include "optimum/optimizer_funcs.h"
#include "numerical/param_range.h"
#include "passes/PassesGroup.h"
#include "video/photograph.h"
#include "video/photogroup.h"
#include "osg/osg3D/Terrain_Manipulator.h"
#include "osg/osgWindow/ViewerManager.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::string;
using std::vector;

// ==========================================================================
int main( int argc, char** argv )
{

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   int n_passes=passes_group.get_n_passes();

// Construct the viewer and instantiate a ViewerManager:

   WindowManager* window_mgr_ptr=new ViewerManager();
   window_mgr_ptr->initialize_window("3D imagery");

// Create OSG root node:

   osg::Group* root = new osg::Group;

// Instantiate Operations object to handle mode, animation and image
// number control:

   Operations operations(ndims,window_mgr_ptr,passes_group);

   ModeController* ModeController_ptr=operations.get_ModeController_ptr();
   root->addChild(operations.get_OSGgroup_ptr());

// Add a custom manipulator to the event handler list:

   osgGA::Terrain_Manipulator* CM_3D_ptr=new osgGA::Terrain_Manipulator(
      ModeController_ptr,window_mgr_ptr);
   window_mgr_ptr->set_CameraManipulator(CM_3D_ptr);

// Instantiate group to hold all decorations:
   
   Decorations decorations(window_mgr_ptr,ModeController_ptr,CM_3D_ptr);

// Read in Noah's original set of photos and reconstructed cameras:

   string subdir=
      "/home/cho/programs/c++/svn/projects/src/mains/newyork/bundler/nyc_1000/Manhattan1012Compressed/";
//   string subdir=
//   "/home/cho/programs/c++/svn/projects/src/mains/newyork/bundler/Manhattan/";
   string image_list_filename=subdir+"Manhattan.1012.txt";
//   string image_list_filename=subdir+"list.compressed.txt";
   string bundle_compressed_filename=subdir+"Manhattan.1012.out";
//   string bundle_compressed_filename=subdir+"bundle.compressed.out";
   string image_sizes_filename="foo.dat";

   photogroup* bundler_photogroup_ptr=new photogroup();

   int n_photos_to_reconstruct=-1;
//   int n_photos_to_reconstruct=8;
   bundler_photogroup_ptr->reconstruct_bundler_cameras(
      subdir,image_list_filename,image_sizes_filename,
      bundle_compressed_filename,n_photos_to_reconstruct);

// Copy original bundler photogroup onto working photogroup:

   photogroup* photogroup_ptr=new photogroup(*bundler_photogroup_ptr);
   int n_photos(photogroup_ptr->get_n_photos());
   cout << "n_photos = " << n_photos << endl;

// Initialize values for 7 global parameters needed to map bundler
// into world coordinates:

/*
//   double scale_0 = 466.301280029;
   double xtrans_0 = 583554.951311;
   double ytrans_0 = 4508724.8005;
   double ztrans_0 = 135.20507285;
//   double az_0= 108.933925848;
//   double el_0= -1.03142393698;
//   double roll_0 = -0.48023128125;
//   min_score = 0.285090632376

   double az_0 = 108.97126;
   double el_0= -1.017785057;
   double roll_0 = -0.4639561375;
   double scale_0 = 466.3011801;
*/

/*
   double scale_0= 465.151514176;
   double xtrans_0 = 583554.951311;
   double ytrans_0 = 4508719.71829;
   double ztrans_0 = 135.20507285;
   double az_0 = 108.991558094;
   double el_0 = -1.00948129137;
   double roll_0 = -0.455652371875;
//   min_score = 0.268823145845
*/

/*
   double scale_0 = 465.130027168;
   double xtrans_0 = 583554.903106;
   double ytrans_0 = 4508719.61596;
   double ztrans_0 = 135.213603341;
   double az_0 = 108.992101202;
   double el_0 = -1.01458234471;
   double roll_0 = -0.457719382225;
//min_score = 0.268783665304
*/

//   double scale_0 = 465.107262286;
//   double xtrans_0 = 583554.894526;
//   double ytrans_0 = 4508719.49732;
//   double ztrans_0 = 135.21422601;
//   double az_0 = 108.99283146;
//   double el_0 = -1.01519976041;
//   double roll_0 = -0.458266485503;
//   min_score = 0.268774555636

// Raw parameters estimated from roughly aligning Noah's 3D point
// cloud derived from 1012 photos with NYC ladar data:

//   double scale_0=16.5671099346348;
//   double xtrans_0=583887.626010023;
//   double ytrans_0=4509462.20835707;
//   double ztrans_0=507.348354146674;
//   double az_0 = 135.226534476547;
//   double el_0 = 2.14044689264945;
//   double roll_0 = -9.6634040587416;

//   double scale_0 = 16.5671099346;
//   double xtrans_0 = 583886.997729;
//   double ytrans_0 = 4509465.34258;
//   double ztrans_0 = 507.845895813;
//   double az_0 = 135.151356352;
//   double el_0 = 2.28169064265;
//   double roll_0 = -9.77477905874;
//   min_score = 0.271104303732

//   double scale_0 = 16.5714747092;
//   double xtrans_0 = 583886.874678;
//   double ytrans_0 = 4509465.62852;
//   double ztrans_0 = 508.151665776;
//   double az_0 = 135.172953115;
//   double el_0 = 2.24952695554;
//   double roll_0= -9.77547197275;
// min_score = 0.266109190218

//   double scale_0 = 16.5730520591;
//   double xtrans_0 = 583886.860862;
//   double ytrans_0 = 4509465.96715;
//   double ztrans_0 = 508.212583203;
//   double az_0 = 135.173032985;
//   double el_0 = 2.24806986292;
//   double roll_0 = -9.77520041898;
// min_score = 0.265274396004

   double scale_0 = 16.5752865695;
   double xtrans_0 = 583887.298309;
   double ytrans_0 = 4509465.89982;
   double ztrans_0 = 508.234588843;
   double az_0 = 135.170030088;
   double el_0 = 2.24855835965;
   double roll_0 = -9.77460748613;
//    min_score = 0.264238531726


   photogroup_ptr->set_bundler_to_world_scalefactor(scale_0);
   photogroup_ptr->set_bundler_to_world_az(az_0*PI/180);
   photogroup_ptr->set_bundler_to_world_el(el_0*PI/180);
   photogroup_ptr->set_bundler_to_world_roll(roll_0*PI/180);
   photogroup_ptr->set_bundler_to_world_translation(
      threevector(xtrans_0,ytrans_0,ztrans_0));

/*
   photogroup_ptr->set_bundler_to_world_scalefactor(466.301280029);
   photogroup_ptr->set_bundler_to_world_az(108.779639832*PI/180);
   photogroup_ptr->set_bundler_to_world_el(-1.11411987448*PI/180);
   photogroup_ptr->set_bundler_to_world_roll(-0.387659671875*PI/180);
   photogroup_ptr->set_bundler_to_world_translation(
      threevector(583552.414049 , 4508737.128, 133.15476035 ));
*/

//   string manual_features_subdir="./packages/bundler/manually_selected/";
   string manual_features_subdir=
//      "./bundler/Manhattan/images/numbered_photos/";
      "./bundler/nyc_1000/Manhattan1012Compressed/images/numbered_photos/";

   string order_filename=manual_features_subdir+"bundler_photo_order.dat";
   photogroup_ptr->set_photo_order(order_filename);
   
   optimizer* optimizer_ptr=new optimizer(photogroup_ptr);
   optimizer_ptr->set_bundler_photogroup_ptr(bundler_photogroup_ptr);

   for (int n=0; n<n_photos; n++)
   {
//      cout << "n = " << n << endl;
      photograph* photograph_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photograph_ptr->get_camera_ptr();
      camera_ptr->construct_internal_parameter_K_matrix();
   }

// As of 4/20/09, we hardwire the pass numbers for the photos for
// which we manually identified 2D tiepoint counterparts to 3D
// features within the NYC point cloud:

   vector<int> manually_selected_photo_numbers;
   manually_selected_photo_numbers.push_back(10);
   manually_selected_photo_numbers.push_back(108);
   manually_selected_photo_numbers.push_back(138);
   manually_selected_photo_numbers.push_back(311);
   manually_selected_photo_numbers.push_back(343);
   manually_selected_photo_numbers.push_back(412);
   manually_selected_photo_numbers.push_back(731);
   manually_selected_photo_numbers.push_back(804);
   manually_selected_photo_numbers.push_back(977);
   manually_selected_photo_numbers.push_back(978);
//   cout << "manually_selected_photo_numbers = " << endl;
//   templatefunc::printVector(manually_selected_photo_numbers);

// Instantiate FeaturesGroup to hold small number of manually
// extracted ladar and corresponding Bundler stills features:

   FeaturesGroup* manual_FeaturesGroup_ptr=new FeaturesGroup(
      ndims,passes_group.get_pass_ptr(n_passes-1),CM_3D_ptr);

   string manual_features_filename=
//      manual_features_subdir+"features_manual_combined_5passes.txt";
      manual_features_subdir+"features_manual_combined_10passes.txt";

   manual_FeaturesGroup_ptr->read_feature_info_from_file(
      manual_features_filename);
//   manual_FeaturesGroup_ptr->write_feature_html_file(11+2);

   optimizer_ptr->extract_manual_feature_info(manual_FeaturesGroup_ptr);

/*
   optimizer_ptr->bundle_adjust_for_global_photosynth_params(
      manual_FeaturesGroup_ptr);

   cout << "inside main after call to bundle_adjust_for_global_photosynth_params()" << endl;
   exit(-1);
*/


// Initialize loops over internal camera parameters:

/*
   double scale_0 = 463.802255025;
   double xtrans_0 = 583548.418438;
   double ytrans_0 = 4508725.27547;
   double ztrans_0 = 133.1258125;
   double az_0 = 108.913895;
   double el_0 = -1.1276;
   double roll_0 = -0.362748375;
//	min_score = 0.0640857766632
*/

//   double scale_0 = 465.591935166;
//   double xtrans_0 = 583551.547603;
//   double ytrans_0 = 4508733.50834;
//   double ztrans_0 = 133.324520458;
//   double az_0 = 108.798323305;
//   double el_0 = -1.10773324074;
//   double roll_0 = -0.370062954545;
// min_score = 0.059928466905

/*
   double scale_0 = 466.301280029;
   double xtrans_0 = 583552.414049;
   double ytrans_0 = 4508737.128;
   double ztrans_0 = 133.15476035;
   double az_0 = 108.779639832;
   double el_0 = -1.11411987448;
   double roll_0 = -0.387659671875;
//min_score = 0.0592527318777
*/

// Results generated on Monday, April 20 after selecting features in
// 10 of Noah's 318 photos with relatively small covariance values:

//   double scale_0= 466.301280029;
//   double xtrans_0= 583552.414049;
//   double ytrans_0= 4508726.87644;
//   double ztrans_0= 135.20507285;
//   double az_0=108.984671082;
//   double el_0=-0.96376362448;
//   double roll_0=-0.387659671875;
//   min_score = 0.336662546825

/*
   double scale_0 = 466.301280029;
   double xtrans_0 = 583554.951311;
   double ytrans_0 = 4508724.8005;
   double ztrans_0 = 135.20507285;
   double az_0= 108.933925848;
   double el_0= -1.03142393698;
   double roll_0 = -0.48023128125;
//   min_score = 0.285090632376
*/

   param_range scale(0.9*scale_0,1.1*scale_0, 5);
   param_range x_trans(xtrans_0 - 20, xtrans_0 + 20, 3);
   param_range y_trans(ytrans_0 - 20, ytrans_0 + 20, 3);
   param_range z_trans(ztrans_0 - 20, ztrans_0+20, 3);
   param_range az((az_0-3)*PI/180, (az_0+3)*PI/180,5);
   param_range el((el_0-2)*PI/180, (el_0+2)*PI/180,5);
   param_range roll((roll_0-2)*PI/180, (roll_0+2)*PI/180,5);

/*
   const double fitted_nyc_to_bundler_distance_ratio=463.38132764396;
   const threevector fitted_bundler_trans
      (583558.678495729 , 4508707.62273733 , 131.773459314555);
   const double global_az = 109.470775746297 * PI/180;
   const double global_el = -0.520154656320816 * PI/180;
   const double global_roll = -0.257684381003458 * PI/180;

   param_range scale(1.0*463.38,1.0*463.38, 1);
   param_range x_trans(583558.67 - 0, 583558.67 + 0, 1);
   param_range y_trans(4508707.62 - 0, 4508707.62 + 0, 1);
   param_range z_trans(131.773 - 0, 131.773+0, 1);
   param_range az((109.47077-0)*PI/180, (109.47077+0)*PI/180,1);
   param_range el((-0.5201-0)*PI/180, (-0.5201+0)*PI/180,1);
   param_range roll((-0.257-0)*PI/180, (0.257+0)*PI/180,1);
*/

   threevector bundler_rotation_origin(
      583299.091845454  ,4506309.89236364 , 101.864543137272);
//		 fitted bundler feature COM

//   threevector bundler_rotation_origin(
//      583299.023754546 , 
//      4506310.19790909 , 
//      101.864543137272);
   // NYC feature COM

   double min_score=POSITIVEINFINITY;
  
   int counter=0;
//   int n_iters=5;
//   int n_iters=10;
   int n_iters=15;
   for (int iter=0; iter<n_iters; iter++)
   {
      cout << "iter = " << iter << " of " << n_iters << endl;

// ========================================================================
// Begin while loops over camera parameters here
// ========================================================================

      while (scale.prepare_next_value())
      {
         cout << scale.get_counter() << " " << flush;

         while (x_trans.prepare_next_value())
         {
            while (y_trans.prepare_next_value())
            {
               while (z_trans.prepare_next_value())
               {
                  while (az.prepare_next_value())
                  {
                     while (el.prepare_next_value())
                     {
                        while (roll.prepare_next_value())
                        {

                           double score=0;
                           for (int k=0; 
                                k<manually_selected_photo_numbers.size(); k++)
                           {
                              int n=manually_selected_photo_numbers[k];
//                              cout << "n = " << n << endl;
                              photograph* photograph_ptr=
                                 photogroup_ptr->get_photograph_ptr(n);
                              camera* camera_ptr=photograph_ptr->
                                 get_camera_ptr();

                              photograph* bundler_photograph_ptr=
                                 bundler_photogroup_ptr->
                                 get_photograph_ptr(n);

                              *camera_ptr=*(bundler_photograph_ptr->
                                            get_camera_ptr());


                              camera_ptr->convert_bundler_to_world_coords(
                                 x_trans.get_value(),y_trans.get_value(),
                                 z_trans.get_value(),
			         bundler_rotation_origin,
				 az.get_value(),
                                 el.get_value(),roll.get_value(),
                                 scale.get_value());

                              camera_ptr->
                                 construct_projection_matrix_for_fixed_K();
//                              cout << " *P_ptr = " 
//                                   << *(camera_ptr->get_P_ptr()) << endl;
                           
                              double avg_residual=optimizer_ptr->
                                 projection_error(n);
//                              cout << "avg_residual = " << avg_residual 
//                                   << endl;
                              if (finite(avg_residual) != 0)
                              {
                                 score += 1000*avg_residual;
                              }
                              else
                              {
                                 score += POSITIVEINFINITY;
                                 break;
                              }

                           } // loop over index k labeling manually selected
			     //   photos

                           if (score < min_score)
                           {
                              min_score=score;
                              scale.set_best_value();
                              x_trans.set_best_value();
                              y_trans.set_best_value();
                              z_trans.set_best_value();
                              az.set_best_value();
                              el.set_best_value();
                              roll.set_best_value();
                           }

//                           cout << "score = " << score 
//                                << " min_score = " << min_score 
//                                << " s_count = " << scale.get_counter()
//                                << " counter = " << counter++ << endl;

                           
                        } // roll while loop
                     }  // el while loop
                  } // az while loop
               } // z_trans while loop
            } // y_trans while loop
         } // x_trans while loop
      } // scale while loop
      cout << endl;

// ========================================================================
// End while loop over camera parameters
// ========================================================================

      double frac=0.45;
      scale.shrink_search_interval(scale.get_best_value(),frac);
      x_trans.shrink_search_interval(x_trans.get_best_value(),frac);
      y_trans.shrink_search_interval(y_trans.get_best_value(),frac);
      z_trans.shrink_search_interval(z_trans.get_best_value(),frac);
      az.shrink_search_interval(az.get_best_value(),frac);
      el.shrink_search_interval(el.get_best_value(),frac);
      roll.shrink_search_interval(roll.get_best_value(),frac);

      cout.precision(12);
      cout << "Best scale value = " << scale.get_best_value() << endl;
      cout << "Best x_trans value = " << x_trans.get_best_value() << endl;
      cout << "Best y_trans value = " << y_trans.get_best_value() << endl;
      cout << "Best z_trans value = " << z_trans.get_best_value() << endl;
      cout << "Best az value = " << az.get_best_value()*180/PI << endl;
      cout << "Best el value = " << el.get_best_value()*180/PI << endl;
      cout << "Best roll value = " << roll.get_best_value()*180/PI << endl;

      cout << "min_score = " << min_score << endl;

//      outputfunc::enter_continue_char();

   } // loop over iter index

   cout.precision(12);


   delete optimizer_ptr;
   delete window_mgr_ptr;
}
