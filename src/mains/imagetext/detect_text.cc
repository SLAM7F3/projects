// ==========================================================================
// DETECT_TEXT imports the dictionary generated by program DICTIONARY, 
// inverse square root of the whitening covariance matrix generated by
// program WHITEN_DESCRIPTORS, and the probabilistic
// decision function generated by program SVM_TEXT.  Looping over some
// input set of testing image chips, this program then extracts
// 9K-dimensional feature vectors and effectively dots them with the
// components within the linear SVM classifier weight vector.  If the
// dotproduct exceeds a user-specified threshold fraction, the input
// test image is classified as "text".  Confusion matrix results are
// calculated and written to text file output.

// 			      detect_text

// ==========================================================================
// Last updated on 6/2/14; 6/8/14; 6/22/14
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <flann/flann.hpp>
#include <flann/io/hdf5.h>
#include "dlib/svm.h"

#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "image/imagefuncs.h"
#include "numrec/nrfuncs.h"
#include "general/sysfuncs.h"
#include "classification/text_detector.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   nrfunc::init_time_based_seed();

   double Ng_char_threshold=0.9;
   cout << "Enter Ng char threshold:" << endl;
   cin >> Ng_char_threshold;

   timefunc::initialize_timeofday_clock();

   string classification_subdir="/data1/imagetext/classification_results_"+
      stringfunc::number_to_string(Ng_char_threshold)+"/";
   filefunc::dircreate(classification_subdir);
   string classified_text_subdir=classification_subdir+"text/";
   string classified_nontext_subdir=classification_subdir+"nontext/";
   filefunc::dircreate(classified_text_subdir);
   filefunc::dircreate(classified_nontext_subdir);

   string testing_images_subdir="./testing_data/";
   string dictionary_subdir="./training_data/dictionary/";
   bool RGB_pixels_flag=false;
   text_detector* text_detector_ptr=new text_detector(
      dictionary_subdir,RGB_pixels_flag);

   const unsigned int K=1500;
//   int K=text_detector_ptr->get_K();
   text_detector_ptr->import_inverse_sqrt_covar_matrix();
   text_detector_ptr->compute_Dtrans_inverse_sqrt_covar_matrix();

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("png");
   allowed_suffixes.push_back("jpg");

   bool search_all_children_dirs_flag=false;
   vector<string> image_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,testing_images_subdir,
         search_all_children_dirs_flag);
   int n_images=image_filenames.size();
//    cout << "Number of input images = " << n_images << endl;

   int i_start=0;
   int i_stop=4000;
//   int i_stop=n_images;

// Import binary and probabilistic decision functions generated by an
// SVM with a linear kernel on 32x32 text and non-text images:

   const unsigned int nineK=9*K;
   typedef dlib::matrix<double, nineK, 1> Ng_sample_type;
   typedef dlib::linear_kernel<Ng_sample_type> Ng_kernel_type;
   Ng_sample_type Ng_sample;

   typedef dlib::decision_function<Ng_kernel_type> Ng_dec_funct_type;
   typedef dlib::normalized_function<Ng_dec_funct_type> Ng_funct_type;
   Ng_funct_type Ng_funct;

   typedef dlib::probabilistic_decision_function<Ng_kernel_type> 
      Ng_probabilistic_funct_type;  
   typedef dlib::normalized_function<Ng_probabilistic_funct_type> 
      Ng_pfunct_type;
   Ng_pfunct_type Ng_pfunct;

   string learned_funcs_subdir="./learned_functions/";
   string learned_Ng_pfunct_filename=learned_funcs_subdir+
      "text_Ng_pfunct_30000_30000.dat";
   cout << "learned_Ng_pfunct_filename = "
        << learned_Ng_pfunct_filename << endl;
   ifstream fin6(learned_Ng_pfunct_filename.c_str(),ios::binary);
   dlib::deserialize(Ng_pfunct, fin6);

   int n_classified_text_images=0;
   int n_classified_nontext_images=0;
   int n_apriori_text_images=0;
   int n_apriori_nontext_images=0;

   bool apriori_text_flag,classified_text_flag;
   unsigned int n_true_positives=0;
   unsigned int n_false_positives=0;
   unsigned int n_false_negatives=0;
   unsigned int n_true_negatives=0;
   genmatrix confusion_matrix(2,2);

   string output_filename="text_vs_nontext.dat";
   ofstream outstream;
   filefunc::openfile(output_filename,outstream);

   for (int i=i_start; i<i_stop; i++)
   {
      double progress_frac = (i-i_start)/double(i_stop-i_start);
      outputfunc::print_elapsed_and_remaining_time(progress_frac);

      int j=n_images * nrfunc::ran1();
      string curr_image_filename=image_filenames[j];
      string image_basename=filefunc::getbasename(curr_image_filename);
      
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         image_basename,"_");
      if (substrings[0]=="nontext")
      {
         apriori_text_flag=false;
         n_apriori_nontext_images++;
      }
      else
      {
         apriori_text_flag=true;
         n_apriori_text_images++;
      }

      text_detector_ptr->import_image_from_file(curr_image_filename);

      unsigned int width,height;
      imagefunc::get_image_width_height(curr_image_filename,width,height);

      cout << "i = " << i 
           << " width = " << width << " height = " << height 
           << " image_filename = " << curr_image_filename
           << endl;

      text_detector_ptr->set_window_width(width);
      text_detector_ptr->set_window_height(height);

      text_detector_ptr->average_window_features(0,0);

      float* window_histogram=text_detector_ptr->
         get_nineK_window_descriptor();

// Check whether window_histogram is nearly equal to zero
// vector.  If so, ignore this trivial descriptor:

      int n_nonzero_entries=0;
      for (unsigned int k=0; k<nineK; k++)
      {
         if (!nearly_equal(window_histogram[k],0)) 
         {
            n_nonzero_entries++;
         }
         Ng_sample(k) = window_histogram[k];
      }

      double Ng_char_prob=Ng_pfunct(Ng_sample);

      cout << "Ng char probability = " << Ng_char_prob << endl;
      string unix_cmd;
      if (Ng_char_prob < Ng_char_threshold)
      {
         cout << "Input image is NOT text" << endl;
         n_classified_nontext_images++;
         classified_text_flag=false;
         unix_cmd="cp "+curr_image_filename+" "+classified_nontext_subdir;
      }
      else
      {
         cout << "Input image is TEXT" << endl;
         n_classified_text_images++;
         classified_text_flag=true;
         unix_cmd="cp "+curr_image_filename+" "+classified_text_subdir;
      }
//      sysfunc::unix_command(unix_cmd);
//      outputfunc::enter_continue_char();

      if (apriori_text_flag && classified_text_flag)
      {
         n_true_positives++;
      }
      else if (!apriori_text_flag && !classified_text_flag)
      {
         n_true_negatives++;
      }
      else if (apriori_text_flag && !classified_text_flag)
      {
         n_false_negatives++;
      }
      else if (!apriori_text_flag && classified_text_flag)
      {
         n_false_positives++;
      }

      cout << "n_classified_text_images = "
           << n_classified_text_images
           << " n_apriori_text_images = "
           << n_apriori_text_images << endl;
      cout << "n_classified_nontext_images = "
           << n_classified_nontext_images
           << " n_apriori_nontext_images = "
           << n_apriori_nontext_images << endl;

      int n_positives=n_true_positives+n_false_positives;
      double frac_true_positives=double(n_true_positives)/n_positives;
      double frac_false_positives=double(n_false_positives)/n_positives;

      int n_negatives=n_true_negatives+n_false_negatives;
      double frac_false_negatives=double(n_false_negatives)/n_negatives;
      double frac_true_negatives=double(n_true_negatives)/n_negatives;

      confusion_matrix.put(0,0,frac_true_positives);
      confusion_matrix.put(0,1,frac_false_positives);
      confusion_matrix.put(1,0,frac_false_negatives);
      confusion_matrix.put(1,1,frac_true_negatives);
      
      cout << "Confusion matrix:" << endl;
      cout << confusion_matrix << endl;

      if (i==i_stop-1)
      {
         outstream << "Number of classified images = " 
                   << i_stop - i_start << endl;
         outstream << "Ng char threshold = " << Ng_char_threshold << endl; 
         outstream << "n_classified_text_images = "
                   << n_classified_text_images
                   << " n_apriori_text_images = "
                   << n_apriori_text_images << endl;
         outstream << "n_classified_nontext_images = "
                   << n_classified_nontext_images
                   << " n_apriori_nontext_images = "
                   << n_apriori_nontext_images << endl << endl;
         outstream << "Confusion matrix:" << endl;
         outstream << confusion_matrix << endl;
      }
      
   } // loop over index i labeling input images
   cout << endl;

   filefunc::closefile(output_filename,outstream);
   string banner="Exported confusion matrix results to "+
      output_filename;
   outputfunc::write_big_banner(banner);

   delete text_detector_ptr;
}

