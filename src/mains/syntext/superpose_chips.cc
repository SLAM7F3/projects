// ==========================================================================
// Program SUPERPOSE_CHIPS imports a set of synthetic text chips and
// their masks generated by program CREATE_STRING_IMAGES.  It also
// takes in a set of background internet photos which should contain
// no text content.  SUPERPOSE_CHIPS generates a specified number of
// output tiles whose pixel size is consistent with deeplab semantic
// segmentation network finetuning.  

// For each tile, this program randomly selects a non-text background.
// It next randomly picks 1, 2, 3 or 4 string image chips to superpose
// on the tile background.  If more than one string is superposed on a
// tile, SUPERPOSE_CHIPS tries to separate them in the vertical
// direction so as to minimize multi-string overlap.  An 8-bit
// greyscale mask is generated for each tile which marks the location
// of all synthetic text within the overall tile.

// Tiles and masks are exported to separate folders, and their
// associations are recorded within text files.  20% of the tile/mask
// pairs are reserved for DNN finetuning validation.  A shuffled set
// of training and testing tile/mask filename pairs are written to
// text files which are needed as inputs for Deeplab.  A final set of
// tile and mask chips are also exported to a deeplab_inputs folder so
// that they can be more easily uploaded to Titan GPU machines for
// Deeplab processing.

// ==========================================================================
// Last updated on 3/2/16; 3/3/16; 3/11/16
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "math/constants.h"
#include "general/filefuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();
   nrfunc::init_time_based_seed();

// Store pairs of tile and corresponding mask filenames within an STL
// map:

   typedef pair<string, string> STRING_PAIR;
   typedef std::map<int, vector<STRING_PAIR> > IMAGE_TILES_MAP;
// independent int: image ID
// dependent vector<string,string > : pairs of tile and mask filenames associated with image

   IMAGE_TILES_MAP image_tiles_map;
   IMAGE_TILES_MAP::iterator image_tiles_map_iter;
   
   string synthetic_subdir="./training_data/syn_strings/";
   string deeplab_inputs_subdir=synthetic_subdir+"deeplab_inputs/";
   filefunc::dircreate(deeplab_inputs_subdir);

   vector<string> chips_subdirs, masks_subdirs;
   chips_subdirs.push_back(synthetic_subdir+"Mar11_30K_syn_words/rotated_images/");
   masks_subdirs.push_back(synthetic_subdir+"Mar11_30K_syn_words/rotated_masks/");
//   chips_subdirs.push_back(synthetic_subdir+"Mar2_30K_syn_numerals/00000/");
//   masks_subdirs.push_back(chips_subdirs.back()+"masks/");
//   chips_subdirs.push_back(synthetic_subdir+"Mar2_50K_syn_words/00000/");
//   masks_subdirs.push_back(chips_subdirs.back()+"masks/");

   vector<string> chip_filenames=filefunc::image_files_in_multi_subdirs(
      chips_subdirs);
   vector<string> mask_filenames=filefunc::image_files_in_multi_subdirs(
      masks_subdirs);
   int n_image_chips = chip_filenames.size();
      
   string extended_chips_subdir=synthetic_subdir+"extended_chips/";
   filefunc::dircreate(extended_chips_subdir);
   string extended_masks_subdir=synthetic_subdir+"extended_masks/";
   filefunc::dircreate(extended_masks_subdir);

   string backgrounds_subdir = "./images/internet/non_text/";
   vector<string> background_filenames=filefunc::image_files_in_subdir(
      backgrounds_subdir);
   int n_backgrounds = background_filenames.size();

   int tile_size = 321 * 3;
   int tile_width = tile_size;
   int tile_height = tile_size;
   int n_images = 1;
   int n_channels = 4;
   texture_rectangle *tile_tr = new texture_rectangle(
      tile_width, tile_height, n_images, n_channels, NULL);
   texture_rectangle *tile_mask_tr = new texture_rectangle(
      tile_width, tile_height, n_images, n_channels, NULL);

   int background_counter = 0;
   int tstart = 0;
   int tstop = 35000;
//   int tstop = 60000;
   unsigned int n_tiles = tstop - tstart;
   cout << "n_tiles = " << n_tiles << endl;

// ---------------------------------------------------------------
// Main loop over all tiles starts here:

   int tskip = 1;
   for(int t = tstart; t < tstop; t += tskip)
   {
      outputfunc::update_progress_fraction(t,100,n_tiles);

      if ((t-tstart)%100 == 0)
      {
         double progress_frac = double(t - tstart)/n_tiles;
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }

// Step 1: Clear contents of current tile's texture rectangle:

      tile_tr->clear_all_RGB_values();
      tile_mask_tr->clear_all_RGB_values();

// Step 2: Overlay some non-text background image onto current tile's
// texture rectangle:

      texture_rectangle *background_tr_ptr = new texture_rectangle(
         background_filenames[background_counter%n_backgrounds], NULL);
      background_counter++;
      tile_tr->overlay_layer(0,0,background_tr_ptr);
      delete background_tr_ptr;

// Step 3: Randomly select maximum number of strings which can appear
// within the current tile:

      int n_max_strings = nrfunc::ran1() * 5;
      n_max_strings = basic_math::max(n_max_strings, 1);
      for(int s = 0; s < n_max_strings; s++)
      {
         int i = nrfunc::ran1() * n_image_chips;

//      cout << "t = " << t << " s = " << s << 
//           << " image_filename = " << chip_filenames[i] 
//           << " mask_filename = " << mask_filenames[i]
//           << endl;
      
         texture_rectangle* chip_tr_ptr = new texture_rectangle(
            chip_filenames[i], NULL);
         int chip_width = chip_tr_ptr->getWidth();
         int chip_height = chip_tr_ptr->getHeight();

         texture_rectangle* mask_tr_ptr = new texture_rectangle(
            mask_filenames[i], NULL);
//      int mask_width = mask_tr_ptr->getWidth();
//      int mask_height = mask_tr_ptr->getHeight();
//      cout << "chip_width = " << chip_width 
//           << " chip_height = " << chip_height << endl;
//      cout << "mask_width = " << mask_width 
//           << " mask_height = " << mask_height << endl;

// Step 4: Randomly overlay current text image chip onto tile texture.
// If more than one text string is to be displayed on the tile, try to
// separate them in the vertical direction so as to minimize their
// overlap:

         int pu_start = -chip_width + nrfunc::ran1() * 
            (chip_width + tile_width);

         int pv_spread = tile_height + chip_height;
         double s_lo_frac = double(s) / n_max_strings;
         double s_hi_frac = double(s+1) / n_max_strings;
         int pv_min = -chip_height + s_lo_frac * pv_spread;
         int pv_max = -chip_height + s_hi_frac * pv_spread;
         int pv_start = pv_min + nrfunc::ran1() * (pv_max - pv_min);
         tile_tr->overlay_layer(pu_start, pv_start, chip_tr_ptr); 

         bool generate_mask_flag = true;
         tile_mask_tr->overlay_layer(pu_start, pv_start, mask_tr_ptr,
                                     generate_mask_flag); 
      
         delete chip_tr_ptr;
         delete mask_tr_ptr;
      } // loop over s labeling potential tile strings

      string tile_image_filename=extended_chips_subdir+"tile_"+
         stringfunc::integer_to_string(t,6)+".jpg";
      tile_tr->write_curr_frame(tile_image_filename);

      bool visualize_mask_flag = true;
//      bool visualize_mask_flag = false;

      string bytearray_filename=extended_masks_subdir+"bytearray_"+
         stringfunc::integer_to_string(t,6)+".png";
      vector<vector<unsigned char> > byte_array = 
         videofunc::generate_byte_array(
            tile_mask_tr, NULL,
//               NULL, padded_mask_ptr, 
            0, tile_width - 1, 0, tile_height - 1,
            visualize_mask_flag);
      videofunc::write_8bit_greyscale_pngfile(
         byte_array, bytearray_filename);

// Save correspondence between tile image and tile mask to STL map:

      STRING_PAIR P;
      P.first = "/extended_chips/"+filefunc::getbasename(tile_image_filename);
      P.second = "/extended_masks/"+filefunc::getbasename(bytearray_filename);

      image_tiles_map_iter = image_tiles_map.find(t);
      if(image_tiles_map_iter == image_tiles_map.end()){
         vector<STRING_PAIR> V;
         V.push_back(P);
         image_tiles_map[t] = V;
      }
      else{
         vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
         V_ptr->push_back(P);
      }

   } // loop over index t labeling tiles
// ---------------------------------------------------------------

   delete tile_tr;
   delete tile_mask_tr;

   cout << "image_tiles_map.size() = " << image_tiles_map.size() << endl;

// Take first 80% of randomized image IDs for training and last 20%
// for testing:

   vector<int> random_seq = mathfunc::random_sequence(
      tstart, tstop, tstop - tstart + 1);

   const double training_frac = 0.8;
   unsigned int n_training = training_frac * n_tiles;
   cout << "n_training = " << n_training << endl;

   string images_masks_training_filename=deeplab_inputs_subdir+
      "images_masks_training.txt";
   ofstream outstream;
   filefunc::openfile(images_masks_training_filename, outstream);   

   for(unsigned int i = 0; i < n_training; i++)
   {
      int curr_image_ID = random_seq[i];
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end()) continue;
      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
      }
   }
   filefunc::closefile(images_masks_training_filename, outstream);

   string images_masks_testing_filename=deeplab_inputs_subdir+
      "images_masks_testing.txt";
   filefunc::openfile(images_masks_testing_filename, outstream);   

   for(unsigned int i = n_training; i < n_tiles; i++)
   {
      int curr_image_ID = random_seq[i];
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end()) continue;
      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
      }
   }
   filefunc::closefile(images_masks_testing_filename, outstream);

// Recall several authors stress that training and validation data
// sets should be randomized!  As John Wood pointed out, we can use
// the linux utility "shuf" to generate random permutations:

   string shuffled_images_masks_training_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_training.txt";
//      cout << "shuffled_images_masks_training_filename = "
//           << shuffled_images_masks_training_filename << endl;
   string unix_cmd = "shuf "+images_masks_training_filename+" > "+
      shuffled_images_masks_training_filename;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   string shuffled_images_masks_testing_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_testing.txt";
//      cout << "shuffled_images_masks_testing_filename = "
//           << shuffled_images_masks_testing_filename << endl;
   unix_cmd = "shuf "+images_masks_testing_filename+" > "+
      shuffled_images_masks_testing_filename;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

// Create object names file containing background and text classes:

   string object_names_filename=deeplab_inputs_subdir+
      "object_names.classes";
   filefunc::openfile(object_names_filename, outstream);
   outstream << "__background__" << endl;
   outstream << "text" << endl;
   filefunc::closefile(object_names_filename, outstream);
    
// Move folders containing extended chips and masks into
// deeplab_inputs_subdir:

   unix_cmd="mv "+extended_chips_subdir+" "+deeplab_inputs_subdir;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);
   
   unix_cmd="mv "+extended_masks_subdir+" "+deeplab_inputs_subdir;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   string banner="Exported deeplab inputs to "+deeplab_inputs_subdir;
   outputfunc::write_big_banner(banner);
} 


