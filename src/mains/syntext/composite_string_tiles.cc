// ==========================================================================
// Program COMPOSITE_STRING_TILES imports a set of synthetic text
// chips and their masks generated by programs GENERATE_STRING_IMAGES
// and VERTICAL_STRING_IMAGES.  It also takes in a set of background
// internet photos which should contain no text content.
// COMPOSITE_STRING_TILES generates a specified number of output tiles
// whose pixel size is consistent with deeplab semantic segmentation
// network finetuning.

// Each composite tile contains 3x3 individual tiles.  A random
// internet image is first laid down as a background for the entire
// composite tile.  Foreground text chips are then randomly superposed
// onto the background texture.  Foreground chip bounding boxes are
// not allowed to overlap.

// Entropy density is calculated within the background image within
// candidate foreground bboxes locations.  If the background entropy
// density is too large, the candidate foreground text location is
// rejected.  the Average foreground and background RGB values are
// also calculated for each image chip before it's superposed.  If
// their color contents are not sufficiently different, the candidate
// foreground chip is rejected and another random chip is selected.
// The number of foreground overlays within each composite varies
// randomly over the interval [9,27].  

// Once a composite image is formed, each pixel's RGB values are
// fluctuatued by a nonzero amount of random gaussian noise.  A
// sizable fraction of the composites are also blurred by a random
// amount.  We found that such composite degradation significantly
// improves deeplab semantic segmentation classifier performance on
// test images containing genuine text content.

// 8-bit greyscale "character" and "word" masks are also iteratively
// constructed which display the location of all synthetic text within
// the entire composite.  Once generation of a composite image and its
// associated masks are completed, they are decomposed into 3x3
// individual tiles.  Individual tiles and masks are exported to
// separate output folders.

// Multiple instances of COMPOSITE_STRING_TILES can be run in parallel
// on a single CPU machine.

//                      ./composite_string_tiles

// ==========================================================================
// Last updated on 4/17/16; 4/20/16; 4/22/16; 5/18/16
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "math/constants.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/sysfuncs.h"
#include "text/textfuncs.h"
#include "time/timefuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();

   nrfunc::init_time_based_seed();
 
   string training_data_subdir="./training_data";
   int syn_words_ID = -1;
   cout << "Enter synthetic words ID (-1 for default):" << endl;
   cin >> syn_words_ID;
   string synthetic_subdir="./training_data/synthetic_words";
   if(syn_words_ID >= 0)
   {
      synthetic_subdir += "_"+stringfunc::integer_to_string(syn_words_ID,2);
   }
   synthetic_subdir += "/";

   vector<string> chips_subdirs, charmasks_subdirs, wordmasks_subdirs;
   chips_subdirs.push_back(synthetic_subdir+"rotated_images/");
   charmasks_subdirs.push_back(synthetic_subdir+"rotated_char_masks/");
   wordmasks_subdirs.push_back(synthetic_subdir+"rotated_word_masks/");

//   chips_subdirs.push_back(synthetic_subdir+"combined_images/");
//   charmasks_subdirs.push_back(synthetic_subdir+"combined_char_masks/");
//   wordmasks_subdirs.push_back(synthetic_subdir+"combined_word_masks/");

   vector<string> chip_filenames=filefunc::image_files_in_multi_subdirs(
      chips_subdirs);
   vector<string> charmask_filenames=filefunc::image_files_in_multi_subdirs(
      charmasks_subdirs);
   vector<string> wordmask_filenames=filefunc::image_files_in_multi_subdirs(
      wordmasks_subdirs);
   int n_image_chips = chip_filenames.size();
   cout << "chip_filenames.size = " << chip_filenames.size() << endl;
   cout << " charmask_filenames.size = " << charmask_filenames.size() << endl;
   cout << " wordmask_filenames.size = " << wordmask_filenames.size() << endl;
   if( (chip_filenames.size() != charmask_filenames.size()) ||
       (chip_filenames.size() != wordmask_filenames.size()) )
   {
      exit(-1);
   }

// Keep track of synthetic text image chips which are just foreground

   vector<bool> just_foreground_chip;
   for(unsigned int i = 0; i < chip_filenames.size(); i++)
   {
      string curr_chip_filename = chip_filenames[i];
      string substring = "JustForeground";
      int substr_posn = 
         stringfunc::first_substring_location(chip_filenames[i],substring);
      just_foreground_chip.push_back( (substr_posn >= 0) );
   }

   string composites_subdir=synthetic_subdir+"composites/";
   filefunc::dircreate(composites_subdir);
   string comp_images_subdir=composites_subdir+"comp_images/";
   filefunc::dircreate(comp_images_subdir);

   string output_tiles_subdir=synthetic_subdir+"output_tiles/";
   filefunc::dircreate(output_tiles_subdir);
   string output_charmasks_subdir=synthetic_subdir+"output_charmasks/";
   filefunc::dircreate(output_charmasks_subdir);
   string output_wordmasks_subdir=synthetic_subdir+"output_wordmasks/";
   filefunc::dircreate(output_wordmasks_subdir);

   string backgrounds_subdir = "./images/internet/non_text/";
   vector<string> background_filenames=filefunc::image_files_in_subdir(
      backgrounds_subdir);
   int n_backgrounds = background_filenames.size();
   cout << "Total number of non-text backgrounds = " << n_backgrounds << endl;

   int n_parallel_sessions;
   cout << endl;
   cout << "Enter number of parallel COMPOSITE_STRING_TILES sessions to run:"
        << endl;
   cin >> n_parallel_sessions;

   cout << "Enter current parallel session index [0,n_parallel_sessions-1]:" 
        << endl;
   int p;
   cin >> p;
   if(p <0 || p > n_parallel_sessions-1)
   {
      exit(-1);
   }

   int n_tiles_per_session;
   cout << "Enter number of composite tiles to generate per session:" << endl;
   cin >> n_tiles_per_session;

   int nchips_per_session = n_image_chips / n_parallel_sessions;
   int chip_start = p;
   int chip_stop = chip_start + (nchips_per_session-1) * n_parallel_sessions;

   int n_backgrounds_per_session = n_backgrounds / n_parallel_sessions;
   int b_start = p;
   int b_stop = b_start + (n_backgrounds_per_session-1) * n_parallel_sessions;

//   int chip_start = p * double(n_image_chips)/n_parallel_sessions;
//   int chip_stop = (p+1) * double(n_image_chips)/n_parallel_sessions;
//   int b_start =  p * double(n_backgrounds)/n_parallel_sessions;
//   int b_stop =  (p+1) * double(n_backgrounds)/n_parallel_sessions;
   cout << "Current parallel session index = " << p << endl;
   cout << "  Start chip = " << chip_start
        << "  stop chip = " << chip_stop << endl;
   cout << "  Start background = " << b_start
        << "  stop background = " << b_stop << endl << endl;

   int individual_tile_size = 321;
   int n_individual_tiles = 3;
   int composite_tile_size = n_individual_tiles * individual_tile_size;

   int tstart = p;
   int tstop = tstart + (n_tiles_per_session - 1) * n_parallel_sessions;
   int tstep = n_parallel_sessions;

   int t_offset = 0;
   tstart = t_offset + p;

   unsigned int n_composite_tiles = tstop - tstart;
   cout << "Number of composite_tiles to generate = " << n_composite_tiles 
        << endl;
   cout << "Number of individual tiles of pixel size " 
        << individual_tile_size << " = " 
        << n_individual_tiles * n_individual_tiles * n_composite_tiles
        << endl;
   cout << "tstart = " << tstart << " tstop = " << tstop \
        << " tstep = " << tstep << endl;

   textfunc::import_foreground_background_colors_decision_function();

   texture_rectangle* composite_image_tr_ptr = new texture_rectangle(
      composite_tile_size, composite_tile_size, 1, 4, NULL);
   texture_rectangle* charmask_tr_ptr = new texture_rectangle(
      composite_tile_size, composite_tile_size, 1, 4, NULL);
   texture_rectangle* wordmask_tr_ptr = new texture_rectangle(
      composite_tile_size, composite_tile_size, 1, 4, NULL);

// ---------------------------------------------------------------
// Main loop over all composite tiles starts here:

   vector<int> previous_chip_IDs;

   for(int t = tstart; t < tstop; t += tstep)
   {
      outputfunc::update_progress_fraction(t,10,n_composite_tiles);

      cout << "Parallel session = " << p
           << "   t = " << t << " tstart = " << tstart
           << " tstop = " << tstop 
           << " tstep = " << tstep << endl;
      if ((t-tstart)%20 == 0)
      {
         double progress_frac = double(t - tstart)/n_composite_tiles;
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }

      bool OK_background_flag = false;
      string composite_image_filename;
      while(!OK_background_flag)
      {
         int curr_background_id = 
            b_start + 0.999 * nrfunc::ran1() * (b_stop - b_start);
//      cout << "curr_background_id = " << curr_background_id 
//           << " of " << n_backgrounds << endl;
         string curr_background_filename=background_filenames[curr_background_id];
//      cout << "curr_background_filename = " << curr_background_filename
//           << endl;

         unsigned int background_width, background_height;
         imagefunc::get_image_width_height(
            curr_background_filename, background_width, background_height);
//      cout << "background width = " << width 
//           << " background height = " << height << endl;
         int dwidth = background_width - composite_tile_size;
         int dheight = background_height - composite_tile_size;

         composite_image_filename=comp_images_subdir+"composite_image_"+
            stringfunc::integer_to_string(t,5)+".png";
         string unix_cmd="convert '"+curr_background_filename+"' -crop "+
            stringfunc::number_to_string(composite_tile_size)+"x"+
            stringfunc::number_to_string(composite_tile_size)+"+"+
            stringfunc::number_to_string(nrfunc::ran1() * dwidth)+"+"+
            stringfunc::number_to_string(nrfunc::ran1() * dheight)+" png32:"+
            composite_image_filename;
//       cout << unix_cmd << endl;
         sysfunc::unix_command(unix_cmd);
//      cout << "composite_image_filename = " << composite_image_filename 
//           << endl;

// Import cropped background image into *composite_image_tr_ptr:

         composite_image_tr_ptr->import_photo_from_file(
            composite_image_filename);
         int n_channels = composite_image_tr_ptr->getNchannels();
         if(n_channels < 3 || n_channels > 4)
         {
            cout << "composite n_channels = " << n_channels << endl;
            cout << "t = " << t << endl;
            cout << "curr_background_id = " << curr_background_id 
                 << " of " << n_backgrounds << endl;
            cout << "curr_background_filename = " << curr_background_filename
                 << endl;
            cout << "n_channels = " << n_channels << endl;
         }
         else
         {
            OK_background_flag = true;
         }
      } // OK_background_flag while looop
      

      twoDarray* SrtwoDarray_ptr = new twoDarray(
         composite_tile_size, composite_tile_size);
      twoDarray* SgtwoDarray_ptr = new twoDarray(
         composite_tile_size, composite_tile_size);
      twoDarray* SbtwoDarray_ptr = new twoDarray(
         composite_tile_size, composite_tile_size);
      composite_image_tr_ptr->RGB_entropy_integral_images(
         SrtwoDarray_ptr, SgtwoDarray_ptr, SbtwoDarray_ptr);

// Clear char and word masks:

      charmask_tr_ptr->clear_all_RGB_values();
      wordmask_tr_ptr->clear_all_RGB_values();
      string composite_charmask_filename=
         composites_subdir+"composite_charmask_"+
         stringfunc::integer_to_string(t,5)+".png";
      string composite_wordmask_filename=
         composites_subdir+"composite_wordmask_"+
         stringfunc::integer_to_string(t,5)+".png";

      int max_n_overlays = 9 + nrfunc::ran1() * (27 - 9);
      vector<bounding_box> overlay_bboxes;
      for(int n = 0; n < max_n_overlays; n++)
      {
         int curr_chip_id;

// As of 4/7/16, we attempt to facilitate deep network learning that
// text is independent of background by explicitly repeating
// foreground synthetic text images multiple times against different
// backgrounds:

         int n_previous_chips = previous_chip_IDs.size();
         bool reusing_previous_chip_flag = false;

         if(n_previous_chips > 200)
         {
            curr_chip_id = previous_chip_IDs.back();
            previous_chip_IDs.pop_back();
            reusing_previous_chip_flag = true;
         }
         else
         {
            bool chip_id_set = false;
            while(!chip_id_set)
            {
               curr_chip_id = chip_start + 0.999 * nrfunc::ran1() * 
                  (chip_stop - chip_start);

// As of 4/8/16, we intentionally bias choice of synthesized text
// towards pure foregrounds with no constant color bbox underlays:

               if(just_foreground_chip[curr_chip_id])
               {
                  chip_id_set = true;
               }
               else
               {
                  if(nrfunc::ran1() > 0.75)
                  {
                     chip_id_set = true;
                  }
               }
            } // while !chip_id_set loop
         }
            
//            cout << "curr_chip_id = " << curr_chip_id << endl;
         string curr_chip_filename=chip_filenames[curr_chip_id];
//            cout << "curr_chip_filename = " << curr_chip_filename << endl;
         string curr_charmask_filename=charmask_filenames[curr_chip_id];
//            cout << "curr_charmask_filename = " << curr_charmask_filename 
//                 << endl;
         string curr_wordmask_filename=wordmask_filenames[curr_chip_id];
//            cout << "curr_wordmask_filename = " << curr_wordmask_filename 
//                 << endl;

         unsigned int chip_width, chip_height;
         if(!imagefunc::get_image_width_height(
               curr_chip_filename, chip_width, chip_height))
         {
            cout << "Couldn't get chip width & height for " 
                 << curr_chip_filename << endl;
            continue;
         }
//         cout << "chip_width = " << chip_width 
//              << "  chip_height = " << chip_height << endl;

         int qx, qy;
         int qx_min = -0.5 * chip_width;
         int qx_max = composite_tile_size - 0.5 * chip_width;
         int qy_min = -0.5 * chip_height;
         int qy_max = composite_tile_size - 0.5 * chip_height;
         bounding_box curr_bbox;

         bool OK_candidate_bbox_flag = false;
         int max_trials = 5;
         for(int trial = 0; trial < max_trials && !OK_candidate_bbox_flag; 
             trial++)
         {
            qx = qx_min + nrfunc::ran1() * (qx_max - qx_min);
            qy = qy_min + nrfunc::ran1() * (qy_max - qy_min);
            curr_bbox = bounding_box(
               qx, qx + chip_width, qy, qy + chip_height);
//            cout << " qx = " << qx << " qy = " << qy << endl;

// Reject current candidate bbox if its overlaps any existing bbox:

            OK_candidate_bbox_flag = true;
            for(unsigned int b = 0; b < overlay_bboxes.size(); b++)
            {
               if(curr_bbox.overlap(overlay_bboxes[b]))
               {
                  OK_candidate_bbox_flag = false;
                  break;
               }
            } // loop over index b labeling existing bboxes

         } // loop over trial index 

         if(!OK_candidate_bbox_flag) continue;
//         cout << "curr_bbox = " << curr_bbox << endl;

// Calculate entropy density within background image's bounding box.
// Reject current text candidate if it only contains foreground
// content and if bbox entropy is too high:

         if(just_foreground_chip[curr_chip_id])
         {
            int px_lo = basic_math::max(qx, 0);
            int px_hi = basic_math::min(
               int(qx + chip_width), composite_tile_size - 1);
            int py_lo = basic_math::max(qy, 0);
            int py_hi = basic_math::min(
               int(qy + chip_height), composite_tile_size - 1);
            double n_pixels = (px_hi - px_lo) * (py_hi - py_lo);

            if(n_pixels >= 1)
            {
//               cout << "px_lo = " << px_lo
//                    << " px_hi = " << px_hi << endl;
//               cout << "py_lo = " << py_lo
//                    << " py_hi = " << py_hi << endl;
//               cout << "n_pixels = " << n_pixels << endl;
               double Sr, Sg, Sb;
               composite_image_tr_ptr->bbox_RGB_entropies(
                  px_lo, px_hi, py_lo, py_hi,
                  SrtwoDarray_ptr, SgtwoDarray_ptr, SbtwoDarray_ptr, 
                  Sr, Sg, Sb);
//               cout << "Sr = " << Sr << " Sg = " << Sg << " Sb = " 
//                    <<  Sb << endl;
                  
               double Sr_density = Sr / n_pixels;
               double Sg_density = Sg / n_pixels;
               double Sb_density = Sb / n_pixels;
//                  cout << "Sr_density = " << Sr_density
//                       << " Sg_density = " << Sg_density
//                       << " Sb_density = " << Sb_density
//                       << endl;

//                  const double entropy_dens_threshold = 0.2;
               const double entropy_dens_threshold = 0.23;
//                  const double median_entropy_dens = 0.25;
//                  const double entropy_dens_threshold = 0.3;

               if(Sr_density > entropy_dens_threshold ||
                  Sg_density > entropy_dens_threshold ||
                  Sb_density > entropy_dens_threshold) 
               {
//                     cout << "  Sr_dens=" << Sr_density
//                          << " Sg_dens=" << Sg_density
//                          << " Sb_dens=" << Sb_density
//                          << " Sdens_thresh="
//                          << entropy_dens_threshold << endl;
//                     continue;
               }

            } // n_pixels >= 1 conditional
         } // just_foreground_chip conditional

// Calculate average RGB values for background and foreground chips
// specified by current chip's pixel bbox:

         colorfunc::RGB average_background_RGB;
         videofunc::compute_average_subimage_RGB(
            composite_image_tr_ptr,
            qx, qx + chip_width, qy, qy + chip_height,
            average_background_RGB);

         texture_rectangle* foreground_tr_ptr = new texture_rectangle(
            curr_chip_filename, NULL);
         if(foreground_tr_ptr->get_VideoType() != 
            texture_rectangle::still_image)
         {
            cout << "Couldn't load " << curr_chip_filename << endl;
            continue;
         }

         if(foreground_tr_ptr->getNchannels() < 3 ||
            foreground_tr_ptr->getNchannels() > 4)
         {
            cout << "curr_chip_filename = " << curr_chip_filename
                 << " has n_channels = " << foreground_tr_ptr->getNchannels()
                 << endl;
            continue;
         }
         
         colorfunc::RGB average_foreground_RGB;
         videofunc::compute_average_subimage_RGB(
            foreground_tr_ptr,
            0, chip_width, 0, chip_height,
            average_foreground_RGB);
         delete foreground_tr_ptr;
//            cout << "avg foreground : R = " << average_foreground_RGB.first
//                 << " G = " << average_foreground_RGB.second
//                 << " B = " << average_foreground_RGB.third
//                 << endl;

         colorfunc::RGB delta_RGB;
         delta_RGB.first = fabs(average_foreground_RGB.first - 
                                average_background_RGB.first);
         delta_RGB.second = fabs(average_foreground_RGB.second - 
                                 average_background_RGB.second);
         delta_RGB.third = fabs(average_foreground_RGB.third - 
                                average_background_RGB.third);
//            cout << "delta : R = " << delta_RGB.first
//                 << " G = " << delta_RGB.second
//                 << " B = " << delta_RGB.third
//                 << endl;
         double total_delta_rgb = delta_RGB.first + delta_RGB.second +
            delta_RGB.third;

         if(total_delta_rgb < 100)
//         if(total_delta_rgb < 50)
         {
//            cout << "  Total_delta_rgb = " << total_delta_rgb 
//                 << " less than threshold = 50" << endl;
            continue;
         }

/*
         double classification_score_threshold = 0.999;
         if(!textfunc::test_foreground_background_color_acceptability(
               classification_score_threshold, average_foreground_RGB,
               average_background_RGB)) 
         {
            cout << "foreground/background acceptability test failed"
                 << endl;
            continue;
         }
*/

         if(!composite_image_tr_ptr->overlay(curr_chip_filename, qx, qy))
         {
            continue;
         }
         charmask_tr_ptr->overlay(curr_charmask_filename, qx, qy);
         wordmask_tr_ptr->overlay(curr_wordmask_filename, qx, qy);

         if(previous_chip_IDs.size() < 1000 && !reusing_previous_chip_flag)
         {
            int max_chip_repeats = 5;
            for(int r = 0; r < max_chip_repeats; r++)
            {
               int n_insert = 0.6*nrfunc::ran1()*previous_chip_IDs.size();
               previous_chip_IDs.insert(previous_chip_IDs.begin()+
                                        n_insert, curr_chip_id);
            }
         }

         overlay_bboxes.push_back(curr_bbox);
      } // loop over index n labeling candidate overlays
      cout << "   n_overlays = " << overlay_bboxes.size() << endl;

      delete SrtwoDarray_ptr;
      delete SgtwoDarray_ptr;
      delete SbtwoDarray_ptr;

// Add noise to entire composite image:

      double noise_frac= 0.02 + nrfunc::ran1() * (0.09 - 0.02); // Apr 20 run
//      double noise_frac= 0.02 + nrfunc::ran1() * (0.07 - 0.02); // Apr 19 run
//      double noise_frac= nrfunc::ran1() * 0.07;   // Apr 18 run (bad recall)
      double sigma = noise_frac * 255;
      composite_image_tr_ptr->add_gaussian_noise(sigma);

      Magick::Image composite_image(
         composite_image_tr_ptr->getWidth(),
         composite_image_tr_ptr->getHeight(), 
         "RGBA", MagickCore::CharPixel,
         composite_image_tr_ptr->get_image_ptr()->data());
      composite_image.depth(8);

// Randomly select some fraction of composite images to blur by some
// random amount:

//      if(nrfunc::ran1() > 0.4)     // Apr 18 run  (bad recall)
//      {
//         double blur_sigma=nrfunc::ran1() * 2;  // Apr 18, 19 runs
//         videofunc::gaussian_blur_image(composite_image,blur_sigma);
//      }

      double random_blur = nrfunc::ran1();
      double blur_sigma = 0;
      if(random_blur < 0.25)
      {
         blur_sigma = 0;
      }
      else if (random_blur >= 0.25 && random_blur < 0.50)
      {
         blur_sigma = 0.5 + nrfunc::ran1();  
      }
      else if (random_blur >= 0.50 && random_blur < 0.65)
      {
         blur_sigma = 1.5 + nrfunc::ran1();        
      }
      else if (random_blur >= 0.65 && random_blur < 0.80)
      {
         blur_sigma = 2.5 + nrfunc::ran1();        
      }
      else if (random_blur >= 0.80 && random_blur < 0.90)
      {
         blur_sigma = 3.0 + nrfunc::ran1();        
      }
      else
      {
         blur_sigma = 4.0;  
      }

      if(blur_sigma > 0)
      {
         videofunc::gaussian_blur_image(composite_image,blur_sigma);
      }
      
      composite_image.write(composite_image_filename);      

      charmask_tr_ptr->write_curr_frame(composite_charmask_filename);
      wordmask_tr_ptr->write_curr_frame(composite_wordmask_filename);

      bool visualize_composite_mask_flag = true;
//      bool visualize_composite_mask_flag = false;

// For multi-valued masks, we set nontrivial_pixel_value = 0 so that
// any spurious bright regions in the mask will be reset to black:

      int nontrivial_pixel_value = 0;
//      int nontrivial_pixel_value = 1;

      vector<vector<unsigned char> > char_byte_array = 
         videofunc::generate_byte_array(
            composite_charmask_filename,
            0, composite_tile_size - 1, 
            0, composite_tile_size - 1,
            visualize_composite_mask_flag, nontrivial_pixel_value);
      string char_bytearray_filename=composites_subdir+"char_bytearray_"+
         stringfunc::integer_to_string(t,5)+".png";
      videofunc::write_8bit_greyscale_pngfile(
         char_byte_array, char_bytearray_filename);
//      cout << "Exported " << char_bytearray_filename << endl;

      vector<vector<unsigned char> > word_byte_array = 
         videofunc::generate_byte_array(
            composite_wordmask_filename,
            0, composite_tile_size - 1, 
            0, composite_tile_size - 1,
            visualize_composite_mask_flag, nontrivial_pixel_value);
      string word_bytearray_filename=composites_subdir+"word_bytearray_"+
         stringfunc::integer_to_string(t,5)+".png";
      videofunc::write_8bit_greyscale_pngfile(
         word_byte_array, word_bytearray_filename);
//      cout << "Exported " << word_bytearray_filename << endl;

// Break apart big composited tile into individual tiles:

      string unix_cmd="convert "+composite_image_filename+" -crop "+
         stringfunc::number_to_string(n_individual_tiles)+"x"+
         stringfunc::number_to_string(n_individual_tiles)+
         "@ +repage +adjoin "+
         output_tiles_subdir+"tile_"+stringfunc::integer_to_string(t,5)
         +".jpg";
//      cout << unix_cmd << endl;
      sysfunc::unix_command(unix_cmd);

// On 3/14/16, we empirically found that we can't use the same
// "convert" command in order to break apart the 8-bit greyscale
// composite mask into individual mask tiles.  So we instead
// explicitly generate a byte array for each mask tile and export it
// to an output PNG file:

      int mask_tile_counter = 0;
      for(int r = n_individual_tiles-1; r >=0; r--)
      {
         int py_start = r * individual_tile_size;
         int py_stop = py_start + individual_tile_size - 1;
         for(int c= 0; c < n_individual_tiles; c++)
         {
            int px_start = c * individual_tile_size;
            int px_stop = px_start + individual_tile_size - 1;
            
            bool visualize_tile_mask_flag = false;
            vector<vector<unsigned char> > char_byte_array = 
               videofunc::generate_byte_array(
                  composite_charmask_filename,
                  px_start, px_stop, py_start, py_stop,
                  visualize_tile_mask_flag, nontrivial_pixel_value);
            string char_bytearray_filename=output_charmasks_subdir+"charmask_"+
               stringfunc::integer_to_string(t,5)+"-"+
               stringfunc::number_to_string(mask_tile_counter)+".png";
            videofunc::write_8bit_greyscale_pngfile(
               char_byte_array, char_bytearray_filename);

            vector<vector<unsigned char> > word_byte_array = 
               videofunc::generate_byte_array(
                  composite_wordmask_filename,
                  px_start, px_stop, py_start, py_stop,
                  visualize_tile_mask_flag, nontrivial_pixel_value);
            string word_bytearray_filename=output_wordmasks_subdir+"wordmask_"+
               stringfunc::integer_to_string(t,5)+"-"+
               stringfunc::number_to_string(mask_tile_counter++)+".png";
            videofunc::write_8bit_greyscale_pngfile(
               word_byte_array, word_bytearray_filename);

         } // loop over index c labeling tile columns
      } // loop over index r labeling tile rows
   } // loop over index t labeling tiles

   delete composite_image_tr_ptr;
   delete charmask_tr_ptr;
   delete wordmask_tr_ptr;
} 
