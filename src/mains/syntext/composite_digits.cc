// ==========================================================================
// Program COMPOSITE_DIGITS imports a set of synthetic text
// chips and their masks generated by programs GENERATE_STRING_IMAGES
// and VERTICAL_STRING_IMAGES.  It also takes in a set of background
// internet photos which should contain no text content.
// COMPOSITE_DIGITS generates a specified number of output tiles
// whose pixel size is consistent with deeplab semantic segmentation
// network finetuning.

// Each composite tile contains 3x3 individual tiles.  A random
// internet image is first laid down as a background for the entire
// composite tile.  Foreground text chips are then randomly superposed
// onto the background texture.  Foreground chip bounding boxes are
// not allowed to overlap.

// Entropy density is calculated within the background image within
// candidate foreground bboxes locations.  If the background entropy
// density is too large, the candidate foreground text location is
// rejected.  the Average foreground and background RGB values are
// also calculated for each image chip before it's superposed.  If
// their color contents are not sufficiently different, the candidate
// foreground chip is rejected and another random chip is selected.
// The number of foreground overlays within each composite varies
// randomly over the interval [9,27].  

// Once a composite image is formed, each pixel's RGB values are
// fluctuatued by a nonzero amount of random gaussian noise.  A
// sizable fraction of the composites are also blurred by a random
// amount.  We found that such composite degradation significantly
// improves deeplab semantic segmentation classifier performance on
// test images containing genuine text content.

// 8-bit greyscale "character" and "word" masks are also iteratively
// constructed which display the location of all synthetic text within
// the entire composite.  Once generation of a composite image and its
// associated masks are completed, they are decomposed into 3x3
// individual tiles.  Individual tiles and masks are exported to
// separate output folders.

// Multiple instances of COMPOSITE_DIGITS can be run in parallel
// on a single CPU machine.

//                      ./composite_digits

// ==========================================================================
// Last updated on 4/20/16; 4/22/16; 5/18/16; 8/30/16
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "math/constants.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/sysfuncs.h"
#include "text/textfuncs.h"
#include "time/timefuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();

   nrfunc::init_time_based_seed();

   string training_data_subdir="./training_data";
   int syn_words_ID = -1;
   cout << "Enter synthetic words ID (-1 for default):" << endl;
   cin >> syn_words_ID;
   string synthetic_subdir="./training_data/synthetic_words";
   if(syn_words_ID >= 0)
   {
      synthetic_subdir += "_"+stringfunc::integer_to_string(syn_words_ID,2);
   }
   synthetic_subdir += "/";

   vector<string> chips_subdirs, charmasks_subdirs, wordmasks_subdirs;
   chips_subdirs.push_back(synthetic_subdir+"rotated_images/");

   vector<string> chip_filenames=filefunc::image_files_in_multi_subdirs(
      chips_subdirs);
   int n_image_chips = chip_filenames.size();
   cout << "chip_filenames.size = " << chip_filenames.size() << endl;
   
// Keep track of synthetic text image chips which are just foreground
// Also extract digit class from image chips' basenames:

   vector<bool> just_foreground_chip;
   vector<string> digit_class_str;
   for(unsigned int i = 0; i < chip_filenames.size(); i++)
   {
      string curr_chip_filename = chip_filenames[i];
      string substring = "JustForeground";
      int substr_posn = 
         stringfunc::first_substring_location(chip_filenames[i],substring);
      just_foreground_chip.push_back( (substr_posn >= 0) );

      vector<string> substrings = stringfunc::decompose_string_into_substrings(
         curr_chip_filename, "._");
      digit_class_str.push_back(substrings[substrings.size() - 2]);
   }

   string composites_subdir=synthetic_subdir+"composites/";
   filefunc::dircreate(composites_subdir);
   string comp_images_subdir=composites_subdir+"comp_images/";
   filefunc::dircreate(comp_images_subdir);

   string output_tiles_subdir=synthetic_subdir+"output_tiles/";
   filefunc::dircreate(output_tiles_subdir);

   string backgrounds_subdir = "./images/internet/non_text/";
   vector<string> background_filenames=filefunc::image_files_in_subdir(
      backgrounds_subdir);
   int n_backgrounds = background_filenames.size();
   cout << "Total number of non-text backgrounds = " << n_backgrounds << endl;

   int n_parallel_sessions;
   cout << endl;
   cout << "Enter number of parallel COMPOSITE_DIGITS sessions to run:"
        << endl;
   cin >> n_parallel_sessions;

   cout << "Enter current parallel session index [0,n_parallel_sessions-1]:" 
        << endl;
   int p;
   cin >> p;
   if(p <0 || p > n_parallel_sessions-1)
   {
      exit(-1);
   }

   int n_tiles_per_session;
   cout << "Enter number of composite tiles to generate per session:" << endl;
   cin >> n_tiles_per_session;

   int nchips_per_session = n_image_chips / n_parallel_sessions;
   int chip_start = p;
   int chip_stop = chip_start + (nchips_per_session-1) * n_parallel_sessions;

   int n_backgrounds_per_session = n_backgrounds / n_parallel_sessions;
   int b_start = p;
   int b_stop = b_start + (n_backgrounds_per_session-1) * n_parallel_sessions;

   cout << "Current parallel session index = " << p << endl;
   cout << "  Start chip = " << chip_start
        << "  stop chip = " << chip_stop << endl;
   cout << "  Start background = " << b_start
        << "  stop background = " << b_stop << endl << endl;

   int individual_tile_size = 96;
   int n_individual_tiles = 1;   
   int composite_tile_size = n_individual_tiles * individual_tile_size;

   int tstart = p;
   int tstop = tstart + (n_tiles_per_session - 1) * n_parallel_sessions;
   int tstep = n_parallel_sessions;

   int t_offset = 0;
   tstart = t_offset + p;

   unsigned int n_composite_tiles = tstop - tstart;
   cout << "Number of composite_tiles to generate = " << n_composite_tiles 
        << endl;
   cout << "Number of individual tiles of pixel size " 
        << individual_tile_size << " = " 
        << n_individual_tiles * n_individual_tiles * n_composite_tiles
        << endl;
   cout << "tstart = " << tstart << " tstop = " << tstop \
        << " tstep = " << tstep << endl;

   textfunc::import_foreground_background_colors_decision_function();

   texture_rectangle* composite_image_tr_ptr = new texture_rectangle(
      composite_tile_size, composite_tile_size, 1, 4, NULL);

// ---------------------------------------------------------------
// Main loop over all composite tiles starts here:

   vector<int> previous_chip_IDs;

   for(int t = tstart; t < tstop; t += tstep)
   {
      outputfunc::update_progress_fraction(t,10,n_composite_tiles);

      cout << "Parallel session = " << p
           << "   t = " << t << " tstart = " << tstart
           << " tstop = " << tstop 
           << " tstep = " << tstep << endl;
      if ((t-tstart)%20 == 0)
      {
         double progress_frac = double(t - tstart)/n_composite_tiles;
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }

      bool OK_background_flag = false;
      string composite_image_filename;
      while(!OK_background_flag)
      {
         int curr_background_id = 
            b_start + 0.999 * nrfunc::ran1() * (b_stop - b_start);
//      cout << "curr_background_id = " << curr_background_id 
//           << " of " << n_backgrounds << endl;
         string curr_background_filename=background_filenames[
            curr_background_id];
//      cout << "curr_background_filename = " << curr_background_filename
//           << endl;

         unsigned int background_width, background_height;
         imagefunc::get_image_width_height(
            curr_background_filename, background_width, background_height);
//      cout << "background width = " << width 
//           << " background height = " << height << endl;
         int dwidth = background_width - composite_tile_size;
         int dheight = background_height - composite_tile_size;

//         composite_image_filename=comp_images_subdir+"composite_image_"+
//            stringfunc::integer_to_string(t,5)+".png";

         composite_image_filename=comp_images_subdir+"comp_image.png";

         string unix_cmd="convert '"+curr_background_filename+"' -crop "+
            stringfunc::number_to_string(composite_tile_size)+"x"+
            stringfunc::number_to_string(composite_tile_size)+"+"+
            stringfunc::number_to_string(nrfunc::ran1() * dwidth)+"+"+
            stringfunc::number_to_string(nrfunc::ran1() * dheight)+" png32:"+
            composite_image_filename;
//         cout << unix_cmd << endl;
         sysfunc::unix_command(unix_cmd);
//         cout << "composite_image_filename = " << composite_image_filename 
//              << endl;

// Import cropped background image into *composite_image_tr_ptr:

         composite_image_tr_ptr->import_photo_from_file(
            composite_image_filename);
         int n_channels = composite_image_tr_ptr->getNchannels();
         if(n_channels < 3 || n_channels > 4)
         {
            cout << "composite n_channels = " << n_channels << endl;
            cout << "t = " << t << endl;
            cout << "curr_background_id = " << curr_background_id 
                 << " of " << n_backgrounds << endl;
            cout << "curr_background_filename = " << curr_background_filename
                 << endl;
            cout << "n_channels = " << n_channels << endl;
         }
         else
         {
            OK_background_flag = true;
         }
      } // OK_background_flag while looop
      
      twoDarray* SrtwoDarray_ptr = new twoDarray(
         composite_tile_size, composite_tile_size);
      twoDarray* SgtwoDarray_ptr = new twoDarray(
         composite_tile_size, composite_tile_size);
      twoDarray* SbtwoDarray_ptr = new twoDarray(
         composite_tile_size, composite_tile_size);
      composite_image_tr_ptr->RGB_entropy_integral_images(
         SrtwoDarray_ptr, SgtwoDarray_ptr, SbtwoDarray_ptr);

      bool bad_chip_flag = true;
      int max_n_overlays = 1;
      string curr_class_str="";
      for(int n = 0; n < max_n_overlays; n++)
      {
         int curr_chip_id;
         bool chip_id_set = false;
         while(!chip_id_set)
         {
            curr_chip_id = chip_start + 0.999 * nrfunc::ran1() * 
               (chip_stop - chip_start);

// As of 4/8/16, we intentionally bias choice of synthesized text
// towards pure foregrounds with no constant color bbox underlays:

            if(just_foreground_chip[curr_chip_id])
            {
               chip_id_set = true;
            }
            else
            {
               if(nrfunc::ran1() > 0.75)
               {
                  chip_id_set = true;
               }
            }
         } // while !chip_id_set loop

//         cout << "curr_chip_id = " << curr_chip_id << endl;
         string curr_chip_filename=chip_filenames[curr_chip_id];
//         cout << "curr_chip_filename = " << curr_chip_filename << endl;
         curr_class_str = digit_class_str[curr_chip_id];

         unsigned int chip_width, chip_height;
         if(!imagefunc::get_image_width_height(
               curr_chip_filename, chip_width, chip_height))
         {
            cout << "Couldn't get chip width & height for " 
                 << curr_chip_filename << endl;
            continue;
         }
//         cout << "chip_width = " << chip_width 
//              << "  chip_height = " << chip_height << endl;

         int qx_min = 0.25 * chip_width;
         int qx_max = composite_tile_size - 0.75 * chip_width;
         int qy_min = 0.25 * chip_height;
         int qy_max = composite_tile_size - 0.75 * chip_height;
         int qx = qx_min + nrfunc::ran1() * (qx_max - qx_min);
         int qy = qy_min + nrfunc::ran1() * (qy_max - qy_min);
         bounding_box curr_bbox = bounding_box(
            qx, qx + chip_width, qy, qy + chip_height);
//         cout << " qx = " << qx << " qy = " << qy << endl;
//         cout << "curr_bbox = " << curr_bbox << endl;

// Calculate entropy density within background image's bounding box.
// Reject current text candidate if it only contains foreground
// content and if bbox entropy is too high:

         if(just_foreground_chip[curr_chip_id])
         {
            int px_lo = basic_math::max(qx, 0);
            int px_hi = basic_math::min(
               int(qx + chip_width), composite_tile_size - 1);
            int py_lo = basic_math::max(qy, 0);
            int py_hi = basic_math::min(
               int(qy + chip_height), composite_tile_size - 1);
            double n_pixels = (px_hi - px_lo) * (py_hi - py_lo);

            if(n_pixels >= 1)
            {
//               cout << "px_lo = " << px_lo
//                    << " px_hi = " << px_hi << endl;
//               cout << "py_lo = " << py_lo
//                    << " py_hi = " << py_hi << endl;
//               cout << "n_pixels = " << n_pixels << endl;
               double Sr, Sg, Sb;
               composite_image_tr_ptr->bbox_RGB_entropies(
                  px_lo, px_hi, py_lo, py_hi,
                  SrtwoDarray_ptr, SgtwoDarray_ptr, SbtwoDarray_ptr, 
                  Sr, Sg, Sb);
//               cout << "Sr = " << Sr << " Sg = " << Sg << " Sb = " 
//                    <<  Sb << endl;
                  
               double Sr_density = Sr / n_pixels;
               double Sg_density = Sg / n_pixels;
               double Sb_density = Sb / n_pixels;
//                  cout << "Sr_density = " << Sr_density
//                       << " Sg_density = " << Sg_density
//                       << " Sb_density = " << Sb_density
//                       << endl;

//                  const double entropy_dens_threshold = 0.2;
               const double entropy_dens_threshold = 0.23;
//                  const double median_entropy_dens = 0.25;
//                  const double entropy_dens_threshold = 0.3;

               if(Sr_density > entropy_dens_threshold ||
                  Sg_density > entropy_dens_threshold ||
                  Sb_density > entropy_dens_threshold) 
               {
//                     cout << "  Sr_dens=" << Sr_density
//                          << " Sg_dens=" << Sg_density
//                          << " Sb_dens=" << Sb_density
//                          << " Sdens_thresh="
//                          << entropy_dens_threshold << endl;
//                     continue;
               }

            } // n_pixels >= 1 conditional
         } // just_foreground_chip conditional

// Calculate average RGB values for background and foreground chips
// specified by current chip's pixel bbox:

         colorfunc::RGB average_background_RGB;
         videofunc::compute_average_subimage_RGB(
            composite_image_tr_ptr,
            qx, qx + chip_width, qy, qy + chip_height,
            average_background_RGB);

         texture_rectangle* foreground_tr_ptr = new texture_rectangle(
            curr_chip_filename, NULL);
         if(foreground_tr_ptr->get_VideoType() != 
            texture_rectangle::still_image)
         {
            cout << "Couldn't load " << curr_chip_filename << endl;
            continue;
         }

         if(foreground_tr_ptr->getNchannels() < 3 ||
            foreground_tr_ptr->getNchannels() > 4)
         {
            cout << "curr_chip_filename = " << curr_chip_filename
                 << " has n_channels = " << foreground_tr_ptr->getNchannels()
                 << endl;
            continue;
         }
         
         colorfunc::RGB average_foreground_RGB;
         videofunc::compute_average_subimage_RGB(
            foreground_tr_ptr,
            0, chip_width, 0, chip_height,
            average_foreground_RGB);
         delete foreground_tr_ptr;
//            cout << "avg foreground : R = " << average_foreground_RGB.first
//                 << " G = " << average_foreground_RGB.second
//                 << " B = " << average_foreground_RGB.third
//                 << endl;

         colorfunc::RGB delta_RGB;
         delta_RGB.first = fabs(average_foreground_RGB.first - 
                                average_background_RGB.first);
         delta_RGB.second = fabs(average_foreground_RGB.second - 
                                 average_background_RGB.second);
         delta_RGB.third = fabs(average_foreground_RGB.third - 
                                average_background_RGB.third);
//            cout << "delta : R = " << delta_RGB.first
//                 << " G = " << delta_RGB.second
//                 << " B = " << delta_RGB.third
//                 << endl;
         double total_delta_rgb = delta_RGB.first + delta_RGB.second +
            delta_RGB.third;

         if(total_delta_rgb < 100)
//         if(total_delta_rgb < 50)
         {
//            cout << "  Total_delta_rgb = " << total_delta_rgb 
//                 << " less than threshold = 50" << endl;
            continue;
         }

         if(!composite_image_tr_ptr->overlay(curr_chip_filename, qx, qy))
         {
            continue;
         }

         bad_chip_flag = false;
      } // loop over index n labeling candidate overlays

      delete SrtwoDarray_ptr;
      delete SgtwoDarray_ptr;
      delete SbtwoDarray_ptr;

      if(bad_chip_flag)
      {
         t -= tstep;
         cout << "BAD CHIP IGNORED " << endl;
         continue;
      }

// Add noise to entire composite image:

      double noise_frac= 0.02 + nrfunc::ran1() * (0.07 - 0.02); // Apr 19 run
      double sigma = noise_frac * 255;
      composite_image_tr_ptr->add_gaussian_noise(sigma);

      Magick::Image composite_image(
         composite_image_tr_ptr->getWidth(),
         composite_image_tr_ptr->getHeight(), 
         "RGBA", MagickCore::CharPixel,
         composite_image_tr_ptr->get_image_ptr()->data());
      composite_image.depth(8);

// Randomly select some fraction of composite images to blur by some
// random amount:

      double random_blur = nrfunc::ran1();
      double blur_sigma = 0;
      if(random_blur < 0.25)
      {
         blur_sigma = 0;
      }
      else if (random_blur >= 0.25 && random_blur < 0.50)
      {
         blur_sigma = 0.5 + nrfunc::ran1();  
      }
      else if (random_blur >= 0.50)
      {
         blur_sigma = 1.5 + nrfunc::ran1();        
      }

      if(blur_sigma > 0)
      {
         videofunc::gaussian_blur_image(composite_image,blur_sigma);
      }

// Append image chip class string onto end of output image filename:

      string digit_chip_filename=comp_images_subdir+"composite_image_"+
         stringfunc::integer_to_string(t,5)+"_"+curr_class_str+".png";
      composite_image.write(digit_chip_filename);      
   } // loop over index t labeling tiles

   delete composite_image_tr_ptr;
} 
