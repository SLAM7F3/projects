// ==========================================================================
// Program PREPARE_DEEPLAB_INPUTS imports tile and mask pairs
// generated by program COMPOSITE_STRING_TILES.  This program ignores
// any input tile for which a corresponding mask file does not exist
// and vice-versa.  It also rejects any tile,mask pair which do not
// both have pixel width = height = tile_pixel_size.  

// Associations between tiles and masks are stored in an STL map.  20%
// of the tile/mask pairs are reserved for DNN finetuning validation.
// A shuffled set of training and testing tile/mask filename pairs are
// written to text files which are needed as inputs for Deeplab.  A
// final set of tile and mask chips are also exported to a
// deeplab_inputs folder so that they can be more easily uploaded to
// Titan GPU machines for Deeplab processing.

// 			./prepare_deeplab_inputs

// ==========================================================================
// Last updated on 3/27/16; 4/1/16; 4/6/16; 4/22/16
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "math/constants.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/sysfuncs.h"
#include "text/textfuncs.h"
#include "time/timefuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();

   unsigned int tile_pixel_size = 321;

// Store pairs of tile and corresponding mask filenames within an STL
// map:

   typedef pair<string, string> STRING_PAIR;
   typedef std::map<int, vector<STRING_PAIR> > IMAGE_TILES_MAP;
// independent int: image ID
// dependent vector<string,string > : pairs of tile and mask filenames associated with image

   IMAGE_TILES_MAP img_tile_charmask_map, img_tile_wordmask_map;
   IMAGE_TILES_MAP::iterator image_tiles_map_iter;

   string training_data_subdir="./training_data";   
   int syn_words_ID = -1;
   cout << "Enter synthetic words ID (-1 for default):" << endl;
   cin >> syn_words_ID;
   string synthetic_subdir="./training_data/synthetic_words";
   if(syn_words_ID >= 0)
   {
      synthetic_subdir += "_"+stringfunc::integer_to_string(syn_words_ID,2);
   }
   filefunc::add_trailing_dir_slash(synthetic_subdir);

   string deeplab_inputs_subdir=synthetic_subdir+"deeplab_inputs/";
   filefunc::dircreate(deeplab_inputs_subdir);

   string output_tiles_subdir=synthetic_subdir+"output_tiles/";
   filefunc::dircreate(output_tiles_subdir);
   string output_charmasks_subdir=synthetic_subdir+"output_charmasks/";
   filefunc::dircreate(output_charmasks_subdir);
   string output_wordmasks_subdir=synthetic_subdir+"output_wordmasks/";
   filefunc::dircreate(output_wordmasks_subdir);

   vector<string> tile_filenames=filefunc::image_files_in_subdir(
      output_tiles_subdir);
   vector<string> charmask_filenames=filefunc::image_files_in_subdir(
      output_charmasks_subdir);
   vector<string> wordmask_filenames=filefunc::image_files_in_subdir(
      output_wordmasks_subdir);
   int n_tiles = tile_filenames.size();
   int n_charmasks = charmask_filenames.size();
   int n_wordmasks = wordmask_filenames.size();
   cout << "n_tiles = " << n_tiles
        << " n_charmasks = " << n_charmasks 
        << " n_wordmasks = " << n_wordmasks 
        << endl;

// Save correspondence between tile image and tile mask to STL map:

   for(int t = 0; t < n_tiles; t ++)
   {
      outputfunc::update_progress_fraction(t,1000,n_tiles);

      string tile_filename = tile_filenames[t];
      string tile_basename=filefunc::getbasename(tile_filename);
      string prefix=stringfunc::prefix(tile_basename);
      prefix = prefix.substr(4,prefix.size() -4);
      string charmask_basename="charmask"+prefix+".png";
      string charmask_filename=output_charmasks_subdir+charmask_basename;
      string wordmask_basename="wordmask"+prefix+".png";
      string wordmask_filename=output_wordmasks_subdir+wordmask_basename;
//      cout << t << " " << tile_basename << "  " 
//                << charmask_basename 
//                << wordmask_basename << endl;

// Make sure both tile and mask image files actually exist on disk:

      if(!filefunc::fileexist(tile_filename) || 
         !filefunc::fileexist(charmask_filename) ||
         !filefunc::fileexist(wordmask_filename) )
      {
         cout << "t = " << t 
              << " Problem: tile_filename = " << tile_filename
              << " charmask_filename = " << charmask_filename
              << " wordmask_filename = " << wordmask_filename
              << endl;
         continue;
      }

// Ignore any tile and mask images which do not both have image width
// and height = tile_pixel_size:

      unsigned int tile_width,tile_height,charmask_width,charmask_height,
         wordmask_width,wordmask_height;
      if(imagefunc::get_image_width_height(
            tile_filename,tile_width,tile_height) &&
         imagefunc::get_image_width_height(
            charmask_filename,charmask_width,charmask_height) &&
         imagefunc::get_image_width_height(
            wordmask_filename,wordmask_width,wordmask_height))
      {
         if( (tile_width != tile_pixel_size) ||
             (tile_height != tile_pixel_size) ||
             (charmask_width != tile_pixel_size) ||
             (charmask_height != tile_pixel_size) ||
             (wordmask_width != tile_pixel_size) ||
             (wordmask_height != tile_pixel_size))
         {
//            cout << "tile_width = " << tile_width
//                 << " tile_height = " << tile_height
//                 << " tile_filename = " << tile_filename << endl;
//            cout << "charmask_width = " << charmask_width
//                 << " charmask_height = " << charmask_height
//                 << " charmask_filename = " << charmask_filename << endl;
//            cout << "wordmask_width = " << wordmask_width
//                 << " wordmask_height = " << wordmask_height
//                 << " wordmask_filename = " << wordmask_filename << endl;
            continue;
         }
      }

      STRING_PAIR P;
      P.first = "/output_tiles/"+tile_basename;

      P.second = "/output_charmasks/"+charmask_basename;
      vector<STRING_PAIR> Vchar;
      Vchar.push_back(P);
      img_tile_charmask_map[t] = Vchar;

      P.second = "/output_wordmasks/"+wordmask_basename;
      vector<STRING_PAIR> Vword;
      Vword.push_back(P);
      img_tile_wordmask_map[t] = Vword;

   } // loop over index t labeling tiles
// ---------------------------------------------------------------

   cout << endl;
   cout << "img_tile_charmask_map.size() = " 
        << img_tile_charmask_map.size() << endl;
   cout << "img_tile_wordmask_map.size() = " 
        << img_tile_wordmask_map.size() << endl;

// Reserve 20% of randomized image IDs for testing.  But restrict
// n_testing <= max_testing_samples to avoid excessive deeplab
// computation time being spent on validation:

   const double testing_frac = 0.2;
   int max_testing_samples = 8000;
   int n_testing = basic_math::min(int(testing_frac * n_tiles), 
                                   max_testing_samples);
   int n_training = n_tiles - n_testing;

   string images_charmasks_training_filename=deeplab_inputs_subdir+
      "images_charmasks_training.txt";
   string images_wordmasks_training_filename=deeplab_inputs_subdir+
      "images_wordmasks_training.txt";
   ofstream char_outstream, word_outstream;
   filefunc::openfile(images_charmasks_training_filename, char_outstream);   
   filefunc::openfile(images_wordmasks_training_filename, word_outstream);   

   vector<int> random_seq = mathfunc::random_sequence(
      0, n_tiles-1, n_tiles);

   int n_valid_training = 0;
   for(int i = 0; i < n_training; i++)
   {
      int curr_image_ID = random_seq[i];

      image_tiles_map_iter = img_tile_charmask_map.find(curr_image_ID);
      if(image_tiles_map_iter == img_tile_charmask_map.end()) continue;
      vector<STRING_PAIR> *Vchar_ptr = &image_tiles_map_iter->second;

      image_tiles_map_iter = img_tile_wordmask_map.find(curr_image_ID);
      if(image_tiles_map_iter == img_tile_wordmask_map.end()) continue;
      vector<STRING_PAIR> *Vword_ptr = &image_tiles_map_iter->second;

      for(unsigned int j = 0; j < Vchar_ptr->size(); j++)
      {
         STRING_PAIR P = Vchar_ptr->at(j);
         char_outstream << P.first << " " << P.second << endl;
         P = Vword_ptr->at(j);
         word_outstream << P.first << " " << P.second << endl;
         n_valid_training++;
      }
   }
   filefunc::closefile(images_charmasks_training_filename, char_outstream);
   filefunc::closefile(images_wordmasks_training_filename, word_outstream);
   cout << "n_valid_training samples = " << n_valid_training << endl;

   string images_charmasks_testing_filename=deeplab_inputs_subdir+
      "images_charmasks_testing.txt";
   string images_wordmasks_testing_filename=deeplab_inputs_subdir+
      "images_wordmasks_testing.txt";
   filefunc::openfile(images_charmasks_testing_filename, char_outstream);   
   filefunc::openfile(images_wordmasks_testing_filename, word_outstream);   

   int n_valid_testing = 0;
   for(int i = n_training; i < n_tiles; i++)
   {
      int curr_image_ID = random_seq[i];

      image_tiles_map_iter = img_tile_charmask_map.find(curr_image_ID);
      if(image_tiles_map_iter == img_tile_charmask_map.end()) continue;
      vector<STRING_PAIR> *Vchar_ptr = &image_tiles_map_iter->second;

      image_tiles_map_iter = img_tile_wordmask_map.find(curr_image_ID);
      if(image_tiles_map_iter == img_tile_wordmask_map.end()) continue;
      vector<STRING_PAIR> *Vword_ptr = &image_tiles_map_iter->second;

      for(unsigned int j = 0; j < Vchar_ptr->size(); j++)
      {
         STRING_PAIR P = Vchar_ptr->at(j);
         char_outstream << P.first << " " << P.second << endl;
         P = Vword_ptr->at(j);
         word_outstream << P.first << " " << P.second << endl;
         n_valid_testing++;
      }
   }
   filefunc::closefile(images_charmasks_testing_filename, char_outstream);
   filefunc::closefile(images_wordmasks_testing_filename, word_outstream);
   cout << "n_valid_testing samples = " << n_valid_testing << endl;

// Recall several authors stress that training and validation data
// sets should be randomized!  As John Wood pointed out, we can use
// the linux utility "shuf" to generate random permutations:

   string shuffled_images_charmasks_training_filename=deeplab_inputs_subdir+
      "shuffled_images_charmasks_training.txt";
   string shuffled_images_wordmasks_training_filename=deeplab_inputs_subdir+
      "shuffled_images_wordmasks_training.txt";
   cout << "shuffled_images_charmasks_training_filename = "
        << shuffled_images_charmasks_training_filename << endl;
   cout << "shuffled_images_wordmasks_training_filename = "
        << shuffled_images_wordmasks_training_filename << endl;

   string unix_cmd = "shuf "+images_charmasks_training_filename+" > "+
      shuffled_images_charmasks_training_filename;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   unix_cmd = "shuf "+images_wordmasks_training_filename+" > "+
      shuffled_images_wordmasks_training_filename;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   string shuffled_images_charmasks_testing_filename=deeplab_inputs_subdir+
      "shuffled_images_charmasks_testing.txt";
   string shuffled_images_wordmasks_testing_filename=deeplab_inputs_subdir+
      "shuffled_images_wordmasks_testing.txt";
   cout << "shuffled_images_charmasks_testing_filename = "
        << shuffled_images_charmasks_testing_filename << endl;
   cout << "shuffled_images_wordmasks_testing_filename = "
        << shuffled_images_wordmasks_testing_filename << endl;
   unix_cmd = "shuf "+images_charmasks_testing_filename+" > "+
      shuffled_images_charmasks_testing_filename;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   unix_cmd = "shuf "+images_wordmasks_testing_filename+" > "+
      shuffled_images_wordmasks_testing_filename;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

// Create object names file containing background and text classes:

   string object_names_filename=deeplab_inputs_subdir+
      "char_object_names.classes";
   ofstream outstream;
   filefunc::openfile(object_names_filename, outstream);

// As of 4/6/16, we assume "character" mask contains horizontal
// character information within phrases.  We also assume "word" mask
// contains vertical half character information within phrases:

   outstream << "__background__" << endl;
   outstream << "start_char" << endl;
   outstream << "middle_char" << endl;
   outstream << "stop_char" << endl;
   outstream << "single_char" << endl;
   outstream << "space_char" << endl;
   outstream << "vertical_start_char" << endl;
   outstream << "vertical_middle_char" << endl;
   outstream << "vertical_stop_char" << endl;
   filefunc::closefile(object_names_filename, outstream);

   object_names_filename=deeplab_inputs_subdir+
      "word_object_names.classes";
   filefunc::openfile(object_names_filename, outstream);
   outstream << "__background__" << endl;
   outstream << "top_half_val" << endl;
   outstream << "bottom_half_val" << endl;
   filefunc::closefile(object_names_filename, outstream);

// Move folders containing output chips and masks into
// deeplab_inputs_subdir:

   unix_cmd="mv "+output_tiles_subdir+" "+deeplab_inputs_subdir;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);
   
   unix_cmd="mv "+output_charmasks_subdir+" "+deeplab_inputs_subdir;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   unix_cmd="mv "+output_wordmasks_subdir+" "+deeplab_inputs_subdir;
   cout << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

   string banner="Exported deeplab inputs to "+deeplab_inputs_subdir;
   outputfunc::write_big_banner(banner);
} 
