// ==========================================================================
// Program MONTAGE_STRINGS imports a set of synthetic text image chips
// and their masks generated by program GENERATE_STRING_IMAGES.  It
// ignores any synthetic text chips which are either nontrivially
// rotated or contain background underlay bbox content.
// MONTAGE_STRINGS composites together a small random number of text
// chips within a vertical column against an alpha = 0 background.
// The montaged chips and masks are exported to montaged_images
// subdirs.

//                      ./montage_strings

// ==========================================================================
// Last updated on 4/15/16
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "math/constants.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/sysfuncs.h"
#include "text/textfuncs.h"
#include "time/timefuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   timefunc::initialize_timeofday_clock();

   nrfunc::init_time_based_seed();
 
   string training_data_subdir="./training_data";
   int syn_words_ID = -1;
   cout << "Enter synthetic words ID (-1 for default):" << endl;
   cin >> syn_words_ID;
   string synthetic_subdir="./training_data/synthetic_words";
   if(syn_words_ID >= 0)
   {
      synthetic_subdir += "_"+stringfunc::integer_to_string(syn_words_ID,2);
   }
   synthetic_subdir += "/";

   string rotated_images_subdir=synthetic_subdir+"rotated_images/";
   string rotated_charmasks_subdir=synthetic_subdir+"rotated_char_masks/";
   string rotated_wordmasks_subdir=synthetic_subdir+"rotated_word_masks/";

   string montaged_images_subdir = synthetic_subdir+"montaged_images/";
   string montaged_charmasks_subdir = synthetic_subdir+"montaged_char_masks/";
   string montaged_wordmasks_subdir = synthetic_subdir+"montaged_word_masks/";
   filefunc::dircreate(montaged_images_subdir);
   filefunc::dircreate(montaged_charmasks_subdir);
   filefunc::dircreate(montaged_wordmasks_subdir);

   vector<string> chips_subdirs, charmasks_subdirs, wordmasks_subdirs;
   chips_subdirs.push_back(rotated_images_subdir);
   charmasks_subdirs.push_back(rotated_charmasks_subdir);
   wordmasks_subdirs.push_back(rotated_wordmasks_subdir);

   vector<string> chip_filenames=filefunc::image_files_in_multi_subdirs(
      chips_subdirs);
   vector<string> charmask_filenames=filefunc::image_files_in_multi_subdirs(
      charmasks_subdirs);
   vector<string> wordmask_filenames=filefunc::image_files_in_multi_subdirs(
      wordmasks_subdirs);
   int n_image_chips = chip_filenames.size();
   cout << "chip_filenames.size = " << chip_filenames.size() << endl;
   cout << " charmask_filenames.size = " << charmask_filenames.size() << endl;
   cout << " wordmask_filenames.size = " << wordmask_filenames.size() << endl;
   if( (chip_filenames.size() != charmask_filenames.size()) ||
       (chip_filenames.size() != wordmask_filenames.size()) )
   {
      exit(-1);
   }

// Keep track of synthetic text image chips which are just foreground
// and unrotated:

   vector<bool> just_foreground_chip, unrotated_chip;
   for(unsigned int i = 0; i < chip_filenames.size(); i++)
   {
      string curr_chip_filename = chip_filenames[i];
      string substring = "JustForeground";
      int substr_posn = 
         stringfunc::first_substring_location(chip_filenames[i],substring);
      just_foreground_chip.push_back( (substr_posn >= 0) );

      substring = "NoRot";
      substr_posn = 
         stringfunc::first_substring_location(chip_filenames[i],substring);
      unrotated_chip.push_back( (substr_posn >= 0) );
   }

   int tstart, tstop;
   cout << "Enter index for starting string combo to process:" << endl;
   cin >> tstart;
   cout << "Enter index for stopping string combo to process:" << endl;
   cin >> tstop;
   int n_string_combos = tstop - tstart;

// ---------------------------------------------------------------
// Main loop over all string combos starts here:

   for(int t = tstart; t < tstop; t++)
   {
      if ((t-tstart)%100 == 0)
      {
         double progress_frac = double(t - tstart)/n_string_combos;
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }

      string montaged_string_filename=
         montaged_images_subdir+"montaged_string_"+
         stringfunc::integer_to_string(t,5)+"_JustForeground_NoRot.png";
      string montaged_charmask_filename=
         montaged_charmasks_subdir+"montaged_charmask_"+
         stringfunc::integer_to_string(t,5)+"_JustForeground_NoRot.png";
      string montaged_wordmask_filename=
         montaged_wordmasks_subdir+"montaged_wordmask_"+
         stringfunc::integer_to_string(t,5)+"_JustForeground_NoRot.png";

      int n_overlays = 2 + nrfunc::ran1() * 2;
      vector<int> overlay_chip_IDs;
      for(int n = 0; n < n_overlays; n++)
      {
         int curr_chip_id;
         bool chip_id_set = false;
         while(!chip_id_set)
         {
            curr_chip_id = nrfunc::ran1() * n_image_chips;

// As of 4/8/16, we intentionally bias choice of synthesized text
// towards pure foregrounds with no constant color bbox underlays:

            if(just_foreground_chip[curr_chip_id] &&
               unrotated_chip[curr_chip_id])
            {
               chip_id_set = true;
            }
         } // while !chip_id_set loop
         overlay_chip_IDs.push_back(curr_chip_id);
      }
// As of 7 am on Fri Apr 15, we assume that strings will be combined
// in a single vertical column

      int montage_width = 0;

      vector<int> chip_pys;
      chip_pys.push_back(0);
      for(unsigned int n = 0; n < overlay_chip_IDs.size(); n++)
      {
         int curr_chip_id = overlay_chip_IDs[n];
         string curr_chip_filename=chip_filenames[curr_chip_id];
         unsigned int chip_width, chip_height;

         imagefunc::get_image_width_height(
            curr_chip_filename, chip_width, chip_height);
         montage_width = basic_math::max(
            montage_width, int(chip_width));
         int next_chip_py = chip_pys.back() + 1.1 * chip_height;
         chip_pys.push_back(next_chip_py);
      }
      int montage_height = chip_pys.back();
      
      texture_rectangle* composite_image_tr_ptr = new texture_rectangle(
         montage_width, montage_height, 1, 4, NULL);
      texture_rectangle* charmask_tr_ptr = new texture_rectangle(
         montage_width, montage_height, 1, 4, NULL);
      texture_rectangle* wordmask_tr_ptr = new texture_rectangle(
         montage_width, montage_height, 1, 4, NULL);

      for(unsigned int n = 0; n < overlay_chip_IDs.size(); n++)
      {
         int curr_chip_id = overlay_chip_IDs[n];
         string curr_chip_filename=chip_filenames[curr_chip_id];
         string curr_charmask_filename=charmask_filenames[curr_chip_id];
         string curr_wordmask_filename=wordmask_filenames[curr_chip_id];

//         cout << "n = " << n << " curr_chip_id = " << curr_chip_id << endl;
//         cout << "curr_chip_filename = " << curr_chip_filename << endl;
//         cout << "curr_charmask_filename = " << curr_charmask_filename << endl;
//         cout << "curr_wordmask_filename = " << curr_wordmask_filename << endl;

         int qx = 0;
         int qy = chip_pys[n];
         
         composite_image_tr_ptr->overlay(curr_chip_filename, qx, qy);
         charmask_tr_ptr->overlay(curr_charmask_filename, qx, qy);
         wordmask_tr_ptr->overlay(curr_wordmask_filename, qx, qy);

      } // loop over index n labeling string overlays

      Magick::Image composite_image(
         composite_image_tr_ptr->getWidth(),
         composite_image_tr_ptr->getHeight(), 
         "RGBA", MagickCore::CharPixel,
         composite_image_tr_ptr->get_image_ptr()->data());
      composite_image.depth(8);
      composite_image.write(montaged_string_filename);      

      charmask_tr_ptr->write_curr_frame(montaged_charmask_filename);
      wordmask_tr_ptr->write_curr_frame(montaged_wordmask_filename);

/*
      bool visualize_composite_mask_flag = true;
//      bool visualize_composite_mask_flag = false;

// For multi-valued masks, we set nontrivial_pixel_value = 0 so that
// any spurious bright regions in the mask will be reset to black:

      int nontrivial_pixel_value = 0;
//      int nontrivial_pixel_value = 1;

      vector<vector<unsigned char> > char_byte_array = 
         videofunc::generate_byte_array(
            composite_charmask_filename,
            0, composite_image_tr_ptr->getWidth() - 1,
            0, composite_image_tr_ptr->getHeight() - 1,
            visualize_composite_mask_flag, nontrivial_pixel_value);
      string char_bytearray_filename=composites_subdir+"char_bytearray_"+
         stringfunc::integer_to_string(t,5)+".png";
      videofunc::write_8bit_greyscale_pngfile(
         char_byte_array, char_bytearray_filename);
//      cout << "Exported " << char_bytearray_filename << endl;

      vector<vector<unsigned char> > word_byte_array = 
         videofunc::generate_byte_array(
            composite_wordmask_filename,
            0, composite_image_tr_ptr->getWidth() - 1,
            0, composite_image_tr_ptr->getHeight() - 1,
            visualize_composite_mask_flag, nontrivial_pixel_value);
      string word_bytearray_filename=composites_subdir+"word_bytearray_"+
         stringfunc::integer_to_string(t,5)+".png";
      videofunc::write_8bit_greyscale_pngfile(
         word_byte_array, word_bytearray_filename);
//      cout << "Exported " << word_bytearray_filename << endl;
*/

      delete composite_image_tr_ptr;
      delete charmask_tr_ptr;
      delete wordmask_tr_ptr;
   } // loop over index t labeling tiles

} 
