// ========================================================================
// Program TILE_FUSE is a specialized fusion program written to merge
// Lubbock satellite EO from input geotif files with ladar point
// clouds from tdp files.  The tile's number is extracted from its tdp
// filename which is passed as a command line argument.  Geotif files
// corresponding to the 3x3 EO tiles surrounding the ladar tile are
// read in to ensure every XYZ point matches onto some EO pixel
// currently accessible within memory.  Local linear transformation
// parameters for the particular ladar tile are read in from a text
// file generated by program TILE_TRANSFORM.  Each XYZ point in the
// ladar tile is then mapped onto corresponding easting & northing
// coordinates within the EO geotifs.  RGB values are subsequently
// saved into an output tdp file.

// 		     tile_fuse tile_400_filled.tdp

// ========================================================================
// Last updated on 1/30/08; 1/31/08; 2/1/08; 2/3/08; 2/7/08
// ========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "gdal_priv.h"
#include "math/basic_math.h"
#include "color/colorfuncs.h"
#include "osg/osgSceneGraph/ColorMap.h"
#include "general/filefuncs.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "osg/osg3D/PointCloudsGroup.h"
#include "image/raster_parser.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::ofstream;
   using std::string;
   using std::vector;

// First read in TDP file containing ladar tile:

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);

// Read input TDP file containing XYZ cloud information:

   PassesGroup passes_group(&arguments);
   int cloudpass_ID=passes_group.get_curr_cloudpass_ID();
   string tdp_filename=
      passes_group.get_pass_ptr(cloudpass_ID)->get_first_filename();
   cout << "tdp_filename = " << tdp_filename << endl;
   int n_points=tdpfunc::npoints_in_tdpfile(tdp_filename);

// Store XYZ info within STL vectors:

   vector<double> X,Y,Z;
   X.reserve(n_points);
   Y.reserve(n_points);
   Z.reserve(n_points);
   tdpfunc::read_XYZ_points_from_tdpfile(tdp_filename,X,Y,Z);

//   cout << "X.size() = " << X.size() << endl;
//   cout << "Y.size() = " << Y.size() << endl;
//   cout << "Z.size() = " << Z.size() << endl;

// Extract center tile number from tdp filename:

   vector<string> substrings=stringfunc::decompose_string_into_substrings(
      tdp_filename,"_");
   templatefunc::printVector(substrings);
   string tile_number_str=substrings[1].substr(1,4);
//   cout << "tile_number_str = " << tile_number_str << endl;
   int center_tile_number=stringfunc::string_to_number(tile_number_str);

// Next read in neighboring EO tif files.  Every XYZ point within the
// central ladar tile should map onto some pixel within the aggregate
// of all these EO geotif files.

   string tile_info_filename="tile_neighbors.dat";
   if (!filefunc::ReadInfile(tile_info_filename))
   {
      cout << "Could not read in tile_info_filename = "
           << tile_info_filename << endl;
   }
   
   cout.precision(12);
//   int center_tile_number;
//   cout << "Enter center tile number:" << endl;
//   cin >> center_tile_number;
   int line_number=center_tile_number-100;

   string subdir="/media/LACIE/Bluegrass/eo/Quickbird/small_tiles/";
   vector<string> tile_neighbor_filenames;
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[line_number]);
//      int tile_number=stringfunc::string_to_number(substrings[0]);
      tile_neighbor_filenames.clear();

      for (unsigned int j=1; j<substrings.size(); j++)
      {
         tile_neighbor_filenames.push_back(subdir+substrings[j]);
         cout << tile_neighbor_filenames.back() << " ";
      }
      cout << endl;
   }

// Instantiate a set of raster_parser objects to hold red, green and
// blue pixel arrays for each EO geotif:
   
   vector<raster_parser*> RasterParser_ptrs;
   typedef Triple<twoDarray*,twoDarray*,twoDarray*> RGB_twoDarray_ptr;
   RGB_twoDarray_ptr curr_RGB_twoDarray_ptr;
   vector<RGB_twoDarray_ptr> RGB_twoDarray_ptrs;
   
   for (unsigned int t=0; t<tile_neighbor_filenames.size(); t++)
   {
      cout << "t = " << t << endl;
      raster_parser* curr_rasterparser_ptr=new raster_parser;
      RasterParser_ptrs.push_back(curr_rasterparser_ptr);
      curr_rasterparser_ptr->open_image_file(tile_neighbor_filenames[t]);

      curr_rasterparser_ptr->fetch_raster_band(0);
      curr_RGB_twoDarray_ptr.first=curr_rasterparser_ptr->
         get_RtwoDarray_ptr();
      curr_rasterparser_ptr->read_raster_data(curr_RGB_twoDarray_ptr.first);

      curr_rasterparser_ptr->fetch_raster_band(1);
      curr_RGB_twoDarray_ptr.second=curr_rasterparser_ptr->
         get_GtwoDarray_ptr();
      curr_rasterparser_ptr->read_raster_data(curr_RGB_twoDarray_ptr.second);

      curr_rasterparser_ptr->fetch_raster_band(2);
      curr_RGB_twoDarray_ptr.third=curr_rasterparser_ptr->
         get_BtwoDarray_ptr();
      curr_rasterparser_ptr->read_raster_data(curr_RGB_twoDarray_ptr.third);
      
      RGB_twoDarray_ptrs.push_back(curr_RGB_twoDarray_ptr);

   } // loop over index t labeling tile neighbors

   vector<int> R,G,B;
   R.reserve(n_points);
   G.reserve(n_points);
   B.reserve(n_points);

// Read in linear transformation parameters precalculated for Lubbock
// tiles 1-678 via program RUBBER:

   string linear_warp_filename="linear_warp.txt";
   if (!filefunc::ReadInfile(linear_warp_filename))
   {
      cout << "Could not read in linear warp parameters from file = "
           << linear_warp_filename << endl;
      exit(-1);
   }

   substrings.clear();
   vector<double> linear_warp_params=
      stringfunc::string_to_numbers(filefunc::text_line[line_number]);

   genmatrix M(2,2);
   M.put(0,0,linear_warp_params[1]);
   M.put(0,1,linear_warp_params[2]);
   M.put(1,0,linear_warp_params[3]);
   M.put(1,1,linear_warp_params[4]);
   twovector trans(linear_warp_params[5],linear_warp_params[6]);

   cout << "tile number = " << linear_warp_params[0] << endl;
   cout << "M = " << M << endl;
   cout << "trans = " << trans << endl;

// Hardwire z threshold values for all Lubbock ladar tiles:
   
   double zmin=862;
   double zmax=1061;
   ColorMap z_colormap;
   z_colormap.set_mapnumber(9);	// wrap 2
//   z_colormap.set_mapnumber(11);	// wrap 4
//   z_colormap.set_mapnumber(13);	// wrap 16
   z_colormap.set_max_threshold(zmax);
   z_colormap.set_min_threshold(zmin);

// Loop over every XYZ point within ladar tile, compute its matching
// (and physically incorrect!) easting and northing counterpart
// coordinates within the EO geotifs, and retrieve its corresponding
// RGB values:

   for (unsigned int p=0; p<X.size(); p++)
   {
      double init_x=X[p];
      double init_y=Y[p];
      double init_z=Z[p];

      double curr_x=M.get(0,0)*init_x+M.get(0,1)*init_y+trans.get(0);
      double curr_y=M.get(1,0)*init_x+M.get(1,1)*init_y+trans.get(1);
//      double curr_x=init_x;
//      double curr_y=init_y;
      double curr_z=init_z;

      osg::Vec4ub z_color=z_colormap.retrieve_curr_color(curr_z);

      bool voxel_colored_flag=false;
      for (unsigned int t=0; t<RGB_twoDarray_ptrs.size() && 
              !voxel_colored_flag; t++)
      {
         curr_RGB_twoDarray_ptr=RGB_twoDarray_ptrs[t];
         twoDarray* RtwoDarray_ptr=curr_RGB_twoDarray_ptr.first;
         twoDarray* GtwoDarray_ptr=curr_RGB_twoDarray_ptr.second;
         twoDarray* BtwoDarray_ptr=curr_RGB_twoDarray_ptr.third;
      
//         cout << "t = " << t << endl;
//         cout << "xlo = " << RtwoDarray_ptr->get_xlo()
//              << " xhi = " << RtwoDarray_ptr->get_xhi() << endl;
//         cout << "ylo = " << RtwoDarray_ptr->get_ylo()
//              << " yhi = " << RtwoDarray_ptr->get_yhi() << endl;

         unsigned int px,py;
         if (RtwoDarray_ptr->point_to_pixel(curr_x,curr_y,px,py) &&
             !voxel_colored_flag)
         {

// Drape pure EO RGB values onto ladar point cloud:

            R.push_back(RtwoDarray_ptr->get(px,py));
            G.push_back(GtwoDarray_ptr->get(px,py));
            B.push_back(BtwoDarray_ptr->get(px,py));

/*

// Correlate hues with ladar height and saturation+value with EO:

            double R_EO=RtwoDarray_ptr->get(px,py)/255.0;
            double G_EO=GtwoDarray_ptr->get(px,py)/255.0;
            double B_EO=BtwoDarray_ptr->get(px,py)/255.0;

            double H_EO,S_EO,V_EO;
            colorfunc::RGB_to_hsv(R_EO,G_EO,B_EO,H_EO,S_EO,V_EO);

            double R_Z=static_cast<int>(z_color.r())/255.0;
            double G_Z=static_cast<int>(z_color.g())/255.0;
            double B_Z=static_cast<int>(z_color.b())/255.0;
            double H_Z,S_Z,V_Z;
            colorfunc::RGB_to_hsv(R_Z,G_Z,B_Z,H_Z,S_Z,V_Z);

            double fused_r,fused_g,fused_b;
            colorfunc::hsv_to_RGB(H_Z,S_EO,V_EO,fused_r,fused_g,fused_b);

            int R_fused=fused_r*255;
            int G_fused=fused_g*255;
            int B_fused=fused_b*255;
            R_fused=min(255,R_fused);
            G_fused=min(255,G_fused);
            B_fused=min(255,B_fused);

            R.push_back(R_fused);
            G.push_back(G_fused);
            B.push_back(B_fused);
*/

            voxel_colored_flag=true;
         }
         else
         {
            if (!voxel_colored_flag && t==RGB_twoDarray_ptrs.size()-1)
            {
               R.push_back(static_cast<int>(z_color.r()));
               G.push_back(static_cast<int>(z_color.g()));
               B.push_back(static_cast<int>(z_color.b()));
               voxel_colored_flag=true;
            }
         } // point inside RtwoDarray conditional

         if (p%100000==0 && voxel_colored_flag)
         {
            cout << "p=" << p << " x=" << curr_x << " y=" << curr_y
                 << " t=" << t << " px=" << px << " py=" << py 
                 << " R=" << R.back() 
                 << " G=" << G.back() 
                 << " B=" << B.back() << endl;
         }

      } // loop over index t labeling tile neighbors

   } // loop over index p labeling XYZ points

// Write colored XYZ points to output tdp file:
   
   string UTMzone="14";
   string prefix=stringfunc::prefix(tdp_filename);
   string fused_tdp_filename=prefix+"_fused.tdp";
   cout << "fused_tdp_filename = " << fused_tdp_filename << endl;

   tdpfunc::write_relative_xyzrgba_data(
      UTMzone,fused_tdp_filename,X,Y,Z,R,G,B);

}
