// =======================================================================
// Program UVCORRECT_PANOS imports fitted sinusoid horizon parameters
// generated by program FIT_HORIZONS.  Looping over a set of raw
// WISP panoramas, it applies U-dependent sine function V-offsets to
// each input image.  The physical horizon within a "V-corrected"
// panorama appears as a horizontal line in the output image.  Obvious
// "U-shearing" of vertical edges within "V-corrected" panoramas can
// be removed via a V-dependent cosine function.  Corrected versions of
// the input panoramas which are unwarped in both the U and V image
// plane directions are exported.  Subsampled versions of the
// corrected panoramas are also exported so that SIFT/ASIFT can later
// be run on them for video stabilization purposes.

//			       ./uvcorrect_panos

// =======================================================================
// Last updated on 7/15/13; 8/8/13; 8/22/13; 12/23/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "video/camerafuncs.h"
#include "math/constant_vectors.h"
#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "math/rotation.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);

   timefunc::initialize_timeofday_clock();

   int pixel_width=40000;
   int pixel_height=2200;
   double Umax=double(pixel_width)/double(pixel_height);
   cout << "Umax = " << Umax << endl;
   
   double IFOV=2*PI/pixel_width;
   double elevation_extent=pixel_height*IFOV; //  0 <= V <= 1
   cout << "elevation_extent = " << elevation_extent*180/PI << " degs" << endl;

// On Dunmeyer's Ubuntu 12.4 box:
   
   string date_string="05202013";
   cout << "Enter date string (e.g. 05202013 or 05222013):" << endl;
   cin >> date_string;
   filefunc::add_trailing_dir_slash(date_string);

   string MayFieldtest_subdir=
      "/data/DIME/panoramas/May2013_Fieldtest/";
//   string FSFdate_subdir=MayFieldtest_subdir+"05202013/";
   string FSFdate_subdir=MayFieldtest_subdir+date_string;
   cout << "FSFdate_subdir = " << FSFdate_subdir << endl;

   int scene_ID;
   cout << "Enter scene ID:" << endl;
   cin >> scene_ID;
   string scene_ID_str=stringfunc::integer_to_string(scene_ID,2);
   string panos_subdir=FSFdate_subdir+"Scene"+scene_ID_str+"/";
   cout << "panos_subdir = " << panos_subdir << endl;

   string raw_images_subdir=panos_subdir+"raw/";
   string horizons_subdir=panos_subdir+"horizons/";
   string params_filename=horizons_subdir+"filtered_sinusoid_params.dat";
//   string params_filename=horizons_subdir+"sinusoid_params.dat";

   filefunc::ReadInfile(params_filename);

//   string blank_image_filename=
//      "~/programs/c++/svn/projects/src/mains/dime/blank_40Kx2.2K.jpg";
   string blank_image_filename="./blank_40Kx2.2K.jpg";
   texture_rectangle* input_texture_rectangle_ptr=
      new texture_rectangle(blank_image_filename,NULL);
   texture_rectangle* vcorrected_texture_rectangle_ptr=
      new texture_rectangle(blank_image_filename,NULL);
   texture_rectangle* uvcorrected_texture_rectangle_ptr=
      new texture_rectangle(blank_image_filename,NULL);

   double numer=0;
   double denom=0;
   int istart=0;
   int istop=filefunc::text_line.size()-1;
   for (int i=istart; i<=istop; i++)
   {
      double progress_frac=double(i-istart)/double(istop-istart);
      outputfunc::print_elapsed_and_remaining_time(progress_frac);

      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      string image_basename=substrings[0];
      string image_filename=raw_images_subdir+image_basename;
      string uvcorrected_image_filename=horizons_subdir+"uvcorrected_"+
         image_basename;

      string banner="Correcting "+image_basename;
      outputfunc::write_banner(banner);

      double A=stringfunc::string_to_number(substrings[1]);
      double phi=stringfunc::string_to_number(substrings[2])*PI/180;
      double v_avg=stringfunc::string_to_number(substrings[3]);
      double max_score=stringfunc::string_to_number(substrings[4]);
      numer += max_score*v_avg;
      denom += max_score;

      bool export_images_flag=true;
//      bool export_images_flag=false;
      
      if (!export_images_flag) continue;

      input_texture_rectangle_ptr->import_photo_from_file(
         image_filename);

      camerafunc::vcorrect_WISP_image(
         input_texture_rectangle_ptr,vcorrected_texture_rectangle_ptr,A,phi);

// On 3/25/13, we empirically found that the "u-shearing" parameters
// needed in order to remove obvious horizontal shearing artefacts
// from "V-corrected" panoramas are simply related to A, phi and
// v_avg!

      camerafunc::ucorrect_WISP_image(
         vcorrected_texture_rectangle_ptr,
         uvcorrected_texture_rectangle_ptr,
         0,v_avg,-A,phi);

      uvcorrected_texture_rectangle_ptr->write_curr_frame(
         uvcorrected_image_filename);

// Generate subsampled version of v-corrected panorama on which we can
// run SIFT and ASIFT:

      string subsampled_filename=horizons_subdir+
         "subsampled_uvcorrected_"+image_basename;
      string unix_cmd="convert -resize 9.9% "+uvcorrected_image_filename+" "+
         subsampled_filename;
      sysfunc::unix_command(unix_cmd);

      banner="Exported "+uvcorrected_image_filename;
      outputfunc::write_banner(banner);

   } // loop over index i labeling input images

   delete input_texture_rectangle_ptr;
   delete vcorrected_texture_rectangle_ptr;
   delete uvcorrected_texture_rectangle_ptr;

// Compute py_horizon averaged over all input WISP panoramas:

   double mean_v_avg=numer/denom;
   double delta_v=mean_v_avg-0.5;
   int pv_horizon=(1-mean_v_avg)*pixel_height;

   cout << "<v_avg> = " << mean_v_avg << endl;
   cout << "Delta_v = " << delta_v << endl;
   cout << "pv_horizon = " << pv_horizon << endl;

// Extract WISP sensor's altitude above sea-level from py_horizon:

   double delta_vert_pixels=delta_v*pixel_height;
   cout << "delta_vert_pixels = " << delta_vert_pixels << endl;
   double delta_vert_theta=delta_vert_pixels*IFOV;
   cout << "delta_vert_theta = " << delta_vert_theta*180/PI << " degs" << endl;
   double theta=PI/2+delta_vert_theta;
   cout << "theta = " << theta*180/PI << endl;
   double Re=6371*1000;
   double a=Re*(1/sin(theta)-1);
   cout << "WISP altitude above sea-level a = " << a << " meters" << endl;

// Compute radial distance (range) to horizon:

   double r=sqrt(2*Re*a+a*a);
   cout << "Range to horizon r = " << r << " meters" << endl;

   string banner="Finished running program UVCORRECT_PANOS";
   outputfunc::write_big_banner(banner);
   outputfunc::print_elapsed_time();
}
