// ========================================================================
// Program STABILIZE_PANELS imports affine transformation parameters
// from the text file generated by program TEMPORAL_MATCHER.  Looping
// over each pixel within a new stabilized version of each WISP panel
// frame, STABILIZE_PANELS retrieves its counterpart pixel intensity
// from the pre-warped WISP panel.  After this transformation, each
// new WISP panel should be stabilized relative to the zeroth
// (georegistered) panel.  Stabilized images are exported to
// date-time stamped PNG files.

//			  ./stabilize_panels

// ========================================================================
// Last updated on 3/18/13; 3/19/13
// ========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "osg/osgOperations/Operations.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "video/texture_rectangle.h"
#include "osg/osgWindow/ViewerManager.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::string;
using std::vector;

// ==========================================================================
int main( int argc, char** argv )
{

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string panels_subdir=bundler_IO_subdir+"images/panels/";
   string stable_subdir=panels_subdir+"stable/";
   filefunc::dircreate(stable_subdir);

   string affine_transforms_filename=bundler_IO_subdir+
      "2D_translation_p4.dat";
   filefunc::ReadInfile(affine_transforms_filename);
   int n_lines=filefunc::text_line.size();
   int n_panos=n_lines/4;
   cout << "n_lines = " << n_lines << " n_panos = " << n_panos << endl;

// Construct the viewer and instantiate a ViewerManager:

   WindowManager* window_mgr_ptr=new ViewerManager();

// Instantiate Operations object to handle mode, animation and image
// number control:

   bool display_movie_state=true; 
   bool display_movie_number=true;
   bool display_movie_world_time=true;
//   bool display_movie_state=false;
//   bool display_movie_number=false;
//   bool display_movie_world_time=false;

   bool hide_Mode_HUD_flag=false;
//   bool hide_Mode_HUD_flag=true;
   Operations operations(
      ndims,window_mgr_ptr,passes_group,
      display_movie_state,display_movie_number,display_movie_world_time,
      hide_Mode_HUD_flag);

   operations.set_master_world_start_UTC(
      passes_group.get_world_start_UTC_string());
   operations.set_master_world_stop_UTC(
      passes_group.get_world_stop_UTC_string());

   double start_UTC=operations.get_master_world_start_time();
   double stop_UTC=operations.get_master_world_stop_time();

// FAKE FAKE:  Tues Mar 19, 2013 at 2:36 pm

// Hardwire time_per_pano for first 100 Deer Island panos

   double time_per_pano=1.92541;	// secs  Deer Island 
   stop_UTC=start_UTC+n_panos*time_per_pano;
   

   Clock clock;
//   bool display_UTC_flag=false;
   bool display_UTC_flag=true;
   int UTM_zone=19;	// Boston
   clock.compute_UTM_zone_time_offset(UTM_zone);
   clock.convert_elapsed_secs_to_date(start_UTC);
   cout << "start date/time = " 
        << clock.YYYY_MM_DD_H_M_S("_",":",display_UTC_flag) << endl;
   clock.convert_elapsed_secs_to_date(stop_UTC);
   cout << "stop date/time = " 
        << clock.YYYY_MM_DD_H_M_S("_",":",display_UTC_flag) << endl;

   
   vector<twovector> d_UV;
   for (int pano=0; pano<n_panos; pano++)
   {
      int curr_linenumber=pano*4+2;
      string curr_line=filefunc::text_line[curr_linenumber];
      vector<double> column_values=stringfunc::string_to_numbers(curr_line);
      d_UV.push_back(twovector(column_values[0],column_values[1]));
   }

   texture_rectangle* curr_texture_rectangle_ptr=new texture_rectangle;
   texture_rectangle* next_texture_rectangle_ptr=new texture_rectangle;
   texture_rectangle* prev_texture_rectangle_ptr=new texture_rectangle;
   texture_rectangle* stabilized_texture_rectangle_ptr=new texture_rectangle;

   int pano_step=1;
//   int pano_step=10;
   for (int pano=0; pano<n_panos; pano += pano_step)
   {
      cout << endl;
      cout << "Stabilizing pano " << pano << " of " << n_panos << endl;

      double curr_UTC=start_UTC+(stop_UTC-start_UTC)*(pano-0)/(n_panos);
      clock.convert_elapsed_secs_to_date(curr_UTC);
      string curr_date_time_str=clock.YYYY_MM_DD_H_M_S(
         "_","-",display_UTC_flag);
      cout << "Current date/time = " << curr_date_time_str << endl;

      int panel_start=0;
      int panel_stop=9;
//      int panel_start=4;
//      int panel_stop=4;
      int n_panels=10;
      for (int p=panel_start; p<=panel_stop; p++)
      {
         cout << " Processing panel = " << p << endl;

         string pano_ID_str=stringfunc::integer_to_string(pano,5);
         string curr_panel_filename=panels_subdir+
            "wisp_p"+stringfunc::number_to_string(p)+"_res0_"+
            pano_ID_str+".png";
         string next_panel_filename=panels_subdir+
            "wisp_p"+stringfunc::number_to_string(modulo(p+1,n_panels))+
            "_res0_"+pano_ID_str+".png";
         string prev_panel_filename=panels_subdir+
            "wisp_p"+stringfunc::number_to_string(modulo(p-1,n_panels))+
            "_res0_"+pano_ID_str+".png";

         curr_texture_rectangle_ptr->import_photo_from_file(
            curr_panel_filename);
         next_texture_rectangle_ptr->import_photo_from_file(
            next_panel_filename);
         prev_texture_rectangle_ptr->import_photo_from_file(
            prev_panel_filename);

         stabilized_texture_rectangle_ptr->import_photo_from_file(
            curr_panel_filename);

         int width=curr_texture_rectangle_ptr->getWidth();
         int height=curr_texture_rectangle_ptr->getHeight();
//      cout << "width = " << width << " height = " << height << endl;
//         int n_channels=curr_texture_rectangle_ptr->getNchannels();
//      cout << "n_channels = " << n_channels << endl;

//         int d_px=width*d_UV[pano].get(0);
         int d_px=height*d_UV[pano].get(0);
         int d_py=-height*d_UV[pano].get(1);
         cout << "d_px = " << d_px << " d_py = " << d_py << endl;

         twoDarray* ptwoDarray_ptr=curr_texture_rectangle_ptr->
            fill_ptwoDarray_from_single_channel_byte_data();
         ptwoDarray_ptr=next_texture_rectangle_ptr->
            fill_ptwoDarray_from_single_channel_byte_data();
         ptwoDarray_ptr=prev_texture_rectangle_ptr->
            fill_ptwoDarray_from_single_channel_byte_data();
         ptwoDarray_ptr=stabilized_texture_rectangle_ptr->
            fill_ptwoDarray_from_single_channel_byte_data();

// Loop over all pixels within stabilized video panel:

         for (int px=0; px<width; px++)
         {
            for (int py=0; py<height; py++)
            {
               int pixel_intensity=0;
               if (px+d_px >= 0 && px+d_px < width &&
                   py+d_py >= 0 && py+d_py < height)
               {
                  pixel_intensity=curr_texture_rectangle_ptr->
                     get_pixel_intensity(px+d_px,py+d_py);
               }
               else if (px+d_px >= width && 
                   py+d_py >= 0 && py+d_py < height)
               {
                  pixel_intensity=next_texture_rectangle_ptr->
                     get_pixel_intensity(px+d_px-width,py+d_py);
               }
               else if (px+d_px < 0 && 
                   py+d_py >= 0 && py+d_py < height)
               {
                  pixel_intensity=prev_texture_rectangle_ptr->
                     get_pixel_intensity(px+d_px+width,py+d_py);
               }
               stabilized_texture_rectangle_ptr->set_pixel_intensity_value(
                  px,py,pixel_intensity);
            }
         }

         string output_panel_filename=stable_subdir+
            "p"+stringfunc::number_to_string(p)+"_"+curr_date_time_str+
            "_res0_"+pano_ID_str+".png";

         stabilized_texture_rectangle_ptr->write_curr_frame(
            output_panel_filename);
      }
   } // loop over pano index labeling WISP-360 panoramas
   
   delete curr_texture_rectangle_ptr;
   delete next_texture_rectangle_ptr;
   delete prev_texture_rectangle_ptr;
   delete stabilized_texture_rectangle_ptr;
}
