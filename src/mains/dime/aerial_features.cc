// =======================================================================
// Program AERIAL_FEATURES imports projected May 2013 Panama City
// field test aerial tracks generated by AERIAL_TRACKS.  In
// particular, it reads in track label, panel_ID, panel_U and panel_V
// information as a function of pano ID.  Looping over all 10
// wagonwheel panels, AERIAL_FEATURES exports 2D feature files which
// contain U,V feature track coordinates as functions of video
// framenumber.  The resulting UV feature files can be imported into
// program VPLAYER in order to directly compare WISP video with aerial
// tracks projected into georegistered image planes.

//			      ./aerial_features

// =======================================================================
// Last updated on 8/8/13; 8/12/13; 12/23/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "general/outputfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"
#include "track/tracks_group.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main( int argc, char** argv ) 
{
   std::set_new_handler(sysfunc::out_of_memory);

   string date_string="05202013";
   cout << "Enter date string (e.g. 05202013 or 05222013):" << endl;
   cin >> date_string;
   filefunc::add_trailing_dir_slash(date_string);

   string bundler_subdir="./bundler/DIME/";
   string MayFieldtest_subdir=bundler_subdir+"May2013_Fieldtest/";
   string FSFdate_subdir=MayFieldtest_subdir+date_string;
//   string FSFdate_subdir=MayFieldtest_subdir+"05202013/";
   cout << "FSFdate_subdir = " << FSFdate_subdir << endl;

   int scene_ID;
   cout << "Enter scene ID:" << endl;
   cin >> scene_ID;
   string scene_ID_str=stringfunc::integer_to_string(scene_ID,2);
   string bundler_IO_subdir=FSFdate_subdir+"Scene"+scene_ID_str+"/";
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string aerial_tracks_subdir=bundler_IO_subdir+"aerial_tracks/";
   string stable_frames_subdir=bundler_IO_subdir+"stable_frames/";
   string FSF_track_filename=stable_frames_subdir+"FSF_UTM_track.dat";

   timefunc::initialize_timeofday_clock();

//   bool northern_hemisphere_flag=true;
//   int specified_UTM_zonenumber=16;	// Panama City, FL
   Clock clock;
   tracks_group ship_tracks_group,aerial_tracks_group;

// Import scene-specific track for WISP sensor generated by program
// GEOREG_FSF_PANOS:

   int FSF_track_ID=0;
   track* FSF_track_ptr=ship_tracks_group.generate_new_track(FSF_track_ID);

   filefunc::ReadInfile(FSF_track_filename);
   vector<threevector> wisp_XYZ;
   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);
      double epoch_time=column_values[1];
      double easting=column_values[2];
      double northing=column_values[3];
      double altitude=column_values[4];
      threevector curr_WISP_posn(easting,northing,altitude);
      FSF_track_ptr->set_XYZ_coords(epoch_time,curr_WISP_posn);
   }

// Import aerial tracks generated by program AERIAL_TRACKS:

   vector<string> aerial_track_filenames=
      filefunc::files_in_subdir_matching_substring(
         aerial_tracks_subdir,"projected_tracks_");
   string aerial_tracks_filename=aerial_track_filenames.back();
   cout << "Input aerial tracks filename = "
        << aerial_tracks_filename << endl;
   filefunc::ReadInfile(aerial_tracks_filename);

   typedef std::map<int,std::vector<fourvector> > FEATURES_MAP;
   FEATURES_MAP* features_map_ptr=new FEATURES_MAP;
   FEATURES_MAP::iterator iter;

// independent integer = pano_ID
// Dependent STL vec of fourvectors = (track_label,panel_ID,panel_U,panel_V)

   double prev_elapsed_secs=-1;

   vector<double> elapsed_secs;   
   vector<fourvector> feature_fourvectors;
   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);

      int pano_ID=column_values[0];
      double curr_elapsed_secs=column_values[1];
      elapsed_secs.push_back(curr_elapsed_secs);

      if (prev_elapsed_secs < 0)
      {
         prev_elapsed_secs=curr_elapsed_secs;
      }
      else if (!nearly_equal(curr_elapsed_secs,prev_elapsed_secs))
      {
         (*features_map_ptr)[pano_ID]=feature_fourvectors;
         feature_fourvectors.clear();

         prev_elapsed_secs=curr_elapsed_secs;
      }
      
      int curr_track_label=column_values[2];
      double curr_easting=column_values[3];
      double curr_northing=column_values[4];
      double curr_altitude=column_values[5];
      int curr_panel_ID=column_values[8];
      double curr_panel_U=column_values[9];
      double curr_panel_V=column_values[11];

      threevector curr_aircraft_posn(curr_easting,curr_northing,curr_altitude);

      threevector curr_WISP_posn;
      FSF_track_ptr->get_interpolated_posn(curr_elapsed_secs,curr_WISP_posn);
      double curr_range=(curr_aircraft_posn-curr_WISP_posn).magnitude();

      double track_label_and_panel_ID=curr_track_label+0.1*curr_panel_ID;
      fourvector curr_fourvector(
         track_label_and_panel_ID,curr_range,curr_panel_U,curr_panel_V);

      feature_fourvectors.push_back(curr_fourvector);

   } // loop over index i labeling lines in aerial_tracks_filename

   double total_elapsed_time=elapsed_secs.back()-elapsed_secs.front();
   const double time_per_frame=2;	// secs
   int n_total_frames=total_elapsed_time/time_per_frame;
   
   cout << "total_elapsed_time = "
        << total_elapsed_time << " secs = "
        << total_elapsed_time/60 << " mins" << endl;
   cout << "n_total_frames = " << n_total_frames << endl;

   int n_video_frames=features_map_ptr->size();
   cout << "n_video_frames = " << n_video_frames << endl;
   
   int n_panels=10;
   for (int panel=0; panel<n_panels; panel++)
   {
      ofstream feature_stream;
      feature_stream.precision(10);
   
      string output_filename=aerial_tracks_subdir+"features_2D_AERIAL_"+
         stringfunc::number_to_string(panel)+".txt";
      filefunc::openfile(output_filename,feature_stream);
      feature_stream << "# Frame   Feature_ID   Passnumber   U 			 V  	   Range (kms)" << endl;
      feature_stream << endl;

      bool targets_projected_flag=false;
      int video_framenumber=0;
      for (iter=features_map_ptr->begin(); iter != features_map_ptr->end();
           iter++)
      {
         vector<fourvector> feature_fourvectors=iter->second;
         for (unsigned int feature_index=0; 
              feature_index<feature_fourvectors.size(); feature_index++)
         {
            fourvector curr_fourvector=feature_fourvectors[feature_index];

            double track_label_and_panel_ID=curr_fourvector[0];
            int curr_track_label=basic_math::mytruncate(
               track_label_and_panel_ID);
            track_label_and_panel_ID -= curr_track_label;
            int curr_panel_ID=basic_math::round(track_label_and_panel_ID*10);

            double curr_range_in_kms=0.001*curr_fourvector[1];
            double curr_panel_U=curr_fourvector[2];
            double curr_panel_V=curr_fourvector[3];

            if (curr_panel_ID != panel) continue;
         
            int video_passnumber=0;
//            double score=NEGATIVEINFINITY;

            feature_stream << video_framenumber << "\t\t"
                           << curr_track_label << "\t"
                           << video_passnumber << "\t"
                           << curr_panel_U << "\t\t"
                           << curr_panel_V << "\t"
                           << stringfunc::number_to_string(
                              curr_range_in_kms,1) << endl;
            targets_projected_flag=true;
         } // loop over feature_index
         video_framenumber++;
      }
      filefunc::closefile(output_filename,feature_stream);

// Aerial targets generally project onto only some subset of all
// panels.  So delete any feature files which do not contain
// any nontrivial information:

      if (!targets_projected_flag)
      {
         filefunc::deletefile(output_filename);
      }
      else
      {
         string banner="Exported "+output_filename;
         outputfunc::write_big_banner(banner);
      }

   } // loop over panel index
   delete features_map_ptr;

   string banner="Finished running program AERIAL_FEATURES";
   outputfunc::write_banner(banner);
   outputfunc::print_elapsed_time();
}
