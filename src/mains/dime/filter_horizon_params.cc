// =======================================================================
// Program FILTER_HORIZON_PARAMS imports sinuosoidal-fit parameters to
// panorama image plane horizons generated by program FIT_HORIZONS.  
// It first generates probability distributions for the amplitude A,
// sinusoidal phase phi, and averaged DC value v parameters over all
// frames from an FSF scene.  After computing these parameters'
// medians and quartile-widths, FILTER_HORIZON_PARAMETERS identifies
// outliers among the input values as those which lie more than 3
// quartile widths away from the median.  Outlier values are ignored
// in subsequent gaussian filtering of the inlier parameter inputs.
// Raw and filtered parameter values are plotted as functions of
// panorama frame number.  The filtered sinuosoidal parameter values
// are exported to a new text file within horizons_subdir.

//			      ./filter_horizon_params

// =======================================================================
// Last updated on 7/1/13; 7/11/13; 8/8/13; 8/12/13
// =======================================================================

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "filter/filterfuncs.h"
#include "math/mathfuncs.h"
#include "plot/metafile.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

int main( int argc, char** argv ) 
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::map;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// On Dunmeyer's Ubuntu 12.4 box:

   string date_string="05202013";
   cout << "Enter date string (e.g. 05202013 or 05222013):" << endl;
   cin >> date_string;
   filefunc::add_trailing_dir_slash(date_string);

   string DIME_subdir="/data/DIME/";
   string MayFieldtest_subdir=DIME_subdir+"panoramas/May2013_Fieldtest/";
//   string FSFdate_subdir=MayFieldtest_subdir+"05202013/";
   string FSFdate_subdir=MayFieldtest_subdir+date_string;
   cout << "FSFdate_subdir = " << FSFdate_subdir << endl;
   int scene_ID;
   cout << "Enter scene ID:" << endl;
   cin >> scene_ID;
   string scene_ID_str=stringfunc::integer_to_string(scene_ID,2);
   string panos_subdir=FSFdate_subdir+"Scene"+scene_ID_str+"/";
//   cout << "panos_subdir = " << panos_subdir << endl;
   string horizons_subdir=panos_subdir+"horizons/";

   string sinusoid_params_filename=horizons_subdir+"sinusoid_params.dat";
   cout << "sinusoid_params_filename = " 
        << sinusoid_params_filename << endl;

   vector<vector<string> > all_substrings=filefunc::ReadInSubstrings(
      sinusoid_params_filename);

   vector<double> frame_number,A,phi,v_avg;
   int n_panos=all_substrings.size();
   for (int p=0; p<n_panos; p++)
   {
      frame_number.push_back(p);
      vector<string> curr_substrings=all_substrings[p];
      A.push_back(stringfunc::string_to_number(curr_substrings[1]));
      phi.push_back(stringfunc::string_to_number(curr_substrings[2]));
      v_avg.push_back(stringfunc::string_to_number(curr_substrings[3]));
   } // loop over index p labeling panos

   prob_distribution prob_A(A,100);
   double A_median=prob_A.median();
   double A_quartile=prob_A.quartile_width();
   cout << "A = " << A_median << " +/- " << A_quartile << endl;
   int n_max_bin;
   double peak_density=prob_A.peak_density_value(n_max_bin);
   double peak_A=prob_A.get_x(n_max_bin);
   cout << "peak_density = " << peak_density 
        << " peak_A = " << peak_A << endl;
//   prob_A.writeprobdists(false);
//   outputfunc::enter_continue_char();

   prob_distribution prob_phi(phi,100);
   double phi_median=prob_phi.median();
   double phi_quartile=prob_phi.quartile_width();
   cout << "phi = " << phi_median << " +/- " << phi_quartile << endl;
   peak_density=prob_phi.peak_density_value(n_max_bin);
   double peak_phi=prob_phi.get_x(n_max_bin);
   cout << "peak_density = " << peak_density 
        << " peak_phi = " << peak_phi << endl;
//   prob_phi.writeprobdists(false);
//   outputfunc::enter_continue_char();


   prob_distribution prob_vavg(v_avg,100);
   double vavg_median=prob_vavg.median();
   double vavg_quartile=prob_vavg.quartile_width();
   cout << "vavg = " << vavg_median << " +/- " << vavg_quartile << endl;
   peak_density=prob_phi.peak_density_value(n_max_bin);
   double peak_vavg=prob_vavg.get_x(n_max_bin);
   cout << "peak_density = " << peak_density 
        << " peak_vavg = " << peak_vavg << endl;
//   prob_vavg.writeprobdists(false);

// Ignore any input A, phi or v_avg value which lies more than 3
// quartile_widths away from median values:

   vector<bool> AOK_flag,phiOK_flag,vavgOK_flag;
   for (int i=0; i<n_panos; i++)
   {
      if (fabs(A[i]-A_median) < 3*A_quartile)
      {
         AOK_flag.push_back(true);
      }
      else
      {
         AOK_flag.push_back(false);
      }

      if (fabs(phi[i]-phi_median) < 3*phi_quartile)
      {
         phiOK_flag.push_back(true);
      }
      else
      {
         phiOK_flag.push_back(false);
      }

      if (fabs(v_avg[i]-vavg_median) < 3*vavg_quartile)
      {
         vavgOK_flag.push_back(true);
      }
      else
      {
         vavgOK_flag.push_back(false);
      }
   } // loop over index i labeling panos



   double dx=1;
   double sigma=5;
   vector<double> h;
//   h.reserve(35);
   h.reserve(45);
   filterfunc::gaussian_filter(dx,sigma,h);
   
   bool wrap_around_input_values=false;
   vector<double> A_filtered,phi_filtered,vavg_filtered;
   filterfunc::brute_force_filter(
      A,AOK_flag,h,A_filtered,wrap_around_input_values);
   filterfunc::brute_force_filter(
      phi,phiOK_flag,h,phi_filtered,wrap_around_input_values);
   filterfunc::brute_force_filter(
      v_avg,vavgOK_flag,h,vavg_filtered,wrap_around_input_values);
   
   double A_min=mathfunc::minimal_value(A);
   double A_max=mathfunc::maximal_value(A);
   double delta_A=A_max-A_min;
   A_min -= 0.2*delta_A;
   A_max += 0.2*delta_A;
   A_min=0;

   string meta_filename=horizons_subdir+"A";
   string title="Amplitude vs frame number";
   string x_label="Frame number";
   string y_label="Sinusoid amplitude";
   double frame_min=0;
   double frame_max=n_panos;
   metafile meta;
   meta.set_parameters(
      meta_filename,title,x_label,y_label,frame_min,frame_max,A_min,A_max);
   meta.set_thickness(1);
   meta.openmetafile();
   meta.write_header();
   meta.write_curve(frame_number,A);
   meta.set_thickness(2);
   meta.write_curve(frame_number,A_filtered,colorfunc::blue);
   meta.closemetafile();

//   string unix_cmd="meta_to_pdf "+meta_filename;
//   sysfunc::unix_command(unix_cmd);
   string banner="Exported "+meta_filename;
   outputfunc::write_banner(banner);

   double phi_min=mathfunc::minimal_value(phi);
   double phi_max=mathfunc::maximal_value(phi);
   double delta_phi=phi_max-phi_min;
   phi_min -= 0.2*delta_phi;
   phi_max += 0.2*delta_phi;
   phi_min=0;
   phi_max=360;

   meta_filename=horizons_subdir+"phi";
   title="Phi vs frame number";
   x_label="Frame number";
   y_label="Sinusoid phase angle";
   meta.set_parameters(
      meta_filename,title,x_label,y_label,frame_min,frame_max,phi_min,phi_max);
   meta.set_thickness(1);
   meta.openmetafile();
   meta.write_header();
   meta.write_curve(frame_number,phi);
   meta.set_thickness(2);
   meta.write_curve(frame_number,phi_filtered,colorfunc::blue);
   meta.closemetafile();

//   unix_cmd="meta_to_pdf "+meta_filename;
//   sysfunc::unix_command(unix_cmd);
   banner="Exported "+meta_filename;
   outputfunc::write_banner(banner);


   double v_avg_min=mathfunc::minimal_value(v_avg);
   double v_avg_max=mathfunc::maximal_value(v_avg);
   double delta_v_avg=v_avg_max-v_avg_min;
   v_avg_min -= 0.2*delta_v_avg;
   v_avg_max += 0.2*delta_v_avg;
   v_avg_min=0;

   meta_filename=horizons_subdir+"v_avg";
   title="V_average vs frame number";
   x_label="Frame number";
   y_label="Sinusoid mean";
   meta.set_parameters(
      meta_filename,title,x_label,y_label,frame_min,frame_max,
      v_avg_min,v_avg_max);
   meta.set_thickness(1);
   meta.openmetafile();
   meta.write_header();
   meta.write_curve(frame_number,v_avg);
   meta.set_thickness(2);
   meta.write_curve(frame_number,vavg_filtered,colorfunc::blue);
   meta.closemetafile();

//   unix_cmd="meta_to_pdf "+meta_filename;
//   sysfunc::unix_command(unix_cmd);
   banner="Exported "+meta_filename;
   outputfunc::write_banner(banner);

// Export filtered amplitude, sinusoidal phase and averaged DC value to
// output text file:

   string filtered_sinusoid_params_filename=horizons_subdir+
      "filtered_sinusoid_params.dat";
   ofstream filtered_stream;
   filefunc::openfile(filtered_sinusoid_params_filename,filtered_stream);
   
   filtered_stream << "# image_basename       A       phi       v_avg       max_score" << endl;
   filtered_stream << endl;

   for (int p=0; p<n_panos; p++)
   {
      vector<string> curr_substrings=all_substrings[p];
      filtered_stream << curr_substrings[0] << "  ";
      filtered_stream << A_filtered[p] << "  ";
      filtered_stream << phi_filtered[p] << "  ";
      filtered_stream << vavg_filtered[p] << "  ";
      filtered_stream << curr_substrings[4] << endl;
   } // loop over index p labeling panos
   
   filefunc::closefile(filtered_sinusoid_params_filename,filtered_stream);
   banner="Exported filtered horizon parameters to "+
      filtered_sinusoid_params_filename;
   outputfunc::write_banner(banner);

   banner="Finished running program FILTER_HORIZON_PARAMS";
   outputfunc::write_big_banner(banner);
}
