// ==========================================================================
// Program EXTRACT_INLIERS imports F & D genvector descriptors for
// SIFT, Hessian-Affine, corner, etc features from HDF5 binary files
// for two images generated by program CONSOLIDATE.  It then performs
// tiepoint matching using Lowe's ratio test.  A *coarse* estimate for
// the fundamental matrix is derived via RANSAC with tiepoint pairs
// required to approximately satisfy XY^T * F * UV = 0. 
// EXTRACT_INLIERS builds FLANN library nearest neighbor indices.
// After performing ~1000 RANSAC iterations, this program generates
// its best fundamental matrix estimate.  EXTRACT_INLIERS exports 
// inlier tiepoint pairs to a pair of feature text files.
// ==========================================================================
// Last updated on 4/7/12; 4/9/12; 4/10/12; 4/11/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <lmcurve.h>
#include "general/filefuncs.h"
#include "structmotion/fundamental.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "geometry/plane.h"
#include "math/quaternion.h"
#include "video/sift_detector.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ios;
using std::ofstream;
using std::ostream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);

   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group);
   int n_photos=photogroup_ptr->get_n_photos();

//   bool FLANN_flag=false;
   bool FLANN_flag=true;
   sift_detector SIFT(photogroup_ptr,FLANN_flag);

   SIFT.import_consolidated_features(bundler_IO_subdir);

// For FLIR video images, do not accept SIFT features at very
// top/bottom of image nor too far to the left:

//   SIFT.set_min_allowed_V(0.136);
//   SIFT.set_max_allowed_V(0.878);
   
   string sift_keys_subdir="./";
//   SIFT.extract_SIFT_features(sift_keys_subdir);

// As of late 2011, we believe the following parameters are reasonable
// for fundamental matrix tiepoint matching on generic image pairs:

   const int n_min_quadrant_features=1;		
//   const int n_min_quadrant_features=2;

//   const double sqrd_max_ratio=sqr(0.6);	
//   const double sqrd_max_ratio=sqr(0.675);
   double max_ratio=0.65;
   cout << "Enter Lowe ratio threshold:" << endl;
   cout << "(Default value = 0.65)" << endl;
   cin >> max_ratio;
   double sqrd_max_ratio=sqr(max_ratio);

   double worst_frac_to_reject=0;

   double max_scalar_product=0.01;
//   double max_scalar_product=0.001;
   cout << "Enter max value for fundamental matrix scalar product:" << endl;
   cout << "(Default value = 0.01)" << endl;
//   cout << "(Default value = 0.001)" << endl;
   cin >> max_scalar_product;

// SIFT tiepoint inlier identification becomes LESS stringent as
// max_sqrd_delta increases.

//   const int n_min_quadrant_features=1;		// marriott example
//   const double sqrd_max_ratio=sqr(0.9);	// marriott example
//   const double worst_frac_to_reject=0.001;
//   const double max_sqrd_delta=sqr(0.2);

   SIFT.identify_candidate_feature_matches_via_fundamental_matrix(
      n_min_quadrant_features,sqrd_max_ratio,worst_frac_to_reject,
      max_scalar_product);

   fundamental* fundamental_ptr=SIFT.get_fundamental_ptr();
   genmatrix* F_ptr=fundamental_ptr->get_F_ptr();

   cout.precision(12);
   cout << "*fundamental_ptr = " << *fundamental_ptr << endl;
   cout << "fundamental rank = " << F_ptr->rank() << endl;
   cout << "Det(F) = " << F_ptr->determinant() << endl;
   
   cout << "eprime epipole = " << fundamental_ptr->get_epipole_XY()
        << endl;
   cout << "e epipole = " << fundamental_ptr->get_epipole_UV()
        << endl;

   cout << endl;
   for (int r=0; r<3; r++)
   {
      for (int c=0; c<3; c++)
      {
         cout << "F_ptr->put(" << r << "," << c << ","
              << F_ptr->get(r,c) << ");" << endl;
      }
   }
   cout << endl;
}

   
