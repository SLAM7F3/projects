// ==========================================================================
// Program AFFINE_OUTLIERS reads in a pair of matched feature files
// generated by program EXTRACT_INLIERS.  It translates the
// XY and UV tiepoints so that they have zero-valued COMS.
// The tiepoints are then rotated and rescaled so that their 2x2
// covariance matrices equal the identity.  AFFINE_OUTLIERS computes
// the median and quartile widths for |X-U| and |Y-V|.  It then
// compares d_XU=|X-U| and d_YV=|Y-V| for each tiepoint pair against
// the median and quartile widths.  Any tiepoint pair whose d_XU or
// d_YV values lie significantly above the median are declared to be
// affine outliers.  This program exports a new set of feature files
// from which the affine outlier tiepoint pairs are excluded.
// ==========================================================================
// Last updated on 4/8/12; 4/9/12; 4/10/12
// ==========================================================================

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <lmcurve.h>
#include <levmar.h>

#include "general/filefuncs.h"
#include "structmotion/fundamental.h"
#include "math/mathfuncs.h"
#include "templates/mytemplates.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "general/sysfuncs.h"
#include "numrec/nrfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::ostream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);

   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   photogroup_ptr->read_photographs(passes_group);
   int n_photos=photogroup_ptr->get_n_photos();

   string features_subdir="./features/";
   vector<string> feature_filenames,new_feature_filenames;
   for (int n=0; n<n_photos; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      string photo_filename=photo_ptr->get_filename();
      string basename=filefunc::getbasename(photo_filename);
      basename=stringfunc::prefix(basename);
      feature_filenames.push_back(
         features_subdir+"features_2D_"+basename+".txt");
      new_feature_filenames.push_back(
         features_subdir+"new_features_2D_"+basename+".txt");
      cout << "n = " << n 
           << " features_filename = " << feature_filenames.back() << endl;
   }

/*
//   string features1_filename=features_subdir+"features_2D_kermit000.txt";
//   string features2_filename=features_subdir+"features_2D_kermit002.txt";

//   string features1_filename=features_subdir+"features_2D_ts.txt";
//   string features2_filename=features_subdir+"features_2D_tower_pushcart.txt";

   string features1_filename=features_subdir+"features_2D_herb2.txt";
   string features2_filename=features_subdir+"features_2D_herb3.txt";

//   string features1_filename=features_subdir+"features_2D_herb1.txt";
//   string features2_filename=features_subdir+"features_2D_tower_pushcart.txt";

//   string features1_filename=features_subdir+"features_2D_herb1.txt";
//   string features2_filename=features_subdir+"features_2D_herb3.txt";

//   string features1_filename=features_subdir+"features_2D_tower3.txt";
//   string features2_filename=features_subdir+"features_2D_tower_pushcart.txt";

//   string features1_filename=features_subdir+"features_2D_redbldg1.txt";
//   string features2_filename=features_subdir+"features_2D_redbldg2.txt";

//   string features1_filename=features_subdir+"features_2D_ts.txt";
//   string features2_filename=features_subdir+"features_2D_tower_pushcart.txt";
*/

   vector<int> features_ID,features_copy_ID;
   vector<genvector*> inlier_XY_ptrs,inlier_UV_ptrs;

   filefunc::ReadInfile(feature_filenames[0]);
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);
      
      features_ID.push_back(column_values[1]);
      genvector* XY_ptr=new genvector(2);
      XY_ptr->put(0,column_values[3]);
      XY_ptr->put(1,column_values[4]);
      inlier_XY_ptrs.push_back(XY_ptr);
      cout << "ID = " << features_ID.back()
           << " X = " << XY_ptr->get(0)
           << " Y = " << XY_ptr->get(1) << endl;
   }

   filefunc::ReadInfile(feature_filenames[1]);
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);

      features_copy_ID.push_back(column_values[1]);
      genvector* UV_ptr=new genvector(2);
      UV_ptr->put(0,column_values[3]);
      UV_ptr->put(1,column_values[4]);
      inlier_UV_ptrs.push_back(UV_ptr);
      cout << "ID = " << features_copy_ID.back()
           << " U = " << UV_ptr->get(0)
           << " V = " << UV_ptr->get(1) << endl;
   }
 
   genvector* mu_XY_ptr=mathfunc::mean(inlier_XY_ptrs);
   genvector* mu_UV_ptr=mathfunc::mean(inlier_UV_ptrs);

   cout << "mu_XY = " << *mu_XY_ptr << endl;
   cout << "mu_UV = " << *mu_UV_ptr << endl;
   
   genmatrix* XY_covar_ptr=mathfunc::covariance_matrix(inlier_XY_ptrs);
   genmatrix* UV_covar_ptr=mathfunc::covariance_matrix(inlier_UV_ptrs);

   cout << "XY_covar = " << *XY_covar_ptr << endl;
   cout << "UV_covar = " << *UV_covar_ptr << endl;
   
   genmatrix D_xy(2,2),R_xy(2,2);
   XY_covar_ptr->sym_eigen_decomposition(D_xy,R_xy);

   genmatrix D_uv(2,2),R_uv(2,2);
   UV_covar_ptr->sym_eigen_decomposition(D_uv,R_uv);

   cout << "R_xy * D_xy * R_xy^T = "
        << R_xy * D_xy * R_xy.transpose() << endl;

   cout << "R_uv * D_uv * R_uv^T = "
        << R_uv * D_uv * R_uv.transpose() << endl;

   genmatrix Dinv_sqrt_xy(2,2),Dinv_sqrt_uv(2,2);
   Dinv_sqrt_xy.clear_values();
   Dinv_sqrt_uv.clear_values();
   Dinv_sqrt_xy.put(0,0,1.0/sqrt(D_xy.get(0,0)));
   Dinv_sqrt_xy.put(1,1,1.0/sqrt(D_xy.get(1,1)));
   Dinv_sqrt_uv.put(0,0,1.0/sqrt(D_uv.get(0,0)));
   Dinv_sqrt_uv.put(1,1,1.0/sqrt(D_uv.get(1,1)));

   cout << "D_xy = " << D_xy << endl;
   cout << "D_uv = " << D_uv << endl;

// Translate XY and UV so that their mean lies at (0,0):

   int n_inliers=inlier_XY_ptrs.size();
   for (int n=0; n<n_inliers; n++)
   {
      twovector XY=*(inlier_XY_ptrs[n]);
      XY -= *mu_XY_ptr;
      XY = R_xy.transpose() * XY;
      XY = Dinv_sqrt_xy * XY;
      *(inlier_XY_ptrs[n]) = XY;

      twovector UV=*(inlier_UV_ptrs[n]);
      UV -= *mu_UV_ptr;
      UV = R_uv.transpose() * UV;
      UV = Dinv_sqrt_uv * UV;
      *(inlier_UV_ptrs[n]) = UV;
   } // loop over index n labeling tiepoints
   

// Recompute means and covariance matrices:

   mu_XY_ptr=mathfunc::mean(inlier_XY_ptrs);
   mu_UV_ptr=mathfunc::mean(inlier_UV_ptrs);

   cout << "New mu_XY = " << *mu_XY_ptr << endl;
   cout << "New mu_UV = " << *mu_UV_ptr << endl;
   
   XY_covar_ptr=mathfunc::covariance_matrix(inlier_XY_ptrs);
   UV_covar_ptr=mathfunc::covariance_matrix(inlier_UV_ptrs);

   cout << "New XY_covar = " << *XY_covar_ptr << endl;
   cout << "New UV_covar = " << *UV_covar_ptr << endl;

   int n_affine_inliers=0;
   vector<double> d_xu,d_yv;
   for (int n=0; n<n_inliers; n++)
   {
      twovector XY=*(inlier_XY_ptrs[n]);
      twovector UV=*(inlier_UV_ptrs[n]);

      double x=XY.get(0);
      double y=XY.get(1);

      double u=UV.get(0);
      double v=UV.get(1);
      
      double max_delta=0.2;
      d_xu.push_back(fabs(x-u));
      d_yv.push_back(fabs(y-v));
      
      if (fabs(x-u) > max_delta || fabs(y-v) > max_delta) continue;

      n_affine_inliers++;
      cout << "n = " << n
           << " x = " << XY.get(0)
           << " u = " << UV.get(0)

           << "   y = " << XY.get(1)
           << " v = " << UV.get(1)
           << endl;
   }

   templatefunc::Quicksort(d_xu,features_ID);
   templatefunc::Quicksort(d_yv,features_copy_ID);

   cout << "n_affine_inliers = " << n_affine_inliers << endl;
   cout << "mean(d_xu) = " << mathfunc::mean(d_xu) << endl;
   cout << "mean(d_yv) = " << mathfunc::mean(d_yv) << endl;

   double median_xu,median_yv;
   double quartile_xu,quartile_yv;
   mathfunc::median_value_and_quartile_width(
      d_xu,median_xu,quartile_xu);
   mathfunc::median_value_and_quartile_width(
      d_yv,median_yv,quartile_yv);
   cout << "median(d_xu) = " << median_xu
        << " quartile width(d_xu) = " << quartile_xu << endl;
   cout << "median(d_yv) = " << median_yv
        << " quartile width(d_yv) = " << quartile_yv << endl;

   typedef map<int,int> OUTLIERS_MAP;
   OUTLIERS_MAP* outliers_map_ptr=new OUTLIERS_MAP;
   
   const double max_ratio=2;
//   const double max_ratio=4;

   for (int n=0; n<d_xu.size(); n++)
   {
      double ratio=fabs(d_xu[n]-median_xu)/quartile_xu;
      cout << "n = " << n << " d_xu = " << d_xu[n] 
           << " feature ID = " << features_ID[n]
           << " ratio = " << ratio;
      if (ratio > max_ratio) 
      {
         cout << "  *** Likely outlier! ***";
         (*outliers_map_ptr)[features_ID[n]]=1;
      }
      cout << endl;
   }
   cout << endl;

   for (int n=0; n<d_yv.size(); n++)
   {
      double ratio=fabs(d_yv[n]-median_yv)/quartile_yv;
      cout << "n = " << n << " d_yv = " << d_yv[n] 
           << " feature ID = " << features_copy_ID[n]
           << " ratio = " << ratio;
      if (ratio > max_ratio) 
      {
         cout << "  *** Likely outlier! ***";
         (*outliers_map_ptr)[features_copy_ID[n]]=1;
      }
      cout << endl;
   }
   
// Export new version of features sans outliers identified via affine
// transformation:

   ofstream outstream;
   for (int n=0; n<feature_filenames.size(); n++)
   {
      filefunc::openfile(new_feature_filenames[n],outstream);
      outstream << "# time feature-ID image-ID U V Freq" << endl;
      outstream << endl;

      filefunc::ReadInfile(feature_filenames[n]);
      for (int i=0; i<filefunc::text_line.size(); i++)
      {
         vector<double> column_values=stringfunc::string_to_numbers(
            filefunc::text_line[i]);
         int curr_feature_ID=column_values[1];
         OUTLIERS_MAP::iterator iter=outliers_map_ptr->find(curr_feature_ID);
         if (iter != outliers_map_ptr->end()) continue;
         outstream << filefunc::text_line[i] << endl;
      }
      filefunc::closefile(new_feature_filenames[n],outstream);
   } // loop over index n labeling feature files

   string banner="New feature files without outliers exported to "
      +new_feature_filenames[0]+" and "+new_feature_filenames[1];
   outputfunc::write_big_banner(banner);

   delete outliers_map_ptr;
}

   
