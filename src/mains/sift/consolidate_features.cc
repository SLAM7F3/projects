// ==========================================================================
// Program CONSOLIDATE_FEATURES imports ascii SIFT, Hessian-affine &
// Edge-laplacian key files generated by EXTRACT_SIFT_FEATURES and
// EXTRACT_DESCRIPTORS.  It ignores any hessian_affine feature
// whose pixel location lies too close to some existing SIFT feature.
// A consolidated set of "F" and "D" descriptors is subsequently
// written to hdf5 binary format files for each image.
// ==========================================================================
// Last updated on 12/3/12; 5/24/13; 5/31/13; 6/17/14
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <flann/flann.hpp>
#include <flann/io/hdf5.h>

#include "cluster/akm.h"
#include "datastructures/descriptor.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "video/sift_detector.h"
#include "general/sysfuncs.h"
#include "image/TwoDarray.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   string image_sizes_filename=passes_group.get_image_sizes_filename();
   string sift_keys_subdir=bundler_IO_subdir+"images/keys/";
//   cout << "sift_keys_subdir = " << sift_keys_subdir << endl;

// Read photographs from input video passes:

   photogroup* photogroup_ptr=new photogroup;
   int n_photos_to_reconstruct=-1;
   photogroup_ptr->generate_bundler_photographs(
      bundler_IO_subdir,image_list_filename,image_sizes_filename,
      n_photos_to_reconstruct);

   bool FLANN_flag=true;
   sift_detector* sift_detector_ptr=new sift_detector(NULL,FLANN_flag);

   vector<string> sift_keys_filenames=sift_detector_ptr->
      import_sift_keys_filenames(sift_keys_subdir);

   int i_start=0;
   int i_stop=sift_keys_filenames.size();
   for (int i=i_start; i<i_stop; i++)
   {
      photograph* photograph_ptr=photogroup_ptr->get_photograph_ptr(i);

      string sift_keys_filename=sift_keys_filenames[i];
      cout << "sift_keys_filename = " << sift_keys_filename << endl;
      string basename=filefunc::getbasename(sift_keys_filename);
      basename=stringfunc::prefix(basename);
//      cout << "basename = " << basename << endl;

      string hesaff_keys_filename=sift_keys_subdir+basename+".hesaff";
//      cout << "hesaff_keys_filename = " << hesaff_keys_filename << endl;
      string sedgelap_keys_filename=sift_keys_subdir+basename+".sedgelap";
//      cout << "sedgelap_keys_filename = " << sedgelap_keys_filename << endl;

      string image_filename=bundler_IO_subdir+"images/"+basename+".jpg";
//      cout << "image_filename = " << image_filename << endl;

      cout << "i = " << i << " i_stop = " << i_stop
           << " Processing " << image_filename << endl;

      unsigned int width,height;
      imagefunc::get_image_width_height(image_filename,width,height);
//      cout << "width = " << width << " height = " << height << endl;

      twoDarray* ztwoDarray_ptr=new twoDarray(width,height);
      ztwoDarray_ptr->clear_values();
      double max_U=double(width)/double(height);
      ztwoDarray_ptr->init_coord_system(0,max_U,0,1);

      bool Lowe_SIFT_flag=true;
      vector<sift_detector::feature_pair> currimage_sift_info;         
      sift_detector_ptr->parse_Lowe_features(
         Lowe_SIFT_flag,photograph_ptr->get_xdim(),
         photograph_ptr->get_ydim(),
         sift_keys_filename,currimage_sift_info);

// First import conventional SIFT descriptors:

      int feature_ID=0;
      for (int f=0; f<currimage_sift_info.size(); f++)
      {
         descriptor* F_ptr=currimage_sift_info[f].first;
         double U=F_ptr->get(1);
         double V=F_ptr->get(2);
         unsigned int pu,pv;
         ztwoDarray_ptr->point_to_pixel(U,V,pu,pv);
         ztwoDarray_ptr->put(pu,pv,feature_ID);
         feature_ID++;
      } // loop over index f labeling sift features

// Mark pixel locations which are described by SIFT features:

      int z_integral=0;
      for (int pu=0; pu<width; pu++)
      {
         for (int pv=0; pv<height; pv++)
         {
            if (ztwoDarray_ptr->get(pu,pv) > 0) z_integral++;
         }
      }
//      cout << "z_integral = " << z_integral << endl;
//      cout << "currimage_sift_info.size() = "
//           << currimage_sift_info.size() << endl;

/*
// Next import hessian-affine descriptors.  Ignore any which lie too
// close to existing SIFT descriptor pixel locations:

      vector<sift_detector::feature_pair> currimage_hesaff_info;         
      sift_detector_ptr->parse_detector_descriptor_features(
         photograph_ptr,hesaff_keys_filename,currimage_hesaff_info);
//      cout << "currimage_hesaff_info.size() = "
//           << currimage_hesaff_info.size() << endl;

      for (int f=0; f<currimage_hesaff_info.size(); f++)
      {
         descriptor* F_ptr=currimage_hesaff_info[f].first;
         double U=F_ptr->get(1);
         double V=F_ptr->get(2);
         unsigned int pu,pv;
         ztwoDarray_ptr->point_to_pixel(U,V,pu,pv);
         if (ztwoDarray_ptr->get(pu,pv) > 0) continue;
         F_ptr->put(0,feature_ID);
         feature_ID++;
         currimage_sift_info.push_back(currimage_hesaff_info[f]);
      } // loop over index f labeling sift features

//      cout << "currimage_sift_info.size() = "
//           << currimage_sift_info.size() << endl;
//      cout << "feature_ID = " << feature_ID << endl;

// Import sedgelap descriptors.  Ignore any which lie too close to
// existing descriptor pixel locations:

      vector<sift_detector::feature_pair> currimage_sedgelap_info;         
      sift_detector_ptr->parse_detector_descriptor_features(
         photograph_ptr,sedgelap_keys_filename,currimage_sedgelap_info);
//      cout << "currimage_sedgelap_info.size() = "
//           << currimage_sedgelap_info.size() << endl;

      for (int f=0; f<currimage_sedgelap_info.size(); f++)
      {
         descriptor* F_ptr=currimage_sedgelap_info[f].first;
         double U=F_ptr->get(1);
         double V=F_ptr->get(2);
         unsigned int pu,pv;
         ztwoDarray_ptr->point_to_pixel(U,V,pu,pv);
         if (ztwoDarray_ptr->get(pu,pv) > 0) continue;
         F_ptr->put(0,feature_ID);
         feature_ID++;
         currimage_sift_info.push_back(currimage_sedgelap_info[f]);
      } // loop over index f labeling sift features

//      cout << "currimage_sift_info.size() = "
//           << currimage_sift_info.size() << endl;
//      cout << "feature_ID = " << feature_ID << endl;
*/

      vector<descriptor*>* F_ptrs_ptr=new vector<descriptor*>;
      vector<descriptor*>* D_ptrs_ptr=new vector<descriptor*>;
      for (int f=0; f<currimage_sift_info.size(); f++)
      {
         F_ptrs_ptr->push_back(currimage_sift_info[f].first);
         D_ptrs_ptr->push_back(currimage_sift_info[f].second);
      } // loop over index f labeling SIFT features

      string output_file_prefix="F_";
      sift_detector_ptr->get_akm_ptr()->export_SIFT_features_in_HDF5_format(
         sift_keys_filename,sift_keys_subdir,output_file_prefix,F_ptrs_ptr);

      output_file_prefix="D_";
      sift_detector_ptr->get_akm_ptr()->export_SIFT_features_in_HDF5_format(
         sift_keys_filename,sift_keys_subdir,output_file_prefix,D_ptrs_ptr);
      
// Destroy all previously instantiated descriptors:

      for (int j=0; j<currimage_sift_info.size(); j++)
      {
         delete currimage_sift_info[j].first;
         delete currimage_sift_info[j].second;
      }

      delete F_ptrs_ptr;
      delete D_ptrs_ptr;
      delete ztwoDarray_ptr;

   } // loop over index i labeling photos


}
