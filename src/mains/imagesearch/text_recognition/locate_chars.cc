// ==========================================================================
// Program LOCATE_CHARS imports the probabilistic classifier
// function computed with a gaussian kernel exported by
// program SVM_SHAPE.  It also imports the probabilistic classified
// function computed with a linear kernel exported by program TEXT.  
// LOCATE_CHARS first computes connected components within
// binary thresholded versions of an input image for thresholds
// ranging from 255 down to 0.  Following Neumann and Matas,
// "Real-time scene text localization and recognition", CVPR 2012, we
// compute aspect_ratio, compactness, n_holes and median horizontal
// crossings for each candidate extremal region.  These features are
// mapped into a probability that the candidate extremal region
// corresponds to a text character.

// Coates-Ng text localization is subsequently performed within
// bounding boxes nominated via the extremal region shape procedure.  

// Finally, bounding boxes are placed around detected text characters.
// A composite displaying the locations
// of all candidate text bounding boxes is exported as a jpeg image.

//				locate_chars

// ==========================================================================
// Last updated on 9/5/12; 9/10/12; 12/17/13; 11/11/15
// ==========================================================================

#include  <fstream>
#include  <iostream>
#include  <map>
#include  <string>
#include  <vector>
#include "dlib/svm.h"

#include "image/binaryimagefuncs.h"
#include "image/compositefuncs.h"
#include "video/connected_components.h"
#include "image/connectfuncs.h"
#include "general/filefuncs.h"
#include "image/graphicsfuncs.h"
#include "image/imagefuncs.h"
#include "numrec/nrfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "classification/text_detector.h"
#include "video/texture_rectangle.h"
#include "math/threevector.h"
#include "time/timefuncs.h"
#include "video/videofuncs.h"

#include "datastructures/Quadruple.h"
#include "math/ltquadruple.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::string;
using std::vector;

using namespace dlib;

int main(int argc, char* argv[])
{
   cout.precision(12);

// The svm functions use column vectors to contain a lot of the
// data on which they operate. So the first thing we do here is
// declare a convenient typedef.

// This typedef declares a matrix with K rows and 1 column.  It will
// be the object that contains each of our K dimensional samples. 

//   const int K_shapes=4;
//   const int K_shapes=7;
   const int K_shapes=11;
//   const int K_shapes=10;
   typedef matrix<double, K_shapes, 1> shapes_sample_type;
   shapes_sample_type shapes_sample;

// This is a typedef for the type of kernel we are going to use in
// this example.  In this case I have selected the gaussian kernel that
// can operate on our K-dim shapes_sample_type objects

   typedef radial_basis_kernel<shapes_sample_type> shapes_kernel_type;

// Another thing that is worth knowing is that just about everything
// in dlib is serializable. So for example, you can save the
// learned_pfunct object to disk and recall it later like so:

   typedef decision_function<shapes_kernel_type> shapes_dec_funct_type;
   typedef normalized_function<shapes_dec_funct_type> shapes_funct_type;
   shapes_funct_type shapes_funct;

   string projects_rootdir = getenv("PROJECTSROOT");
   string home_subdir=projects_rootdir+
      "/src/mains/imagesearch/text_recognition/";

   string learned_funcs_subdir=home_subdir+"learned_functions/";
   string shapes_binary_filename=learned_funcs_subdir+
      "shapes_bifunc_15938_10824_11features.dat";            
//      "shapes_bifunc_6408_5165_11features.dat";
//      "shapes_bifunc_6408_5165_7features.dat";
//      "shapes_bifunc_6408_5165.dat";
//      "shapes_bifunc_1143_3568.dat";
//      "shapes_bifunc_1555_3131.dat";
   cout << "shapes_binary_filename = " << shapes_binary_filename << endl;
   ifstream fin1(shapes_binary_filename.c_str(),ios::binary);
   deserialize(shapes_funct, fin1);

   typedef probabilistic_decision_function<shapes_kernel_type> 
      shapes_probabilistic_funct_type;  
   typedef normalized_function<shapes_probabilistic_funct_type> 
      shapes_pfunct_type;
   std::vector<shapes_pfunct_type*> shapes_pfuncts_ptrs;

// Import probabilistic decision function generated by SVM_SHAPE:

   string shapes_pfunct_filename=learned_funcs_subdir+
      "shapes_pfunct_15938_10824_11features.dat";		// text
//      "shapes_pfunct_6408_5165_11features.dat";
//      "shapes_pfunct_6408_5165_7features.dat";
//      "shapes_pfunct_6408_5165.dat";
//      "shapes_pfunct_1143_3568.dat";
//      "shapes_pfunct_1555_3131.dat";
   cout << "shapes_pfunct_filename = " << shapes_pfunct_filename << endl;
   ifstream fin2(shapes_pfunct_filename.c_str(),ios::binary);
   
   shapes_pfunct_type* shapes_pfunct_ptr=new shapes_pfunct_type;
   deserialize(*shapes_pfunct_ptr,fin2);
   shapes_pfuncts_ptrs.push_back(shapes_pfunct_ptr);

/*
// Import binary and probabilistic decision functions trained on text
// and non-text randomness features:

   const int K_random=1;
//   const int K_random=6;
   typedef matrix<double, K_random, 1> random_sample_type;
   random_sample_type random_sample;

// This is a typedef for the type of kernel we are going to use in
// this example.  In this case I have selected the gaussian kernel that
// can operate on our K-dim shapes_sample_type objects

   typedef radial_basis_kernel<random_sample_type> random_kernel_type;

// Another thing that is worth knowing is that just about everything
// in dlib is serializable. So for example, you can save the
// learned_pfunct object to disk and recall it later like so:

   typedef decision_function<random_kernel_type> random_dec_funct_type;
   typedef normalized_function<random_dec_funct_type> random_funct_type;
   random_funct_type random_funct;

   string random_binary_filename=learned_funcs_subdir+
      "randomness_bifunc_2524_1640.dat";
   cout << "random_binary_filename = " << random_binary_filename << endl;
   ifstream fin3(random_binary_filename.c_str(),ios::binary);
   deserialize(random_funct, fin3);

   typedef probabilistic_decision_function<random_kernel_type> 
      random_probabilistic_funct_type;  
   typedef normalized_function<random_probabilistic_funct_type> 
      random_pfunct_type;
   random_pfunct_type random_pfunct;

   string random_pfunct_filename=learned_funcs_subdir+
      "randomness_pfunct_2524_1640.dat";
   cout << "random_pfunct_filename = " << random_binary_filename << endl;
   ifstream fin4(random_pfunct_filename.c_str(),ios::binary);
   deserialize(random_pfunct, fin4);
*/

// Import binary and probabilistic decision functions generated by an
// SVM with a linear kernel on 50K text char and non-char images:

   const int K_Ng=1024;
   const int nineK=9*K_Ng;
   typedef matrix<double, nineK, 1> Ng_sample_type;
   typedef linear_kernel<Ng_sample_type> Ng_kernel_type;
   Ng_sample_type Ng_sample;

   typedef decision_function<Ng_kernel_type> Ng_dec_funct_type;
   typedef normalized_function<Ng_dec_funct_type> Ng_funct_type;
   Ng_funct_type Ng_funct;

   typedef probabilistic_decision_function<Ng_kernel_type> 
      Ng_probabilistic_funct_type;  
   typedef normalized_function<Ng_probabilistic_funct_type> 
      Ng_pfunct_type;
   Ng_pfunct_type Ng_pfunct;

   string learned_Ng_pfunct_filename=learned_funcs_subdir+
      "text_Ng_pfunct_51404_51404.dat";
//      "Ng_pfunct_50K.dat";
//      "Ng_pfunct_19871.dat";
   cout << "learned_Ng_pfunct_filename = "
        << learned_Ng_pfunct_filename << endl;
   ifstream fin6(learned_Ng_pfunct_filename.c_str(),ios::binary);
   deserialize(Ng_pfunct, fin6);
 
   double Ng_char_threshold=0.9;
   cout << "Enter Ng char threshold:" << endl;
   cin >> Ng_char_threshold;

// Import dictionary trained on 50K text and non-text images:

   bool RGB_pixels_flag=false;
   string dictionary_subdir=home_subdir+"training_data/dictionary/";
   text_detector* text_detector_ptr=new text_detector(
      dictionary_subdir,RGB_pixels_flag);
   text_detector_ptr->import_inverse_sqrt_covar_matrix();
   texture_rectangle* texture_rectangle_ptr=text_detector_ptr->
      get_texture_rectangle_ptr();

// ----------------------------------------------------------------------
// Sample images hardwired for testing and development purposes:   

   cout << "0: light C against dark background" << endl;
   cout << "1: light FAVOURITE against dark background" << endl;
   cout << "2: light WWW against dark background" << endl;
   cout << "3: light library against dark background" << endl;
   cout << "4: light library against dark background" << endl;
   cout << "5: light open against dark background" << endl;
   cout << "6: light ROGERS against red background" << endl;
   cout << "7: kermit000" << endl;
   cout << "8: Whole foods interior" << endl;
   cout << "9: Pork store front" << endl;
   cout << "10: Garden Room awning" << endl;
   cout << "11: GREGGS store window" << endl;
   cout << "12: Street signs" << endl;
   cout << "13: Main Street sign" << endl;
   cout << "14: Do Not Block sign" << endl;
   cout << "15: Dilemma Cafe" << endl;
   cout << "16: News hour frame" << endl;
   cout << "17: Many signs" << endl;
   cout << "18: Cropped stop sign" << endl;
   cout << "19: Pork store sign" << endl;
   cout << "20: simulated image" << endl;
   cout << "21: Enter image filename from curr subdir" << endl;

   int image_number=1;
//   int image_number=21;
   cout << "Enter image number:" << endl;
   cin >> image_number;

   string image_subdir;
   if (image_number==0)
   {
      image_subdir=home_subdir+
         "training_data/char_intensity/bright_chars_dark_background/";
   }
   else if (image_number >= 1 && image_number <= 5)
   {
      image_subdir=home_subdir+"training_data/icdar03/words/test/2/";
   }
   else if (image_number >=6 && image_number <= 6)
   {
      image_subdir=home_subdir+
         "training_data/icdar03/words/test/3/";
   }
   else if (image_number >= 7 && image_number <= 7)
   {
      image_subdir="/data/ImageEngine/kermit/";
   }
   else if (image_number >=8 && image_number <= 11)
   {
      image_subdir=home_subdir+"training_data/stores/";
   }
   else if (image_number >=12 && image_number <= 14)
   {
      image_subdir=home_subdir+"training_data/street_signs/";
   }
   else if (image_number >=15 && image_number <= 15)
   {
      image_subdir=home_subdir+"training_data/text_database/";
   }
   else if (image_number >=16 && image_number <= 16)
   {
      image_subdir=home_subdir+"training_data/NewsWrap/";
   }
   else if (image_number >=17 && image_number <= 18)
   {
      image_subdir=home_subdir+"training_data/street_signs/";
   }
   else if (image_number >=19 && image_number <= 19)
   {
      image_subdir=home_subdir+"training_data/stores/";
   }
   else if (image_number >=20 && image_number <= 21)
   {
      image_subdir="./";
   }
   
   string image_filename;
   if (image_number==0)
   {
      image_filename=image_subdir+"00285.jpg"; // light C/dark bkgnd
   }
   else if (image_number==1)
   {
      image_filename=image_subdir+"120.jpg"; // light FAVOURITE/dark bkgnd
   }
   else if (image_number==2)
   {
      image_filename=image_subdir+"122.jpg"; // light www on dark bkgnd
   }
   else if (image_number==3)
   {
      image_filename=image_subdir+"152.jpg"; // light library on dark bkgnd
   }
   else if (image_number==4)
   {
      image_filename=image_subdir+"157.jpg"; // light library on dark bkgnd
   }
   else if (image_number==5)
   {
      image_filename=image_subdir+"158.jpg"; // light open on dark bkgnd
   }
   else if (image_number==6)
   {
      image_filename=image_subdir+"227.jpg"; // 
   }
   else if (image_number==7)
   {
      image_filename=image_subdir+"kermit000.jpg"; // 
   }
   else if (image_number==8)
   {
      image_filename=image_subdir+"produce.jpg";
   }
   else if (image_number==9)
   {
      image_filename=image_subdir+"pork_store.jpg";
   }
   else if (image_number==10)
   {
      image_filename=image_subdir+"garden_room.jpg";
   }
   else if (image_number==11)
   {
      image_filename=image_subdir+"reduced_greggs.jpg";
   }
   else if (image_number==12)
   {
      image_filename=image_subdir+"P6180940.JPG";
   }
   else if (image_number==13)
   {
      image_filename=image_subdir+"MainStreet.jpg";
   }
   else if (image_number==14)
   {
      image_filename=image_subdir+"DoNotBlock.jpg";
   }
   else if (image_number==15)
   {
      image_filename=image_subdir+"reduced_text_img0251.png";
   }
   else if (image_number==16)
   {
      image_filename=image_subdir+"frame-0011.jpg";
   }
   else if (image_number==17)
   {
      image_filename=image_subdir+"000_0360.jpg";
   }
   else if (image_number==18)
   {
      image_filename=image_subdir+"stop_sign.jpg";
   }
   else if (image_number==19)
   {
      image_filename=image_subdir+"pork_store_sign.jpg";
   }
   else if (image_number==20)
   {
      image_filename=image_subdir+"./sim_image.jpg";
   }
   else if (image_number==21)
   {
      cout << "Enter image filename from current subdirectory:" << endl;
      cin >> image_filename;
      image_filename=image_subdir+image_filename;
   }

// On 9/3/12, we experimented with calling ImageMagick to reduce
// number of input image colors.  To our great surprise, we found that
// such color reduction dramatically HURTS extremal region bounding box
// extraction.  It also does NOT significantly cut down the number of
// extremal regions found per image!  So we abandon this idea...

//   string reduced_colors_filename=+"reduced_colors.png";
//   string unix_cmd=
//      "convert "+image_filename+" -dither None -colors 5 "+
//      reduced_colors_filename;
//   sysfunc::unix_command(unix_cmd);

//   image_filename=reduced_colors_filename;

   std::vector<polygon> all_polygons;

   string bboxes_subdir=home_subdir+"bboxes/";
//   string unix_cmd="/bin/rm -r -f "+bboxes_subdir;
//   cout << "unix_cmd = " << unix_cmd << endl;
//   sysfunc::unix_command(unix_cmd);
   filefunc::dircreate(bboxes_subdir);

/*
   string candidate_char_patches_subdir=home_subdir+"candidate_char_patches/";
   string unix_cmd="/bin/rm -r -f "+candidate_char_patches_subdir;
//   cout << "unix_cmd = " << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);
   filefunc::dircreate(candidate_char_patches_subdir);
*/

//   int color_channel_ID=-1;
   int color_channel_ID=-2;	// TOC12 ppt signs
//   cout << "Enter color channel ID:" << endl;
//   cout << "-2 = luminosity, -1 = value, 0 = saturation, 1 = red, 2 = green, 3 = blue" << endl;
//   cin >> color_channel_ID;
   
   timefunc::initialize_timeofday_clock();

   int index=0;
   int n_detections=0;
   int n_rejections=0;
//   int n_sigmaz_rejections=0;
//   int n_skewz_rejections=0;
//   int n_quartic_z_rejections=0;
   int n_Ng_rejections=0;
//   int candidate_char_counter=0;

   connected_components* connected_components_ptr=NULL;
   connectfunc::create_extremal_region_pooled_memory();

   typedef Quadruple<int,int,int,int> BBOX_PIXEL_COORDS;
   typedef std::map<BBOX_PIXEL_COORDS,extremal_region*,ltquadruple > 
      BBOXES_MAP;
   BBOXES_MAP* bboxes_map_ptr=NULL;

// =======================================================================
// Outermost loop over bright vs dark characters starts here:

//   for (int brightness_iter=0; brightness_iter < 1; brightness_iter++)
//   for (int brightness_iter=1; brightness_iter < 2; brightness_iter++)
   for (int brightness_iter=0; brightness_iter < 2; brightness_iter++)
   {
      cout << "brightness_iter = " << brightness_iter << endl;
      
      bool invert_binary_values_flag;
      int threshold_start,threshold_stop,d_threshold;

      if (brightness_iter==0)	// bright chars dark background
      {
         invert_binary_values_flag=false;
         threshold_start=254;
         threshold_stop=1;
         d_threshold=-1;
      }
      else if (brightness_iter==1) // dark chars bright background
      {
         invert_binary_values_flag=true; 
         threshold_start=1;
         threshold_stop=254;
         d_threshold=1;
      }

      delete connected_components_ptr;   
      connected_components_ptr=new connected_components();
      connected_components_ptr->set_shapes_pfuncts_ptrs(&shapes_pfuncts_ptrs);
      connected_components_ptr->reset_image(
         image_filename,color_channel_ID);

      connected_components::TREE_PTR tree_ptr=connected_components_ptr->
         get_tree_ptr();

// ----------------------------------------------------------------------
      for (int threshold=threshold_start; threshold != threshold_stop; 
           threshold += d_threshold)
      {
         int level=-1;
         if (!invert_binary_values_flag)
         {
            level=255-threshold;
         }
         else
         {
            level=threshold;
         }

         string region_type;
         if (brightness_iter==0)
         {
            region_type="bright_region";
         }
         else
         {
            region_type="dark_region";
         }
         int n_treenodes=0;
         int n_leafnodes=0;
         if (tree_ptr != NULL) n_treenodes=tree_ptr->size();
         if (tree_ptr != NULL) n_leafnodes=tree_ptr->get_n_leaf_nodes();

         if (level%10==0)
         {
            cout << region_type 
                 << "  level=" << level 
                 << "  n_nodes=" << n_treenodes
                 << "  n_leafnodes=" << n_leafnodes
                 << endl;
         }

         bool RLE_flag=false;
//         bool RLE_flag=true;
         bool export_connected_regions_flag=false;
//         bool export_connected_regions_flag=true;
         connected_components_ptr->compute_connected_components(
            index,threshold,level,RLE_flag,invert_binary_values_flag,
            export_connected_regions_flag);

         const double shapes_prob_threshold=0.5;

         int start_symbol_ID=0;
         int stop_symbol_ID=1;
         connected_components_ptr->compute_text_shape_probs(
            level,shapes_prob_threshold,start_symbol_ID,stop_symbol_ID);
         
//          outputfunc::enter_continue_char();
      } // loop over threshold index
// ----------------------------------------------------------------------

      double elapsed_time=timefunc::elapsed_timeofday_time();
      cout << "ELAPSED TIME = " << elapsed_time << endl;

      int symbol_ID=0;
      std::vector<connected_components::TREENODE_PTR> stable_region_node_ptrs=
         connected_components_ptr->identify_stable_extremal_regions(symbol_ID);

      cout << "total n_nodes = " << tree_ptr->size() << endl;
      cout << "n_leaf nodes = " << tree_ptr->get_n_leaf_nodes() << endl;
      cout << "stable_region_node_ptrs.size() = "
           << stable_region_node_ptrs.size() << endl;
//      outputfunc::enter_continue_char();

// Instantiate and fill STL map with bounding box corner coordinates:

      delete bboxes_map_ptr;
      BBOXES_MAP* bboxes_map_ptr=new BBOXES_MAP;
      // *bboxes_map_ptr independent var = left bottom & top right bbox corners
      // dependent var = extremal_region ptr

      for (unsigned int n=0; n<stable_region_node_ptrs.size(); n++)
      {
         connected_components::TREENODE_PTR treenode_ptr=
            stable_region_node_ptrs[n];
         extremal_region* extremal_region_ptr=treenode_ptr->get_data_ptr();

         unsigned int left_pu,bottom_pv,right_pu,top_pv;
         extremal_region_ptr->get_bbox(left_pu,bottom_pv,right_pu,top_pv);
         right_pu++;
         top_pv++;
         
         BBOX_PIXEL_COORDS bbox_corners(
            left_pu,bottom_pv,right_pu,top_pv);
         BBOXES_MAP::iterator iter=bboxes_map_ptr->find(bbox_corners);
         if (iter==bboxes_map_ptr->end())
         {
            (*bboxes_map_ptr)[bbox_corners]=extremal_region_ptr;

//               cout << "level = " << level
//                    << " char prob = " << basic_math::round(100*char_prob)
//                    << " bottom left: pu = " << left_pu
//                    << " pv = " << bottom_pv
//                    << " top right: pu = " << right_pu
//                    << " pv = " << top_pv << endl;
         }
      } // loop over index n labeling stable region nodes 
   
      cout << "Initially, bboxes_map_ptr->size() = " << bboxes_map_ptr->size()
           << endl;

// Merge bounding boxes whose sizes are nearly equal:
   
//   const int bbox_distance_toler=1;	// pixels
      const int sqr_bbox_distance_toler=sqr(2);	// pixels
//      const int bbox_distance_toler=3;	// pixels
//      const int bbox_distance_toler=4;	// pixels

      bool changed_flag=false;
      do 
      {
         changed_flag=false;

         for (BBOXES_MAP::iterator iter=bboxes_map_ptr->begin();
              iter != bboxes_map_ptr->end(); iter++)
         {
            BBOX_PIXEL_COORDS curr_bbox_corners=iter->first;
            if (iter->second==NULL) continue;

            int left_pu=curr_bbox_corners.first;
            int bottom_pv=curr_bbox_corners.second;
            int right_pu=curr_bbox_corners.third;
            int top_pv=curr_bbox_corners.fourth;
      
            for (BBOXES_MAP::iterator iter2=bboxes_map_ptr->begin();
                 iter2 != bboxes_map_ptr->end(); iter2++)
            {
               if (iter2==iter) continue;
               if (iter->second==NULL) continue;
               if (iter2->second==NULL) continue;
            
               BBOX_PIXEL_COORDS next_bbox_corners=iter2->first;
               double sqr_magnitude=
                  sqr(curr_bbox_corners.first-next_bbox_corners.first)+
                  sqr(curr_bbox_corners.second-next_bbox_corners.second)+
                  sqr(curr_bbox_corners.third-next_bbox_corners.third)+
                  sqr(curr_bbox_corners.fourth-next_bbox_corners.fourth);
               if (sqr_magnitude > sqr_bbox_distance_toler) continue;

               left_pu=basic_math::min(left_pu,next_bbox_corners.first);
               bottom_pv=basic_math::min(bottom_pv,next_bbox_corners.second);
               right_pu=basic_math::max(right_pu,next_bbox_corners.third);
               top_pv=basic_math::max(top_pv,next_bbox_corners.fourth);
               BBOX_PIXEL_COORDS new_bbox_corners(
                  left_pu,bottom_pv,right_pu,top_pv);
               
               if (iter->second->get_pixel_area() > 
                   iter2->second->get_pixel_area())
               {
                  (*bboxes_map_ptr)[new_bbox_corners]=iter->second;
                  iter2->second=NULL;
               }
               else
               {
                  (*bboxes_map_ptr)[new_bbox_corners]=iter2->second;
                  iter->second=NULL;
               }
               changed_flag=true;
            } // loop over iter2
         } // loop over iter
      }
      while (changed_flag);

      cout << "After bbox merging, bboxes_map_ptr->size() = " 
           << bboxes_map_ptr->size() << endl;

// Prepare to compute Coates-Ng text character probabilities for all 
// surviving candidate bbox regions:

      texture_rectangle_ptr->import_photo_from_file(image_filename);

      for (BBOXES_MAP::iterator iter=bboxes_map_ptr->begin();
           iter != bboxes_map_ptr->end(); iter++)
      {
         extremal_region* extremal_region_ptr=iter->second;
         if (extremal_region_ptr==NULL) continue;

/*
// Decode and display RLE pixel regions for all surviving extremal
// regions:

         texture_rectangle* ER_texture_rectangle_ptr=
            new texture_rectangle();
         ER_texture_rectangle_ptr->import_photo_from_file(image_filename);

         twoDarray* cc_twoDarray_ptr=
            ER_texture_rectangle_ptr->instantiate_ptwoDarray_ptr();
         cc_twoDarray_ptr->initialize_values(255);
         extremal_region_ptr->run_length_decode(cc_twoDarray_ptr);

         ER_texture_rectangle_ptr->
            convert_single_twoDarray_to_three_channels(
               cc_twoDarray_ptr,true);
         string ER_output_filename=bboxes_subdir+
            "ER_"+stringfunc::integer_to_string(
               extremal_region_ptr->get_ID(),3)+".jpg";
         ER_texture_rectangle_ptr->write_curr_frame(ER_output_filename);
         delete ER_texture_rectangle_ptr;
*/


         int left_pu=iter->first.first;
         int top_pv=iter->first.second;
         int right_pu=iter->first.third-1;
         int bottom_pv=iter->first.fourth-1;
       
// Copy current bounding box chip into *qtwoDarray_ptr.  Then rescale
// chip's size so that new version stored in *qnew_twoDarray_ptr has
// height or width precisely equal to 32 pixels in size:

         int width=right_pu-left_pu+1;
         int height=bottom_pv-top_pv+1;
         double aspect_ratio=double(width)/double(height);

         int new_width,new_height;
         if (aspect_ratio > 1)
         {
            new_width=32;
            new_height=new_width/aspect_ratio;
         }
         else
         {
            new_height=32;
            new_width=aspect_ratio*new_height;
         }

         texture_rectangle_ptr->refresh_ptwoDarray_ptr();
         twoDarray* qtwoDarray_ptr=texture_rectangle_ptr->export_sub_twoDarray(
            left_pu,right_pu,top_pv,bottom_pv);
         qtwoDarray_ptr->init_coord_system(0,1,0,1);

         twoDarray* qnew_twoDarray_ptr=compositefunc::downsample(
            new_width,new_height,qtwoDarray_ptr);
         delete qtwoDarray_ptr;

/*
// For debugging purposes only, export *qnew_twoDarray_ptr as new JPG
// image chip:

         texture_rectangle* subtexture_rectangle_ptr=new
            texture_rectangle(new_width,new_height,1,3,NULL);
         subtexture_rectangle_ptr->generate_blank_image_file(
            new_width,new_height,"blank.jpg",0.5);
         subtexture_rectangle_ptr->convert_single_twoDarray_to_three_channels(
            qnew_twoDarray_ptr);
         string candidate_char_patches_subdir="./candidate_patches/";
         filefunc::dircreate(candidate_char_patches_subdir);
         string patch_filename=candidate_char_patches_subdir+
            "candidate_char_patch_"+stringfunc::integer_to_string(
               candidate_char_counter++,3)+".jpg";
         cout << "patch_filename = " << patch_filename << endl;
         subtexture_rectangle_ptr->write_curr_frame(patch_filename);
         delete subtexture_rectangle_ptr;

// Need to compute K_Ng-dim features for 8x8 patches within
// *qnew_twoDarray_ptr.  Pool features within 3x3 sectors into
// single nineK=9*K_Ng vector.  Then compute probability rescaled chip
// corresponds to text character using learned Ng probability decision
// function...

         texture_rectangle_ptr->import_photo_from_file(patch_filename);
         texture_rectangle_ptr->refresh_ptwoDarray_ptr();
         texture_rectangle_ptr->reset_ptwoDarray_ptr(qnew_twoDarray_ptr);
*/

         texture_rectangle_ptr->instantiate_ptwoDarray_ptr();
         *(texture_rectangle_ptr->get_ptwoDarray_ptr()) = *qnew_twoDarray_ptr;
         delete qnew_twoDarray_ptr;

         text_detector_ptr->set_window_width(new_width);
         text_detector_ptr->set_window_height(new_height);
         text_detector_ptr->clear_window_features_vector();

//         bool perform_Ng_classification_flag=false;
         bool perform_Ng_classification_flag=true;
         if (perform_Ng_classification_flag)
         {
            double Ng_char_prob=1;
            bool flag=text_detector_ptr->average_window_features(0,0);
            if (flag)
            {
               float* window_histogram=text_detector_ptr->
                  get_nineK_window_descriptor();
               for (int k=0; k<nineK; k++)
               {
                  Ng_sample(k)=window_histogram[k];
//               cout << "k = " << k << " window_histogram[k] = "
//                    << window_histogram[k] << endl;
               } // loop over index k labeling dictionary descriptors
               Ng_char_prob=Ng_pfunct(Ng_sample);
               cout << "Ng char probability = " << Ng_char_prob << endl;
//            outputfunc::enter_continue_char();
            }

            if (Ng_char_prob < Ng_char_threshold)
            {
               n_Ng_rejections++;
               continue;
            }
         } // perform_Ng_classification_flag

         double left_u,top_v,right_u,bottom_v;
         texture_rectangle_ptr->get_uv_coords(left_pu,top_pv,left_u,top_v);
         texture_rectangle_ptr->get_uv_coords(
            right_pu,bottom_pv,right_u,bottom_v);

         std::vector<threevector> vertices;
         vertices.push_back(threevector(left_u,top_v));
         vertices.push_back(threevector(left_u,bottom_v));
         vertices.push_back(threevector(right_u,bottom_v));
         vertices.push_back(threevector(right_u,top_v));
         polygon bbox(vertices);
         std::vector<polygon> polygons;
         polygons.push_back(bbox);
         all_polygons.push_back(bbox);

         n_detections++;

      } // loop over *bboxes_map_ptr

   } // loop over brightness_iter
// =======================================================================

   delete bboxes_map_ptr;
   delete connected_components_ptr;   
   delete text_detector_ptr;

   cout << "n_detections = " << n_detections << endl;
   cout << "n_rejections = " << n_rejections << endl;
//   cout << "n_sigmaz_rejections = " << n_sigmaz_rejections << endl;
//   cout << "n_skewz_rejections = " << n_skewz_rejections << endl;
//   cout << "n_quartic_z_rejections = " << n_quartic_z_rejections << endl;
   cout << "n_Ng_rejections = " << n_Ng_rejections << endl;
   double rejection_frac=
      double(n_rejections)/double(n_rejections+n_detections);
   cout << "R/(R+D) = " << rejection_frac << endl;

// Display all text character bounding boxes within a single,
// composite image:

   texture_rectangle* composite_texture_rectangle_ptr=new texture_rectangle();
   composite_texture_rectangle_ptr->import_photo_from_file(image_filename);

   string composite_output_filename=bboxes_subdir+"composite_char_bboxes.jpg";
   int contour_color_index=-1;
//   cout << "Enter color index:" << endl;
//   cin >> contour_color_index;
   int thickness=0;
//   cout << "Enter output polygon thickness:" << endl;
//   cin >> thickness;

   videofunc::display_polygons(
      all_polygons,composite_texture_rectangle_ptr,
      contour_color_index,thickness);

   composite_texture_rectangle_ptr->write_curr_frame(
      composite_output_filename);

   delete composite_texture_rectangle_ptr;
   connectfunc::delete_extremal_region_pooled_memory();

   double total_time=timefunc::elapsed_timeofday_time();
   cout << "TOTAL PROCESSING TIME = " << total_time << " secs = " 
        << total_time / 60.0 << " minutes" << endl;
}

