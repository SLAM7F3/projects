// ==========================================================================
// Program MULTINETS first reads in tree, building and road
// intersection network information generated by programs TREES, ORTHO
// and STREETS from ascii text files.  It regenerates tree cluster,
// building and road networks based upon this input data.  MULTINETS
// next constructs city blocks from the road network information and
// generates a new city block network.
// ==========================================================================
// Last updated on 8/8/05; 4/24/06
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <set>
#include <string>
#include <vector>
#include "urban/bldgstrandfuncs.h"
#include "urban/cityblock.h"
#include "urban/cityblockfuncs.h"
#include "image/connectfuncs.h"
#include "threeDgraphics/draw3Dfuncs.h"
#include "ladar/featurefuncs.h"
#include "general/filefuncs.h"
#include "geometry/geometry_funcs.h"
#include "image/graphicsfuncs.h"
#include "ladar/groundfuncs.h"
#include "datastructures/Hashtable.h"
#include "image/imagefuncs.h"
#include "ladar/ladarfuncs.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "geometry/parallelogram.h"
#include "image/recursivefuncs.h"
#include "urban/roadfuncs.h"
#include "urban/roadpoint.h"
#include "urban/roadsegment.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "urban/tree_cluster.h"
#include "urban/treefuncs.h"
#include "image/TwoDarray.h"
#include "urban/urbanfuncs.h"
#include "urban/urbanimage.h"
#include "geometry/voronoifuncs.h"
#include "threeDgraphics/xyzpfuncs.h"

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::ifstream;
   using std::ios;
   using std::istream;
   using std::ofstream;
   using std::ostream;
   using std::pair;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);
  
   bool input_param_file;
   unsigned int ninputlines,currlinenumber;
   string inputline[200];
   string logfilename=sysfunc::get_projectsrootdir()
      +"src/mains/alirt_acc/multinets.logfile";

   filefunc::parameter_input(
      argc,argv,input_param_file,inputline,ninputlines);
   currlinenumber=0;

// Read in contents of partially processed binary xyzp file:

   cout << "Enter refined feature image:" << endl;
   urbanimage cityimage;
//   cityimage.set_public_software(true);

// Chimney footprint dimensions:
   const double delta_x=0.3;	// meters
   const double delta_y=0.3;	// meters
   cityimage.initialize_image(input_param_file,inputline,currlinenumber);
   cityimage.parse_and_store_input_data(delta_x,delta_y);
   cityimage.compute_data_bbox(cityimage.get_z2Darray_ptr(),false);

// Eliminate junk nearby edges of data bounding box:

   ladarfunc::crop_data_inside_bbox(0.01,cityimage.get_data_bbox_ptr(),
                                    cityimage.get_z2Darray_ptr());
   ladarfunc::crop_data_inside_bbox(0.01,cityimage.get_data_bbox_ptr(),
                                    cityimage.get_p2Darray_ptr());

   twoDarray const *ztwoDarray_ptr=cityimage.get_z2Darray_ptr();
   twoDarray const *features_twoDarray_ptr=cityimage.get_p2Darray_ptr();
   twoDarray const *features_and_heights_twoDarray_ptr=
      urbanfunc::color_feature_heights(
         ztwoDarray_ptr,features_twoDarray_ptr);

// ==========================================================================
// Trees, road and buildings networks restoration
// ==========================================================================

// Read in previously saved trees network information from ascii text
// file:

   string trees_network_filename=cityimage.get_imagedir()+"trees_network.txt";
   bool vertices_lie_in_plane=false;
   treefunc::trees_network_ptr=
      treefunc::readin_trees_network_from_textfile(
         trees_network_filename,vertices_lie_in_plane);
   KDTree::KDTree<3, threevector>* kdtree_ptr=
      treefunc::generate_tree_network_kdtree(treefunc::trees_network_ptr);

// Draw tree cluster COMs and cylinders:

   twoDarray* COMs_twoDarray_ptr=new twoDarray(
      features_and_heights_twoDarray_ptr);
   features_and_heights_twoDarray_ptr->copy(COMs_twoDarray_ptr);
//   cityimage.draw_network_posns(
//      treefunc::trees_network_ptr,COMs_twoDarray_ptr);

//   string COMs_filename=cityimage.get_imagedir()+"tree_cylinders.xyzp";   
//   xyzpfunc::write_xyzp_data(
//      ztwoDarray_ptr,COMs_twoDarray_ptr,COMs_filename);
//   cityimage.draw_network_contour_cylinders(
//      COMs_filename,treefunc::trees_network_ptr);
//   draw3Dfunc::append_fake_xyzp_points_in_twoDarray_middle(
//      COMs_twoDarray_ptr,COMs_filename);

// Read in previously saved road intersections network information
// from ascii text file:

   string intersections_network_filename=cityimage.get_imagedir()+
      "intersections_network.txt";
   roadfunc::intersections_network_ptr=
      roadfunc::readin_road_network_from_textfile(
         intersections_network_filename);
   roadfunc::intersections_network_ptr->sort_all_site_neighbors();

// Read in previously saved buildings network information from ascii
// text file:

   string bldgs_text_filename=cityimage.get_imagedir()+"buildings_network.txt";
   cityimage.set_buildings_network_ptr(
      urbanfunc::readin_buildings_network_from_textfile(bldgs_text_filename));
//   cityimage.get_buildings_network_ptr()->sort_all_site_neighbors();

//   cout << "total number of buildings = " 
//        << cityimage.get_buildings_network_ptr()->size()
//        << endl;

// ==========================================================================
// City block network generation based upon road intersections network
// ==========================================================================

// Generate city block map and city block contours:

   twoDarray* cityblock_regions_twoDarray_ptr=new twoDarray(ztwoDarray_ptr);

   cityblockfunc::generate_cityblocks_network(
      cityimage.get_imagedir(),cityimage.get_data_bbox_ptr(),
         roadfunc::intersections_network_ptr,ztwoDarray_ptr,
         cityblock_regions_twoDarray_ptr);
   cityblockfunc::find_cityblock_road_segments(
      roadfunc::intersections_network_ptr);

/*
   draw3Dfunc::draw_thick_lines=true;
   string cityblock_contours_filename=cityimage.get_imagedir()+
      "cityblocks_contours.xyzp";   
   for (int c=0; c<cityblockfunc::cityblocks_network_ptr->size(); c++)
   {
      cityblock* curr_cityblock_ptr=cityblockfunc::cityblocks_network_ptr->
         get_site_data_ptr(c);
      contour* curr_contour_ptr=curr_cityblock_ptr->get_contour_ptr();
      curr_contour_ptr->translate(5*z_hat);
      draw3Dfunc::draw_contour(
         *curr_contour_ptr,cityblock_contours_filename,
         draw3Dfunc::annotation_value1);
   }
   draw3Dfunc::append_fake_xyzp_points_in_twoDarray_middle(
      ztwoDarray_ptr,cityblock_contours_filename);
*/

// Assign city block IDs to buildings & identify building islands:

   cityblockfunc::set_building_cityblock_IDs(
      cityimage.get_buildings_network_ptr(),
      cityblock_regions_twoDarray_ptr);
   cityblockfunc::eliminate_blocks_with_no_buildings(
      cityimage.get_buildings_network_ptr(),
      roadfunc::intersections_network_ptr,cityblock_regions_twoDarray_ptr);
   cityblockfunc::identify_building_islands(
      cityimage.get_buildings_network_ptr(),
      cityblock_regions_twoDarray_ptr);

/*
   while(true)
   {
      int c;
      cout << "Enter cityblock to annotate:" << endl;
      cin >> c;

      string cityblock_regions_filename=cityimage.get_imagedir()+
         "cityblock_regions.xyzp";
      twoDarray* recolored_blocks_twoDarray_ptr=
         cityblockfunc::recolor_cityblocks(cityblock_regions_twoDarray_ptr);
      xyzpfunc::write_xyzp_data(
         ztwoDarray_ptr,recolored_blocks_twoDarray_ptr,
         cityblock_regions_filename,false);
      delete recolored_blocks_twoDarray_ptr;
      draw3Dfunc::append_fake_xyzp_points_in_twoDarray_middle(
         ztwoDarray_ptr,cityblock_regions_filename);
//      cityblockfunc::get_cityblock_ptr(c)->
//         annotate_block_label(cityblock_regions_filename);
//      cityblockfunc::get_cityblock_ptr(c)->annotate_roadsegment_labels(
//         cityblock_regions_filename);
   }
*/

   cityblockfunc::identify_cityblocks_near_roadpoints(
      cityblock_regions_twoDarray_ptr,roadfunc::intersections_network_ptr);
   cityblockfunc::identify_street_corner_buildings(
      roadfunc::intersections_network_ptr,
      cityimage.get_buildings_network_ptr());

   delete cityblock_regions_twoDarray_ptr;

// Generate city block building sub-networks:

   cityblockfunc::prune_multiblock_links(
      cityimage.get_buildings_network_ptr());
   cityblockfunc::generate_cityblock_neighbors_networks(
      cityimage.get_buildings_network_ptr());
   cityblockfunc::identify_building_tadpoles();

// Find buildings' front directions:

   cityblockfunc::compute_building_front_dirs();
   cityblockfunc::eliminate_building_tripoles();
   cityblockfunc::eliminate_inconsistent_nextdoor_links();
   cityblockfunc::propagate_building_front_dirs();
   cityblockfunc::eliminate_building_tripoles();
   cityblockfunc::eliminate_inconsistent_nextdoor_links();
   cityblockfunc::identify_buildings_on_street();

// Establish building neighbors' handedness (as viewed from the
// street!).  Use this information to refine front direction and
// corner building identification:

   cityblockfunc::establish_building_neighbor_handedness();
   cityblockfunc::infer_more_building_front_dirs();
   cityblockfunc::improve_corner_building_identification();
   cityblockfunc::break_remaining_building_tripoles();
   cityblockfunc::associate_buildings_with_roadsegments();

// Look for tall trees located behind buildings:

   double max_bldg_to_tree_dist=20;	// meters
   double min_angle_rel_to_front=175*PI/180;	// radians
   double max_angle_rel_to_front=185*PI/180;	// radians
   double min_tree_height=10.0;	// meters
   double max_tree_height=100.0;	// meters
 
   Linkedlist<int>* bldgs_with_tall_trees_in_back_list_ptr=
      urbanfunc::search_for_trees_near_bldgs(
         cityimage.get_buildings_network_ptr(),kdtree_ptr,
         max_bldg_to_tree_dist,min_angle_rel_to_front,max_angle_rel_to_front,
         min_tree_height,max_tree_height);
   cout << "# bldgs with tall trees in back = " 
        << bldgs_with_tall_trees_in_back_list_ptr->size() << endl;

// Look for small shrubs located to the left and rear of buildings:

   max_bldg_to_tree_dist=8;	// meters
   min_angle_rel_to_front=220*PI/180;	// radians
   max_angle_rel_to_front=240*PI/180;	// radians
   min_tree_height=3;	// meters
   max_tree_height=5;	// meters

   Linkedlist<int>* bldgs_with_small_shrubs_on_rear_left_list_ptr=
      urbanfunc::search_for_trees_near_bldgs(
         cityimage.get_buildings_network_ptr(),kdtree_ptr,
         max_bldg_to_tree_dist,min_angle_rel_to_front,max_angle_rel_to_front,
         min_tree_height,max_tree_height);
   cout << "# bldgs with small shrubs on rear left = " 
        << bldgs_with_small_shrubs_on_rear_left_list_ptr->size() 
        << endl;

/*
   while(true)
   {
      int n;
      cout << "Enter building number n:" << endl;
      cin >> n;

      double rho;
      cout << "Enter radius rho in meters:" << endl;
      cin >> rho;

      double min_angle_rel_to_front,max_angle_rel_to_front;
      cout << "Enter min angle rel to front:" << endl;
      cin >> min_angle_rel_to_front;
      cout << "Enter max angle rel to front:" << endl;
      cin >> max_angle_rel_to_front;
      min_angle_rel_to_front *= PI/180.0;
      max_angle_rel_to_front *= PI/180.0;
//      const double min_angle_rel_to_front=170*PI/180.0;
//      const double max_angle_rel_to_front=190*PI/180.0;

      double min_tree_to_bldg_height_ratio=1.0;
      double max_tree_to_bldg_height_ratio=10.0;

      building* curr_bldg_ptr=cityimage.get_buildings_network_ptr()->
         get_site_data_ptr(n);
      urbanfunc::search_for_trees_near_bldg(
         curr_bldg_ptr,rho,min_angle_rel_to_front,max_angle_rel_to_front,
         min_tree_to_bldg_height_ratio,max_tree_to_bldg_height_ratio,
         kdtree_ptr);
   }
*/

// Copy cityblock nextdoor neighbor link information into entire
// cityimage buildings network:

   cityimage.get_buildings_network_ptr()->delete_all_neighbor_links();
   cityblockfunc::copy_only_nextdoor_neighbor_links(
      cityimage.get_buildings_network_ptr());
   
   vector<int> tripoles=cityimage.get_buildings_network_ptr()->
      generate_npole_list(3);
//   cout << "All tripoles = " << endl;
//   templatefunc::printVector(tripoles);

// ==========================================================================
// Construct building strands and hardwire-in relative building
// height, rooftop spine direction and gross vegetation direction
// information into a video strand.  Score how closely each strand
// matches *video_strand_ptr.
// ==========================================================================

//   int strand_length=3;
   int strand_length=4;
//   int strand_length=5;

   cityblockfunc::construct_building_neighbor_strands(
      strand_length,bldgs_with_tall_trees_in_back_list_ptr,
      bldgs_with_small_shrubs_on_rear_left_list_ptr);
   Strand<building_info*>* video_strand_ptr=
      bldgstrandfunc::set_video_strand();

   int score_threshold=1;
//   cout << "Enter score threshold:" << endl;
//   cin >> score_threshold;
   cityblockfunc::score_strands_agreement_with_video_data(
      video_strand_ptr,score_threshold);

// ==========================================================================
// Draw final 3D network results
// ==========================================================================

   double delta_z=3;	// meters
//   draw3Dfunc::draw_thick_lines=true;		// default
   draw3Dfunc::draw_thick_lines=false;	// for poster
//   draw3Dfunc::ds=0.2;			// default
//   draw3Dfunc::ds=0.1;
//   draw3Dfunc::ds=0.05;
   draw3Dfunc::ds=0.02;			// for poster
//   draw3Dfunc::delta_phi=60*PI/180;
   draw3Dfunc::delta_phi=10*PI/180;		// for poster

   twoDarray* intersections_twoDarray_ptr=new twoDarray(
      features_and_heights_twoDarray_ptr);
   features_and_heights_twoDarray_ptr->copy(intersections_twoDarray_ptr);

   string networks_filename=cityimage.get_imagedir()+"networks.xyzp";   
   filefunc::deletefile(networks_filename);
//   roadfunc::draw_roadpoints(
//      roadfunc::intersections_network_ptr,intersections_twoDarray_ptr,false);
//   xyzpfunc::write_xyzp_data(
//      ztwoDarray_ptr,intersections_twoDarray_ptr,networks_filename);
//   draw3Dfunc::append_fake_xyzp_points_in_twoDarray_middle(
//      intersections_twoDarray_ptr,networks_filename);

// Draw 3D road network:

   outputfunc::write_banner("Drawing 3D road network:");

   draw3Dfunc::draw_3D_nearest_neighbor_links(
      networks_filename,roadfunc::intersections_network_ptr,
      featurefunc::road_sentinel_value,delta_z);

//   roadfunc::annotate_roadpoint_labels(
//      roadfunc::intersections_network_ptr,networks_filename,
//      draw3Dfunc::annotation_value1);

// Draw 3D buildings network:

   outputfunc::write_banner("Drawing 3D buildings network:");

//   urbanfunc::draw_3D_buildings(
//      cityimage.get_buildings_network_ptr(),
//      networks_filename,featurefunc::building_sentinel_value,false);

//   urbanfunc::draw_3D_buildings(
//      bldgs_with_small_shrubs_on_rear_left_list_ptr,
//      cityimage.get_buildings_network_ptr(),
//      networks_filename,draw3Dfunc::annotation_value1,
//      draw3Dfunc::annotation_value2,false);
//   cityblockfunc::draw_3D_strands(
//      cityimage.get_buildings_network_ptr(),networks_filename,
//      draw3Dfunc::annotation_value1);
//   urbanfunc::annotate_building_labels(
//      cityimage.get_buildings_network_ptr(),
//      networks_filename,draw3Dfunc::annotation_value2,false);
//   urbanfunc::draw_3D_building_front_dirs(
//      cityimage.get_buildings_network_ptr(),
//      networks_filename,draw3Dfunc::annotation_value1,false);
//   draw3Dfunc::draw_3D_nearest_neighbor_links(
//      networks_filename,cityimage.get_buildings_network_ptr(),
//      0.22,delta_z);
   draw3Dfunc::append_fake_xyzp_points_in_twoDarray_middle(
      ztwoDarray_ptr,networks_filename);

   delete bldgs_with_tall_trees_in_back_list_ptr;
   delete bldgs_with_small_shrubs_on_rear_left_list_ptr;
   delete features_and_heights_twoDarray_ptr;
   delete roadfunc::intersections_network_ptr;
   delete cityblockfunc::cityblocks_network_ptr;
   delete video_strand_ptr;

   cityimage.summarize_results();
   cityimage.update_logfile("multinets");
}


