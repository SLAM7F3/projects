// ==========================================================================
// Program DRAPE_BLDG takes in multiple PNG images of the walls of our
// favorite apartment building in Lowell.  It drapes these pictures'
// RGB values onto the polygonal sides of the 3D model which was
// automatically generated by program ORTHO.  The polygons making up
// the model are also written to the output XYZP file.  When
// concatenated with feature classification information, we end up
// with a very pretty pixel-level fused ladar/video 3D image.
// ==========================================================================
// Last updated on 2/23/05
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "color/colorfuncs.h"
#include "math/constants.h"
#include "threeDgraphics/draw3Dfuncs.h"
#include "general/filefuncs.h"
#include "math/mymatrix.h"
#include "templates/mytemplates.h"
#include "geometry/parallelepiped.h"
#include "geometry/polygon.h"
#include "space/spasefuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "urban/urbanfuncs.h"
#include "threeDgraphics/xyzpfuncs.h"

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::ios;
   using std::ofstream;
   using std::ostream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// ==========================================================================
// Constant definitions
// ==========================================================================

// Generate building wall polygons in XYZ space:

   string input_subdir="./2D_images/";
   string walls_filename=input_subdir+"apartment_wall_polys.txt";
   vector<polygon>* walls_poly_ptr=
      urbanfunc::readin_building_wall_polys(walls_filename);
   vector<polygon> polygon_face;
   const double max_distance=POSITIVEINFINITY;
//   const double delta_s=0.025;	// meter
   const double delta_s=0.04;	// meter

// Open output XYZP file:

   string output_subdir="./xyzp_files/";
   filefunc::dircreate(output_subdir);
   string xyzp_filename=output_subdir+"drape.xyzp";
   filefunc::deletefile(xyzp_filename);

// Drape visible PNG photo #1:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[8]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_1.png","apartment1_1_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #2:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[9]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_2.png","apartment1_2_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #3:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[10]);
   polygon_face.push_back( (*walls_poly_ptr)[11]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_3.png","apartment1_3_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #4:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[0]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_4.png","apartment1_4_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #5:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[1]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_5.png","apartment1_5_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #6:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[2]);
   polygon_face.push_back( (*walls_poly_ptr)[3]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_6.png","apartment1_6_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #7:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[4]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_7.png","apartment1_7_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #8:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[5]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_8.png","apartment1_8_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Drape visible PNG photo #9:

   polygon_face.clear();
   polygon_face.push_back( (*walls_poly_ptr)[6]);
   polygon_face.push_back( (*walls_poly_ptr)[7]);
   draw3Dfunc::drape_PNG_image_onto_polygons(
      input_subdir,"apartment1_9.png","apartment1_9_xyz_uv.txt",
      xyzp_filename,polygon_face,max_distance,delta_s);

// Superpose wireframe onto XYZP output file:

   myvector walls_COM;
   for (int i=0; i<walls_poly_ptr->size(); i++)
   {
      polygon wall_poly( (*walls_poly_ptr)[i] );
      draw3Dfunc::draw_polygon(
         wall_poly,xyzp_filename,draw3Dfunc::annotation_value1);
      walls_COM += wall_poly.vertex_average()/(walls_poly_ptr->size());
   }
   delete walls_poly_ptr;

// Add fake color map points into final XYZP file:

   draw3Dfunc::append_fake_xyzp_points_for_dataviewer_coloring(
      xyzp_filename,walls_COM);
   filefunc::gunzip_file_if_gzipped(xyzp_filename);
}
