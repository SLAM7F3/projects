// ========================================================================
// Program GPS2KML reads in the metadata ascii file generated by
// Ross Anderson's program which ran on the Mac-Mini along with the
// FLIR for Twin Otter flights.  It extracts aircraft GPS information
// from this metadata file.  This program writes out TDP, OSGA and KML
// file versions of the GPS flightpath.

//		       		GPS2KML

// ========================================================================
// Last updated on 7/3/11; 7/5/11; 7/6/11; 2/28/13
// ========================================================================

#include <iostream>
#include <set>
#include <string>
#include <vector>

#include "geometry/bounding_box.h"
#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "gearth/kml_parser.h"
#include "astro_geo/geopoint.h"
#include "geometry/polyline.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "track/tracks_group.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

   string metadata_filename="./20110525_091610.txt";
   cout << endl << endl;
   cout << "Enter full path for Ross Anderson's FLIR metadata file:" << endl;
   cin >> metadata_filename;

   filefunc::ReadInfile(metadata_filename);

   string metafile_subdir=filefunc::getdirname(metadata_filename);
   string metafile_basename=filefunc::getbasename(metadata_filename);
   string metafile_prefix=stringfunc::prefix(metafile_basename);

// Ignore any flight path points lying outside a bounding box:

// HAFB:

   double min_easting=310870-6*1000;
   double min_northing=4701756-3*1000;
   double max_easting=315796+3*1000;
   double max_northing=4705068+3*1000;

/*
// Grand Canyon

   double min_easting=375046;
   double min_northing=3975435;
   double max_easting=437255;
   double max_northing=4017568;
*/

   bounding_box bbox(min_easting,max_easting,min_northing,max_northing);

   int n_waypoints=filefunc::text_line.size();
   int n_points_inside=0;
   vector<threevector> GPS_position;

   tracks_group* tracks_group_ptr=new tracks_group();
   track* track_ptr=tracks_group_ptr->generate_new_track();

// Extract GPS flight path:

   ofstream outstream;
   string waypoints_filename="Otter_GPS_track.txt";
   filefunc::openfile(waypoints_filename,outstream);
   outstream.precision(12);

   outstream << "# HHMMSS     Epoch secs      Easting      Northing      Altitude" << endl;
   outstream << endl;

   cout << "n_waypoints = " << n_waypoints << endl;

   Clock clock;
   for (int i=0; i<n_waypoints; i++)
   {
      vector<string> column_values=
         stringfunc::decompose_string_into_substrings(
            filefunc::text_line[i],",");

      if (!stringfunc::is_number(column_values[5])) continue;

      vector<string> date_time_substrings=
         stringfunc::decompose_string_into_substrings(
         column_values[0],"_");

      string YYYYMMDD=date_time_substrings[0];
      string HHMMSS=date_time_substrings[1];

      int year,month,day,hour,minute;
      double secs;
      clock.parse_YYYYMMDD_string(YYYYMMDD,year,month,day);
      clock.parse_HHMMSS_string(HHMMSS,hour,minute,secs);
      const int hour_offset_to_UTC=4;	// Boston
      int UTC_hour=hour+hour_offset_to_UTC;
      clock.set_UTC_time(year,month,day,UTC_hour,minute,secs);
      double elapsed_secs=clock.secs_elapsed_since_reference_date();

// FAKE FAKE:  Sunday Jun 19, 2011 at 8:47 am
// Next line for testing only

// Time for 5-25-11 Otter flying in from west side of HAFB and
// circling around LL for first time:

//      if (elapsed_secs < 1306329484.18 || elapsed_secs > 1306329818.2)
//         continue;

// Time for 5-25-11 Otter flying around Credit Union:

//      if (elapsed_secs < 1306330241.22 || elapsed_secs > 1306330440.29)
//         continue;

//      double curr_az=stringfunc::string_to_number(column_values[1]);
//      double curr_el=stringfunc::string_to_number(column_values[2]);
//      double curr_roll=stringfunc::string_to_number(column_values[10]);
//      double curr_FOV_U=stringfunc::string_to_number(column_values[3]);
      double curr_latitude=stringfunc::string_to_number(column_values[5]);
      double curr_longitude=stringfunc::string_to_number(column_values[6]);
      double curr_altitude=stringfunc::string_to_number(column_values[7]);

      threevector lonlatalt(curr_longitude,curr_latitude,curr_altitude);
      threevector v(Zero_vector);
      track_ptr->set_posn_velocity(elapsed_secs,lonlatalt,v);

      geopoint curr_waypoint(curr_longitude,curr_latitude);
      double curr_easting=curr_waypoint.get_UTM_easting();
      double curr_northing=curr_waypoint.get_UTM_northing();
//      if (!bbox.point_inside(curr_easting,curr_northing)) continue;

      outstream << HHMMSS << "  "
                << elapsed_secs << "  "
                << curr_easting << "  "
                << curr_northing << "  "
                << curr_altitude << endl;

      threevector curr_GPS_posn(curr_easting,curr_northing,curr_altitude);
      GPS_position.push_back(curr_GPS_posn);
      n_points_inside++;

   } // loop over index i labeling waypoints

   filefunc::closefile(waypoints_filename,outstream);

   cout << "n_waypoints = " << n_waypoints << endl;
   cout << "n_points_inside = " << n_points_inside << endl;

// Generate TDP file containing flight path extracted from Ross'
// metadata file:

   string UTMzone="";
   string tdp_filename="GPS_flightpath.tdp";
   tdpfunc::write_relative_xyz_data(tdp_filename,GPS_position);

   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);

// Write out KML file containing GPS path:

   kml_parser KMLparser;
   double r=1;
   double g=0;
   double b=1;
   double a=1;
   double polyline_width=3;

   threevector lonlatalt;
   vector<threevector> vertices;
   for (unsigned int i=0; i<track_ptr->size(); i++)
   {
      double curr_t=track_ptr->get_time(i);
      if (track_ptr->get_interpolated_posn(curr_t,lonlatalt))
      {
         vertices.push_back(lonlatalt);
      }
   }

   string output_kml_filename=
      metafile_subdir+"flightpath_"+metafile_basename+".kml";
   KMLparser.generate_polyline_kml_file(
      r,g,b,a,polyline_width,vertices,output_kml_filename);

   cout << endl << endl;
   string banner="KML file containing GPS flight path written to "+
      output_kml_filename;
   outputfunc::write_big_banner(banner);

   string track_kml_filename=
      metafile_subdir+"track_"+metafile_basename+".kml";

   KMLparser.generate_track_kml_file(
      r,g,b,a,polyline_width,track_ptr,track_kml_filename);

   cout << endl << endl;
   banner="KML file containing GPS track written to "+
      track_kml_filename;
   outputfunc::write_big_banner(banner);

   delete tracks_group_ptr;
}


