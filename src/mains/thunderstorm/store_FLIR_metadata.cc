// ========================================================================
// Program STORE_FLIR_METADATA reads in the metadata ascii file generated by
// Ross Anderson's program which ran on the Mac-Mini along with the
// FLIR for Twin Otter flights.  It extracts aircraft GPS, aircraft
// orientation and FLIR pointing information from this metadata file.
// After manipulating and reformating the input metadata, this program
// exports it to output files aircraft_metadata.txt and camera_metadata.txt.
// STORE_FLIR_METADATA also inserts aircraft and camera metadata into
// rows of postgis tables aircraft_metadata and camera_metadata within
// the Tstorm database.

//			    store_FLIR_metadata

// ========================================================================
// Last updated on 10/22/11; 10/26/11; 10/28/11
// ========================================================================

#include <iostream>
#include <set>
#include <string>
#include <vector>

#include "geometry/bounding_box.h"
#include "video/camerafuncs.h"
#include "astro_geo/Clock.h"
#include "postgres/databasefuncs.h"
#include "general/filefuncs.h"
#include "astro_geo/geopoint.h"
#include "passes/PassesGroup.h"
#include "geometry/polyline.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "osg/osgTiles/TilesGroup.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

   int campaign_ID=1;	// Tstorm 4.0

   int mission_ID=1;
   string banner="Enter mission ID:";
   outputfunc::write_big_banner(banner);
   cin >> mission_ID;

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   int cloudpass_ID=passes_group.get_curr_cloudpass_ID();
   cout << "cloudpass_ID = " << cloudpass_ID << endl;
   Pass* cloudpass_ptr=passes_group.get_pass_ptr(cloudpass_ID);

   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();
//   cout << "GISlayer_IDs.size() = " << GISlayer_IDs.size() << endl;

// FAKE FAKE: As of Fri Sep 30, 2011, we hardwire CA/AZ region into
// this program !

   cloudpass_ptr->set_UTM_zonenumber(12);	// AZ
   cloudpass_ptr->set_northern_hemisphere_flag(true);

   PassInfo* cloudpassinfo_ptr=cloudpass_ptr->get_PassInfo_ptr();
   cloudpassinfo_ptr->set_longitude_lo(-125);
   cloudpassinfo_ptr->set_longitude_hi(-109);
   cloudpassinfo_ptr->set_latitude_lo(30);
   cloudpassinfo_ptr->set_latitude_hi(42);
   string map_countries_name="CalifAriz";

// Instantiate TilesGroup to perform raytracing computations:

   TilesGroup* TilesGroup_ptr=new TilesGroup();
   TilesGroup_ptr->set_min_long(cloudpass_ptr->get_PassInfo_ptr()->
                                get_longitude_lo());
   TilesGroup_ptr->set_max_long(cloudpass_ptr->get_PassInfo_ptr()->
                                get_longitude_hi());
   TilesGroup_ptr->set_min_lat(cloudpass_ptr->get_PassInfo_ptr()->
                                get_latitude_lo());
   TilesGroup_ptr->set_max_lat(cloudpass_ptr->get_PassInfo_ptr()->
                                get_latitude_hi());
   TilesGroup_ptr->set_specified_UTM_zonenumber(
      cloudpass_ptr->get_UTM_zonenumber());
   TilesGroup_ptr->set_northern_hemisphere_flag(
      cloudpass_ptr->get_northern_hemisphere_flag());
   string geotif_subdir="/data/DTED/"+map_countries_name+"/geotif/";
   TilesGroup_ptr->set_geotif_subdir(geotif_subdir);
   TilesGroup_ptr->set_geotif_Ztiles_subdir("/data/DTED/all_z_geotif_tiles/");

// Instantiate gis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_database_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(passes_group,GISlayer_IDs);

// FLIR image size in pixels:
      
   const int n_horiz_pixels=1280;
   const int n_vert_pixels=720;
   double aspect_ratio=double(n_horiz_pixels)/double(n_vert_pixels);
   double u0=0.5*aspect_ratio;
   double v0=0.5;

   string metadata_subdir=
      "/home/cho/programs/c++/svn/projects/src/mains/thunderstorm/ross_metadata/";

   string metadata_filename=metadata_subdir+"20110511_211231.txt";
//   string metadata_filename=metadata_subdir+"20110511_234525.txt";
   banner="Enter name of input metadata file residing within "+metadata_subdir;
   outputfunc::write_big_banner(banner);
   cin >> metadata_filename;
   metadata_filename=metadata_subdir+metadata_filename;

   filefunc::ReadInfile(metadata_filename);
   int n_waypoints=filefunc::text_line.size();
   cout << "n_waypoints = " << n_waypoints << endl;

   vector<threevector> GPS_position;

// Extract GPS flight path:

   ofstream aircraft_metadata_stream,camera_stream;
   string aircraft_metadata_filename="aircraft_metadata_mission"+
      stringfunc::number_to_string(mission_ID)+".txt";
   string camera_metadata_filename="camera_metadata_mission"+
      stringfunc::number_to_string(mission_ID)+".txt";
   filefunc::openfile(aircraft_metadata_filename,aircraft_metadata_stream);
   filefunc::openfile(camera_metadata_filename,camera_stream);
   
   aircraft_metadata_stream.precision(12);
   camera_stream.precision(10);

   aircraft_metadata_stream << "# Frame		     Epoch secs      Easting	      Northing   Alt	   Yaw		Pitch		Roll"
                            << endl;
   aircraft_metadata_stream << endl;

   camera_stream << "# Frame	 		HFOV		VFOV	   CAM_AZ	CAM_EL		CAM_ROLL" << endl;
   camera_stream << endl;


   int frame_ID,zeroth_frame_ID=-1;
   Clock clock;
   geopoint curr_waypoint,prev_waypoint;
   vector<threevector> candidate_tgt_posns;
   camera* camera_ptr=new camera();
   vector<polygon> footprint_polygons;
   double footprint_Z=NEGATIVEINFINITY;

// FAKE FAKE:  Sun Oct 23, 2011 at 8 pm
// Limit n_waypoints for ribbon testing only...
   
//   n_waypoints=2000;

//      const double dP_max=10;	// meters**2
//      const double dP_max=20;	// meters**2
//      const double dP_max=100; // meters**2

   double dP_max=-1;
   cout << endl;
   cout << "Enter maximum footprint pixel projected area in m**2:" << endl;
   cin >> dP_max;

   for (int i=0; i<n_waypoints; i++)
   {
      if (i%100==0) 
      {
         cout << "Processing waypoint " << i << endl;
         cout << "n_footprint polygons = " << footprint_polygons.size()
              << endl;
      }
   
      vector<string> column_values=
         stringfunc::decompose_string_into_substrings(
            filefunc::text_line[i],",");

      if (!stringfunc::is_number(column_values[5])) continue;

      vector<string> date_time_substrings=
         stringfunc::decompose_string_into_substrings(
         column_values[0],"_");

      string YYYYMMDD=date_time_substrings[0];
      string HHMMSS=date_time_substrings[1];

      int year,month,day,hour,minute;
      double secs;
      clock.parse_YYYYMMDD_string(YYYYMMDD,year,month,day);
      clock.parse_HHMMSS_string(HHMMSS,hour,minute,secs);
      const int hour_offset_to_UTC=4;	// Boston
      int UTC_hour=hour+hour_offset_to_UTC;
      clock.set_UTC_time(year,month,day,UTC_hour,minute,secs);
      double elapsed_secs=clock.secs_elapsed_since_reference_date();

      if (i==0)
      {
         zeroth_frame_ID=basic_math::mytruncate(elapsed_secs);
      }
      frame_ID=zeroth_frame_ID+i;

      string curr_frame_filename=column_values[0];
      double curr_az=stringfunc::string_to_number(column_values[1]);
      double curr_el=stringfunc::string_to_number(column_values[2]);
      double curr_heading=stringfunc::string_to_number(column_values[8]);
      double curr_pitch=stringfunc::string_to_number(column_values[9]);
      double curr_roll=stringfunc::string_to_number(column_values[10]);
      double curr_FOV_U=stringfunc::string_to_number(column_values[3]);
      double curr_latitude=stringfunc::string_to_number(column_values[5]);
      double curr_longitude=stringfunc::string_to_number(column_values[6]);
      double curr_altitude=stringfunc::string_to_number(column_values[7]);

      prev_waypoint=curr_waypoint;
      curr_waypoint=geopoint(curr_longitude,curr_latitude,curr_altitude);
      if (i==0) continue;
      
      double curr_easting=curr_waypoint.get_UTM_easting();
      double curr_northing=curr_waypoint.get_UTM_northing();
      double prev_easting=prev_waypoint.get_UTM_easting();
      double prev_northing=prev_waypoint.get_UTM_northing();
      double prev_altitude=prev_waypoint.get_altitude();

      threevector curr_GPS_posn(curr_easting,curr_northing,curr_altitude);
      GPS_position.push_back(curr_GPS_posn);

// Compute instantaneous velocity vector's direction vector v_hat via
// finite differencing:

      threevector v_hat(
         curr_easting-prev_easting,curr_northing-prev_northing,
         curr_altitude-prev_altitude);
      v_hat.put(2,0);
      if (v_hat.magnitude() > 0)
      {
         v_hat=v_hat.unitvector();	// velocity pointing direction
         double phi=atan2(v_hat.get(1),v_hat.get(0));
      }
      
// On 29 Sep 2011, we empirically determined the following procedure
// for converting "az", "el", "heading", "pitch", and "roll" from Ross'
// metadata file into an accurate 3D FLIR pointing vector f_hat:

      double phi_h=-90-curr_heading;
      phi_h=basic_math::phase_to_canonical_interval(phi_h,-180,180);
      double curr_yaw=phi_h-90; 
	// measured from north according to right hand rule wrt +z_hat
      phi_h *= PI/180;

//      cout << i << "  velocity dir: " 
//           << v_hat.get(0) << " , "
//           << v_hat.get(1) << " , "
//           << v_hat.get(2) << endl;

// Work with basis set l_hat (aircraft left), b_hat (aircraft behind)
// and t_hat (aircraft top).  Note l_hat x b_hat = t_hat . 

// Firstly, right-hand rotate aircraft coordinate system about z_hat
// by angle phi_h:

      threevector h_hat0(cos(phi_h),sin(phi_h),0); // heading dir vector

      threevector b_hat0=-h_hat0;	// backwards = -heading dir vector
      threevector t_hat0=z_hat;			// "top" pointing direction
      threevector l_hat0=b_hat0.cross(t_hat0);  // LHS pointing dir

// Secondly, pitch aircraft coordinate system about r_hat=-l_hat:

      double cos_pitch=cos(-curr_pitch*PI/180);
      double sin_pitch=sin(-curr_pitch*PI/180);

      threevector l_hat=l_hat0;
      threevector t_hat=cos_pitch*t_hat0+sin_pitch*b_hat0;
      threevector b_hat=-sin_pitch*t_hat0+cos_pitch*b_hat0;

// Finally, roll aircraft coordinate system about h_hat=-b_hat:

      double cos_roll=cos(-curr_roll*PI/180);
      double sin_roll=sin(-curr_roll*PI/180);

      threevector b_hat_prime=b_hat;
      threevector l_hat_prime=cos_roll*l_hat+sin_roll*t_hat;
      threevector t_hat_prime=-sin_roll*l_hat+cos_roll*t_hat;

      l_hat=l_hat_prime;
      b_hat=b_hat_prime;
      t_hat=t_hat_prime;

      double cos_az=cos(curr_az*PI/180);
      double sin_az=sin(curr_az*PI/180);
      double cos_el=cos(curr_el*PI/180);
      double sin_el=sin(curr_el*PI/180);

      threevector U_hat=-sin_az*b_hat+cos_az*l_hat;
      threevector V_hat=-sin_el*cos_az*b_hat-sin_el*sin_az*l_hat+cos_el*t_hat;
      threevector f_hat=cos_el*cos_az*b_hat+cos_el*sin_az*l_hat+sin_el*t_hat;
      threevector W_hat=-f_hat;

//      cout << "U_hat = " << U_hat << endl;
//      cout << "V_hat = " << V_hat << endl;
//      cout << "w_hat = " << W_hat << endl;

//      cout << "FLIR dir: " 
//           << f_hat.get(0) << ", "
//           << f_hat.get(1) << ", "
//           << f_hat.get(2) << endl << endl;
//      cout << "(U_hat x V_hat) . f_hat = " << (U_hat.cross(V_hat)).dot(f_hat)
//           << endl;

      double f,curr_FOV_V;
      curr_FOV_U *= PI/180;
      camerafunc::f_and_vert_FOV_from_horiz_FOV_and_aspect_ratio(
         curr_FOV_U,aspect_ratio,f,curr_FOV_V);
//      cout << "f = " << f
//           << " FOV_V = " << curr_FOV_V*180/PI << endl;

      rotation R,R1;
      R=R.rotation_taking_pqr_to_uvw(-y_hat,z_hat,-x_hat,U_hat,V_hat,W_hat);

      double frustum_az,frustum_el,frustum_roll;
      R.az_el_roll_from_rotation(frustum_az,frustum_el,frustum_roll);
//      cout << "frustum_az = " << frustum_az*180/PI
//           << " frustum_el = " << frustum_el*180/PI
//           << " frustum_roll = " << frustum_roll*180/PI << endl;

//      R1=R.rotation_from_az_el_roll(frustum_az,frustum_el,frustum_roll);

      aircraft_metadata_stream 
         << curr_frame_filename << "  "
         << elapsed_secs << "  "
         << curr_easting << "  "
         << curr_northing << "  "
         << curr_altitude << "  "
         << curr_yaw << "  "
         << curr_pitch << "  "
         << curr_roll 
         << endl;

      camera_stream 
         << curr_frame_filename << "  "
         << curr_FOV_U*180/PI << "  "
         << curr_FOV_V*180/PI << "  "
         << frustum_az*180/PI << "  "
         << frustum_el*180/PI << "  "
         << frustum_roll*180/PI << "  "
         << endl;

      databasefunc::insert_aircraft_metadata(
         postgis_database_ptr,campaign_ID,mission_ID,frame_ID,elapsed_secs,
         curr_frame_filename,curr_waypoint.get_longitude(),
         curr_waypoint.get_latitude(),curr_waypoint.get_altitude(),
         curr_yaw,curr_pitch,curr_roll);

      databasefunc::insert_camera_metadata(
         postgis_database_ptr,campaign_ID,mission_ID,frame_ID,
         curr_FOV_U*180/PI,curr_FOV_V*180/PI,
         frustum_az*180/PI,frustum_el*180/PI,frustum_roll*180/PI);

// FAKE FAKE: As of Weds, Oct 26, 2011 we won't worry about footprint
// stuff.  Instead focus upon populating aircraft and camera metadata
//   tables in FLIR database with multiple Tstorm 4.0 passes:

      continue;


// Instantiate camera and set its intrinsic plus extrinsic parameters:

      camera_ptr->set_internal_params(f,f,u0,v0);
      camera_ptr->set_UV_corners(0,2*u0,0,2*v0);
      threevector world_posn(curr_easting,curr_northing,curr_altitude);
      camera_ptr->set_world_posn(world_posn);
      camera_ptr->set_Rcamera(frustum_az,frustum_el,frustum_roll);
      camera_ptr->construct_projection_matrix(false);

// Compute Z_ground averaged over FLIR image corner ray intercepts
// with SRTM terrain:

      double numer_Z_ground=0;
      int denom_Z_ground=0;
      vector<threevector> UV_corner_world_ray=camera_ptr->
         get_UV_corner_world_ray();
      for (int c=0; c<UV_corner_world_ray.size(); c++)
      {
         threevector r_hat=UV_corner_world_ray[c];
         if (r_hat.get(2) >= 0) continue;

         geopoint aerial_point(
            cloudpass_ptr->get_northern_hemisphere_flag(),
            cloudpass_ptr->get_UTM_zonenumber(),world_posn);

         double curr_Z_ground;
         if (TilesGroup_ptr->estimate_SRTM_z_given_aerial_pt_and_ray(
            aerial_point,r_hat,curr_Z_ground))
         {
            numer_Z_ground += curr_Z_ground;
            denom_Z_ground += 1;
         }
      } // loop over index c labeling UV corner world rays
      
      if (denom_Z_ground==0) continue;
      
      double avg_Z_ground=numer_Z_ground/denom_Z_ground;

      cout.precision(4);
      int n_pixels=0;
      int n_pixels_inside_bbox=0;
      const double d_az=curr_FOV_U/n_horiz_pixels;
      const double d_el=curr_FOV_V/n_vert_pixels;

      double dP_min=POSITIVEINFINITY;
            
      double min_U=POSITIVEINFINITY;
      double max_U=NEGATIVEINFINITY;
      double min_V=POSITIVEINFINITY;
      double max_V=NEGATIVEINFINITY;

      const int pixel_skip=10;

      for (int px=0; px<n_horiz_pixels; px += pixel_skip)
      {
         double U=double(px)/double(n_vert_pixels);
         double curr_az=frustum_az+
            (double(px)/double(n_horiz_pixels)-0.5)*curr_FOV_U;
         
         for (int py=0; py<n_vert_pixels; py += pixel_skip)
         {
            double V=1-double(py)/double(n_vert_pixels);
            double curr_el=frustum_el+(V-0.5)*curr_FOV_V;

            threevector r_hat=camera_ptr->pixel_ray_direction(U,V);

            double r=(avg_Z_ground-world_posn.get(2))/r_hat.get(2);

            double dP=sqr(r)/fabs(tan(curr_el))*d_az*d_el;
            if (dP < dP_max)
            {
               n_pixels_inside_bbox++;
               min_U=basic_math::min(min_U,U);
               max_U=basic_math::max(max_U,U);
               min_V=basic_math::min(min_V,V);
               max_V=basic_math::max(max_V,V);
            }
            dP_min=basic_math::min(dP_min,dP);
            n_pixels++;
         } // loop over py index
      } // loop over px index
      
      if (n_pixels_inside_bbox > 2)
      {
//         cout << "i = " << i << " Z_ground = " << avg_Z_ground  << endl;
//         cout << "dP_min = " << dP_min 
//              << " n_pixels_inside_bbox = " << n_pixels_inside_bbox 
//              << " frac bbox pixels = "
//              << double(n_pixels_inside_bbox)/double(n_pixels)
//              << endl;
//         cout << "min_U = " << min_U << " max_U = " << max_U 
//              << " min_V = " << min_V << " max_V = " << max_V << endl;

         threevector r1_hat=camera_ptr->pixel_ray_direction(min_U,min_V);
         threevector r2_hat=camera_ptr->pixel_ray_direction(max_U,min_V);
         threevector r3_hat=camera_ptr->pixel_ray_direction(max_U,max_V);
         threevector r4_hat=camera_ptr->pixel_ray_direction(min_U,max_V);

         double lambda1=(avg_Z_ground-world_posn.get(2))/(r1_hat.get(2));
         threevector g1=world_posn+lambda1*r1_hat;
         geopoint lower_left(
            cloudpass_ptr->get_northern_hemisphere_flag(),
            cloudpass_ptr->get_UTM_zonenumber(),g1);

         double lambda2=(avg_Z_ground-world_posn.get(2))/(r2_hat.get(2));
         threevector g2=world_posn+lambda2*r2_hat;
         geopoint lower_right(
            cloudpass_ptr->get_northern_hemisphere_flag(),
            cloudpass_ptr->get_UTM_zonenumber(),g2);

         double lambda3=(avg_Z_ground-world_posn.get(2))/(r3_hat.get(2));
         threevector g3=world_posn+lambda3*r3_hat;
         geopoint upper_right(
            cloudpass_ptr->get_northern_hemisphere_flag(),
            cloudpass_ptr->get_UTM_zonenumber(),g3);

         double lambda4=(avg_Z_ground-world_posn.get(2))/(r4_hat.get(2));
         threevector g4=world_posn+lambda4*r4_hat;
         geopoint upper_left(
            cloudpass_ptr->get_northern_hemisphere_flag(),
            cloudpass_ptr->get_UTM_zonenumber(),g4);

         footprint_Z=basic_math::max(footprint_Z,g1.get(2));
         footprint_Z=basic_math::max(footprint_Z,g2.get(2));
         footprint_Z=basic_math::max(footprint_Z,g3.get(2));
         footprint_Z=basic_math::max(footprint_Z,g4.get(2));
         
         cout.precision(12);
//         cout << "lower left = " << lower_left.get_longitude()
//              << " , " << lower_left.get_latitude() << endl;
//         cout << "lower right = " << lower_right.get_longitude()
//              << " , " << lower_right.get_latitude() << endl;
//         cout << "upper right = " << upper_right.get_longitude()
//              << " , " << upper_right.get_latitude() << endl;
//         cout << "upper left = " << upper_left.get_longitude()
//              << " , " << upper_left.get_latitude() << endl;
//         cout << endl;

         vector<threevector> footprint_vertices;
         footprint_vertices.push_back(g1);
         footprint_vertices.push_back(g2);
         footprint_vertices.push_back(g3);
         footprint_vertices.push_back(g4);
         polygon curr_footprint(footprint_vertices);
         
         vector<polygon> new_footprint_polygons=geometry_func::polygon_union(
            curr_footprint,footprint_polygons);
         footprint_polygons.clear();
         footprint_polygons=new_footprint_polygons;
         new_footprint_polygons.clear();
         
//         cout << "footprint_polygons.size() = " << footprint_polygons.size()
//              << endl;
      } // n_pixels_inside_bbox > 2 conditional
   } // loop over index i labeling waypoints
   cout << endl;

   delete camera_ptr;

   filefunc::closefile(aircraft_metadata_filename,aircraft_metadata_stream);
   filefunc::closefile(camera_metadata_filename,camera_stream);

   banner="Aircraft metadata written to "+aircraft_metadata_filename;
   outputfunc::write_big_banner(banner);
   banner="Camera metadata written to "+camera_metadata_filename;
   outputfunc::write_big_banner(banner);

// Export footprint vertices to output textfiles:

   string footprint_subdir="./footprints/";
   filefunc::dircreate(footprint_subdir);
   filefunc::purge_files_in_subdir(footprint_subdir);

   cout << "Number footprint polygons = " << footprint_polygons.size() << endl;

   for (int f=0; f<footprint_polygons.size(); f++)
   {
      polygon curr_poly=footprint_polygons[f];
      string output_filename=footprint_subdir+
         "footprint_"+stringfunc::integer_to_string(f,3)+".dat";
      ofstream outstream;
      filefunc::openfile(output_filename,outstream);
      outstream.precision(12);

      cout << "Footprint f = " << f
           << " n_vertices = " << curr_poly.get_nvertices() << endl;
      
      for (int v=0; v<curr_poly.get_nvertices(); v++)
      {
         threevector curr_vertex=curr_poly.get_vertex(v);
         outstream << curr_vertex.get(0) << "  "
                   << curr_vertex.get(1) << "  "
                   << footprint_Z << endl;
      } // loop over v labeling current polygon vertices

      filefunc::closefile(output_filename,outstream);
   } // loop over index f labeling footprint polygons

   banner="Footprint metadata for dP_max = "+
      stringfunc::number_to_string(dP_max)+" written to "+footprint_subdir;
   outputfunc::write_big_banner(banner);
   
}


