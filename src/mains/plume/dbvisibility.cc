// ========================================================================
// Program DBVISIBILITY is a simplified version of DBVOLUME.  It reads
// in calibration parameters for N <= 10 fixed tripod cameras from the
// sensors table of the PLUME database.  DBVISIBILITY also imports and
// thresholds temporally composited masks generated by program
// TEMPORAL_COMPOSITES.  The thresholded temporal composites are
// output as JPG files.

// DBVISIBILITY instantiates a VolumetricCoincidenceProcessor volume
// whose lateral dimensions are initially set by the cameras'
// positions.  DBVISIBILITY iterates over all voxels within the VCP
// volume and projects each into all cameras' image planes.  If the
// voxel falls inside some minimal number of cameras image planes, it
// is marked with a "detection probability" value proportional to that
// number.

// DBVISIBILITY generates an OpenSceneGraph OSGA file for the point
// cloud associated with all of the marked voxels.  The OSGA file can
// be viewed on the G47 laptop via the VIEWPOINTS program:

// 		       viewpoints visible_hull.osga

// Within the VIEWPOINTS viewer, press "c" to change point coloring
// from the default Z (height) channel to the P (probability)
// channel. The volumes which can be seen by 10, 9, 8, 7 and 6 tripod
// cameras then appear as dark red, light red, dark orange, light
// orange and yellow regions in the 3D map.

// 		./dbvisibility --GIS_layer ./packages/plume_metadata.pkg 

// ========================================================================
// Last updated on 7/12/12; 1/14/13; 1/16/13; 1/28/13
// ========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "geometry/bounding_box.h"
#include "video/camera.h"
#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "postgres/plumedatabasefuncs.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"
#include "coincidence_processing/VolumetricCoincidenceProcessor.h"

#include "general/outputfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::map;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

   int cloudpass_ID=passes_group.get_curr_cloudpass_ID();
   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();

// Instantiate postgis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_db_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(
         passes_group,GISlayer_IDs);
//   cout << "postgis_db_ptr = " << postgis_db_ptr << endl;

   int mission_ID=4;
   cout << "Enter mission ID:" << endl;
   cin >> mission_ID;

   int fieldtest_ID=plumedatabasefunc::retrieve_fieldtest_ID_given_mission_ID(
      postgis_db_ptr,mission_ID);
//   cout << "fieldtest_ID = " << fieldtest_ID << endl;

   string start_timestamp;
   plumedatabasefunc::retrieve_fieldtest_metadata_from_database(
      postgis_db_ptr,fieldtest_ID,start_timestamp);
//   cout << "start_timestamp = " << start_timestamp << endl;
   Clock clock;
   cout.precision(13);

   bool UTC_flag=true;
   double epoch=
      clock.timestamp_string_to_elapsed_secs(start_timestamp,UTC_flag);
   int year=clock.get_year();
   string month_name=clock.get_month_name();

   int day_number;
   string experiment_label;
   plumedatabasefunc::retrieve_mission_metadata_from_database(
      postgis_db_ptr,fieldtest_ID,mission_ID,
      day_number,experiment_label);

   string experiment_subdir="/data/ImageEngine/plume/";
   experiment_subdir += month_name+stringfunc::number_to_string(year)+"/Day";
   experiment_subdir += stringfunc::number_to_string(day_number)+"/"+
      experiment_label+"/";
//   cout << "experiment_subdir = " << experiment_subdir << endl;

   string packages_subdir=experiment_subdir+"packages/";
   filefunc::dircreate(packages_subdir);

   string results_subdir=bundler_IO_subdir+"plume_results/";
   results_subdir += stringfunc::number_to_string(day_number)+
      experiment_label+"/";
   cout << "results_subdir = " << results_subdir << endl;
   filefunc::dircreate(results_subdir);
   string temporal_composites_subdir=results_subdir+"temporal_composites/";
   filefunc::dircreate(temporal_composites_subdir);

//   int max_n_unseen_masks=2;
   int max_n_unseen_masks=4;
   cout << "Maximum number of camera masks NOT seen by candidate voxels:" 
        << endl;
   cin >> max_n_unseen_masks;

// Read tripod camera info from sensors table of plume database:

   vector<int> camera_ID;
   vector<double> focal_param,u0,v0,azimuth,elevation,roll;
   vector<double> x_posn,y_posn,z_posn;
   plumedatabasefunc::retrieve_camera_metadata_from_database(
      postgis_db_ptr,mission_ID,
      camera_ID,focal_param,u0,v0,azimuth,elevation,roll,
      x_posn,y_posn,z_posn);

   double camera_delta_z=0;
//   cout << "camera_delta_z in meters:" << endl;
//   cin >> camera_delta_z;
   
// Instantiate tripod cameras:

   int n_cameras=camera_ID.size();	// n_cameras = 10
   bounding_box bbox;
   vector<camera*> camera_ptrs;
   for (int i=0; i<n_cameras; i++)
   {
      camera* camera_ptr=new camera();
      camera_ptrs.push_back(camera_ptr);
      
      camera_ptr->set_internal_params(
         focal_param[i],focal_param[i],u0[i],v0[i]);
      camera_ptr->set_UV_corners(0,2*u0[i],0,2*v0[i]);
      camera_ptr->set_rel_az(azimuth[i]);
      camera_ptr->set_rel_el(elevation[i]);
      camera_ptr->set_rel_roll(roll[i]);

      double z_camera=z_posn[i]+camera_delta_z;
      camera_ptr->set_world_posn(threevector(x_posn[i],y_posn[i],z_camera));
//      camera_ptr->set_world_posn(threevector(x_posn[i],y_posn[i],z_posn[i]));
      camera_ptr->construct_projection_matrix();

      camera_ptr->compute_fields_of_view(2*u0[i],0,2*v0[i],0);
      bbox.update_bounds(camera_ptr->get_world_posn());
//      cout << "i = " << i << " camera = " << *camera_ptr << endl;
   }
//   cout << "bbox = " << bbox << endl;

   int camera_ID_offset=-1;
   vector<texture_rectangle*> temporal_composite_texture_rectangle_ptrs;
   if (fieldtest_ID==1)
   {
      camera_ID_offset=17;
   }
   else if (fieldtest_ID==2)
   {
      camera_ID_offset=1;

// Import temporal composite masks generated by program TEMPORAL_COMPOSITES:

      for (int m=0; m<n_cameras; m++)
      {
         int camera_ID=m+camera_ID_offset;
         string temporal_composite_filename=temporal_composites_subdir+
            "temporal_composite_"+stringfunc::integer_to_string(camera_ID,2)
            +".jpg";

         texture_rectangle* texture_rectangle_ptr=
            new texture_rectangle(temporal_composite_filename,NULL);
         temporal_composite_texture_rectangle_ptrs.push_back(
            texture_rectangle_ptr);

// Convert temporally composited masks from hsv to greyscale.  Reset
// any "cold" entry in *texture_rectangle_ptr to black:

         double hue_threshold=120;	// green
         double value_threshold=0.5;
         int width=texture_rectangle_ptr->getWidth();
         int height=texture_rectangle_ptr->getHeight();

         int R,G,B;
         double h,s,v,r,g,b;
         for (int py=0; py<height; py++)
         {
            for (int px=0; px<width; px++)
            {
               texture_rectangle_ptr->get_pixel_hsv_values(px,py,h,s,v);

// On 1/16/13, we empirically found that some "red" hue values range
// around 358-360.  So we add a small fudge to h and then reset hue
// values to range from 0 to 360:

               h += 2;
               h=basic_math::phase_to_canonical_interval(h,0,360);

               R=G=B=0;
               if (h < hue_threshold && v > value_threshold)
               {
                  colorfunc::hsv_to_RGB(h,s,v,r,g,b);
                  R=255*r;
                  G=255*g;
                  B=255*b;
               }
               texture_rectangle_ptr->set_pixel_RGB_values(px,py,R,G,B);
            } // loop over px index
         } // loop over py index

// Export thresholded version of temporally composited mask:

         string thresholded_temporal_composite_filename=
            temporal_composites_subdir+
            "thresholded_temporal_composite_"+stringfunc::integer_to_string(
               camera_ID,2)+".jpg";
         texture_rectangle_ptr->write_curr_frame(
            thresholded_temporal_composite_filename);

         string banner="Exported thresholded temporal composite to "
            +thresholded_temporal_composite_filename;
         outputfunc::write_big_banner(banner);

      } // loop over index m labeling cameras

   } // fieldtest_ID conditional

   int n_photos=n_cameras;

   double xmin=bbox.get_xmin();
   double xmax=bbox.get_xmax();
   double ymin=bbox.get_ymin();
   double ymax=bbox.get_ymax();
   double zmin=0;
//   double zmax=5;	// meters  small plume expt 2B
//   double zmax=25;	// meters  (OK for big plume expt 5C)
   double zmax=15;	// meters  (OK for Nov 2012 Expt 2H)

//   double voxel_binsize=0.025; // meter  
   double voxel_binsize=0.1;	 // meter  (OK for big plume events)
   double voxel_volume=voxel_binsize*voxel_binsize*voxel_binsize;

   VolumetricCoincidenceProcessor* VCP_ptr=NULL;
   double plume_volume=-1;

// ========================================================================
// Perform first round of smoke plume volume determination using
// coarse steps through VCP lattice.  After refining XYZ_min and
// XYZ_max, recompute plume volume using fine steps through smaller
// VPC lattice.

   int n_iters=2;
   int mstep=5;
   int nstep=5;
   int pstep=5;

   for (int iter=0; iter < n_iters; iter++)
   {
      if (iter > 0)
      {
         mstep=nstep=pstep=1;
      }

      string banner="Iteration "+stringfunc::number_to_string(iter)+
         " : mstep=nstep=pstep="+stringfunc::number_to_string(mstep);
      outputfunc::write_big_banner(banner);

// Instantiate VCP to hold 3D voxel lattice:

      delete VCP_ptr;
      VCP_ptr=new VolumetricCoincidenceProcessor();

      threevector XYZ_min(xmin,ymin,zmin);
      threevector XYZ_max(xmax,ymax,zmax);
      cout << "XYZ_min = " << XYZ_min << " XYZ_max = " << XYZ_max << endl;
      
      VCP_ptr->initialize_coord_system(XYZ_min,XYZ_max,voxel_binsize);
      cout << "VCP = " << *VCP_ptr << endl;

      xmin=POSITIVEINFINITY;
      xmax=NEGATIVEINFINITY;
      ymin=POSITIVEINFINITY;
      ymax=NEGATIVEINFINITY;
      zmin=POSITIVEINFINITY;
      zmax=NEGATIVEINFINITY;

      int mdim=VCP_ptr->get_mdim();
      int ndim=VCP_ptr->get_ndim();
      int pdim=VCP_ptr->get_pdim();
      int n_voxels=mdim*ndim*pdim;

// Iterate over all voxels in *VCP_ptr.  Project each voxel into all
// tripod cameras' image planes.  Mark those voxels whose projections
// land inside some specified number of image plane mask:

      int n_rejected_voxels=0;
      int R,G,B;
      double u,v;
      threevector voxel_posn;
      for (int m=0; m<mdim; m += mstep)
      {
         outputfunc::update_progress_fraction(m,0.05*mdim,mdim);
         double x=VCP_ptr->m_to_x(m);
         voxel_posn.put(0,x);
         for (int n=0; n<ndim; n += nstep)
         {
            double y=VCP_ptr->n_to_y(n);
            voxel_posn.put(1,y);

            for (int p=0; p<pdim; p += pstep)
            {
               double z=VCP_ptr->p_to_z(p);
               voxel_posn.put(2,z);

// Create STL vector containing boolean indicators for antipodal
// camera pairs:

               vector<int> antipodal_pairs;
               for (int ap=0; ap<5; ap++)
               {
                  antipodal_pairs.push_back(0);
               }

// FAKE FAKE:  Weds Jan 4, 2012 at 9:44 am
// Hardwire n_photos to 1 for viewgraph purposes only!!!

//                  n_photos=1;
//                  n_photos=2;
//                  n_photos=3;

               int n_seen_masks=0;
               bool reject_voxel_flag=false;
               for (int c=0; c<n_photos && !reject_voxel_flag; c++)
               {
                  int antipodal_pair_ID=modulo(c,5);
                  camera* camera_ptr=camera_ptrs.at(c);

// Make sure threevector(x,y,z) lies in front of camera!

                  if (!camera_ptr->XYZ_in_front_of_camera(x,y,z)) 
                  {
                     reject_voxel_flag=true;
                     continue;
                  }

                  camera_ptr->project_XYZ_to_UV_coordinates(x,y,z,u,v);

// Make sure (U,V) lies within camera's image plane!

                  if (!camera_ptr->get_UV_bbox_ptr()->point_inside(u,v)) 
                  {
                     reject_voxel_flag=true;
                     continue;
                  }

// As of 1/16/13, we require U,V to land on a non-null entry within
// temporal_composite_texture_rectangle:
                  

                  if (temporal_composite_texture_rectangle_ptrs.size() > 0)
                  {
                     int R,G,B;
                     temporal_composite_texture_rectangle_ptrs[c]->
                        get_RGB_values(u,v,R,G,B);
//                     if (R==0 && G==0 && B==0) 
                     if (R < 10 && G < 10 && B < 10) 
                     {
                        n_rejected_voxels++;
                        reject_voxel_flag=true;
                        continue;
                     }
                  }
                
                  n_seen_masks++;
                  antipodal_pairs[antipodal_pair_ID]=1;

               } // loop over index c labeling cameras

               if (reject_voxel_flag) continue;

/*
// Count number of antipodal camera pairs that observed the current
// voxel.  If the number exceeds a specified threshold, declare the
// voxel to contain smoke:

               int antipodal_pairs_integral=0;
               for (int ap=0; ap<5; ap++)
               {
                  antipodal_pairs_integral += antipodal_pairs[ap];
               }

               const double antipodal_camera_pairs_threshold=5;
               if (antipodal_pairs_integral < 
               antipodal_camera_pairs_threshold) 
               {
                  n_rejected_voxels++;
                  continue;
               }
*/

               if (n_seen_masks < n_photos-max_n_unseen_masks)
               {
                  n_rejected_voxels++;
                  continue;
               }
               
               VCP_ptr->set_voxel_prob(m,n,p,0.1*n_seen_masks);

               xmin=basic_math::min(xmin,x);
               xmax=basic_math::max(xmax,x);
               ymin=basic_math::min(ymin,y);
               ymax=basic_math::max(ymax,y);
               zmin=basic_math::min(zmin,z);
               zmax=basic_math::max(zmax,z);

            } // loop over index p
         } // loop over index n
      } // loop over index m
      cout << endl;

      plume_volume=VCP_ptr->size()*voxel_volume;
         
      cout << "VCP frac = " << double(VCP_ptr->size())/double(n_voxels)
           << " plume volume = " << plume_volume << endl;

      cout << "n_rejected_voxels = " << n_rejected_voxels << endl;
      double rejected_voxel_frac=
         double(n_rejected_voxels*mstep*nstep*pstep)/
         double(mdim*ndim*pdim);
      cout << "rejected_voxel_frac = " << rejected_voxel_frac << endl;

//      VCP_ptr->renormalize_counts_into_probs();
//      cout << "VCP = " << *VCP_ptr << endl;

   } // loop over iter index

// ========================================================================   

// Ignore visibility plume volume if it is very small:

   const double min_plume_volume=0.01;	// meter**2
   if (plume_volume < min_plume_volume) 
   {
      cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
      cout << "Negligibly small plume reconstructed " << endl;
      cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
      exit(-1);
   }

// Write out XYZP point cloud to TDP and OSGA files.  Calculate
// plume's total volume as product of its number of non-zero voxels
// times voxel_volume:

   double min_prob_threshold=0;
//   bool perturb_voxels_flag=false;
   bool perturb_voxels_flag=true;
   vector<double>* X_ptr=new vector<double>;
   vector<double>* Y_ptr=new vector<double>;
   vector<double>* Z_ptr=new vector<double>;
   vector<double>* P_ptr=new vector<double>;

   int npoints=VCP_ptr->size();
   X_ptr->reserve(npoints);
   Y_ptr->reserve(npoints);
   Z_ptr->reserve(npoints);
   P_ptr->reserve(npoints);

   VCP_ptr->retrieve_XYZP_points(
      X_ptr,Y_ptr,Z_ptr,P_ptr,min_prob_threshold,perturb_voxels_flag);

   cout << "npoints = " << npoints << endl;
   cout << "Z_ptr->size() = " << Z_ptr->size() << endl;
   cout << "Total plume volume = " << Z_ptr->size() * voxel_volume
        << " m**3 " << endl;
//   cout << "VCP volume frac = " << double(VCP_ptr->size())/double(n_voxels)
//        << endl;

// Generate and export distribution function for *P_ptr:

   int n_output_bins=100;
   prob_distribution prob_P(*P_ptr,n_output_bins);
   prob_P.set_xmin(0);
   prob_P.set_xlabel("Voxel 'smokiness'");
   prob_P.writeprobdists(false);

// Write TDP & OSGA files containing XYZP points for 3D hull:

   string tdp_filename=bundler_IO_subdir+"visible_hull.tdp";
   tdpfunc::write_xyzp_data(
      tdp_filename,"",Zero_vector,X_ptr,Y_ptr,Z_ptr,P_ptr);
   delete X_ptr;
   delete Y_ptr;
   delete Z_ptr;
   delete P_ptr;

   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv ./visible_hull.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);

   string osga_filename=bundler_IO_subdir+"visible_hull.osga";
   string banner="Exported visibility hull to "+osga_filename;
   outputfunc::write_big_banner(banner);
}
