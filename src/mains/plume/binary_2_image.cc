// ==========================================================================
// Program BINARY_2_IMAGE reads in bzipped files generated by
// CSV_2_BINARY which compresses change-detection masks from CSV to a
// quantized binary format.  It parses each binary file and exports a
// corresponding JPG.  
// ==========================================================================
// Last updated on 11/28/12; 11/30/12; 1/10/13
// ==========================================================================

#include  <iostream>
#include  <string>
#include  <vector>

#include "image/arrayfuncs.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "video/texture_rectangle.h"
#include "image/TwoDarray.h"

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::ofstream;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(12);

   string subdir="./";
   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("bz2");
   allowed_suffixes.push_back("bin");

   vector<string> input_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,subdir);

   for (int i=0; i<input_filenames.size(); i++)
   {
      string mask_filename=filefunc::getbasename(input_filenames[i]);
      string input_filename=mask_filename;
      if (stringfunc::suffix(mask_filename)=="bz2")
      {
         filefunc::bunzip2_file(mask_filename);
         input_filename=stringfunc::prefix(mask_filename);
      }
//      cout << "input_filename = " << input_filename << endl;

      string banner="Converting binary file "+input_filename
         +" to image format";
      outputfunc::write_banner(banner);

      short xdim,ydim;
      ifstream binary_instream;
      filefunc::open_binaryfile(input_filename,binary_instream);
      filefunc::readobject(binary_instream,xdim);
      filefunc::readobject(binary_instream,ydim);
      cout << "xdim = " << xdim << " ydim = " << ydim << endl;

      twoDarray* ptwoDarray_ptr=new twoDarray(xdim,ydim);
      ptwoDarray_ptr->clear_values();

      double q_min=0;
      double q_max=50;

      short q_short;
      double min_p=1;
      double max_p=-1;

      for (int py=0; py<ydim; py++)
      {
         for (int px=0; px<xdim; px++)
         {
            filefunc::readobject(binary_instream,q_short);
            double q=0.1*q_short;
            double curr_p=(q-q_min)/(q_max-q_min);
//            cout << "q = " << q << " curr_p = " << curr_p << endl;

            min_p=basic_math::min(min_p,curr_p);
            max_p=basic_math::max(max_p,curr_p);

            curr_p=basic_math::min(curr_p,1.0);
            curr_p=basic_math::max(curr_p,0.0);
            ptwoDarray_ptr->put(px,py,curr_p);
         }
      }
      binary_instream.close();
      filefunc::bzip2_file(input_filename);
//      cout << "min_p = " << min_p << " max_p = " << max_p << endl;

      int n_channels=3;
      texture_rectangle* texture_rectangle_ptr=
         new texture_rectangle(xdim,ydim,1,n_channels,NULL);
      texture_rectangle_ptr->initialize_RGB_twoDarray_image(ptwoDarray_ptr);
      texture_rectangle_ptr->fill_twoDarray_image(ptwoDarray_ptr,n_channels);
      delete ptwoDarray_ptr;

//      string greys_image_filename="grey.jpg";
//      texture_rectangle_ptr->write_curr_frame(greys_image_filename);

      texture_rectangle_ptr->convert_grey_values_to_hues();

      string prefix=stringfunc::prefix(input_filename);
      string color_image_filename=prefix+".jpg";
      texture_rectangle_ptr->write_curr_frame(color_image_filename);
      delete texture_rectangle_ptr;

   } // loop over index i labeling input binary compressed files

}

