// ==========================================================================
// Program INTERP_MISSING_SLICES imports the volumes_vs_timeslice.txt
// file generated by program CALC_VOLUMES.  It searches for missing
// reconstructions at isolated time slices.  (For example, if too few
// tripod camera masks exist at some timeslice, then no 3D volume
// reconstruction can be performed.)  INTERP_MISSING_SLICES performs
// piecewise linear interpolation to estimate missing time slice plume
// volumes.  It also links a missing OSGA file at time_slice t to an
// existing OSGA file at time_slice t-1.  
// ==========================================================================
// Last updated on 8/1/12; 8/2/12
// ==========================================================================

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "filter/piecewise_linear.h"
#include "postgres/plumedatabasefuncs.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

   string pwd=filefunc::get_pwd();
   bundler_IO_subdir=pwd+bundler_IO_subdir.substr(
      2,bundler_IO_subdir.size()-2);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

   int cloudpass_ID=passes_group.get_curr_cloudpass_ID();
   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();

// Instantiate postgis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_db_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(
         passes_group,GISlayer_IDs);
//   cout << "postgis_db_ptr = " << postgis_db_ptr << endl;

   int fieldtest_ID=1;
   string start_timestamp;
   plumedatabasefunc::retrieve_fieldtest_metadata_from_database(
      postgis_db_ptr,fieldtest_ID,start_timestamp);
   cout << "start_timestamp = " << start_timestamp << endl;
   Clock clock;
   cout.precision(13);

   bool UTC_flag=true;
   double epoch=
      clock.timestamp_string_to_elapsed_secs(start_timestamp,UTC_flag);
   int year=clock.get_year();
   string month_name=clock.get_month_name();

   int mission_ID=4;
   cout << "Enter mission ID:" << endl;
   cin >> mission_ID;

   int day_number;
   string experiment_label;
   plumedatabasefunc::retrieve_mission_metadata_from_database(
      postgis_db_ptr,fieldtest_ID,mission_ID,
      day_number,experiment_label);

   string results_subdir=bundler_IO_subdir+"plume_results/";
   results_subdir += stringfunc::number_to_string(day_number)+
      experiment_label+"/";
//   cout << "results_subdir = " << results_subdir << endl;

   string plume_volume_filename=results_subdir+"volumes_vs_timeslice.txt";
//   cout << "plume_volume_filename = "
//        << plume_volume_filename << endl;
   filefunc::ReadInfile(plume_volume_filename);


   vector<int> slice_numbers;
   vector<double> volumes;
   vector<twovector> slice_volumes;
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);
      slice_numbers.push_back(column_values[0]);
      volumes.push_back(column_values[1]);
//      cout << "i = " << i 
//           << " slice = " << slice_numbers.back()
//           << " volume = " << volumes.back()
//           << endl;
      slice_volumes.push_back(twovector(slice_numbers.back(),volumes.back()));
   }

   int starting_slice_number=slice_numbers.front();
   int stopping_slice_number=slice_numbers.back();
   int n_slices=stopping_slice_number-starting_slice_number+1;
//   cout << "n_slices = " << n_slices << endl;

// Create soft-links from any missing OSGA file to the existing
// preceding OSGA file:

   string prev_osga_filename="";
   for (int slice_number=starting_slice_number; slice_number <=
           stopping_slice_number; slice_number++)
   {
      string basename="plume_hull_"+stringfunc::integer_to_string(
         slice_number,3)+".osga";
      string osga_filename=results_subdir+basename;
//      cout << "osga_filename = " << osga_filename << endl;
      if (!filefunc::fileexist(osga_filename))
      {
         string unix_cmd="ln -s "+prev_osga_filename+" "+osga_filename;
//         cout << "unix_cmd = " << unix_cmd << endl;
         cout << endl;
         cout << "Linking missing time slice OSGA file "+osga_filename+" to"
              << endl;
         cout << prev_osga_filename << endl;
         sysfunc::unix_command(unix_cmd);
      }
      prev_osga_filename=osga_filename;
   } // loop over slice_number 
   
// Perform piecewise linear interpolation of volumes for missing time
// slice reconstructions:

//   bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   results_subdir=bundler_IO_subdir+"plume_results/";

   cout << "results_subdir = " << results_subdir << endl;

   ofstream interp_stream;
   string interp_filename=results_subdir+"interp_volumes_vs_timeslice.txt";
   filefunc::openfile(interp_filename,interp_stream);
   interp_stream << "# Timeslice  Reconstructed plume volume (m**3)" << endl;
   interp_stream << endl;

   piecewise_linear pl(slice_volumes);
   for (int t=starting_slice_number; t<=stopping_slice_number; t++)
   {
      interp_stream << t << "  " << pl.value(t) << endl;
   }
   filefunc::closefile(interp_filename,interp_stream);
   string banner="Interpolated volumes vs time slices exported to "+
      interp_filename;
   outputfunc::write_big_banner(banner);


}
