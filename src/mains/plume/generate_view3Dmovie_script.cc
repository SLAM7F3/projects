// ==========================================================================
// Program GENERATE_VIEW3DMOVIE_SCRIPT recovers the starting UTC time
// for the first OSGA file generated by program DBVOLUME from the
// photos table in the plume database.  It exports an executable
// script which needs to be run in order to view the reconstructed
// "t>0" plume volumes as 3D point clouds evolving over time.  
// ==========================================================================
// Last updated on 8/1/12; 8/2/12; 1/22/13
// ==========================================================================

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "postgres/plumedatabasefuncs.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

   int cloudpass_ID=passes_group.get_curr_cloudpass_ID();
   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();

// Instantiate postgis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_db_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(
         passes_group,GISlayer_IDs);
//   cout << "postgis_db_ptr = " << postgis_db_ptr << endl;

   int mission_ID=22;
   cout << "Enter mission ID:" << endl;
   cin >> mission_ID;

   int fieldtest_ID=plumedatabasefunc::retrieve_fieldtest_ID_given_mission_ID(
      postgis_db_ptr,mission_ID);
//   cout << "fieldtest_ID = " << fieldtest_ID << endl;

   string start_timestamp;
   plumedatabasefunc::retrieve_fieldtest_metadata_from_database(
      postgis_db_ptr,fieldtest_ID,start_timestamp);
//   cout << "start_timestamp = " << start_timestamp << endl;
   Clock clock;
   cout.precision(13);

   bool UTC_flag=true;
   double epoch=
      clock.timestamp_string_to_elapsed_secs(start_timestamp,UTC_flag);
   int year=clock.get_year();
   string month_name=clock.get_month_name();

   int day_number;
   string experiment_label;
   plumedatabasefunc::retrieve_mission_metadata_from_database(
      postgis_db_ptr,fieldtest_ID,mission_ID,
      day_number,experiment_label);

   string packages_subdir=bundler_IO_subdir+"packages/";
//   cout << "packages_subdir = " << packages_subdir << endl;


   string results_subdir=bundler_IO_subdir+"plume_results/";
   results_subdir += stringfunc::number_to_string(day_number)+
      experiment_label+"/";
   cout << "results_subdir = " << results_subdir << endl;

   string TDP_subdir=results_subdir+"TDP/";
   cout << "TDP_subdir = " << TDP_subdir << endl;

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("tdp");
   vector<string> tdp_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,TDP_subdir);

   vector<int> time_slice_numbers;
   for (int t=0; t<tdp_filenames.size(); t++)
   {
//      cout << "t = " << t << " tdp_filename = " << tdp_filenames[t]
//           << endl;
      string basename=filefunc::getbasename(tdp_filenames[t]);
      string prefix=stringfunc::prefix(basename);
//      cout << "prefix = " << prefix << endl;
      string substring=prefix.substr(11,3);
//      cout << "substring = " << substring << endl;
      time_slice_numbers.push_back(stringfunc::string_to_number(substring));
//      cout << "time_slice_number = " << time_slice_numbers.back() << endl;
   }

   std::sort(time_slice_numbers.begin(),time_slice_numbers.end());

   int starting_slice_number=time_slice_numbers.front();
   cout << "starting_slice_number = "
        << starting_slice_number << endl;
   int stopping_slice_number=time_slice_numbers.back();
   int n_slices=stopping_slice_number-starting_slice_number+1;
   cout << "n_slices = " << n_slices << endl;

   double starting_epoch_time=
      plumedatabasefunc::retrieve_slice_epoch_time_from_database(
         postgis_db_ptr,fieldtest_ID,mission_ID,starting_slice_number);
   double stopping_epoch_time=starting_epoch_time+n_slices;

   int n_cameras=10;
   int camera_ID_offset=-1;
   string tripod_prefix;
   if (fieldtest_ID==1)
   {
      tripod_prefix="tripod";
      camera_ID_offset=17;
   }
   else if (fieldtest_ID==2)
   {
      tripod_prefix="video_tripod";
      camera_ID_offset=1;
   }

   string script_filename="run_dbview3Dmovie";
   ofstream scriptstream;
   filefunc::openfile(script_filename,scriptstream);

   double max_z_threshold=-1;
   if (fieldtest_ID==1)
   {
      max_z_threshold=3;
   }
   else if (fieldtest_ID==2)
   {
      max_z_threshold=13;
   }

   scriptstream << "./dbview3Dmovie \\" << endl;
   scriptstream << results_subdir+"plume_hull*.osga \\" << endl;
   scriptstream << "--prob_colormap 7 \\" << endl;
   scriptstream << "--min_z_threshold 0 --max_z_threshold "+
      stringfunc::number_to_string(max_z_threshold)+" \\" << endl;
   scriptstream << "--region_filename "+packages_subdir
      +tripod_prefix+"_"+stringfunc::integer_to_string(camera_ID_offset,2)
      +".pkg \\" << endl;
   for (int c=0; c<n_cameras; c++)
   {
      int tripod_ID=c+camera_ID_offset;
      scriptstream << "--region_filename "+packages_subdir+tripod_prefix+"_"
         +stringfunc::integer_to_string(tripod_ID,2)+".pkg \\" << endl;
   }
   
   scriptstream << "--GIS_layer ./packages/plume_metadata.pkg \\" 
                << endl;
   scriptstream << "--image_list_filename "+bundler_IO_subdir
      +"image_list.dat  \\" << endl;
   scriptstream << "--image_sizes_filename "+bundler_IO_subdir
      +"image_sizes.dat  \\" << endl;

   clock.convert_elapsed_secs_to_date(starting_epoch_time);
   year=clock.get_year();
   int month=clock.get_month();
   int day=clock.get_day();
   int hour=clock.get_UTC_hour();
   int minute=clock.get_minute();
   double seconds=clock.get_seconds();
   
   scriptstream << "--world_start_UTC "+
      stringfunc::number_to_string(year)+","+
      stringfunc::number_to_string(month)+","+
      stringfunc::number_to_string(day)+","+
      stringfunc::number_to_string(hour)+","+
      stringfunc::number_to_string(minute)+","+
      stringfunc::number_to_string(seconds,2)+" \\" << endl;

   clock.convert_elapsed_secs_to_date(stopping_epoch_time);
   year=clock.get_year();
   month=clock.get_month();
   day=clock.get_day();
   hour=clock.get_UTC_hour();
   minute=clock.get_minute();
   seconds=clock.get_seconds();

   scriptstream << "--world_stop_UTC "+
      stringfunc::number_to_string(year)+","+
      stringfunc::number_to_string(month)+","+
      stringfunc::number_to_string(day)+","+
      stringfunc::number_to_string(hour)+","+
      stringfunc::number_to_string(minute)+","+
      stringfunc::number_to_string(seconds,2)+" \\" << endl;

   scriptstream << "--world_time_step 1.0 \\" << endl;
   scriptstream << "--initial_mode Run_Movie_Mode " << endl;

   filefunc::closefile(script_filename,scriptstream);

   string unix_cmd="chmod a+x "+script_filename;
   sysfunc::unix_command(unix_cmd);
   string banner="Wrote executable script "+script_filename;
   outputfunc::write_big_banner(banner);

}
