// ==========================================================================
// Program GEOREGISTER_CAMERAS reads in reconstructed tripod camera
// posns generated by Noah Snavely's BUNDLER program in some arbitrary
// 3D coordinate system.  It also reads in the text file
// bundler_IO_subdir/measured_camera_posns.dat containing surveyed
// locations for the tripod cameras generated by program
// SURVEY_CAMERA_POSNS.  A modified version of
// measured_camera_posns.dat called modified_measured_camera_posns.dat
// is generated which has the same tripod camera ID multiplicity as
// bundler_IO_subdir/unfitted_reconstructed_camera_posns.dat.  This
// program does NOT alter any of the surveyed camera position vectors!

// GEOREGISTER_CAMERAS next computes the global rotation, translation
// and scaling needed to transform bundler into real-world coordinates.
// It overwrites the trivially-valued parameters in
// bundler_IO_subdir/packages/peter_inputs.pkg with a new version
// containing the global transformation parameters needed to convert
// from bundler's arbitrary coordinate system to the surveyed
// coordinate system.

// georegister_cameras --region_filename ./bundler/plume/Nov_2011/BC_rovers_ABC_tripods/packages/peter_inputs.pkg

// georegister_cameras --region_filename ./bundler/plume/Nov_2011/earth/all_rovers_fixed_tripods/packages/peter_inputs.pkg

// ==========================================================================
// Last updated on 4/27/12; 9/11/12; 9/13/12; 12/17/13
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "bundler/bundlerfuncs.h"
#include "math/constant_vectors.h"
#include "general/filefuncs.h"
#include "math/fourvector.h"
#include "passes/PassesGroup.h"
#include "math/rotation.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "math/threevector.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(10);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   string image_list_filename=passes_group.get_image_list_filename();
   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string bundle_filename=bundler_IO_subdir+"bundle.out";

   string unfitted_measurements_filename=bundler_IO_subdir+
      "unfitted_reconstructed_camera_posns.dat";
   filefunc::ReadInfile(unfitted_measurements_filename);

   vector<int> tripod_IDs;
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<string> column_values=
         stringfunc::decompose_string_into_substrings(filefunc::text_line[i]);
      string curr_filename=column_values[1];
      string separator_chars="_";
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         curr_filename,separator_chars);
      int curr_tripod_ID=stringfunc::string_to_number(substrings[0]);
      tripod_IDs.push_back(curr_tripod_ID);
   }

// Generate modified version of surveyed measurements file where
// multiplicity of camera tripod IDs precisely matches that within
// unfitted_measurements_filename:

   string surveyed_measurements_filename=bundler_IO_subdir+
      "measured_camera_posns.dat";
   string modified_surveyed_measurements_filename=bundler_IO_subdir+
      "modified_measured_camera_posns.dat";
   ofstream outstream;
   filefunc::openfile(modified_surveyed_measurements_filename,outstream);

// Generate signposts text file for surveyed camera positions:

   string signposts_filename=bundler_IO_subdir+"measured_camera_signposts.txt";
   ofstream signposts_stream;
   filefunc::openfile(signposts_filename,signposts_stream);
   signposts_stream << "# Time   SignPost_ID   Passnumber   X  Y  Z  Label"
                    << endl << endl;

   filefunc::ReadInfile(surveyed_measurements_filename);
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<string> column_values=
         stringfunc::decompose_string_into_substrings(filefunc::text_line[i]);
      cout << filefunc::text_line[i] << endl;
      cout << "column_values.size() = " << column_values.size() << endl;
      
      int curr_tripod_ID=stringfunc::string_to_number(column_values[1]);
      double x=stringfunc::string_to_number(column_values[2]);
      double y=stringfunc::string_to_number(column_values[3]);
      double z=stringfunc::string_to_number(column_values[4]);

      int n_repeated=0;
      for (int t=0; t<tripod_IDs.size(); t++)
      {
         if (tripod_IDs[t]==curr_tripod_ID) n_repeated++;
      }
      for (int n=0; n<n_repeated; n++)
      {
         outstream << filefunc::text_line[i] << endl;
      }

      signposts_stream << "0.000        " << i << "         0        " 
                       << x << "   " << y << "   " << z << "      "
                       << curr_tripod_ID << endl;
   }
   filefunc::closefile(modified_surveyed_measurements_filename,outstream);
   filefunc::closefile(signposts_filename,signposts_stream);

// Read in "left" and "right" coordinate system points:

   vector<threevector> left_points,right_points;
   bundlerfunc::read_left_right_points(
      unfitted_measurements_filename,modified_surveyed_measurements_filename,
      left_points,right_points);
   int n_points=left_points.size();
   cout << "n_points = " << n_points << endl;

// Read in "left" and "right" wood-post points:

   string unfitted_wood_posts_filename=bundler_IO_subdir+
      "unfitted_wood_post_posns.dat";
   string surveyed_wood_posts_filename=bundler_IO_subdir+
      "measured_wood_post_posns.dat";
   
   vector<threevector> left_post_points,right_post_points;
   bundlerfunc::read_left_right_points(
      unfitted_wood_posts_filename,surveyed_wood_posts_filename,
      left_post_points,right_post_points);
   int n_post_points=left_post_points.size();
   cout << "n_post_points = " << n_post_points << endl;

// Combine wood-post points with camera positions:

   for (int n=0; n<n_post_points; n++)
   {
      left_points.push_back(left_post_points[n]);
      right_points.push_back(right_post_points[n]);
   }
   

   threevector left_COM,right_COM;
   double az,el,roll,scale;
   threevector trans_Horn,trans_Peter;
   double max_residual_distance=15;	// meters
   double median_residual_dist,quartile_width;
   bundlerfunc::RANSAC_fit_rotation_translation_scale(
      left_points,right_points,left_COM,right_COM,
      az,el,roll,scale,trans_Horn,trans_Peter,
      median_residual_dist,quartile_width);

// Overwrite peter_inputs.pkg containing trivial camera parameters
// with geoaligned camera values:

   string peter_filename="peter_inputs.pkg";
   ofstream peter_stream;
   filefunc::openfile(peter_filename,peter_stream);
   peter_stream << "--bundle_filename " << bundle_filename << endl;
   peter_stream << "--image_list_filename " << image_list_filename << endl;
   peter_stream << "--fitted_world_to_bundler_distance_ratio " << scale 
                << endl;
   peter_stream << "--bundler_translation_X " << trans_Peter.get(0) << endl;
   peter_stream << "--bundler_translation_Y " << trans_Peter.get(1) << endl;
   peter_stream << "--bundler_translation_Z " << trans_Peter.get(2) << endl;
   peter_stream << "--global_az " << az*180/PI << endl;
   peter_stream << "--global_el " << el*180/PI << endl;
   peter_stream << "--global_roll " << roll*180/PI << endl;
   peter_stream << "--bundler_rotation_origin_X " << left_COM.get(0) << endl;
   peter_stream << "--bundler_rotation_origin_Y " << left_COM.get(1) << endl;
   peter_stream << "--bundler_rotation_origin_Z " << left_COM.get(2) << endl;
   peter_stream << endl;
   filefunc::closefile(peter_filename,peter_stream);

   string unix_cmd="mv "+peter_filename+" "+bundler_IO_subdir+
      "packages/";
   sysfunc::unix_command(unix_cmd);
   peter_filename=bundler_IO_subdir+"packages/"+peter_filename;

   vector<threevector> transformed_left_points;
   double avg_residual=bundlerfunc::compute_avg_residual(
      left_points,right_points,transformed_left_points,
      az,el,roll,scale,trans_Horn);

   cout << "Number of geoaligned tripod camera positions = " 
        << transformed_left_points.size() << endl;
//   outputfunc::enter_continue_char();

/*
// Generate TDP file containing geoaligned bundler camera positions:

   string UTMzone="";
   string tdp_filename=bundler_IO_subdir+"geoaligned_camera_posns.tdp";
   tdpfunc::write_xyz_data(UTMzone,tdp_filename,transformed_left_points);

   unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv geoaligned_camera_posns.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
*/

   string banner="Exported georegistered camera parameters to "+
      peter_filename;
   outputfunc::write_big_banner(banner);
}




