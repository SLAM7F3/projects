// ==========================================================================
// Program PARSE_RAVEN_CSV reads in a comma-separated-value file
// generated by the RAVEN system which corresponds to some mpeg video
// clip.  It extracts GPS time and position information for the UAV
// from the metadata.  PARSE_RAVEN_CSV generates text and TDP/OSGA
// files containing the UAV's track.

//				parse_raven_csv

// ==========================================================================
// Last updated on 1/15/12; 1/16/12; 1/17/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "astro_geo/geopoint.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   string raven_datadir="./data/";
   string raven_csv_filename=raven_datadir;

   int flight_number;
   cout << "Enter flight number (1-4)" << endl;
   cin >> flight_number;

   if (flight_number==1)
   {
      raven_csv_filename += 
         "flight1/RavenDDL_RB14956_2011-10-21_11-58-42.00Z.csv";
   }
   else if (flight_number==2)
   {
      raven_csv_filename += 
         "flight2/RavenDDL_RB14956_2011-10-21_12-26-19.00Z.csv";
   }
   else if (flight_number==3)
   {
      raven_csv_filename += 
         "flight3/RavenDDL_RB14956_2011-10-21_12-49-37.00Z.csv";
   }
   else if (flight_number==4)
   {
      raven_csv_filename += 
         "flight4/RavenDDL_RB14956_2011-10-21_13-11-01.00Z.csv";
   }

//   string raven_csv_filename=raven_datadir+
//      "flight2/RavenDDL_RB14956_2011-10-21_12-26-19.00Z.csv";
//   string raven_csv_filename=raven_datadir+
//      "flight3/RavenDDL_RB14956_2011-10-21_12-49-37.00Z.csv";
//   string raven_csv_filename=raven_datadir+
//      "flight4/RavenDDL_RB14956_2011-10-21_13-11-01.00Z.csv";
   filefunc::ReadInfile(raven_csv_filename);

   int UTM_zone=19;	// Boston
   Clock clock;
   clock.compute_UTM_zone_time_offset(UTM_zone);
   double prev_epoch_secs=-1;

   string output_gps_filename="Raven_GPS.txt";
   ofstream outstream;
   outstream.precision(12);
   filefunc::openfile(output_gps_filename,outstream);
   outstream << "# HHMMSS Epoch secs   Easting       Northing   Altitute(m)"
             << endl << endl;

   vector<double> epoch_time,roll_angles,pitch_angles;
   vector<threevector> GPS_posn;
   vector<fourvector> space_time_posns;

   int n_pos_pitch=0;
   int n_neg_pitch=0;
   double max_phi=NEGATIVEINFINITY;
   double min_phi=POSITIVEINFINITY;

   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {

// Skip very first line in CSV file which contains header labels
// rather than data:

      if (i==0) continue;
      
      string curr_line=filefunc::text_line[i];
//      cout << curr_line << endl;

      string separator_chars=",";
      vector<string> column_values=
         stringfunc::decompose_string_into_substrings(
            curr_line,separator_chars);
//      cout << "i = " << i << " column_values.size() = " << column_values.size()
//           << endl;
      
      int month=stringfunc::string_to_number(column_values[49]);
      int day=stringfunc::string_to_number(column_values[50]);
      int year=stringfunc::string_to_number(column_values[51]);

      int hour=stringfunc::string_to_number(column_values[52]);
      int minute=stringfunc::string_to_number(column_values[53]);
      int sec=stringfunc::string_to_number(column_values[54]);
      string HH=stringfunc::integer_to_string(hour,2);
      string MM=stringfunc::integer_to_string(minute,2);
      string SS=stringfunc::integer_to_string(sec,2);
      string HHMMSS=HH+MM+SS;

      clock.set_local_time(year,month,day,hour,minute,sec);
      
      double gps_lat=stringfunc::string_to_number(column_values[55]);
      double gps_lon=stringfunc::string_to_number(column_values[56]);
      double gps_alt=stringfunc::string_to_number(column_values[57]);

//      double speed=stringfunc::string_to_number(column_values[58]);
//      double climb=stringfunc::string_to_number(column_values[59]);
//      double course=stringfunc::string_to_number(column_values[60]);
//      double mag_dev=stringfunc::string_to_number(column_values[61]);

//      double air_speed=stringfunc::string_to_number(column_values[9]);	// m/s

      double phi=stringfunc::string_to_number(column_values[10]);
      phi=basic_math::phase_to_canonical_interval(phi,-180,180);

      if (i > 10)
      {
         max_phi=basic_math::max(phi,max_phi);
         min_phi=basic_math::min(phi,min_phi);
      }

// phi = magnetic heading (relative to magnetic north rather than true
//       north pole) 

      double pitch=stringfunc::string_to_number(column_values[11]);
      if (pitch > 0)
      {
         n_pos_pitch++;
      }
      else
      {
         n_neg_pitch++;
      }
      
// On 1/16/12, we confirmed that bank angle = + roll angle

      double roll=stringfunc::string_to_number(column_values[12]);

//          double flight_time=stringfunc::string_to_number(column_values[25]);
	      // measured in integral secs

      int Raven_serial_ID=stringfunc::string_to_number(column_values[26]);
      int Raven_type=stringfunc::string_to_number(column_values[27]);
      int software_version=stringfunc::string_to_number(column_values[28]);
      double uplink_rate=stringfunc::string_to_number(column_values[29]);


/*
      cout << "i = " << i
           << " magnetic heading = " << phi
           << " min mag heading = " << min_phi
           << " max mag heading = " << max_phi
//           << " pitch = " << pitch
//           << " roll = " << roll << endl;
           << endl;
*/
    

//      if (i < 100)
      {
         cout << "i = " << i
              << " Raven ID = " << Raven_serial_ID
              << " Raven type = " << Raven_type
              << " sw version = " << software_version
              << " uplink_rate = " << uplink_rate
//              << " course = " << course
//              << " mag dev = " << mag_dev
//              << " value[8] = " << column_values[8]
//              << " value[9] = " << column_values[9]
//              << " value[10] = " << column_values[10]
//              << " value[11] = " << column_values[11]
//              << " value[12] = " << column_values[12]
//              << " value[13] = " << column_values[13]
//              << " value[14] = " << column_values[14]
//              << " value[15] = " << column_values[15]
//              << " v[24] = " << column_values[24] 	// msg count  
//              << " v[25] = " << column_values[25] 	// flight time (s)
//              << " v[26] = " << column_values[26] 	// plane ID
//              << " v[27] = " << column_values[27] 	// plane type
//              << " v[28] = " << column_values[28] 	// software version
//              << " v[29] = " << column_values[29] 	// uplink rate f/s
//              << " v[30] = " << column_values[30] 	// tgt waypt ID
//              << " v[31] = " << column_values[31] 	// tgt lat
//              << " v[32] = " << column_values[32] 	// tgt lon
//              << " v[33] = " << column_values[33] 
              << endl;
      }

      cout.precision(10);
//      cout << "date = " << month << " " << day << " " << year 
//           << " time = " << hour << " " << minute << " " << sec << endl;
//      cout << "HHMMSS = " << HHMMSS << endl;
      string day_hour_separator_char=" ";
      string time_separator_char=":";
//      bool display_UTC_flag=false;
//      bool display_UTC_flag=true;
//      int n_secs_digits=1;
//      cout << "UTC = " << clock.YYYY_MM_DD_H_M_S(
//         day_hour_separator_char,time_separator_char,
//         display_UTC_flag,n_secs_digits) << endl;

      geopoint curr_point(gps_lon,gps_lat,gps_alt);
//      int UTM_zonenumber=curr_point.get_UTM_zonenumber();
      threevector UTM_posn=curr_point.get_UTM_posn();

/*
      if (UTM_zonenumber != UTM_zone)
      {
         cout << "UTM_zonenumber = " << UTM_zonenumber << endl;
         cout << "UTM_zone = " << UTM_zone << endl;
         cout << "Need to reset UTM_zone equal to UTM_zonenumber within main!"
              << endl;
         exit(-1);
      }
*/

/*
      cout << "lla = " << gps_lat << " " << gps_lon << " " << gps_alt << endl;
      cout << "speed =" << speed << " climb = " << climb
           << " course = " << course << endl;

      cout << "UTM_zonenumber = " << UTM_zonenumber << endl;
      cout << "UTM_posn = " << UTM_posn << endl;
      cout << endl;
*/

      double curr_epoch_secs=clock.secs_elapsed_since_reference_date();
      if (curr_epoch_secs < 0) continue;
      if (nearly_equal(curr_epoch_secs,prev_epoch_secs)) continue;

      prev_epoch_secs=curr_epoch_secs;

      outstream << HHMMSS << "  "
                << curr_epoch_secs << "  "
                << UTM_posn.get(0) << "  "
                << UTM_posn.get(1) << "  "
                << UTM_posn.get(2) << "  "
                << endl;

      epoch_time.push_back(curr_epoch_secs);
      GPS_posn.push_back(UTM_posn);
      space_time_posns.push_back(fourvector(UTM_posn,curr_epoch_secs));

      pitch_angles.push_back(pitch);
      roll_angles.push_back(roll);
    
   } // loop over index i labeling lines within Raven CSV file

   cout << "max magnetic heading = " << max_phi << endl;
   cout << "min magnetic heading = " << min_phi << endl;

   filefunc::closefile(output_gps_filename,outstream);

   string banner="Wrote Raven GPS track to "+output_gps_filename;
   outputfunc::write_big_banner(banner);

// Set P value associated with GPS XYZ equal to fraction along flight
// path:

   double start_time=epoch_time.front();
   double stop_time=epoch_time.back();

   vector<fourvector> space_timefracs;
   for (unsigned int i=0; i<epoch_time.size(); i++)
   {
      double curr_time=epoch_time[i];
      double curr_time_frac=(curr_time-start_time)/(stop_time-start_time);
      fourvector curr_space_time_posn(space_time_posns[i]);

/*
// FAKE FAKE:  Mon, Jan 16, 2012 at 4:51 pm

      if (pitch_angles[i] < 0)
      {
         curr_time_frac=0.1;
      }
      else
      {
         curr_time_frac=0.9;
      }
*/

      curr_space_time_posn.put(3,curr_time_frac);
      space_timefracs.push_back(curr_space_time_posn);
   }

   cout << "n_pos_pitch = " << n_pos_pitch << endl;
   cout << "n_neg_pitch = " << n_neg_pitch << endl;
   int n_total_pitch=n_pos_pitch+n_neg_pitch;
   cout << "pos pitch frac = " << double(n_pos_pitch)/n_total_pitch
        << " neg pitch frac = " << double(n_neg_pitch)/n_total_pitch
        << endl;

// Create TDP file with GPS track:

   string GPS_tdp_filename="GPS_flightpath.tdp";
   tdpfunc::write_xyzp_data(GPS_tdp_filename,&space_timefracs);
   string unix_cmd="lodtree "+GPS_tdp_filename;
   sysfunc::unix_command(unix_cmd);
//   unix_cmd="mv GPS_flightpath.osga "+bundler_IO_subdir;
//   sysfunc::unix_command(unix_cmd);

}
