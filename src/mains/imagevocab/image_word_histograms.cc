// ==========================================================================
// Program IMAGE_WORD_HISTOGRAMS imports 128D cluster centroids
// generated by program KMEANS.  Looping over binarized SIFT
// key files, it imports SIFT feature descriptors for individual
// images.  IMAGE_WORD_HISTOGRAMS counts and rejects zero-valued
// descriptors. It next maps image SIFT features to word Voronoi
// clusters.  It exports a text file for each image containing its
// Voronoi cell histogram.

// 			./image_word_histograms



// ==========================================================================
// Last updated on 8/19/13; 8/30/13; 9/1/13
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "cluster/akm.h"
#include "datastructures/descriptor.h"
#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "video/sift_detector.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   timefunc::initialize_timeofday_clock();      

   string sift_keys_subdir="/data/sift_keyfiles/";
//   string clusters_filename=sift_keys_subdir+"clusters_32M_descriptors.bin";
   string clusters_filename=
      sift_keys_subdir+
      "clusters_10M_descriptors_32K_clusters_BostonBombing.bin";
//      sift_keys_subdir+"clusters_10M_descriptors_10K_clusters_BostonBombing.bin";


   string image_words_subdir=sift_keys_subdir+"BostonBombing_imagewords_32K_clusters/";
   filefunc::dircreate(image_words_subdir);

   long long bytecount=filefunc::size_of_file_in_bytes(clusters_filename);
   cout << "bytecount = " << bytecount << endl;
   
   int d_dims=128;
   int K=bytecount/(sizeof(float)*d_dims);
   cout << "K = " << K << endl;

// Import Voronoi cell centroids generated by program KMEANS.  First
// identify and rejeect zero-valued centroid descriptors:
   
   int n_zero_descriptors=0;
   int n_voronoi_cells=0;
   float curr_val;
   genvector centroid(d_dims);

   ifstream instream;
   filefunc::open_binaryfile(clusters_filename,instream);

   for (int k=0; k<K; k++)
   {
      bool zero_valued_descriptor_flag=true;
      for (int d=0; d<d_dims; d++)
      {
         filefunc::readobject(instream,curr_val);
         if (!nearly_equal(curr_val,0,1E-8)) zero_valued_descriptor_flag=false;
         centroid.put(d,curr_val);
      }
//      cout << "k = " << k << " centroid = " << centroid << endl;
      if (zero_valued_descriptor_flag)
      {
         n_zero_descriptors++;
      }
      else
      {
         n_voronoi_cells++;
      }
   }
   filefunc::closefile(clusters_filename,instream);

   double zero_descriptors_frac=double(n_zero_descriptors)/K;
   cout << "zero_descriptors_frac = " << zero_descriptors_frac << endl;
   cout << "n_voronoi_cells = " << n_voronoi_cells << endl;
   cout << "n_zero_descriptors = " << n_zero_descriptors << endl;

// Fill FLANN matrix cluster_centers with non-zero valued centroid
// vectors:

   flann::Matrix<float> cluster_centers(
      new float[n_voronoi_cells*d_dims],n_voronoi_cells,d_dims);

   filefunc::open_binaryfile(clusters_filename,instream);

   for (int k=0; k<n_voronoi_cells; k++)
   {
      bool zero_valued_descriptor_flag=true;
      for (int d=0; d<d_dims; d++)
      {
         filefunc::readobject(instream,curr_val);
         if (!nearly_equal(curr_val,0,1E-8)) zero_valued_descriptor_flag=false;
         centroid.put(d,curr_val);
      }
//      cout << "k = " << k << " centroid = " << centroid << endl;
      if (zero_valued_descriptor_flag) continue;

      for (int d=0; d<d_dims; d++)
      {
         cluster_centers[k][d]=centroid.get(d);
      }
   } // loop over index k labeling voronoi centroid descriptors
   filefunc::closefile(clusters_filename,instream);

// Import inverse square root of SIFT features covariance matrix:

   string txt_inverse_sqrt_covar_filename=
      sift_keys_subdir+"inverse_sqrt_covar_matrix.txt";
   
   genmatrix* inverse_sqrt_covar_ptr=mathfunc::
      import_from_dense_text_format(txt_inverse_sqrt_covar_filename);
//   cout << "inverse sqrt covar = " << *inverse_sqrt_covar_ptr << endl;

   flann::Matrix<float> inverse_sqrt_covar(
      new float[d_dims*d_dims],d_dims,d_dims);
   for (int i=0; i<d_dims; i++)
   {
      for (int j=0; j<d_dims; j++)
      {
         inverse_sqrt_covar[i][j]=inverse_sqrt_covar_ptr->get(i,j);
      }
   }
   delete inverse_sqrt_covar_ptr;

// Import descriptors from compressed binary key files:

   string binary_descriptors_subdir=sift_keys_subdir+"binary_descriptors/";
   string BostonBombing_binary_descriptors_subdir=
      binary_descriptors_subdir+"BostonBombing/";

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("lzo");
   vector<string> compressed_descriptor_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,BostonBombing_binary_descriptors_subdir);
//         allowed_suffixes,binary_descriptors_subdir);
   int n_images=compressed_descriptor_filenames.size();
   int i_skip=997;	// prime which doesn't divide n_images=44254
			//    Boston Bombing YouTube frames
//   int i_skip=997;	// prime which doesn't divide n_images=110074
//   long long n_requested_total_features=10000000;   // 10 million
   long long n_requested_total_features=32000000;   // 32 million
//   long long n_requested_total_features=100000000;  // 100 million
   int actual_max_features_per_image=100000;	// hundred thousand

   cout << "n_images = " << n_images << endl;
   cout << "i_skip = " << i_skip << endl;
   cout << "n_requested_total_features = " << n_requested_total_features
        << endl;

   int image_ID=0;
   long long n_total_features=0;
   int keyfile_counter=0;
   int n_rejected_descriptors=0;
   int n_considered_descriptors=0;

   ofstream outstream;
   float* raw_SIFT_descriptor_ptr=new float[d_dims];
   float* whitened_SIFT_descriptor_ptr=new float[d_dims];
   descriptor* raw_descriptor_ptr=new descriptor(d_dims);

   flann::Matrix<float>* SIFT_descriptors_matrix_ptr=
      new flann::Matrix<float>(
         new float[actual_max_features_per_image*d_dims],
         actual_max_features_per_image,d_dims);

   akm* akm_ptr=new akm;
   akm_ptr->set_cluster_centers_matrix_ptr(&cluster_centers);

   while (n_total_features < n_requested_total_features)
   {
      if (keyfile_counter%50==0) outputfunc::print_elapsed_time();
      image_ID=(image_ID+i_skip)%n_images;

// Uncompress binary descriptor .lzo file:

      string unix_cmd="lzop --uncompress "+compressed_descriptor_filenames[
         image_ID];
      sysfunc::unix_command(unix_cmd);

      string descriptor_filename=compressed_descriptor_filenames[image_ID];
      descriptor_filename=descriptor_filename.substr(
         0,descriptor_filename.size()-4);
//      cout << "descriptor_filename = " << descriptor_filename << endl;

      int n_features_in_curr_keyfile=
         filefunc::size_of_file_in_bytes(descriptor_filename)/d_dims;

      if (n_features_in_curr_keyfile > actual_max_features_per_image)
      {
         actual_max_features_per_image=n_features_in_curr_keyfile;
         cout << "actual_max_features_per_image = "
              << actual_max_features_per_image << endl;

         SIFT_descriptors_matrix_ptr=new flann::Matrix<float>(
            new float[actual_max_features_per_image*d_dims],
            actual_max_features_per_image,d_dims);
      }
      else
      {
         SIFT_descriptors_matrix_ptr->rows=n_features_in_curr_keyfile;
      }

      int n_bytes_in_curr_keyfile=n_features_in_curr_keyfile*d_dims;
      unsigned char* data_ptr=filefunc::ReadUnsignedChars(
         descriptor_filename,n_bytes_in_curr_keyfile);

      float* floats_ptr=new float[n_bytes_in_curr_keyfile];
      for (int b=0; b<n_bytes_in_curr_keyfile; b++)
      {
         floats_ptr[b]=stringfunc::unsigned_char_to_ascii_integer(data_ptr[b]);
      }
      delete [] data_ptr;

// Whiten raw features imported from current keyfile.  Load whitened
// feature values into rows of SIFT_descriptors FLANN matrix:

      for (int f=0; f<n_features_in_curr_keyfile; f++)
      {
         for (int d=0; d<d_dims; d++)
         {
            int b=f*d_dims+d;
            raw_SIFT_descriptor_ptr[d]=floats_ptr[b];
            raw_descriptor_ptr->put(d,floats_ptr[b]);
         } // loop over index d 

         n_considered_descriptors++;

// As of 8/31/13, we experiment with ignoring any descriptor with a low 
// entropy as defined by Wei Dong in his Princeton Ph.D. thesis:

         const double min_descriptor_entropy=4.4;
         if (raw_descriptor_ptr->entropy() < min_descriptor_entropy)
         {
            n_rejected_descriptors++;
            continue;
         }

         for (int i=0; i<d_dims; i++)
         {
            whitened_SIFT_descriptor_ptr[i]=0;
            for (int d=0; d<d_dims; d++)
            {
               whitened_SIFT_descriptor_ptr[i] += 
                  inverse_sqrt_covar[i][d] * 
                  (raw_SIFT_descriptor_ptr[d]);
//                  (raw_SIFT_descriptor_ptr[d]-mean_SIFT_descriptor_ptr[d]);
            }
//            cout << whitened_SIFT_descriptor_ptr[i] << " " << flush;

            (*SIFT_descriptors_matrix_ptr)[f][i]=
               whitened_SIFT_descriptor_ptr[i];
         } // loop over index i 

         n_total_features++;

      } // loop over index f labeling features
      delete [] floats_ptr;

// Delete uncompressed binary descriptor file:

      unix_cmd="/bin/rm "+descriptor_filename;
      sysfunc::unix_command(unix_cmd);

//      cout << "descriptor_filename = " << descriptor_filename << endl;
      string image_basename=filefunc::getbasename(descriptor_filename);
      string::size_type underscore_posn=image_basename.find_last_of("_");
      image_basename=image_basename.substr(0,underscore_posn);

      akm_ptr->reset_params(n_features_in_curr_keyfile,d_dims,n_voronoi_cells);
      akm_ptr->set_SIFT_descriptors_matrix_ptr(SIFT_descriptors_matrix_ptr);

      int n_distinct_words=akm_ptr->compute_image_words(
         keyfile_counter++,image_basename,image_words_subdir);
      int word_percentage=100*double(n_distinct_words)/n_voronoi_cells;

      double rejected_descriptor_frac=double(n_rejected_descriptors)/
         n_considered_descriptors;

      cout << keyfile_counter << " " 
           << image_basename << "; "
           << n_distinct_words << " distinct words; "
           << word_percentage << "% of SIFT words;"
           << " n_total_features=" << stringfunc::number_to_string(
              1E-6*n_total_features,1) << "M; "
           << "rejected_descriptor_frac=" << rejected_descriptor_frac
           << endl;

   }   // n_total_features < n_requested_total_features while loop
   cout << endl;

   cout << "actual_max_features_per_image = "
        << actual_max_features_per_image << endl;
   cout << "n_voronoi_cells = " << n_voronoi_cells << endl;

   delete raw_descriptor_ptr;
   delete [] raw_SIFT_descriptor_ptr;
   delete [] whitened_SIFT_descriptor_ptr;
   delete [] inverse_sqrt_covar.ptr();
   delete [] cluster_centers.ptr();
   cout << "Before delete akm_ptr" << endl;
   delete akm_ptr;

   cout << "Before delete [] SIFT_descriptors_matrix_ptr->ptr()" << endl;
   delete [] SIFT_descriptors_matrix_ptr->ptr();
   cout << "Before delete SIFT_descriptors_matrix_ptr" << endl;
   delete SIFT_descriptors_matrix_ptr;

   cout << "At end of program IMAGE_WORD_HISTOGRAMS" << endl;
   outputfunc::print_elapsed_time();
}
