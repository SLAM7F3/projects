// ==========================================================================
// Program TFIDF2 reads in term frequencies and inverse document
// frequencies generated by program TFIDF.  It forms TFIDF products
// for each of N archive images and exports them to text files within
// a tfidf subdirectory of sift_keys_subdir.  It also gzips all text
// files within the term_freqs subdir.
// ==========================================================================
// Last updated on 4/29/12; 4/30/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <flann/flann.hpp>
#include <flann/io/hdf5.h>

#include "cluster/akm.h"
#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "video/sift_detector.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   string sift_keys_subdir=bundler_IO_subdir+"images/keys/";
   cout << "sift_keys_subdir = " << sift_keys_subdir << endl;
   string term_freqs_subdir=sift_keys_subdir+"term_freqs/";
   cout << "term_freqs_subdir = " << term_freqs_subdir << endl;
   string tfidfs_subdir=sift_keys_subdir+"tfidfs/";
   cout << "tfidfs_subdir = " << tfidfs_subdir << endl;
   filefunc::dircreate(tfidfs_subdir);

   string substring="term_freqs";
   vector<string> term_freq_filenames=
      filefunc::file_basenames_in_subdir_matching_substring(
         term_freqs_subdir,substring);
   int n_images=term_freq_filenames.size();
   cout << "n_images = term_freq_filenames.size() = " 
        << term_freq_filenames.size() << endl;

// First import word clusters for entire imagery database only to
// determine number of clusters K:

   string cluster_centers_filename=sift_keys_subdir+
      "whitened_large_cluster_centers.hdf5";
   cout << "cluster_centers_filename = " << cluster_centers_filename
        << endl;

   flann::Matrix<float> cluster_centers;
   flann::load_from_file(
      cluster_centers, cluster_centers_filename.c_str(),"cluster_centers");

   int K=cluster_centers.rows;
   cout << "K = n_cluster_centers = " << K << endl;
   int D=cluster_centers.cols;
   cout << "D = " << D << endl;
   delete [] cluster_centers.ptr();

// Import image words for individual "1 through N" images:

   bool FLANN_flag=true;
   akm* akm_ptr=new akm(FLANN_flag);

   timefunc::initialize_timeofday_clock();
   int i_start=0;
//   cout << "Enter i_start:" << endl;
//   cin >> i_start;
   int i_stop=n_images;

   akm_ptr->clear_document_word_frequencies(K);
   akm_ptr->import_inverse_doc_freq_matrix(sift_keys_subdir);

   for (int index=i_start; index<i_stop; index++)
   {
      cout << "Processing image " << index << " of " << n_images << endl;

      string term_freqs_filename=term_freq_filenames[index];
      akm_ptr->compute_tfidfs(
         index,term_freqs_filename,tfidfs_subdir);

// Compress term frequencies file to save disk space:

//      cout << "term_freqs_filename = "
//           << term_freqs_filename << endl;
      string unix_cmd="gzip "+term_freqs_filename;
      sysfunc::unix_command(unix_cmd);
      
   } // loop over index i labeling individual images

   string banner="Wrote TFIDFs to "+tfidfs_subdir;
   outputfunc::write_big_banner(banner);
}
