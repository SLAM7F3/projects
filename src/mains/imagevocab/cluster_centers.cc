// ==========================================================================
// Program CLUSTER_CENTERS imports into memory a subsampled set of raw
// SIFT descriptors (with unsigned integer values ranging from 0 to
// 255) for an entire imagery database which was generated by program
// ACCUM_FEATURES.  It whitens the sampled raw SIFT descriptors via
// multiplication by the inverse square root of their covariance
// matrix.  CLUSTER_CENTERS next performs multiple rounds of
// approximate K-means clustering on the SIFT descriptors via the
// FLANN library. Finally, cell center descriptors for clusters
// containing some minimal number of SIFT descriptors are exported to
// a binary file in HDF5 format.
// ==========================================================================
// Last updated on 4/11/12; 4/20/12; 4/30/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <flann/flann.hpp>
#include <flann/io/hdf5.h>

#include "cluster/akm.h"
#include "general/filefuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   string sift_keys_subdir=bundler_IO_subdir+"images/keys/";
   cout << "sift_keys_subdir = " << sift_keys_subdir << endl;
   string raw_hdf5_subdir=sift_keys_subdir+"raw/";
   cout << "raw_hdf5_subdir = " << raw_hdf5_subdir << endl;

   const int D=128;

// On 4/3/12, we empirically found that reading in whitened SIFT
// features from HDF5 files is impractically slow !  In contrast,
// reading in raw SIFT features from binary file and then explicitly
// whitening them via multiplication with inverse square root
// covariance matrix runs acceptably fast:

// Import square root of SIFT feature covariance matrix from text file
// generated by program COMPUTE_COVAR:

   string inverse_covar_sqrt_filename=
      sift_keys_subdir+"inverse_sqrt_covar_matrix.dat";
//   cout << "inverse_covar_sqrt_filename = "
//        << inverse_covar_sqrt_filename << endl;
   filefunc::ReadInfile(inverse_covar_sqrt_filename);
   
   flann::Matrix<float> inverse_covar_sqrt(new float[D*D],D,D);
   int line_counter=0;
   for (int i=0; i<D; i++)
   {
      for (int j=0; j<D; j++)
      {
         inverse_covar_sqrt[i][j]=stringfunc::string_to_number(
            filefunc::text_line[line_counter]);
         line_counter++;         
      }
   }

// Import subsampled set of SIFT descriptors into unsigned char* array 
// from byte file all_sift_descriptors.binary generated by program
// ACCUM_FEATURES:

   string SIFT_descriptors_filename=sift_keys_subdir+
      "all_raw_sift_descriptors.binary";
//   cout << "SIFT_descriptors_filename = " << SIFT_descriptors_filename << endl;

   long long byte_count=
      filefunc::size_of_file_in_bytes(SIFT_descriptors_filename);
//   cout << "byte_count = " << byte_count << endl;
   long long n_total_features=byte_count/128;
   cout << "Binary input file contains " 
        << n_total_features << " SIFT descriptors" << endl << endl;

   double desired_n_sampled_features=n_total_features;	// MIT_100
//   double desired_n_sampled_features=3E6;
//   double desired_n_sampled_features=1E7;   // MIT32K_and_aerial   
   int n_feature_skip=n_total_features/desired_n_sampled_features;
   int n_sampled_features=n_total_features/n_feature_skip;
   long long N=n_sampled_features;
   cout << "Number of sampled SIFT descriptors N = " << N << endl;

// Integer K specifies number of desired clusters:

   int K=100000;	// MIT_100
//   int K=50000;
//   int K=300000;
//   int K=750000;	   // MIT32K_and_aerial
   cout << "Desired number clusters K = " << K << endl;

// Integer n_iters specifies number of rounds of approximate K-means
// clustering to perform:

//   int n_iters=2;
//   int n_iters=5;
//   int n_iters=8;
//   int n_iters=10;
//   int n_iters=15;
   int n_iters=20;
   cout << "Number of approximate K-means clustering rounds = "
        << n_iters << endl << endl;
   
   cout << "Importing " << n_sampled_features 
        << " sampled SIFT descriptors from binary file "
        << SIFT_descriptors_filename << endl << endl;

   timefunc::initialize_timeofday_clock();
   unsigned char* char_array=filefunc::ReadUnsignedChars(
      SIFT_descriptors_filename,n_total_features,n_feature_skip,D);
   double import_elapsed_secs=timefunc::elapsed_timeofday_time();
   double import_elapsed_mins=import_elapsed_secs/60.0;
   cout << "Number of minutes needed to read in " << n_sampled_features
        << " SIFT descriptors = " << import_elapsed_mins << endl;

/*
   for (int j=0; j<n_chars; j++)
   {
      unsigned char c=char_array[j];
      int descriptor=stringfunc::unsigned_char_to_ascii_integer(c);
//      cout << "j = " << j << " descriptor = " << descriptor
//           << endl;
   }
*/

   bool FLANN_flag=true;
   akm* akm_ptr=new akm(FLANN_flag);
   akm_ptr->reset_params(N,D,K,n_iters);

   akm_ptr->load_SIFT_descriptors(N,D,char_array,1);
   delete [] char_array;

   akm_ptr->whiten_SIFT_descriptors(inverse_covar_sqrt);

   akm_ptr->randomly_initialize_cluster_centers();

   akm_ptr->iteratively_refine_clusters();

   int min_features_per_cluster=5;
   string output_file_prefix="whitened_";
   int n_exported_clusters=akm_ptr->export_cluster_centers(
      min_features_per_cluster,output_file_prefix,sift_keys_subdir);

   double cluster_elapsed_secs=timefunc::elapsed_timeofday_time()-
      import_elapsed_secs;
   double cluster_elapsed_mins=cluster_elapsed_secs/60.0;

// Export CLUSTER_CENTERS metadata to stdout as well as text file

   string output_filename=sift_keys_subdir+"cluster_centers.summary";
   ofstream outstream;
   filefunc::openfile(output_filename,outstream);
   outstream << "Number of sampled SIFT descriptors N = " << N << endl;
   outstream << "Desired number clusters K = " << K << endl;
   outstream << "Actual number of exported (large) clusters = "
             << n_exported_clusters << endl;
   outstream << "Min features per large cluster = " 
             << min_features_per_cluster << endl;
   outstream  << "Number features per cluster = "
              << akm_ptr->get_mu_n_features_per_cluster() << " +/- " 
              << akm_ptr->get_sigma_n_features_per_cluster() << endl;
   outstream << "Number of rounds of approximate K-means clustering = "
             << n_iters << endl;
   outstream << endl;

   outstream << "Number of minutes needed to read in " << n_sampled_features
             << " SIFT descriptors = " << import_elapsed_mins << endl;
   outstream << "Number of minutes needed to form " << n_exported_clusters 
             << " cells  = " << cluster_elapsed_mins << endl;
   filefunc::closefile(output_filename,outstream);

   cout << "==============================================" << endl;
   cout << "CLUSTER_CENTERS SUMMARY" << endl;
   cout << "==============================================" << endl;
   cout << endl;
   
   cout << "Number of sampled SIFT descriptors N = " << N << endl;
   cout << "Desired number clusters K = " << K << endl;
   cout << "Actual number of exported (large) clusters = "
        << n_exported_clusters << endl;
   cout << "Min features per large cluster = " << min_features_per_cluster
        << endl;
   cout << "Number features per cluster = "
        << akm_ptr->get_mu_n_features_per_cluster() << " +/- " 
        << akm_ptr->get_sigma_n_features_per_cluster() << endl;
   cout << "Number of rounds of approximate K-means clustering = "
        << n_iters << endl;
   cout << endl;

   cout << "Number of minutes needed to read in " << n_sampled_features
        << " SIFT descriptors = " << import_elapsed_mins << endl;
   cout << "Number of minutes needed to form " << n_exported_clusters 
        << " cells  = " << cluster_elapsed_mins << endl;

   cout << "Summary information written to "+output_filename << endl;
}
