// ==========================================================================
// Program GENERATE_VOCAB reads in 128D descriptors for Voronoi cell
// centroids generated by program CLUSTER_CENTERS.  Looping over all
// images which have SIFT key files, it imports SIFT feature
// descriptors for each image.  GENERATE_VOCAB computes the term
// frequencies for each document (= image).  It also computes the
// inverse document frequency for each word ( = voronoi cell
// centroid). Term frequency-inverse document frequency vectors are
// exported for each word.  These TFIDF vectors represent a
// vocabulary dictionary for the entire set of input images.
// ==========================================================================
// Last updated on 4/23/12; 4/24/12; 4/25/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <flann/flann.hpp>
#include <flann/io/hdf5.h>

#include "cluster/akm.h"
#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "video/sift_detector.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   string sift_keys_subdir=bundler_IO_subdir+"images/keys/";
   cout << "sift_keys_subdir = " << sift_keys_subdir << endl;
   string raw_hdf5_subdir=sift_keys_subdir+"raw/";
   cout << "raw_hdf5_subdir = " << raw_hdf5_subdir << endl;

// First import word clusters for entire imagery database:

   string cluster_centers_filename=sift_keys_subdir+
      "whitened_large_cluster_centers.hdf5";
   cout << "cluster_centers_filename = " << cluster_centers_filename
        << endl;

   flann::Matrix<float> cluster_centers;
   flann::load_from_file(
      cluster_centers, cluster_centers_filename.c_str(),"cluster_centers");

   int K=cluster_centers.rows;
   cout << "K = n_cluster_centers = " << K << endl;
   int D=cluster_centers.cols;
   cout << "D = " << D << endl;

// Import square root of SIFT feature covariance matrix from text file
// generated by program COMPUTE_COVAR:

   string inverse_covar_sqrt_filename=
      sift_keys_subdir+"inverse_sqrt_covar_matrix.dat";
//   cout << "inverse_covar_sqrt_filename = "
//        << inverse_covar_sqrt_filename << endl;
   filefunc::ReadInfile(inverse_covar_sqrt_filename);
   
   flann::Matrix<float> inverse_covar_sqrt(new float[D*D],D,D);
   int line_counter=0;
   for (int i=0; i<D; i++)
   {
      for (int j=0; j<D; j++)
      {
         inverse_covar_sqrt[i][j]=stringfunc::string_to_number(
            filefunc::text_line[line_counter]);
         line_counter++;         
      }
   }

// Import raw SIFT descriptors for individual "1 through N" images:

   bool FLANN_flag=true;
   sift_detector* sift_detector_ptr=new sift_detector(NULL,FLANN_flag);
   vector<string> compressed_sift_hdf5_filenames=sift_detector_ptr->
      import_compressed_sift_hdf5_filenames(raw_hdf5_subdir);
   int n_images=compressed_sift_hdf5_filenames.size();
   delete sift_detector_ptr;

   akm* akm_ptr=new akm(FLANN_flag);
   akm_ptr->set_cluster_centers_matrix_ptr(&cluster_centers);

// Allocate extra, last row within tfidf_matrix to hold vocab info for
// "N+1st" images:

   akm_ptr->clear_document_word_frequencies(n_images+1,K);

   float* whitened_row=new float[D];
   flann::Matrix<float> SIFT_descriptors;

   timefunc::initialize_timeofday_clock();
   int i_start=0;
   int i_stop=n_images;

   string prev_compressed_sift_hdf5_filename,prev_sift_hdf5_filename;
   for (int index=i_start; index<i_stop; index++)
   {
      string compressed_sift_hdf5_filename=compressed_sift_hdf5_filenames[
         index];

// On 4/24/12, GENERATE_VOCAB died while processing image 12676 of
// 36177 since HF5open() was unable to open some .hdf5 file.  To avoid 
// such catastrophes in the future, we explicitly check that the
// compressed and uncompressed SIFT hdf5 filenames exist.  If not,
// reset them to their previous values:

      if (!filefunc::fileexist(compressed_sift_hdf5_filename))
      {
         cout << "ERROR!" << endl;
         cout << "Cannot find " << compressed_sift_hdf5_filename << endl;
         cout << "Setting compressed_sift_hdf5_filename to previous value = "
              << prev_compressed_sift_hdf5_filename << endl;
         compressed_sift_hdf5_filename=prev_compressed_sift_hdf5_filename;
      }
      prev_compressed_sift_hdf5_filename=compressed_sift_hdf5_filename;

      string sift_hdf5_filename=
         stringfunc::prefix(compressed_sift_hdf5_filename);

      string unix_cmd="lzop --uncompress "+compressed_sift_hdf5_filename;
      sysfunc::unix_command(unix_cmd);

      if (!filefunc::fileexist(sift_hdf5_filename))
      {
         cout << "ERROR!" << endl;
         cout << "Cannot find " << compressed_sift_hdf5_filename << endl;
         cout << "Setting sift_hdf5_filename to previous value = "
              << prev_sift_hdf5_filename << endl;
         sift_hdf5_filename=prev_sift_hdf5_filename;
      }
      prev_sift_hdf5_filename=sift_hdf5_filename;

      cout << "Processing image " << index << " of " << n_images 
           << " : " << filefunc::getbasename(sift_hdf5_filename) << endl;
      if (index%10==0)
      {
         double elapsed_secs=timefunc::elapsed_timeofday_time();
         double elapsed_mins=elapsed_secs/60.0;
         double elapsed_hours=elapsed_mins/60.0;
         double rate=double(index-i_start)/elapsed_hours;
         double hours_to_go=double(i_stop-index)/rate;

         cout << "Elapsed minutes = " << elapsed_mins 
              << " Elapsed hours = " << elapsed_hours 
              << " Hours-to-go = " << hours_to_go << endl;
         cout << endl;
      }

      delete [] SIFT_descriptors.ptr();
      flann::load_from_file(
         SIFT_descriptors,sift_hdf5_filename.c_str(),"sift_features");

// Delete uncompressed SIFT HDF5 file:

      unix_cmd="/bin/rm "+sift_hdf5_filename;
      sysfunc::unix_command(unix_cmd);

// Whiten raw SIFT descriptors for current image:

      int N=SIFT_descriptors.rows;
//      cout << "N = " << N << endl;
      for (int n=0; n<N; n++)
      {
         for (int i=0; i<D; i++)
         {
            whitened_row[i]=0;
            for (int j=0; j<D; j++)
            {
               whitened_row[i] += inverse_covar_sqrt[i][j]*
                  SIFT_descriptors[n][j];
            }
         }
         
         for (int d=0; d<D; d++)
         {
            SIFT_descriptors[n][d]=whitened_row[d];
         } // loop over index d
      } // loop over index n labeling rows in SIFT_descriptors array

      akm_ptr->reset_params(N,D,K);
      akm_ptr->set_SIFT_descriptors_matrix_ptr(&SIFT_descriptors);
      akm_ptr->compute_term_frequencies(index);

// On 4/25/12, we learned the hard way that exporting sparse TFIDF
// matrices can take over an hour when n_images = O(10K).  So we only
// perform this expensive operation sparingly:

      if (index%10000==0)
      {
         akm_ptr->export_partial_tfidf_and_multi_image_words(
            index,sift_keys_subdir);
         double elapsed_secs=timefunc::elapsed_timeofday_time();
         double elapsed_mins=elapsed_secs/60.0;
         double elapsed_hours=elapsed_mins/60.0;
         cout << "After exporting partial results, elapsed minutes = " 
              << elapsed_mins 
              << " Elapsed hours = " << elapsed_hours << endl;
         cout << endl;
      }

   } // loop over index i labeling individual images

   akm_ptr->compute_inverse_document_frequencies(n_images);

   double elapsed_secs=timefunc::elapsed_timeofday_time();
   double elapsed_mins=elapsed_secs/60.0;
   double elapsed_hours=elapsed_mins/60.0;
   cout << "After computing inverse document frequencies, elapsed minutes = " 
        << elapsed_mins 
        << " Elapsed hours = " << elapsed_hours << endl;
   cout << endl;

   akm_ptr->compute_tfidfs(n_images);

   elapsed_secs=timefunc::elapsed_timeofday_time();
   elapsed_mins=elapsed_secs/60.0;
   elapsed_hours=elapsed_mins/60.0;
   cout << "After computing tfidfs, elapsed minutes = " << elapsed_mins 
        << " Elapsed hours = " << elapsed_hours << endl;
   cout << endl;

   string inverse_doc_freq_filename,vocab_filename;
   akm_ptr->export_vocabulary(
      "whitened_",sift_keys_subdir,
      inverse_doc_freq_filename,vocab_filename);

   string banner="Normalized vocabulary written to "+vocab_filename;
   outputfunc::write_big_banner(banner);

   banner="Inverse document frequency written to "+
      inverse_doc_freq_filename;
   outputfunc::write_big_banner(banner);
}
