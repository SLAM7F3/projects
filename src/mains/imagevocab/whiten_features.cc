// ==========================================================================
// WHITEN_FEATURES imports SIFT descriptors from compressed SIFT HDF5
// binary files within a specified input subdirectory.  It also
// imports the inverse square root of the descriptors' covariance matrix
// which was previously generated by program DESCRIPTORS_COVAR.  Each
// raw SIFT descriptor is multiplied by the inverse square root
// covariance matrix in order to "whiten" it.  Whitened SIFT
// descriptors are exported to compressed HDF5 binary files labeled
// with "whitened_" prefixes.
// ==========================================================================
// Last updated on 3/30/12; 4/17/12; 4/19/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <flann/flann.hpp>
#include <flann/io/hdf5.h>

#include "cluster/akm.h"
#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "video/sift_detector.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   string image_sizes_filename=passes_group.get_image_sizes_filename();
   string sift_keys_subdir=bundler_IO_subdir+"images/keys/";
   cout << "sift_keys_subdir = " << sift_keys_subdir << endl;
   string raw_hdf5_subdir=sift_keys_subdir+"raw/";
   cout << "raw_hdf5_subdir = " << raw_hdf5_subdir << endl;

   const int D=128;

// Import square root of SIFT feature covariance matrix from text file
// generated by program DESCRIPTORS_COVAR:

   string inverse_covar_sqrt_filename=
      sift_keys_subdir+"inverse_sqrt_covar_matrix.dat";
//   cout << "inverse_covar_sqrt_filename = "
//        << inverse_covar_sqrt_filename << endl;
   filefunc::ReadInfile(inverse_covar_sqrt_filename);

   flann::Matrix<float> inverse_covar_sqrt(new float[D*D],D,D);

   int line_counter=0;
   for (int i=0; i<D; i++)
   {
      for (int j=0; j<D; j++)
      {
         inverse_covar_sqrt[i][j]=stringfunc::string_to_number(
            filefunc::text_line[line_counter]);
         line_counter++;         
      }
   }

   bool FLANN_flag=true;
   sift_detector* sift_detector_ptr=new sift_detector(NULL,FLANN_flag);
   vector<string> compressed_sift_hdf5_filenames=sift_detector_ptr->
      import_compressed_sift_hdf5_filenames(raw_hdf5_subdir);
   int n_images=compressed_sift_hdf5_filenames.size();
   delete sift_detector_ptr;

// Import SIFT descriptors for individual "1 through N" images from
// either gzipped or lzop compressed key files:
   
   int i_start=0;
//   cout << "Enter starting image number:" << endl;
//   cin >> i_start;
   int i_stop=n_images;

   float* whitened_row=new float[D];

// Import SIFT descriptors for individual "1 through N" images.
// Whiten all of their SIFT features by multiplying with
// *inverse_covar_sqrt_matrix_ptr:

   string whitened_hdf5_subdir=sift_keys_subdir+"whitened/";
   filefunc::dircreate(whitened_hdf5_subdir);

   flann::Matrix<float> SIFT_descriptors;
   for (int i=i_start; i<i_stop; i++)
   {
      string compressed_sift_hdf5_filename=compressed_sift_hdf5_filenames[i];
      string sift_hdf5_filename=
         stringfunc::prefix(compressed_sift_hdf5_filename);

      string lzo_sift_hdf5_filename=stringfunc::prefix(
         compressed_sift_hdf5_filename);
      lzo_sift_hdf5_filename=lzo_sift_hdf5_filename+".lzo";
      string unix_cmd="lzop --uncompress "+lzo_sift_hdf5_filename;
      sysfunc::unix_command(unix_cmd);

//      cout << "===============================================" << endl;
//      cout << "i = " << i << " Whitening " << sift_hdf5_filename << endl;
      cout << "Whitening image " << i << " of " << n_images << endl;

      delete [] SIFT_descriptors.ptr();
      flann::load_from_file(
         SIFT_descriptors,sift_hdf5_filename.c_str(),"sift_features");

// Delete uncompressed SIFT HDF5 file:

      unix_cmd="/bin/rm "+sift_hdf5_filename;
      sysfunc::unix_command(unix_cmd);

      int N=SIFT_descriptors.rows;
//      cout << "N = " << N << endl;
      for (int n=0; n<N; n++)
      {

         for (int i=0; i<D; i++)
         {
            whitened_row[i]=0;
            for (int j=0; j<D; j++)
            {
               whitened_row[i] += inverse_covar_sqrt[i][j]*
                  SIFT_descriptors[n][j];
            }
         }
         
         for (int d=0; d<D; d++)
         {
            SIFT_descriptors[n][d]=whitened_row[d];
         } // loop over index d
      } // loop over index n labeling rows in SIFT_descriptors array

      string basename=filefunc::getbasename(sift_hdf5_filename);
      string substring=basename.substr(4,basename.size()-4);
      basename="whitened_"+substring;
      string whitened_hdf5_filename=whitened_hdf5_subdir+basename;
      flann::save_to_file(
         SIFT_descriptors,whitened_hdf5_filename,"sift_features");

      unix_cmd="lzop -U "+whitened_hdf5_filename;
      sysfunc::unix_command(unix_cmd);

   } // loop over index i labeling individual images

   delete [] whitened_row;
}

   
