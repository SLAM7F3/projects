// ==========================================================================
// Program ALL_SIGNS is a main program which takes in sets of input
// video frames and searches for all 9 TOC12 ppt signs within them.

//				all_signs

// ==========================================================================
// Last updated on 10/19/12; 10/28/12; 11/1/12
// ==========================================================================

#include  <iostream>
#include  <set>
#include  <string>
#include  <vector>

#include "general/filefuncs.h"
#include "image/extremal_region.h"
#include "image/extremal_regions_group.h"
#include "general/outputfuncs.h"
#include "video/RGB_analyzer.h"
#include "classification/signrecogfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "classification/text_detector.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::pair;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(12);

   bool PointGrey_camera_flag=true;

   string final_signs_subdir="./images/final_signs/";
   string output_subdir=final_signs_subdir+"quantized_colors/";
   filefunc::dircreate(output_subdir);

   extremal_regions_group regions_group;

// Initialize TOC12 sign properties:
   
   signrecogfunc::SIGN_PROPERTIES curr_sign_properties,prev_sign_properties;
   vector<signrecogfunc::SIGN_PROPERTIES> sign_properties=
      signrecogfunc::initialize_sign_properties();

   cout << endl;
   cout << "------------------------------------------------------" << endl;
   cout << "Yellow radiation sign ID = 0" << endl;
   cout << "Orange biohazard sign ID = 1" << endl;
   cout << "Blue-purple radiation sign ID = 2" << endl;
   cout << "Blue water sign ID = 3" << endl;
   cout << "Blue gasoline sign ID = 4" << endl;
   cout << "Red stop sign ID = 5" << endl;
   cout << "Green start sign ID = 6" << endl;
   cout << "Black-white skull sign ID = 7" << endl;
   cout << "Black-white eat sign ID = 8" << endl;
   cout << "------------------------------------------------------" << endl;   

   int sign_ID_start=0;
//   int sign_ID_stop=sign_properties.size()-1;

// As of Thurs, Nov 1, 2012, detection of black & white signs is terrible!
// So we do not attempt to find them for now...

   int sign_ID_stop=sign_properties.size()-1-2;

// Import quantized RGB lookup tables for all TOC12 signs:

   RGB_analyzer* RGB_analyzer_ptr=new RGB_analyzer();
   for (int s=0; s<sign_properties.size(); s++)
   {
      RGB_analyzer_ptr->import_quantized_RGB_lookup_table(
         sign_properties[s].sign_hue);
   }

// Import probabilistic decision functions generated by an SVM with a
// linear kernel on 12K symbol and 96K non-symbol images per TOC12 sign:

   vector<signrecogfunc::Ng_pfunct_type> Ng_pfuncts;
   vector<text_detector*> text_detector_ptrs=
      signrecogfunc::import_Ng_probabilistic_classification_functions(
         sign_properties,Ng_pfuncts);

   texture_rectangle* binary_texture_rectangle_ptr=new texture_rectangle();
   texture_rectangle* black_flooded_texture_rectangle_ptr=
      new texture_rectangle();
   texture_rectangle* black_grads_texture_rectangle_ptr=
      new texture_rectangle();
   texture_rectangle* edges_texture_rectangle_ptr=new texture_rectangle();
   texture_rectangle* quantized_texture_rectangle_ptr=new texture_rectangle();
   texture_rectangle* raw_texture_rectangle_ptr=new texture_rectangle();
   texture_rectangle* selected_colors_texture_rectangle_ptr=
      new texture_rectangle();
   texture_rectangle* texture_rectangle_ptr=new texture_rectangle();

   int video_start=21;
   int video_stop=21;
   int delta_video=1;
//   cout << "Enter starting video pass number ( >= 5):" << endl;
//   cin >> video_start;
//   cout << "Enter stopping video pass number ( <= 20):" << endl;
//   cin >> video_stop;

   timefunc::initialize_timeofday_clock();

   extremal_regions_group::ID_REGION_MAP* black_regions_map_ptr=
      new extremal_regions_group::ID_REGION_MAP;

// Loop over multiple video clips starts here:

   int image_counter=0;
   for (int video_number=video_start; video_number <=video_stop; 
        video_number += delta_video)
   {
      string video_subdir=output_subdir+
         "vid_"+stringfunc::integer_to_string(video_number,2)+"/";
      filefunc::dircreate(video_subdir);

      string image_subdir=final_signs_subdir+"videos/vid";
      image_subdir += stringfunc::integer_to_string(video_number,2)+"_frames/";
      vector<string> image_filenames=filefunc::image_files_in_subdir(
         image_subdir);

      int i_start=0;
      int i_stop=image_filenames.size()-1;
//      cout << "Last image number = " << image_filenames.size() << endl;
//      cout << "Enter starting image number:" << endl;
//      cin >> i_start;
//      cout << "Enter stopping image number:" << endl;
//      cin >> i_stop;
//      i_start--;
//      i_stop--;

// Loop over individual video frames starts here:

      for (int i=i_start; i<=i_stop; i++)
      {
         string orig_image_filename=image_filenames[i];
         cout << "Original image_filename = " << orig_image_filename << endl;
         int frame_number=i+1;

         if (image_counter >= 1)
         {
            signrecogfunc::print_processing_time(image_counter);
         }
         image_counter++;

// Crop white border surrounding PointGrey images captured within
// Tennis Bubble on Saturday, Oct 27, 2012:

         string undistorted_image_filename=orig_image_filename;
         if (PointGrey_camera_flag)
         {
            string cropped_image_filename=signrecogfunc::crop_white_border(
               orig_image_filename);
            undistorted_image_filename=
               signrecogfunc::radially_undistort_PointGrey_image(
                  cropped_image_filename,raw_texture_rectangle_ptr,
                  texture_rectangle_ptr);

            string undistorted_filename=video_subdir+
               "undistorted_"+stringfunc::integer_to_string(frame_number,5)
               +".jpg";
//            texture_rectangle_ptr->write_curr_frame(undistorted_filename);

            string raw_filename=video_subdir+
               "raw_"+stringfunc::integer_to_string(frame_number,5)+".jpg";
 //           raw_texture_rectangle_ptr->write_curr_frame(raw_filename);

// Search for grey-colored vertical stripe on RHS of raw PointGrey
// images.  If found, declare input image to be corrupted:
            
            if (signrecogfunc::detect_corrupted_PointGrey_image(
               raw_filename,raw_texture_rectangle_ptr))
            {
               cout << "Corrupted raw PointGrey image = " 
                    << raw_filename << endl;
            }
         } // PointGrey camera conditional

         int xdim,ydim;
         string image_filename=signrecogfunc::resize_input_image(
            orig_image_filename,xdim,ydim);
         texture_rectangle_ptr->reset_texture_content(image_filename);

// Loop over TOC12 sign IDs starts here:

         vector<polygon> bbox_polygons;
         vector<int> bbox_color_indices;

         for (int curr_sign_ID=sign_ID_start; curr_sign_ID <= sign_ID_stop;
              curr_sign_ID++)
         {
            curr_sign_properties=sign_properties[curr_sign_ID];   

            if (curr_sign_ID > sign_ID_start)
            {
               prev_sign_properties=sign_properties[curr_sign_ID-1];
            }
            else
            {
               prev_sign_properties=curr_sign_properties;
            }
            
            cout << "======================================================"
                 << endl;
            cout << "symbol = " << curr_sign_properties.symbol_name << endl;

            bool bw_sign_flag=false;
            if (curr_sign_properties.sign_hue=="black") bw_sign_flag=true;

            signrecogfunc::reset_texture_image(
               image_filename,binary_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,black_flooded_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,black_grads_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,edges_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,quantized_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,selected_colors_texture_rectangle_ptr);

            if (!bw_sign_flag)
               signrecogfunc::quantize_colors(
                  RGB_analyzer_ptr,curr_sign_properties,
                  texture_rectangle_ptr,
                  quantized_texture_rectangle_ptr,
                  selected_colors_texture_rectangle_ptr,
                  binary_texture_rectangle_ptr);

// Genuine TOC12 signs exhibit strong inner edge content. So compute
// edge maps:

            signrecogfunc::GRADSTEP_MAP black_gradstep_map,white_gradstep_map;

            signrecogfunc::compute_edgemaps(
               curr_sign_ID,sign_ID_start,
               curr_sign_properties,prev_sign_properties,
               edges_texture_rectangle_ptr,
               black_gradstep_map,white_gradstep_map);

            string binary_quantized_filename=video_subdir+
               "binary_colors_"+stringfunc::integer_to_string(frame_number,5)
               +".jpg";

            if (bw_sign_flag)
            {
               signrecogfunc::
                  merge_bright_MSER_and_flooded_black_region_bboxes(
                     xdim,ydim,
                     image_filename,binary_quantized_filename,
                     binary_texture_rectangle_ptr,
                     black_flooded_texture_rectangle_ptr,
                     black_grads_texture_rectangle_ptr,
                     edges_texture_rectangle_ptr,
                     texture_rectangle_ptr,
                     black_gradstep_map,regions_group,black_regions_map_ptr);

// Form bounding box polygons around adjacent bright MSER & flooded
// black regions:

//            cout << "Forming merged bbox polygons" << endl;

               signrecogfunc::
                  form_bright_MSER_and_flooded_black_region_bbox_polygons(
                     xdim,ydim,curr_sign_ID,regions_group,
                     black_regions_map_ptr,curr_sign_properties,
                     texture_rectangle_ptr,text_detector_ptrs,
                     Ng_pfuncts,bbox_polygons,bbox_color_indices);
            }
            else
            {
               binary_texture_rectangle_ptr->write_curr_frame(
                  binary_quantized_filename);

               vector<extremal_region*> extremal_region_ptrs,
                  inverse_extremal_region_ptrs;
               signrecogfunc::compute_connected_components(
                  binary_quantized_filename,curr_sign_properties,
                  extremal_region_ptrs,inverse_extremal_region_ptrs);

               signrecogfunc::form_colored_sign_bbox_polygons(
                  curr_sign_ID,image_filename,
                  extremal_region_ptrs,inverse_extremal_region_ptrs,
                  curr_sign_properties,RGB_analyzer_ptr,
                  texture_rectangle_ptr,quantized_texture_rectangle_ptr,
                  selected_colors_texture_rectangle_ptr,
                  text_detector_ptrs,Ng_pfuncts,
                  bbox_polygons,bbox_color_indices);

            } // bw_sign_flag
         } // loop over curr_sign_ID

         if (bbox_polygons.size() > 0)
         {
            texture_rectangle_ptr->reset_texture_content(image_filename);
            signrecogfunc::export_bbox_polygons(
               texture_rectangle_ptr,bbox_polygons,bbox_color_indices);
            string bboxes_filename=video_subdir+
               "bboxes_"+stringfunc::integer_to_string(frame_number,4)+".jpg";
            texture_rectangle_ptr->write_curr_frame(bboxes_filename);
         }
         
      } // loop over index i labeling image filenames

      signrecogfunc::print_processing_time(image_counter);

   } // loop over video_number 

   delete RGB_analyzer_ptr;
   delete black_regions_map_ptr;

   delete binary_texture_rectangle_ptr;
   delete black_flooded_texture_rectangle_ptr;
   delete black_grads_texture_rectangle_ptr;
   delete edges_texture_rectangle_ptr;
   delete quantized_texture_rectangle_ptr;
   delete raw_texture_rectangle_ptr;
   delete selected_colors_texture_rectangle_ptr;
   delete texture_rectangle_ptr;
}

