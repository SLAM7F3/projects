// ==========================================================================
// SYMBOL_DICTIONARY imports whitened 64x3 RGB color [64x1 greyscale]
// descriptors generated by program WHITEN_SYMBOL_DESCRIPTORS for 8x8
// pixel patches X^i randomly selected from text character images.  It
// initially assigns each patch to some random cluster labeled by 0 <=
// k < K. Score vectors S^i associated with each pixel patch are then
// computed which have precisely one non-zero entry.  We then
// iteratively solve for the 64xK dictionary matrix D which minimizes
// sum_i |D S^i - X^i|. Columns within D are subsequently renormalized
// to have unit magnitude.  The final values in D are exported to a
// binary HDF5 file.

// After each iteration, a PNG file is generated which shows all K 8x8
// descriptors within the dictionary.

// 				symbol_dictionary

// ==========================================================================
// Last updated on 9/27/12; 9/29/12; 10/5/12; 10/20/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <flann/flann.hpp>
#include <flann/io/hdf5.h>

#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "math/genvector.h"
#include "numrec/nrfuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

//   cout << "Sleeping for 25 minutes" << endl;
//   sleep(25*60);
   

   const int K=1024;

   vector<string> symbol_names;
//   symbol_names.push_back("yellow_radiation");
//   symbol_names.push_back("orange_biohazard");
//   symbol_names.push_back("blue_radiation");
//   symbol_names.push_back("blue_water");
   symbol_names.push_back("blue_gas");
//   symbol_names.push_back("red_stop");
//   symbol_names.push_back("green_start");
//   symbol_names.push_back("bw_skull");
//   symbol_names.push_back("bw_eat");

   string final_signs_subdir="./images/final_signs/";
//   string ppt_signs_subdir="./images/ppt_signs/";
   string symbols_input_subdir=final_signs_subdir;

/*
   string symbol_name;
   cout << "Enter symbol name:" << endl;
   cout << "  yellow_radiation,orange_biohazard,blue_radiation" << endl;
   cout << "  blue_water,blue_gas,red_stop" << endl;
   cout << "  green_start,bw_skull,bw_eat:" << endl;
   cin >> symbol_name;
*/

   bool RGB_pixels_flag=false;
//   bool RGB_pixels_flag=true;
   cout << "RGB_pixels_flag = " << RGB_pixels_flag << endl;

   int D=64*3;	// RGB color
   if (!RGB_pixels_flag)
   {
      D=64;	// greyscale
   }

   for (unsigned int s=0; s<symbol_names.size(); s++)
   {
      string symbol_name=symbol_names[s];

      string banner="Computing dictionary for "+symbol_name;
      outputfunc::write_big_banner(banner);

      string symbol_filename=symbols_input_subdir+symbol_name+".png";
      string synthetic_subdir=symbols_input_subdir+"synthetic_symbols/";
      string synthetic_symbols_subdir=synthetic_subdir+symbol_name+"/";
      string dictionary_subdir=synthetic_symbols_subdir;
      string dictionary_pngs_subdir=dictionary_subdir+"dictionary_pngs/";
      filefunc::dircreate(dictionary_pngs_subdir);

// Import whitened patch descriptors for all character images:

      flann::Matrix<float> patch_descriptors;
      string patches_hdf5_filename=dictionary_subdir+
         "whitened_patch_features.hdf5";
      flann::load_from_file(
         patch_descriptors,patches_hdf5_filename.c_str(),"patch_descriptors");

      int N=patch_descriptors.rows;
      cout << "Number of patch descriptors N = " << N << endl;


      vector<genvector*>* S_ptrs_ptr=new vector<genvector*>;
      vector<genvector*>* X_ptrs_ptr=new vector<genvector*>;

      double sum_S_sqrd_mags=0;
      for (int n=0; n<N; n++)
      {
//      cout << n << " " << flush;
         genvector* curr_X_ptr=new genvector(D);         
         X_ptrs_ptr->push_back(curr_X_ptr);

         for (int d=0; d<D; d++)
         {
            curr_X_ptr->put(d,patch_descriptors[n][d]);
         } // loop over index d

//      cout << "n = " << n << endl;
//      cout << "X = " << *curr_X_ptr << endl;
      
// Initially assign each 8x8 pixel patch to some random dictionary
// element:

         int curr_k=K*nrfunc::ran1();
         genvector* curr_S_ptr=new genvector(K);
         S_ptrs_ptr->push_back(curr_S_ptr);

         curr_S_ptr->clear_values();
         curr_S_ptr->put(curr_k,1);

         sum_S_sqrd_mags += curr_S_ptr->sqrd_magnitude();
//      cout << "S = " << *curr_S_ptr << endl;
      } // loop over index n labeling rows in patch_descriptors array
//   cout << endl;

      genmatrix* D_ptr=new genmatrix(D,K);

      cout << "S_ptrs_ptr->size() = " << S_ptrs_ptr->size() << endl;
      cout << "X_ptrs_ptr->size() = " << X_ptrs_ptr->size() << endl;

      int total_width=16*9;
      int total_height=9*K/(total_width/9);
//   int total_height=8*9;
//   int total_height=16*9;
//   int total_height=32*9;

      texture_rectangle* texture_rectangle_ptr=new texture_rectangle(
         total_width,total_height,1,3,NULL);

      string blank_filename="blank.jpg";
      texture_rectangle_ptr->generate_blank_image_file(
         total_width,total_height,blank_filename,0.5);
      texture_rectangle_ptr->import_photo_from_file(blank_filename);

      int n_iters=15;
//      cout << "Enter number of dictionary forming iterations ( < 25):" << endl;
//      cin >> n_iters;

      timefunc::initialize_timeofday_clock();
   
      for (int iter=0; iter<n_iters; iter++)
      {
         banner="Processing iteration "+
            stringfunc::number_to_string(iter+1)+
            " of "+stringfunc::number_to_string(n_iters)+":";
         outputfunc::write_banner(banner);

// Update *D_ptr:

         D_ptr->clear_values();
         for (int n=0; n<N; n++)
         {
            genvector* curr_S_ptr=S_ptrs_ptr->at(n);
            genvector* curr_X_ptr=X_ptrs_ptr->at(n);

//      cout << "n = " << n << " S = " << *curr_S_ptr << endl;
//      cout << "X = " << *curr_X_ptr << endl;
      
            *D_ptr += curr_X_ptr->outerproduct(*curr_S_ptr);
         } // loop over index n labeing 8x8 pixel patches
         *D_ptr /= sum_S_sqrd_mags;

// Reset norm of each column within D to one:

         genvector curr_patch(D);
         for (int k=0; k<K; k++)
         {
            D_ptr->get_column(k,curr_patch);
            curr_patch=curr_patch.unitvector();
            D_ptr->put_column(k,curr_patch);
         } // loop over index k labeling clusters
//      cout << "*D_ptr = " << *D_ptr << endl;

// Update texture rectangle output:

         texture_rectangle_ptr->clear_all_RGB_values();
         for (int k=0; k<K; k++)
         {
            D_ptr->get_column(k,curr_patch);

// For visualization purposes only, compute min and max intensity
// values. Then rescale intensities so that extremal values equal +/- 1:

            double min_z=POSITIVEINFINITY;
            double max_z=NEGATIVEINFINITY;
            for (int d=0; d<D; d++)
            {
               double curr_z=curr_patch.get(d);
               min_z=basic_math::min(min_z,curr_z);
               max_z=basic_math::max(max_z,curr_z);
            }
         
            for (int d=0; d<D; d++)
            {
               double curr_z=curr_patch.get(d);
               curr_z=2*(curr_z-min_z)/(max_z-min_z)-1;
               curr_patch.put(d,curr_z);
            }

            int row=k/16;
            int column=k%16;

            int px_start=column*9;
            int py_start=row*9;
//         cout << "row = " << row << " column = " << column 
//              << " px_start = " << px_start 
//              << " py_start = " << py_start << endl;

            int counter=0;
            for (int pu=0; pu<8; pu++)
            {
               int px=px_start+pu;
               for (int pv=0; pv<8; pv++)
               {
                  int py=py_start+pv;
                  if (RGB_pixels_flag)
                  {
                     double z=curr_patch.get(counter++);
                     int R=0.5*(z+1)*255;
                     z=curr_patch.get(counter++);
                     int G=0.5*(z+1)*255;
                     z=curr_patch.get(counter++);
                     int B=0.5*(z+1)*255;
                     texture_rectangle_ptr->set_pixel_RGB_values(px,py,R,G,B);
                  }
                  else
                  {
                     double z=curr_patch.get(counter++);
                     int R=0.5*(z+1)*255;
                     texture_rectangle_ptr->set_pixel_RGB_values(px,py,R,R,R);
                  }

               } // loop over pv index
            } // loop over pu index

         } // loop over index k labeling dictionary descriptors

         string output_filename=dictionary_pngs_subdir+
            "dictionary_"+stringfunc::number_to_string(iter)+".png";
         texture_rectangle_ptr->write_curr_frame(output_filename);
         cout << "Exported "+output_filename << endl;

// Update S vectors:

         for (int n=0; n<N; n++)
         {
            genvector* curr_S_ptr=S_ptrs_ptr->at(n);
            genvector* curr_X_ptr=X_ptrs_ptr->at(n);

            int best_k=-1;
            double max_dotproduct=NEGATIVEINFINITY;
            for (int k=0; k<K; k++)
            {
               D_ptr->get_column(k,curr_patch);
               double dotproduct=curr_X_ptr->dot(curr_patch);
               if (dotproduct > max_dotproduct)
               {
                  max_dotproduct=dotproduct;
                  best_k=k;
               }
            } // loop over index k labeling clusters
            curr_S_ptr->clear_values();
            curr_S_ptr->put(best_k,max_dotproduct);
         } // loop over index n labeling 8x8 pixel patches

         double elapsed_time=timefunc::elapsed_timeofday_time();
         cout << "Elapsed time = " << elapsed_time << " secs = " 
              << elapsed_time / 60.0 << " minutes" << endl;

      } // loop over iter index

// Export dictionary descriptors to binary HDF5 file:

      flann::Matrix<float>* dictionary_descriptors_ptr=
         new flann::Matrix<float>(new float[D*K],D,K);

      for (int d=0; d<D; d++)
      {
//      cout << d << " " << flush;
         for (int k=0; k<K; k++)
         {
            (*dictionary_descriptors_ptr)[d][k]=D_ptr->get(d,k);
         }
      }
//   cout << endl;

      string dictionary_hdf5_filename=dictionary_subdir+"dictionary.hdf5";
//   cout << "dictionary_hdf5_filename = " << dictionary_hdf5_filename
//        << endl;

// On 8/20/12, we discovered the hard and painful way that FLANN dies
// if it tries to export a dictionary with a K value different from
// one in an already existing dictionary.hdf5 file.  So we explicitly
// delete any existing dictionary.hdf5 before attempting to write out
// a new version:

      filefunc::deletefile(dictionary_hdf5_filename);

      flann::save_to_file(
         *dictionary_descriptors_ptr,dictionary_hdf5_filename,
         "dictionary_descriptors");

      delete dictionary_descriptors_ptr;

      banner="Wrote K = "+stringfunc::number_to_string(K)
         +" dictionary descriptors to "+dictionary_hdf5_filename;
      outputfunc::write_big_banner(banner);

      delete texture_rectangle_ptr;
   } // loop over index s labeling symbol names
   
}

   
