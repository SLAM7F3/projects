// ==========================================================================
// Program COMPUTE_SHAPE_DESCRIPTORS imports connected components
// corresponding to previously thresholded TOC12 symbol and non-text
// character regions generated by program SYMBOLS2PNGS.  Following
// Neumann and Matas, "Real-time scene text localization and
// recognition", CVPR 2012, we compute 11-dimensional feature
// descriptors for each extremal region.  The 11D descriptors are
// written to output text files.

// 			compute_shape_descriptors

// ==========================================================================
// Last updated on 8/9/12; 8/30/12; 8/31/12
// ==========================================================================

#include  <iostream>
#include  <map>
#include  <string>
#include  <vector>

#include "image/binaryimagefuncs.h"
#include "video/connected_components.h"
#include "general/filefuncs.h"
#include "image/graphicsfuncs.h"
#include "image/imagefuncs.h"
#include "numrec/nrfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"

#include "graphs/graph.h"
#include "graphs/graph_hierarchy.h"
#include "datastructures/Linkedlist.h"
#include "graphs/node.h"
#include "math/threevector.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(12);

   connected_components* connected_components_ptr=NULL;

//   int text_type_flag=0;	// non-text
   int text_type_flag=2;	// Symbol
   
//   string nontext_subdir="./images/non_signs/all_nonsigns/non_symbols/";
//   vector<string> char_image_filenames=filefunc::image_files_in_subdir(
//      nontext_subdir);
//   string features_filename="nontext_features.dat";

   string char_type;
   cout << "Enter 'b' for bright chars against dark background " << endl;
   cout << " or 'd' for dark chars against bright background" << endl;
   cin >> char_type;

   bool bright_ccs_flag=true;
   if (char_type=="d")
   {
      bright_ccs_flag=false;
   }
   
   if (bright_ccs_flag)
   {
      cout << "Processing bright chars against dark background" << endl;
   }
   else
   {
      cout << "Processing dark chars against bright background" << endl;
   }

   string alphabet_subdir="./images/ppt_signs/alphabet/";
   string ccs_subdir=alphabet_subdir;
   if (bright_ccs_flag)
   {
      ccs_subdir += "bright_connected_components/";
   }
   else
   {
      ccs_subdir += "dark_connected_components/";
   }
   string synthetic_subdir=ccs_subdir+"synthetic_letters/";

   string symbol_name;
   cout << "Enter symbol name (e.g. 'biohazard','eat','skull'):" << endl;
   cin >> symbol_name;

   string extremal_region_subdir=synthetic_subdir+symbol_name+"/";

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("png");

   bool search_all_children_dirs_flag=false;
   vector<string> char_image_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,extremal_region_subdir,
         search_all_children_dirs_flag);

   string features_filename;
   if (text_type_flag==0)
   {
      features_filename="nontext_features.dat";
   }
   else if (text_type_flag==2)
   {
      if (bright_ccs_flag)
      {
         features_filename=extremal_region_subdir+"features_bright_"
            +symbol_name+".dat";
      }
      else
      {
         features_filename=extremal_region_subdir+"features_dark_"
            +symbol_name+".dat";
      }
   }

   int i_start=0;
//   int i_stop=50;
   int i_stop=char_image_filenames.size();

   int n_holes;
   double aspect_ratio,compactness,n_crossings;

   ofstream features_stream;
   filefunc::openfile(features_filename,features_stream);
   features_stream << "# image aspect_ratio compactness n_holes n_horiz_crossings sigma_x sigma_y covar_xy skew_px sqr_px_py sqr_py_px skew_py" << endl << endl;

   int threshold=128;	// TOC12 symbols
//   cout << "Enter threshold:" << endl;
//   cin >> threshold;

   int feature_counter=0;
   for (int i=i_start; i<i_stop; i++)
   {
      cout << "i = " << i << " of " << i_stop 
           << " : Processing image_filename = " 
           << filefunc::getbasename(char_image_filenames[i])
           << endl;
      
      delete connected_components_ptr;   
      connected_components_ptr=new connected_components();
      connected_components_ptr->set_min_n_connected_components(1);
      connected_components_ptr->set_max_n_connected_components(2);
      connected_components_ptr->reset_image(char_image_filenames[i]);

      int index=0;
      int level=1;
      bool invert_binary_values_flag=false;	// bright chars dark bckgrnd
//      bool export_connected_regions_flag=true;
      bool export_connected_regions_flag=false;
      bool retain_largest_cc_flag=true;
      connected_components_ptr->compute_connected_components(
         index,threshold,level,invert_binary_values_flag,
         export_connected_regions_flag,
         retain_largest_cc_flag);

      connected_components::TREE_PTR tree_ptr=connected_components_ptr->
         get_tree_ptr();

      std::vector<connected_components::TREENODE_PTR> treenode_ptrs=
         tree_ptr->retrieve_nodes_on_level(level);

// Ignore any training image which doesn't have precisely one
// connected component:

      if (text_type_flag != 0 && treenode_ptrs.size() != 1) 
      {
         cout << "# connected components found = "
              << treenode_ptrs.size() << endl;
         continue;
      }

      unsigned int left_bottom_pu,left_bottom_pv,right_top_pu,right_top_pv;
      for (int n=0; n<treenode_ptrs.size(); n++)
      {
         connected_components::TREENODE_PTR treenode_ptr=treenode_ptrs[n];
         extremal_region* extremal_region_ptr=treenode_ptr->get_data_ptr();

         int ID=extremal_region_ptr->get_ID();
         int pixel_area=extremal_region_ptr->get_pixel_area();
         int pixel_perimeter=extremal_region_ptr->get_pixel_perim();
         int euler_number=extremal_region_ptr->get_Euler_number();

         extremal_region_ptr->get_bbox(
            left_bottom_pu,left_bottom_pv,right_top_pu,right_top_pv);
         int pixel_width=right_top_pu-left_bottom_pu;
         int pixel_height=right_top_pv-left_bottom_pv;

//         cout << "node: ID = " << ID
//              << " area = " << pixel_area
//              << " perim = " << pixel_perimeter
//              << " euler = " << euler_number
//              << endl;

//         cout << "left_bottom: pu = " << left_bottom_pu
//              << " pv = " << left_bottom_pv << endl;
//         cout << "right_top: pu = " << right_top_pu
//              << " pv = " << right_top_pv << endl;
         
         double aspect_ratio=extremal_region_ptr->get_aspect_ratio();
         double compactness=extremal_region_ptr->get_compactness();
         int n_holes=extremal_region_ptr->get_n_holes();
         int median_horiz_crossings=extremal_region_ptr->
            get_n_horiz_crossings();

         double dimensionless_sigma_px=extremal_region_ptr->get_sigma_px()/
            pixel_width;
         double dimensionless_sigma_py=extremal_region_ptr->get_sigma_py()/
            pixel_height;
         double dimensionless_px_py_covar=
            extremal_region_ptr->get_dimensionless_px_py_covar();

         double skew_px=extremal_region_ptr->get_skew_px();
         double dimensionless_sqr_px_py=
            extremal_region_ptr->get_dimensionless_sqr_px_py();
         double dimensionless_sqr_py_px=
            extremal_region_ptr->get_dimensionless_sqr_py_px();
         double skew_py=extremal_region_ptr->get_skew_py();

//         cout << "  n = " << n << " node_ID = " << ID << endl;
//         cout << "  aspect_ratio = " << aspect_ratio << endl;
//         cout << "  compactness = " << compactness << endl;
//         cout << "  n_holes = " << n_holes << endl;
//         cout << "  median_horiz_crossings = " << median_horiz_crossings
//              << endl;
//         cout << "  dimensionless_sigma_px = " 
//              << dimensionless_sigma_px << endl;
//         cout << "  dimensionless_sigma_py = " 
//              << dimensionless_sigma_py << endl;
//         cout << "  dimensionless_px_py_covar = " 
//              << dimensionless_px_py_covar << endl;

// No legitimate character has more than 2 holes!

         if (text_type_flag==1 && n_holes > 2) continue;

// On 8/7/12, we discovered the hard and painful way that NANs can be
// generated for TOC12 symbols.  So we must explicitly verify that
// every feature value is OK before writing them to the output file!

         if (mathfunc::my_isnan(aspect_ratio)) continue;
         if (mathfunc::my_isnan(compactness)) continue;
         if (mathfunc::my_isnan(n_holes)) continue;
         if (mathfunc::my_isnan(median_horiz_crossings)) continue;
         if (mathfunc::my_isnan(dimensionless_sigma_px)) continue;
         if (mathfunc::my_isnan(dimensionless_sigma_py)) continue;
         if (mathfunc::my_isnan(dimensionless_px_py_covar)) continue;
         if (mathfunc::my_isnan(skew_px)) continue;
         if (mathfunc::my_isnan(dimensionless_sqr_px_py)) continue;
         if (mathfunc::my_isnan(dimensionless_sqr_py_px)) continue;
         if (mathfunc::my_isnan(skew_py)) continue;

         features_stream << feature_counter++ << "  "
                         << filefunc::getbasename(char_image_filenames[i]) 
                         << "  "
                         << aspect_ratio << "  "
                         << compactness << "  "
                         << n_holes << "  "
                         << median_horiz_crossings << "  "
                         << dimensionless_sigma_px << "  "
                         << dimensionless_sigma_py << "  "
                         << dimensionless_px_py_covar << "  "
                         << skew_px << "  "
                         << dimensionless_sqr_px_py << "  "
                         << dimensionless_sqr_py_px << "  "
                         << skew_py << "  "
                         << endl;

      } // loop over index n labeling treenodes

   } // loop over index i labeling input 32x32 jpeg files
   filefunc::closefile(features_filename,features_stream);

   delete connected_components_ptr;

   string banner="Exported features to "+features_filename;
   outputfunc::write_big_banner(banner);
}

