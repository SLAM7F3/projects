========================================================================
TOC12 README
========================================================================
Last updated on 8/20/12; 8/31/12; 10/4/12
========================================================================

---------------------------------------
SYNTHETIC SYMBOL GENERATION PROGRAMS
---------------------------------------

*. Program CONVERT_GREY_IMAGE_TO_RGB queries the user to enter the name for
some 8-byte greyscale or 24-byte RGB image.  It instantiates a
texture_rectangle object which converts the input 8-byte greyscale image to
a nearly identical 24-byte RGB image.  In order to force the output image
to really have 3 color channels, some small random fluctuations are added
to all non-zero valued pixels.

We wrote this utility program in order to work with "black and white"
images which truly correspond to 3 RGB channels rather than a single
greyscale channel.

*.  Program LETTERS2PNGS is a variant of CHARS2PNGS.  It imports PNG/JPG
images of symbol "letters" generated via LOCATE_CHARS and
connected_components::export_individual_connected_components() enabled.
The UV image is initially oriented in the YZ world-plane.  It is rotated
through az about the world z axis, el about the world y-axis and roll about
the the world x-axis.  The az, el and roll angles are random variables
selected from gaussian distributions with reasonable standard deviations to
simulate camera views of TOC12 symbols in the wild.

The rotated synthetic character image is subsequently projected back into
the YZ world-plane.  The projected image is cropped so that the rotated
character fills most of the projection.  The cropped character is scaled so
that its height equals 32 pixels in size.  Finally, the cropped character
is blurred by some random amount.


*. Program GENERATE_SYMBOL_IMAGES is a variant of GENERATE_CHAR_IMAGES.  It
imports PNG/JPG images of TOC12 symbol "words".  The UV image is initially
oriented in the YZ world-plane.  It is rotated through az about the world z
axis, el about the world y-axis and roll about the the world x-axis.  The
az, el and roll angles are random variables selected from gaussian
distributions with reasonable standard deviations to simulate camera views
of TOC12 symbols in the wild.

The rotated synthetic character image is subsequently projected
back into the YZ world-plane.  The projected image is pasted onto a
random grey-scale background.  On 8/15/12, Geoff Brown recommended
introducing more random variation into the background in order to
desensitize the classifier to actual background variations.

The projected synthetic image is cropped so that the rotated
word fills most of the projection.  The cropped word is scaled so
that its height equals 32 pixels in size.  Finally, the cropped
word is blurred by some random amount.

*.  Program LINK_SYMBOL_IMAGES loops over all 9 TOC12 signs.  For each one,
it generates links to the other 8 signs.  We wrote this utility program in
order to train the Ng classifier on negative examples of symbols to
hopefully reduce false alarms.


------------------------
EXTREMAL REGION PROGRAMS
------------------------

*. Program COMPUTE_SHAPE_DESCRIPTORS imports connected components
corresponding to previously thresholded TOC12 symbol and non-text
character regions generated by program SYMBOLS2PNGS.  Following
Neumann and Matas, "Real-time scene text localization and
recognition", CVPR 2012, we compute 11-dimensional feature
descriptors for each extremal region.  The 11D descriptors are
written to output text files.

*. Program SVM_SHAPE reads in shape descriptors for text and non-text which
were previously generated by COMPUTE_SHAPE_DESCRIPTORS.  It uses Davis
King's DLIB library to train an SVM classifier with a gaussian a
radial-basis kernel.  Binary and probabilistic decision functions which
indicate whether a candidate extremal region may contain a text character
or not are exported in serialized DLIB formats.  Subsequent programs can
then use DLIB to import these trained decision functions.

*.  Program RESIZE_IMAGES needs to be executed from within some
subdirectory containg a set of PNG or JPG files.  It generates subsampled
versions of each input image whose maximum width and height do not exceed
640 x 480.  The output resized images are exported to ./resized_images.

*.  Program LOCATE_SYMBOLS is a variant of LOCATE_CHARS intended for TOC12
sign detection.

-----------------------------------------------------
COATES-NG UNSUPERVISED CLASSIFICATION PROGRAMS
-----------------------------------------------------

*.  Program EXTRACT_NONSYMBOLS searches for JPG, PNG and GIF files within
./images/non_signs/all_nonsigns/ .  Randomly looping over all such
non-symbol image files, it randomly chooses a 32x32 window within some
image. If the image entropy for the random window exceeds a minimal
threshold, EXTRACT_NONSYMBOLS exports it to a file with name of the form
nontext_123456.jpg.

*.  Program SYMBOL_DESCRIPTORS loops over all renormalized greyscale or RGB
character image files depending upon RGB_pixels_flag.  It extracts
n_patches_per_image 8x8 pixel patches from each image.  It converts the 8x8
patches into a 64x3 [64] column vector of RGB color [greyscale] values. Raw
descriptors for all character image patches are exported to a single HDF5
binary file.  Descriptor mean and covariance are also recursively
calculated and written to output text files.

*.  Program WHITEN_SYMBOL_DESCRIPTORS imports color RGB 64x3 [greyscale
64x1] descriptors for 8x8 pixel patches selected from character jpeg images
generated by program SYMBOL_DESCRIPTORS.  It also imports the descriptors'
mean and inverse square root covariance matrix which were previously output
by SYMBOL_DESCRIPTORS.  The mean is subtracted from each raw descriptor,
and the residual is multiplied by the inverse square root covariance matrix
in order to whiten it. covariance matrix in order to "whiten" it.  Whitened
patch descriptors are exported to a single HDF5 binary file.

*.  Program SYMBOL_DICTIONARY imports whitened 64x3 RGB color [64x1
greyscale] descriptors generated by program WHITEN_SYMBOL_DESCRIPTORS for
8x8 pixel patches X^i randomly selected from text character images.  It
initially assigns each patch to some random cluster labeled by 0 <= k <
K. Score vectors S^i associated with each pixel patch are then computed
which have precisely one non-zero entry.  We then iteratively solve for the
64xK dictionary matrix D which minimizes sum_i |D S^i - X^i|. Columns
within D are subsequently renormalized to have unit magnitude.  The final
values in D are exported to a binary HDF5 file.

After each iteration, a PNG file is generated which shows all K 8x8
descriptors within the dictionary.

*.  POOL_SYMBOL_FEATURES reads in a set of text or non-text images files
from a specified input subdirectory.  The width or height for each input
image should precisely equal 32 pixels in size, but both need not equal 32.
It also imports a precomputed symbol dictionary along with whitening mean
and covariance matrices.  Looping over each input window file,
POOL_SYMBOL_FEATURES extracts 8x8 patches in each window for every possible
~25x~25 pixel offset.  Each 8x8 patch is projected onto the dictionary and
converted into a K-dimensional histogram. The histogram descriptors are
averaged together within 3x3 regions of the ~32x~32 window.  So the final
descriptor for each ~32x~32 window is a 9*K dimensional vector.  The 9*K
dimensional window descriptors for all valid ~32x~32 windows are exported
to windows_descriptors.hdf5.

*.  SVM_SYMBOL reads in 9xK dimensional features for N ~32x~32 symbol
windows and N ~32x~32 non-text windows generated by POOL_SYMBOL_FEATURES.
It then uses Davis King's DLIB library to load the input samples along with
their positive and negative labels.  After the ordering of the input
samples is randomized, cross-correlation is performed in order to estimate
a reasonable value for a linear-SVM slack variable C.  DLIB then trains
binary decision and probabilistic decision functions. Serialized versions
of the binary and probabilistic decision functions are exported to output
binary files.

