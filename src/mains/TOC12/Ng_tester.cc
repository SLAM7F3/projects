// ==========================================================================
// Program NG_TESTER takes in the sign label and number for some
// synthetic TOC12 sign image.  It computes and returns the Ng sign
// classification probability.

//				Ng_tester

// ==========================================================================
// Last updated on 9/28/12; 10/1/12; 10/30/12; 6/7/14
// ==========================================================================

#include  <iostream>
#include  <string>
#include  <vector>
#include "dlib/svm.h"

#include "cluster/akm.h"
#include "general/filefuncs.h"
#include "math/genvector.h"
#include "image/imagefuncs.h"
#include "math/mathfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "classification/text_detector.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::ios;
using std::ofstream;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(12);

   string final_signs_subdir="./images/final_signs/";
   string ppt_signs_subdir="./images/ppt_signs/";
//   string symbols_input_subdir=ppt_signs_subdir;
   string symbols_input_subdir=final_signs_subdir;
   string learned_funcs_subdir="./learned_functions/";

   string symbol_name;
   cout << "Enter symbol name:" << endl;
   cout << "  yellow_radiation,orange_biohazard,blue_radiation" << endl;
   cout << "  blue_water,blue_gas,red_stop" << endl;
   cout << "  green_start,bw_skull,bw_eat:" << endl;
   cin >> symbol_name;

// Import probabilistic decision functions generated by an SVM with a
// linear kernel on 5K symbol and 97K non-symbol images:

   const int K_Ng=1024;
   const int nineK=9*K_Ng;

   typedef dlib::matrix<double, nineK, 1> Ng_sample_type;
   typedef dlib::linear_kernel<Ng_sample_type> Ng_kernel_type;
   Ng_sample_type Ng_sample;

   typedef dlib::probabilistic_decision_function<Ng_kernel_type> 
      Ng_probabilistic_funct_type;  
   typedef dlib::normalized_function<Ng_probabilistic_funct_type> 
      Ng_pfunct_type;
   Ng_pfunct_type Ng_pfunct;


   bool RGB_pixels_flag=false;
//   int D=64*3;	// RGB color
//   if (!RGB_pixels_flag)
//   {
//      D=64;	// greyscale
//   }


   string learned_Ng_pfunct_filename=learned_funcs_subdir;
   learned_Ng_pfunct_filename += symbol_name+"/";
   learned_Ng_pfunct_filename += "symbols_Ng_pfunct_";
//   learned_Ng_pfunct_filename += "12000_97748";
   learned_Ng_pfunct_filename += "15000_104000";
   learned_Ng_pfunct_filename += ".dat";
   cout << "learned_Ng_pfunct_filename = "
        << learned_Ng_pfunct_filename << endl;
   ifstream fin6(learned_Ng_pfunct_filename.c_str(),ios::binary);
   deserialize(Ng_pfunct, fin6);

// Import dictionary trained on symbol and non-symbol images:

   string synthetic_subdir=symbols_input_subdir+"synthetic_symbols/";
   string synthetic_symbols_subdir=synthetic_subdir+symbol_name+"/";
   string dictionary_subdir=synthetic_symbols_subdir;
   cout << "dictionary_subdir = " << dictionary_subdir << endl;

   text_detector* text_detector_ptr=new text_detector(dictionary_subdir, RGB_pixels_flag);
   text_detector_ptr->import_inverse_sqrt_covar_matrix();

   int synthetic_ID=100;
   cout << "Enter synthetic char file number:" << endl;
   cin >> synthetic_ID;
   
   string image_filename=dictionary_subdir+"synthetic_char_"+
      stringfunc::integer_to_string(synthetic_ID,5)+".png";

   unsigned int width,height;
   imagefunc::get_image_width_height(image_filename,width,height);
   if (width < 8) exit(-1);
   
   cout << " image_filename = " << image_filename << endl;
   cout << " xdim = " << width << " ydim = " << height
        << endl;


   texture_rectangle* texture_rectangle_ptr=new texture_rectangle();
   texture_rectangle_ptr->reset_texture_content(image_filename);

// Perform TOC12 sign-dependent conversion from RGB to greyscale:

   if (symbol_name=="yellow_radiation" ||
   symbol_name=="orange_biohazard")
   {
      texture_rectangle_ptr->convert_color_image_to_greyscale(); 
   }
   else if (symbol_name=="blue_radiation")
   {
      texture_rectangle_ptr->
         convert_color_image_to_single_color_channel(1,true);  
      // red channel
   }
   else
   {
      texture_rectangle_ptr->convert_color_image_to_luminosity();
   }

// For debugging purposes only, export *qtwoDarray_ptr as new JPG
// image chip:

   twoDarray* qtwoDarray_ptr=texture_rectangle_ptr->
      export_sub_twoDarray(0,width-1,0,height-1);
   qtwoDarray_ptr->init_coord_system(0,1,0,1);

   texture_rectangle* subtexture_rectangle_ptr=new
      texture_rectangle(width,height,1,3,NULL);
   subtexture_rectangle_ptr->generate_blank_image_file(
      width,height,"blank.jpg",0.5);
   bool randomize_blue_values_flag=true;
   subtexture_rectangle_ptr->
      convert_single_twoDarray_to_three_channels(
         qtwoDarray_ptr,randomize_blue_values_flag);
   string candidate_char_patches_subdir="./candidate_patches/";
   filefunc::dircreate(candidate_char_patches_subdir);
   string patch_filename=candidate_char_patches_subdir+"Ng_patch.png";
   cout << "patch_filename = " << patch_filename << endl;
   subtexture_rectangle_ptr->write_curr_frame(patch_filename);
   delete subtexture_rectangle_ptr;

               
   text_detector_ptr->set_texture_rectangle_ptr(texture_rectangle_ptr);
   text_detector_ptr->set_window_width(width);
   text_detector_ptr->set_window_height(height);
   

   double Ng_prob=0;
   if (text_detector_ptr->average_window_features(0,0))
   {
      float* window_histogram=text_detector_ptr->
         get_nineK_window_descriptor();
      for (int k=0; k<nineK; k++)
      {
         Ng_sample(k)=window_histogram[k];
      } // loop over index k labeling dictionary descriptors
      Ng_prob=Ng_pfunct(Ng_sample);
      cout << " Ng char probability = " << Ng_prob << endl;
      
   } // average_window_features conditional
  
   delete text_detector_ptr;
}

