// ==========================================================================
// Program DARK_SIGNS is a cleaned-up version of BLACK_SIGNS which looks for
// TOC12 skull and eat ppt sign regions based primarily upon their
// color and edge contents.
// ==========================================================================
// Last updated on 10/18/12; 10/19/12
// ==========================================================================

#include  <iostream>
#include  <map>
#include  <set>
#include  <string>
#include  <vector>
#include "dlib/svm.h"

#include "image/extremal_regions_group.h"
#include "general/filefuncs.h"
#include "video/RGB_analyzer.h"
#include "classification/signrecogfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "classification/text_detector.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::pair;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(12);

   string ppt_signs_subdir="./images/ppt_signs/";
   string output_subdir=ppt_signs_subdir+"quantized_colors/";
   filefunc::dircreate(output_subdir);

   extremal_regions_group regions_group;

// Initialize TOC12 sign properties:
   
   signrecogfunc::SIGN_PROPERTIES curr_sign_properties,prev_sign_properties;
   vector<signrecogfunc::SIGN_PROPERTIES> sign_properties=
      signrecogfunc::initialize_sign_properties();

   cout << endl;
   cout << "------------------------------------------------------" << endl;
   cout << "Yellow radiation sign ID = 0" << endl;
   cout << "Orange biohazard sign ID = 1" << endl;
   cout << "Blue-purple radiation sign ID = 2" << endl;
   cout << "Blue water sign ID = 3" << endl;
   cout << "Blue gasoline sign ID = 4" << endl;
   cout << "Red stop sign ID = 5" << endl;
   cout << "Green start sign ID = 6" << endl;
   cout << "Black-white skull sign ID = 7" << endl;
   cout << "Black-white eat sign ID = 8" << endl;
   cout << "------------------------------------------------------" << endl;   

   int sign_ID_start=7;
   int sign_ID_stop=8;

// Import quantized RGB lookup tables for all TOC12 signs:

   RGB_analyzer* RGB_analyzer_ptr=new RGB_analyzer();
   for (int s=0; s<sign_properties.size(); s++)
   {
      RGB_analyzer_ptr->import_quantized_RGB_lookup_table(
         sign_properties[s].sign_hue);
   }

// Import probabilistic decision functions generated by an SVM with a
// linear kernel on 12K symbol and 96K non-symbol images per TOC12 sign:

   vector<signrecogfunc::Ng_pfunct_type> Ng_pfuncts;
   vector<text_detector*> text_detector_ptrs=
      signrecogfunc::import_Ng_probabilistic_classification_functions(
         sign_properties,Ng_pfuncts);

   texture_rectangle* texture_rectangle_ptr=new texture_rectangle();
   texture_rectangle* binary_texture_rectangle_ptr=
      new texture_rectangle();
   texture_rectangle* black_flooded_texture_rectangle_ptr=
      new texture_rectangle();
   texture_rectangle* black_grads_texture_rectangle_ptr=
      new texture_rectangle();
   texture_rectangle* edges_texture_rectangle_ptr=new texture_rectangle();

   int video_start=12;
   int video_stop=12;
   int delta_video=1;

   cout << "Enter starting video pass number ( >= 5):" << endl;
   cin >> video_start;
   cout << "Enter stopping video pass number ( <= 20):" << endl;
   cin >> video_stop;

   timefunc::initialize_timeofday_clock();

   extremal_regions_group::ID_REGION_MAP* black_regions_map_ptr=
      new extremal_regions_group::ID_REGION_MAP;

// Loop over multiple video clips starts here:

   int image_counter=0;
   for (int video_number=video_start; video_number <=video_stop; 
        video_number += delta_video)
   {
      string video_subdir=output_subdir+
         "vid_"+stringfunc::integer_to_string(video_number,2)+"/";
      filefunc::dircreate(video_subdir);

      string image_subdir=ppt_signs_subdir+"videos/vid";
      image_subdir += stringfunc::integer_to_string(video_number,2)+"_frames/";
      cout << "image_subdir = " << image_subdir << endl;

      vector<string> image_filenames=filefunc::image_files_in_subdir(
         image_subdir);

      int i_start=0;
      int i_stop=image_filenames.size()-1;
      cout << "Last image number = " << image_filenames.size() << endl;
      cout << "Enter starting image number:" << endl;
      cin >> i_start;
      cout << "Enter stopping image number:" << endl;
      cin >> i_stop;
      i_start--;
      i_stop--;
//      cout << "i_start = " << i_start << " i_stop = " << i_stop << endl;

// Loop over individual video frames starts here:

      for (int i=i_start; i<=i_stop; i++)
      {
         string orig_image_filename=image_filenames[i];
         cout << "Original image_filename = " << orig_image_filename << endl;
         int frame_number=i+1;

         if (image_counter >= 1)
         {
            signrecogfunc::print_processing_time(image_counter);
         }
         image_counter++;

         int xdim,ydim;
         string image_filename=signrecogfunc::resize_input_image(
            orig_image_filename,xdim,ydim);
         texture_rectangle_ptr->reset_texture_content(image_filename);

// Loop over TOC12 sign IDs starts here:

         vector<polygon> bbox_polygons;
         vector<int> bbox_color_indices;

         for (int curr_sign_ID=sign_ID_start; curr_sign_ID <= sign_ID_stop;
              curr_sign_ID++)
         {
            curr_sign_properties=sign_properties[curr_sign_ID];   

            if (curr_sign_ID > sign_ID_start)
            {
               prev_sign_properties=sign_properties[curr_sign_ID-1];
            }
            else
            {
               prev_sign_properties=curr_sign_properties;
            }
            
            cout << "======================================================"
                 << endl;
            cout << "symbol = " << curr_sign_properties.symbol_name << endl;

            signrecogfunc::reset_texture_image(
               image_filename,black_flooded_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,binary_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,edges_texture_rectangle_ptr);
            signrecogfunc::reset_texture_image(
               image_filename,black_grads_texture_rectangle_ptr);

// Genuine TOC12 signs exhibit strong inner edge content. So compute
// edge maps:

            signrecogfunc::GRADSTEP_MAP black_gradstep_map,white_gradstep_map;

            signrecogfunc::compute_edgemaps(
               curr_sign_ID,sign_ID_start,
               curr_sign_properties,prev_sign_properties,
               edges_texture_rectangle_ptr,
               black_gradstep_map,white_gradstep_map);

            string binary_quantized_filename=video_subdir+
               "binary_black_"+stringfunc::number_to_string(frame_number)+
               ".jpg";

            signrecogfunc::merge_bright_MSER_and_flooded_black_region_bboxes(
               xdim,ydim,
               image_filename,binary_quantized_filename,
               binary_texture_rectangle_ptr,
               black_flooded_texture_rectangle_ptr,
               black_grads_texture_rectangle_ptr,
               edges_texture_rectangle_ptr,
               texture_rectangle_ptr,
               black_gradstep_map,regions_group,black_regions_map_ptr);

// Form bounding box polygons around adjacent bright MSER & flooded
// black regions:

//            cout << "Forming merged bbox polygons" << endl;

            signrecogfunc::
               form_bright_MSER_and_flooded_black_region_bbox_polygons(
                  xdim,ydim,curr_sign_ID,regions_group,
                  black_regions_map_ptr,curr_sign_properties,
                  texture_rectangle_ptr,text_detector_ptrs,
                  Ng_pfuncts,bbox_polygons,bbox_color_indices);

         } // loop over curr_sign_ID

         if (bbox_polygons.size() > 0)
         {
            texture_rectangle_ptr->reset_texture_content(image_filename);
            signrecogfunc::export_bbox_polygons(
               texture_rectangle_ptr,bbox_polygons,bbox_color_indices);
            string bboxes_filename=video_subdir+
               "bboxes_"+stringfunc::integer_to_string(frame_number,4)+".jpg";
            texture_rectangle_ptr->write_curr_frame(bboxes_filename);
         }

      } // loop over index i labeling image filenames

      signrecogfunc::print_processing_time(image_counter);

   } // loop over video_number 

   regions_group.purge_dark_and_bright_regions();
   regions_group.destroy_all_regions(black_regions_map_ptr);
   delete black_regions_map_ptr;

   delete RGB_analyzer_ptr;
   delete texture_rectangle_ptr;
   delete edges_texture_rectangle_ptr;
   delete black_flooded_texture_rectangle_ptr;
   delete black_grads_texture_rectangle_ptr;
   delete binary_texture_rectangle_ptr;

   regions_group.set_bright_cc_twoDarray_ptr(NULL);
}

