// ==========================================================================
// Program GPSFIT reads in reconstructed camera posns generated by
// Bundler/VSFM.  It also reads in a text file containing hardware GPS
// measurements for the camera generated by program
// PARSE_PUMA_METADATA.  If the two input files are NOT in precise
// correspondence, GPSFIT ignores any entries for which a
// reconstructed frame does NOT have corresponding GPS metadata.

// Within a RANSAC loop, GPSFIT applies B. Horn's closed-form
// least-squares fitting procedure to compute the global rotation,
// translation and scaling needed to transform the bundler camera path
// into the GPS path.  It reports the average residual
// between the transformed and measured paths.  This program also
// exports the transformed path as a TDP and OSGA file.

//  gpsfit --region_filename ./bundler/Puma/May30_2013/Day1_flt2/VSFM_subset/packages/peter_inputs.pkg 

// ==========================================================================
// Last updated on 12/10/13; 12/30/13; 1/8/14
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "bundler/bundlerfuncs.h"
#include "math/constant_vectors.h"
#include "general/filefuncs.h"
#include "math/fourvector.h"
#include "passes/PassesGroup.h"
#include "math/rotation.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "math/threevector.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(10);
   timefunc::initialize_timeofday_clock();

//   bool GoPro_camera_flag=false;
   bool GoPro_camera_flag=true;

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string bundle_filename=bundler_IO_subdir+"bundle.out";
   string image_sizes_filename=bundler_IO_subdir+"image_sizes.dat";
   string packages_subdir=bundler_IO_subdir+"packages/";
   string peter_inputs_filename=packages_subdir+"peter_inputs.pkg";

// Enter temporal offset for GPS waypoint measurements:

   int delta_time_step;
   if (GoPro_camera_flag)
   {
      delta_time_step=0;	// sec
   }
   else
   {
      delta_time_step=1;	// sec
   }
   
//   cout << "Enter delta time step (in secs):" << endl;
//   cin >> delta_time_step;

// Read in "left" (reconstructed) and "right" (GPS) coordinate system
// points:

   string reconstructed_posns_filename=bundler_IO_subdir+
      "orig_reconstructed_camera_posns.dat";			// bundler
   filefunc::ReadInfile(reconstructed_posns_filename);
   vector<string> reconstructed_posn_lines=filefunc::text_line;
   cout << "reconstructed_posn_lines.size() = " 
        << reconstructed_posn_lines.size() << endl;

   string GPS_filename=bundler_IO_subdir+"puma.geoposns";
   filefunc::ReadInfile(GPS_filename);
   vector<string> GPS_waypoint_lines=filefunc::text_line;
   cout << "GPS_waypoint_lines.size() = "
        << GPS_waypoint_lines.size() << endl;

   typedef map<string,threevector> CAMERA_POSNS_MAP;
   CAMERA_POSNS_MAP::iterator iter;
   CAMERA_POSNS_MAP reconstructed_camera_posns_map,gps_posns_map;

// independent string = original video frame file basename
// dependent threevector = camera posn (either from GPS or reconstruction)

   for (int i=0; i<GPS_waypoint_lines.size(); i++)
   {
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(GPS_waypoint_lines[i]);
      string image_filename=substrings[0];

// Program PARSE_PUMA_METADATA exports 6 columns per row.  But in late
// December 2013, Nick Armstrong-Crews generated an effective
// puma.geoposns file for Bryce Remesch's MIT UAV data set which has 4
// columns per row:

      threevector gps_posn;
      if (substrings.size()==4)
      {
         gps_posn=threevector(
            stringfunc::string_to_number(substrings[1]),
            stringfunc::string_to_number(substrings[2]),
            stringfunc::string_to_number(substrings[3]));
      }
      else if (substrings.size()==6)
      {
         gps_posn=threevector(
            stringfunc::string_to_number(substrings[3]),
            stringfunc::string_to_number(substrings[4]),
            stringfunc::string_to_number(substrings[5]));
      }

      string separator_chars="-.";
      if (GoPro_camera_flag)
      {
         separator_chars += "G";
      }
      substrings.clear();
      substrings=stringfunc::decompose_string_into_substrings(
         image_filename,separator_chars);
//      for (int s=0; s<substrings.size(); s++)
//      {
//         cout << "s = " << s << " substrings[s] = " << substrings[s]
//              << endl;
//      }
      
      int orig_frame_ID;
      if (GoPro_camera_flag)
      {
         orig_frame_ID=stringfunc::string_to_number(substrings[0]);
      }
      else
      {
         orig_frame_ID=stringfunc::string_to_number(substrings[1]);
      }

      int revised_frame_ID=orig_frame_ID+delta_time_step;
      if (GoPro_camera_flag)
      {
         image_filename="G"+stringfunc::integer_to_string(
            revised_frame_ID,7)+".JPG";
      }
      else
      {
         image_filename="frame-"+stringfunc::integer_to_string(
            revised_frame_ID,5)+".jpg";
      }
//      cout << "i = " << i << " image_filename = " << image_filename << endl;
//      cout << "orig_frame_ID = " << orig_frame_ID << endl;

      gps_posns_map[image_filename]=gps_posn;
   }
//   cout << "gps_posns_map.size() = " << gps_posns_map.size() << endl;

   vector<threevector> left_points,right_points;
   for (int i=0; i<reconstructed_posn_lines.size(); i++)
   {
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(
            reconstructed_posn_lines[i]);
//      for (int s=0; s<substrings.size(); s++)
//      {
//         cout << "s = " << s << " substrings[s] = " << substrings[s]
//              << endl;
//      }

      string image_filename=substrings[1];
      iter=gps_posns_map.find(image_filename);
      if (iter==gps_posns_map.end()) continue;

      threevector reconstructed_posn(
         stringfunc::string_to_number(substrings[2]),
         stringfunc::string_to_number(substrings[3]),
         stringfunc::string_to_number(substrings[4]));
      left_points.push_back(reconstructed_posn);

      threevector gps_posn=iter->second;
      right_points.push_back(gps_posn);
   } // loop over index i labeling lines in GPS_filename
//   cout << "right_points.size() = " << right_points.size() << endl;
   
   threevector left_COM,right_COM;
   double az,el,roll,scale;
   threevector trans_Horn,trans_Peter;
//   double max_residual_distance=150;	// meters
//   cout << "Enter max residual distance" << endl;
//   cin >> max_residual_distance;

   double median_residual_dist,quartile_width;
   bundlerfunc::RANSAC_fit_rotation_translation_scale(
      left_points,right_points,left_COM,right_COM,
      az,el,roll,scale,trans_Horn,trans_Peter,
      median_residual_dist,quartile_width);

   cout << "median_residual_dist = " << median_residual_dist
        << " quartile_width = " << quartile_width << endl;
   double max_residual_distance=median_residual_dist+3*quartile_width;
   cout << "max_residual_dist = " << max_residual_distance << endl;

//   cout << "Enter max residual dist (for outlier determination)" << endl;
//   cin >> max_residual_distance;

   cout << "trans_Horn = " << trans_Horn << endl;
   cout << "trans_Peter = " << trans_Peter << endl;

// For purposes of mapping GPS to transformed reconstructed points,
// store ALL (and not just inlier) transformed reconstructed camera
// positions within STL vector transformed_left_points:

   vector<threevector> transformed_left_points;
   double avg_residual=bundlerfunc::compute_avg_residual(
      left_points,right_points,transformed_left_points,
      az,el,roll,scale,trans_Horn);

// Export indices for outlier left-right tiepoint pairs to text file
// which can later be imported into
// mains/photosynth/write_viewbundler_script:

   vector<int> outlier_indices=bundlerfunc::identify_left_right_pair_outliers(
      left_points,right_points,az,el,roll,scale,
      trans_Horn,max_residual_distance);
   string banner="Number outlier pairs detected = "+
      stringfunc::number_to_string(outlier_indices.size());
   outputfunc::write_banner(banner);

   string outlier_filename=bundler_IO_subdir+"outlier.indices";
   ofstream outlier_stream;
   filefunc::openfile(outlier_filename,outlier_stream);

   for (int i=0; i<outlier_indices.size(); i++)
   {
      int curr_index=outlier_indices[i];
      outlier_stream << curr_index << " ";
   }
   outlier_stream << endl;
   filefunc::closefile(outlier_filename,outlier_stream);

   banner="Exported outlier left-right pair indices to "+
      outlier_filename;
   outputfunc::write_banner(banner);
 
// Compute average residual difference between transformed inlier left
// points and right points:

   vector<int> inlier_indices=bundlerfunc::identify_left_right_pair_inliers(
      left_points,right_points,az,el,roll,scale,
      trans_Horn,max_residual_distance);
   
   vector<threevector> inlier_left_points,inlier_right_points;
   for (int i=0; i<inlier_indices.size(); i++)
   {
      int curr_index=inlier_indices[i];
      inlier_left_points.push_back(left_points[curr_index]);
      inlier_right_points.push_back(right_points[curr_index]);
   }

   vector<threevector> transformed_inlier_left_points;
   double avg_inlier_residual=bundlerfunc::compute_avg_residual(
      inlier_left_points,inlier_right_points,transformed_inlier_left_points,
      az,el,roll,scale,trans_Horn);

// Export georegistered peter_inputs package file:

   ofstream outstream;
   outstream.precision(12);
   filefunc::openfile(peter_inputs_filename,outstream);

   outstream << "--bundle_filename " << bundle_filename << endl;
   outstream << "--image_list_filename " << image_list_filename << endl;
   outstream << "--fitted_world_to_bundler_distance_ratio " << scale << endl;
   outstream << "--bundler_translation_X " << trans_Peter.get(0) << endl;
   outstream << "--bundler_translation_Y " << trans_Peter.get(1) << endl;
   outstream << "--bundler_translation_Z " << trans_Peter.get(2) << endl;
   outstream << "--global_az " << az*180/PI << endl;
   outstream << "--global_el " << el*180/PI << endl;
   outstream << "--global_roll " << roll*180/PI << endl;
   outstream << "--bundler_rotation_origin_X " << left_COM.get(0) << endl;
   outstream << "--bundler_rotation_origin_Y " << left_COM.get(1) << endl;
   outstream << "--bundler_rotation_origin_Z " << left_COM.get(2) << endl;
   outstream << "--image_sizes_filename " << image_sizes_filename << endl;
   outstream << endl;

   filefunc::closefile(peter_inputs_filename,outstream);

   banner="Exported georegistered peter_inputs package to "+
      peter_inputs_filename;
   outputfunc::write_big_banner(banner);

// Draw connection lines between corresponding GPS and geoaligned
// reconstructed camera points:
   
   double curr_p=0.35;
   vector<double> P;
   vector<threevector> connection_line_points;
   for (int i=0; i<right_points.size(); i++)
   {
      threevector GPS_point(right_points[i]);
      threevector reconstructed_point(transformed_left_points[i]);
      int n_line_points=100;
      
      for (int n=1; n<n_line_points; n++)
      {
         double frac=double(n)/n_line_points;
         threevector interp_point=frac*GPS_point+(1-frac)*reconstructed_point;
         connection_line_points.push_back(interp_point);
         P.push_back(curr_p);
      } // loop over index labeling connection line points

      curr_p += 0.05;
      if (curr_p > 0.9) curr_p=0.35;
   } // loop over index i labeling GPS & reconstructed camera points

// Generate TDP file containing connection line points:

   string tdp_filename="connection_lines.tdp";
   tdpfunc::write_xyzp_data(tdp_filename,&connection_line_points,&P);

   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv "+tdp_filename+" "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv connection_lines.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);


// Generate TDP file containing GPS flight path:

   const double p_GPS=0.25;	// blue coloring
   P.clear();
   for (int i=0; i<right_points.size(); i++)
   {
      P.push_back(p_GPS);
   }

   tdp_filename="GPS_camera_path.tdp";
   tdpfunc::write_xyzp_data(tdp_filename,&right_points,&P);

   unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv "+tdp_filename+" "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv GPS_camera_path.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);

// Generate TDP file containing inlier geoaligned bundler camera path:

   const double p_geoaligned=1.0;	// red coloring
   P.clear();
   for (int i=0; i<transformed_inlier_left_points.size(); i++)
   {
      P.push_back(p_geoaligned);
   }

   tdp_filename="geoaligned_camera_path.tdp";
   tdpfunc::write_xyzp_data(tdp_filename,&transformed_inlier_left_points,&P);

   unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv "+tdp_filename+" "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv geoaligned_camera_path.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);

   cout << "At end of program GPSFIT" << endl;
   outputfunc::print_elapsed_time();
}
