// ==========================================================================
// Program PARSE_PUMA_METADATA imports the metadata text file
// generated for a PUMA UAV flight.  It computes the UAV's starting
// altitude on the ground as well as its takeoff and landing epoch times.
// It exports a simplified metadata file to
// bundler_IO_subdir/puma.metadata which contains video frame
// filename, UAV geolocation, UAV orientation and ground target
// geolocation as functions of GPS time.  PARSE_PUMA_METADATA also
// exports to bundler_IO_subdir/puma.geoposns the UAV's geoloation as
// a function of epoch and local times.

// 			     ./parse_puma_metadata

// ==========================================================================
// Last updated on 12/4/13; 12/30/13; 1/8/14
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "astro_geo/geopoint.h"
#include "passes/PassesGroup.h"
#include "filter/piecewise_linear.h"
#include "general/stringfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

int main (int argc, char * argv[])
{
   cout.precision(12);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);
   int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// Constant declarations:

/*
// Metadata info generated by this program for Camp Edwards, April 24,
// 2013 (Day 1) flight 1 which looks visually reasonable:

   int UTM_zone=19;	// MA
   int takeoff_frame_ID=375;
   int touchdown_frame_ID=2203;

   double actual_takeoff_epoch=1366826870;
   double actual_landing_epoch=1366828693;
*/

/*
// Metadata info generated by this program for Camp Edwards, April 25,
// 2013 (Day 2) flight 3 which looks visually reasonable:

   int UTM_zone=19;	// MA
   int takeoff_frame_ID=862;
   int touchdown_frame_ID=5248;

   double actual_takeoff_epoch=1366915263;   //   
   double actual_landing_epoch=1366919642;   //   

   double wristwatch_takeoff_epoch=1366918870;   //   2013-04-25 14:41:10 local
   double wristwatch_landing_epoch=1366923280;   //   2013-04-25 15:54:40 local

   cout << "actual_landing_epoch-actual_takeoff_epoch = " 
        << actual_landing_epoch-actual_takeoff_epoch << endl;
*/

/*
// Metadata info for Camp Edwards, May 30, 2013 (Day1) flight 2 which
// looks visually reasonable:

// Netbook time reading: frame 142, 11:55:17 local time, epoch= 1369932917
// Netbook time reading: frame 146, 11:55:21 local time, epoch= 1369932921

   int UTM_zone=19;	// MA
   int touchdown_frame_ID=3292;		// observed in aerial video
   double actual_landing_epoch=1369936067;

   int takeoff_frame_ID=674;		// deduced from derived flight time
   double actual_takeoff_epoch=1369933449;

//   double recorded_takeoff_epoch = 1369929842;
//   double recorded_landing_epoch = 1369932460;
//   recorded_landing_epoch-recorded_takeoff_epoch = 2618.00000215
*/

/*
// Metadata info generated by this program for Yuma Proving Grounds, Sep 13,
// 2013 flight:

//   int UTM_zone=11;	// Yuma Proving Grounds, AZ
   int UTM_zone=19;	// MA
//   double recorded_takeoff_epoch = 1379088593;
//   double recorded_landing_epoch = 1379092209;
   double flight_duration=3616; // = 1379092209-1379088593

   int takeoff_frame_ID=2165;
   int touchdown_frame_ID=takeoff_frame_ID+flight_duration;
   
   double actual_takeoff_epoch=1379088593+takeoff_frame_ID-1;
   double actual_landing_epoch=actual_takeoff_epoch+flight_duration;
   cout << "actual_landing_epoch-actual_takeoff_epoch = " 
        << actual_landing_epoch-actual_takeoff_epoch << endl;
*/

// ==========================================================================

   cout << endl;
   cout << "Dates and places for Puma data passes:" << endl << endl;
   cout << "1: 24 April 2013 at Camp Edwards" << endl;
   cout << "2: 30 May 2013 at Camp Edwards" << endl;
   cout << "3: 13 Sep 2013 at Yuma Proving Grounds" << endl;
   cout << endl;

   int data_pass_ID,flight_ID;
   cout << "Enter Puma data pass ID:" << endl;
   cin >> data_pass_ID;

   int UTM_zone,takeoff_frame_ID,touchdown_frame_ID;
   double actual_takeoff_epoch,actual_landing_epoch;
   
   string puma_subdir,input_filename;
   if (data_pass_ID==1)
   {
      puma_subdir="/data_third_disk/Puma/April24_2013/";
      cout << "Puma flights:" << endl;
      cout << "1: Day 1 flight 1" << endl;
      cout << "2: Day 2 flight 3" << endl;
      cout << "Enter flight ID:" << endl;
      cout << endl;
      cin >> flight_ID;
      if (flight_ID==1)
      {
         input_filename=puma_subdir+"Day1_flt1/day1_flt1.txt";

         UTM_zone=19;	// MA
         takeoff_frame_ID=375;
         touchdown_frame_ID=2203;

         actual_takeoff_epoch=1366826870;
         actual_landing_epoch=1366828693;
      }
      else if (flight_ID==2)
      {
         input_filename=puma_subdir+"Day2_flt3/day2_flt3.txt";

         UTM_zone=19;	// MA
         takeoff_frame_ID=862;
         touchdown_frame_ID=5248;

         actual_takeoff_epoch=1366915263;   //   
         actual_landing_epoch=1366919642;   //   
         double wristwatch_takeoff_epoch=1366918870;   //   2013-04-25 14:41:10 local
         double wristwatch_landing_epoch=1366923280;   //   2013-04-25 15:54:40 local
      }
   }
   else if (data_pass_ID==2)
   {
      puma_subdir="/data_third_disk/Puma/May30_2013/";

      cout << "Puma flights:" << endl;
      cout << "1: Day 1 flight 2" << endl;
      cout << "2: Day 1 flight 3" << endl;
      cout << "Enter flight ID:" << endl;
      cout << endl;
      cin >> flight_ID;
      if (flight_ID==1)
      {
         input_filename=puma_subdir+"Day1_flt2/Day1_flt2.txt";

// Netbook time reading: frame 142, 11:55:17 local time, epoch= 1369932917
// Netbook time reading: frame 146, 11:55:21 local time, epoch= 1369932921

         UTM_zone=19;	// MA
         takeoff_frame_ID=674;	// deduced from derived flight time
         touchdown_frame_ID=3292;		// observed in aerial video

         actual_takeoff_epoch=1369933449;
         actual_landing_epoch=1369936067;
      }
      else if (flight_ID==2)
      {
         input_filename=puma_subdir+"Day1_flt3/Day1_flt3.txt";

         cout << "Need to hardwire takeoff and touchdown frame IDs as well as actual takeoff and landing epochs within c++ code!"  << endl;
         exit(-1);
      }
   }
   if (data_pass_ID==3)
   {
      puma_subdir="/data_third_disk/Puma/Sep13_2013_YPG/";
      input_filename=puma_subdir+"2013_09_13_flt1_bin2txt.txt";

//    UTM_zone=11;	// Yuma Proving Grounds, AZ
      UTM_zone=19;	// MA
//   double recorded_takeoff_epoch = 1379088593;
//   double recorded_landing_epoch = 1379092209;
      double flight_duration=3616; // = 1379092209-1379088593

      takeoff_frame_ID=2165;
      touchdown_frame_ID=takeoff_frame_ID+flight_duration;
   
      actual_takeoff_epoch=1379088593+takeoff_frame_ID-1;
      actual_landing_epoch=actual_takeoff_epoch+flight_duration;
   }

   cout << "actual_landing_epoch-actual_takeoff_epoch = " 
        << actual_landing_epoch-actual_takeoff_epoch << endl;

//   string puma_subdir="/data_third_disk/Puma/April24_2013/";
//   string input_filename=puma_subdir+"Day1_flt1/day1_flt1.txt";
//   string input_filename=puma_subdir+"Day2_flt3/day2_flt3.txt";

//   string puma_subdir="/data_third_disk/Puma/May30_2013/";
//   string input_filename=puma_subdir+"Day1_flt2/Day1_flt2.txt";
//   string input_filename=puma_subdir+"Day1_flt3/Day1_flt3.txt";
   
//   string puma_subdir="/data_third_disk/Puma/Sep13_2013_YPG/";
//   string input_filename=puma_subdir+"2013_09_13_flt1_bin2txt.txt";

   string basename=filefunc::getbasename(input_filename);
   string flight_label=stringfunc::prefix(basename);

   filefunc::ReadInfile(input_filename);

// As of 5/20/13, we assume input Puma metadata file contains several
// seconds when UAV was still on ground.  So we determine UAV's
// starting altitude by averaging together its first 100 altitude
// entries in the metadata file:

   double starting_UAV_altitude=0;	// meters 

   int n_initial_bins=100;
   int i_start=1;
   for (int i=i_start; i<i_start+n_initial_bins; i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);

      double UAV_altitude=stringfunc::string_to_number(substrings[9]);
//      cout << "i = " << i << " UAV_altitude = " << UAV_altitude << endl;
      starting_UAV_altitude += UAV_altitude;
   }
   starting_UAV_altitude /= n_initial_bins;
   cout << "starting_UAV_altitude = " << starting_UAV_altitude << endl;

//    outputfunc::enter_continue_char();

// Hardwire reasonable ground target altitude as surrogate for DTED
// measurement:

   double ground_tgt_altitude=starting_UAV_altitude;

// Next search Puma metadata file in the forward direction for a takeoff
// event.  As of 5/20/13, we identify the takeoff time by when the UAV
// is more than 5 meters above starting_UAV_altitude:

   double altitude_threshold=5;	// meters
   double recorded_takeoff_epoch,recorded_landing_epoch;
   Clock clock;

   int i_stop=filefunc::text_line.size()-1;
   cout.precision(12);
   for (int i=i_start; i<=i_stop; i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);

      int month=stringfunc::string_to_number(substrings[50]);
      int day=stringfunc::string_to_number(substrings[51]);
      int year=stringfunc::string_to_number(substrings[52]);
      int hour=stringfunc::string_to_number(substrings[53]);
      int minute=stringfunc::string_to_number(substrings[54]);
      double secs=stringfunc::string_to_number(substrings[55]);

//      cout << "year = " << year << " month = " << month 
//           << " day = " << day << " hour = " << hour
//           << " minute = " << minute << " secs = " << secs << endl;

      clock.compute_UTM_zone_time_offset(UTM_zone);
      clock.set_UTC_time(year,month,day,hour,minute,secs);
      double elapsed_secs=clock.secs_elapsed_since_reference_date();
      if (elapsed_secs < 0) continue;

//      double gps_altitude=stringfunc::string_to_number(substrings[58]);
      double UAV_altitude=stringfunc::string_to_number(substrings[9]);

      if (UAV_altitude-starting_UAV_altitude > altitude_threshold)
      {
         recorded_takeoff_epoch=elapsed_secs;
         break;
      }
   }
   cout << "recorded_takeoff_epoch = " << recorded_takeoff_epoch << endl;

// Next search Puma metadata file in the backward direction for a landing
// event.  As of 5/20/13, we identify the landing time by when the UAV
// is more than than 5 meters above starting_UAV_altitude:

   i_start=filefunc::text_line.size()-1;
   i_stop=1;
   cout.precision(12);
   for (int i=i_start; i>=i_stop; i--)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);

      int month=stringfunc::string_to_number(substrings[50]);
      int day=stringfunc::string_to_number(substrings[51]);
      int year=stringfunc::string_to_number(substrings[52]);
      int hour=stringfunc::string_to_number(substrings[53]);
      int minute=stringfunc::string_to_number(substrings[54]);
      double secs=stringfunc::string_to_number(substrings[55]);

//      cout << "year = " << year << " month = " << month 
//           << " day = " << day << " hour = " << hour
//           << " minute = " << minute << " secs = " << secs << endl;

      clock.compute_UTM_zone_time_offset(UTM_zone);
      clock.set_UTC_time(year,month,day,hour,minute,secs);
      double elapsed_secs=clock.secs_elapsed_since_reference_date();
      if (elapsed_secs < 0) continue;

      double UAV_altitude=stringfunc::string_to_number(substrings[9]);
      if (UAV_altitude-starting_UAV_altitude > altitude_threshold)
      {
         recorded_landing_epoch=elapsed_secs;
         break;
      }
   }
   cout << "recorded_landing_epoch = " << recorded_landing_epoch << endl;

// On 5/20/13, we empirically found (to our horror) that the recorded
// times for takeoff and landing can be way off from the actual
// wristwatch times!  

   cout << "recorded_landing_epoch-recorded_takeoff_epoch = " 
        << recorded_landing_epoch-recorded_takeoff_epoch << endl;

   typedef map<double,vector<vector<double> >* > PUMA_MAP;
   PUMA_MAP puma_map;
   PUMA_MAP::iterator iter;

   i_start=1;
   i_stop=filefunc::text_line.size()-1;
   for (int i=i_start; i<=i_stop; i++)
   {
      if (i%100==0) cout << i << " " << flush;
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);

//      for (int s=0; s<substrings.size(); s++)
//      {
//         cout << "s+1 = " << s+1 << " substring = " << substrings[s] << endl;
//      }
      
      int month=stringfunc::string_to_number(substrings[50]);
      int day=stringfunc::string_to_number(substrings[51]);
      int year=stringfunc::string_to_number(substrings[52]);
      int hour=stringfunc::string_to_number(substrings[53]);
      int minute=stringfunc::string_to_number(substrings[54]);
      double secs=stringfunc::string_to_number(substrings[55]);

//      cout << "year = " << year << " month = " << month 
//           << " day = " << day << " hour = " << hour
//           << " minute = " << minute << " secs = " << secs << endl;

      clock.compute_UTM_zone_time_offset(UTM_zone);
      clock.set_UTC_time(year,month,day,hour,minute,secs);
      double recorded_epoch=clock.secs_elapsed_since_reference_date();
      if (recorded_epoch < 0) continue;

// Perform necessary temporal stretch and translation in order to
// convert recorded epoch time to actual epoch time:

      double recorded_frac=(recorded_epoch-recorded_takeoff_epoch)/
         (recorded_landing_epoch-recorded_takeoff_epoch);
      double actual_epoch=actual_takeoff_epoch+
         recorded_frac*(actual_landing_epoch-actual_takeoff_epoch);
   
      double gps_altitude=stringfunc::string_to_number(substrings[58]);
      double UAV_altitude=stringfunc::string_to_number(substrings[9]);
      double UAV_latitude=stringfunc::string_to_number(substrings[56]);
      double UAV_longitude=stringfunc::string_to_number(substrings[57]);
      double UAV_speed=stringfunc::string_to_number(substrings[59]);

      double UAV_Heading=stringfunc::string_to_number(substrings[11]);
      double UAV_Pitch=stringfunc::string_to_number(substrings[12]);
      double UAV_Bank=stringfunc::string_to_number(substrings[13]);

//      cout << "i = " << i 
//           << " actual_epoch = " << actual_epoch
//           << " GPS alt = " << gps_altitude
//           << " UAV alt = " << UAV_altitude
//           << " UAV speed = " << UAV_speed << endl;

//      cout << "UAV_lon = " << UAV_longitude 
//           << " UAV_lat = " << UAV_latitude
//           << " UAV_alt = " << UAV_altitude << endl;
      geopoint UAV_geopt(UAV_longitude,UAV_latitude,UAV_altitude);
//      cout << "UAV geolocation = " << UAV_geopt << endl;

      double ground_tgt_latitude=stringfunc::string_to_number(
         substrings[125]);
      double ground_tgt_longitude=stringfunc::string_to_number(
         substrings[126]);
//      double ground_tgt_altitude=stringfunc::string_to_number(
//         substrings[80]);

//      cout << "ground tgt: lon = " << ground_tgt_longitude
//           << " lat = " << ground_tgt_latitude << endl;
      geopoint ground_tgt_geopt(
         ground_tgt_longitude,ground_tgt_latitude,ground_tgt_altitude);
//      cout << "ground target geolocation = " << ground_tgt_geopt << endl;
//      cout << "===============================================" << endl;

      iter=puma_map.find(actual_epoch);
      if (iter==puma_map.end())
      {
         vector<double> UAV_easting,UAV_northing,UAV_alt;
         vector<double> UAV_heading,UAV_pitch,UAV_bank;
         vector<double> tgt_easting,tgt_northing,tgt_alt;
         
         UAV_easting.push_back(UAV_geopt.get_UTM_easting());
         UAV_northing.push_back(UAV_geopt.get_UTM_northing());
         UAV_alt.push_back(UAV_geopt.get_altitude());

         UAV_heading.push_back(UAV_Heading);
         UAV_pitch.push_back(UAV_Pitch);
         UAV_bank.push_back(UAV_Bank);

         tgt_easting.push_back(ground_tgt_geopt.get_UTM_easting());
         tgt_northing.push_back(ground_tgt_geopt.get_UTM_northing());
         tgt_alt.push_back(ground_tgt_geopt.get_altitude());
         vector<vector<double> >* puma_metadata_ptr=
            new vector<vector<double> >;
         puma_metadata_ptr->push_back(UAV_easting);
         puma_metadata_ptr->push_back(UAV_northing);
         puma_metadata_ptr->push_back(UAV_alt);
         puma_metadata_ptr->push_back(UAV_heading);
         puma_metadata_ptr->push_back(UAV_pitch);
         puma_metadata_ptr->push_back(UAV_bank);

         puma_metadata_ptr->push_back(tgt_easting);
         puma_metadata_ptr->push_back(tgt_northing);
         puma_metadata_ptr->push_back(tgt_alt);
         (puma_map)[actual_epoch]=puma_metadata_ptr;
      }
      else
      {
         vector<vector<double> >* puma_metadata_ptr=iter->second;
         puma_metadata_ptr->at(0).push_back(UAV_geopt.get_UTM_easting());
         puma_metadata_ptr->at(1).push_back(UAV_geopt.get_UTM_northing());
         puma_metadata_ptr->at(2).push_back(UAV_geopt.get_altitude());
         puma_metadata_ptr->at(3).push_back(UAV_Heading);
         puma_metadata_ptr->at(4).push_back(UAV_Pitch);
         puma_metadata_ptr->at(5).push_back(UAV_Bank);
         puma_metadata_ptr->at(6).push_back(
            ground_tgt_geopt.get_UTM_easting());
         puma_metadata_ptr->at(7).push_back(
            ground_tgt_geopt.get_UTM_northing());
         puma_metadata_ptr->at(8).push_back(ground_tgt_geopt.get_altitude());
      }
   } // loop over index i labeling input file text line
   cout << endl;

   cout << "puma_map.size() = " << puma_map.size() << endl;

   vector<double> epoch,UAV_easting,UAV_northing,UAV_altitude;
   vector<double> UAV_heading,UAV_pitch,UAV_bank;
   vector<double> tgt_easting,tgt_northing,tgt_altitude;
   for (iter=puma_map.begin(); iter != puma_map.end(); iter++)
   {
      epoch.push_back(iter->first);
      vector<vector<double> >* puma_metadata_ptr=iter->second;
      UAV_easting.push_back(mathfunc::mean(puma_metadata_ptr->at(0)));
      UAV_northing.push_back(mathfunc::mean(puma_metadata_ptr->at(1)));
      UAV_altitude.push_back(mathfunc::mean(puma_metadata_ptr->at(2)));
      UAV_heading.push_back(mathfunc::mean(puma_metadata_ptr->at(3)));
      UAV_pitch.push_back(mathfunc::mean(puma_metadata_ptr->at(4)));
      UAV_bank.push_back(mathfunc::mean(puma_metadata_ptr->at(5)));
      tgt_easting.push_back(mathfunc::mean(puma_metadata_ptr->at(6)));
      tgt_northing.push_back(mathfunc::mean(puma_metadata_ptr->at(7)));
      tgt_altitude.push_back(mathfunc::mean(puma_metadata_ptr->at(8)));
   } // loop over puma_map iterator

   string metadata_filename=bundler_IO_subdir+"puma.metadata";
   ofstream outstream;
   outstream.precision(10);
   filefunc::openfile(metadata_filename,outstream);
   outstream << "# image_filename   epoch (secs) UAV_easting UAV_northing UAV_alt  UAV_heading UAV_pitch UAV_bank tgt_easting  tgt_northing  tgt_alt" << endl;
   outstream << endl;

   string geoposn_filename=bundler_IO_subdir+"puma.geoposns";
   ofstream geostream;
   geostream.precision(10);
   filefunc::openfile(geoposn_filename,geostream);

   geostream << "# image_filename  HHMMSS (local)  Epoch     UAV_easting UAV_northing   UAV_alt" << endl;
   geostream << endl;

   for (int frame_ID=takeoff_frame_ID; frame_ID <= touchdown_frame_ID;
        frame_ID++)
   {
      string frame_filename="frame-"+stringfunc::integer_to_string(
         frame_ID,5)+".jpg";
      double flight_frac=double(frame_ID-takeoff_frame_ID)/
         double(touchdown_frame_ID-takeoff_frame_ID);
      double curr_epoch=actual_takeoff_epoch+flight_frac*
         (actual_landing_epoch-actual_takeoff_epoch);

      clock.convert_elapsed_secs_to_date(curr_epoch);
//      bool display_UTC_flag=true;
      bool display_UTC_flag=false;
      int n_secs_digits=2;
      bool display_year_month_day_flag=false;
      string day_hour_separator_char=" ";
      string time_separator_char="";
      string HHMMSS=clock.YYYY_MM_DD_H_M_S(
         day_hour_separator_char,time_separator_char,display_UTC_flag,
         n_secs_digits,display_year_month_day_flag);

//      cout << "frame_ID = " << frame_ID
//           << " flight_frac = " << flight_frac 
//           << " curr_epoch = " << curr_epoch 
//           << " dt = " << curr_epoch-epoch.front() 
//           << endl;

      piecewise_linear UAV_easting_piecewise_linear(epoch,UAV_easting);
      piecewise_linear UAV_northing_piecewise_linear(epoch,UAV_northing);
      piecewise_linear UAV_altitude_piecewise_linear(epoch,UAV_altitude);

      piecewise_linear UAV_heading_piecewise_linear(epoch,UAV_heading);
      piecewise_linear UAV_pitch_piecewise_linear(epoch,UAV_pitch);
      piecewise_linear UAV_bank_piecewise_linear(epoch,UAV_bank);

      piecewise_linear tgt_easting_piecewise_linear(epoch,tgt_easting);
      piecewise_linear tgt_northing_piecewise_linear(epoch,tgt_northing);
      piecewise_linear tgt_altitude_piecewise_linear(epoch,tgt_altitude);

      double curr_UAV_easting=UAV_easting_piecewise_linear.value(curr_epoch);
      double curr_UAV_northing=UAV_northing_piecewise_linear.value(curr_epoch);
      double curr_UAV_altitude=UAV_altitude_piecewise_linear.value(curr_epoch);

      double curr_UAV_heading=UAV_heading_piecewise_linear.value(curr_epoch);
      double curr_UAV_pitch=UAV_pitch_piecewise_linear.value(curr_epoch);
      double curr_UAV_bank=UAV_bank_piecewise_linear.value(curr_epoch);

      double curr_tgt_easting=tgt_easting_piecewise_linear.value(curr_epoch);
      double curr_tgt_northing=tgt_northing_piecewise_linear.value(curr_epoch);
      double curr_tgt_altitude=tgt_altitude_piecewise_linear.value(curr_epoch);

      outstream << frame_filename << "  "
                << curr_epoch << "  "
                << curr_UAV_easting << "  "
                << curr_UAV_northing << "  "
                << curr_UAV_altitude << "  "
                << curr_UAV_heading << "  "
                << curr_UAV_pitch << "  "
                << curr_UAV_bank << "  "
                << curr_tgt_easting << "  "
                << curr_tgt_northing << "  "
                << curr_tgt_altitude << "  "
                << endl;

      geostream << frame_filename << "  "
                << HHMMSS << "  "
                << curr_epoch << "  "
                << curr_UAV_easting << "  "
                << curr_UAV_northing << "  "
                << curr_UAV_altitude << "  "
                << endl;

   } // loop over frame_ID index
   filefunc::closefile(metadata_filename,outstream);
   filefunc::closefile(geoposn_filename,geostream);

   string banner="Exported "+metadata_filename;
   outputfunc::write_big_banner(banner);
   banner="Exported "+geoposn_filename;
   outputfunc::write_big_banner(banner);
} 

