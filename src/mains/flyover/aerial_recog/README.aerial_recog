========================================================================
Aerial imagery segmentation README
========================================================================
Last updated on 6/21/14; 6/22/14
========================================================================

*. RESIZE_CHIPS needs to be executed from within some subdirectory
containing a set of JPG image chips.  It generates subsampled versions of
each input image whose maximum width and height do not exceed 32 x 32.  The
output resized image chips are exported to ./resized_chips.

-----------------------------------------------------
COATES-NG UNSUPERVISED FEATURE LEARNING PROGRAMS
-----------------------------------------------------

*.  INITIAL_DESCRIPTORS loops over all input image files within
raw_char_subdir.  It extracts n_patches_per_image 8x8 pixel patches from
each image.  It converts the 8x8 patches into a 192x1 [64x1] column vector
of RGB values [grey-scale intensities].  Raw descriptors for all character
image patches are "contrast normalized" and then exported to a single HDF5
binary file.

*.  WHITEN_DESCRIPTORS imports contrast normalized 192x1 RGB-valued [64x1
greyscale intensity] descriptors for 8x8 pixel patches selected from
character jpeg images generated by program INITIAL_DESCRIPTORS.  It
computes the descriptors' covariance matrix along with a regularized
version of its inverse square root covariance matrix.  Each input
descriptor is whitened by multiplying it by the inverse square root
covariance matrix. Whitened patch descriptors are exported to a single HDF5
binary file.  The inverse square root of the covariance matrix is also
exported to a text file within the dictionary subdirectory.

*.  DICTIONARY imports whitened 192x1 RGB [64x1 greyscale ] descriptors
generated by program WHITEN_DESCRIPTORS for 8x8 pixel patches randomly
selected from positive class 32x32 image chips.  It initially fills
dictionary matrix D with column vectors populated via a Normal distribution
and normalized to unit magnitude.  It then iteratively updates score matrix
S and dictionary D following the prescription laid out in "Learning feature
representations with K-means" by Coates and Ng, 2013.  After each
iteration, a PNG fileis generated which illustrates all K 8x8 dictionary
elements.  The final Kbest values in D are exported to a binary HDF5 file.

*.  BINARY_DICTIONARY imports the best trained elements within the
dictionary exported by program DICTIONARY from an HDF5 file.  It calls
fwrite to export the dictionary matrix D rows and K columns to a flat
binary file which could be imported via Pwin C code.

*.  CHECK_DICTIONARY imports the best trained elements within the
dictionary exported by program DICTIONARY.  It generates a PNG composite
that illustrates the Kbest 8x8 dictionary elements.

*.  POOL_FEATURES reads in a set of positive or negative class images files
from a specified input subdirectory.  The width or height for each input
image should precisely equal 32 pixels in size, but both need not equal 32.
It also imports a precomputed character dictionary along with an inverse
square root covariance matrix.  Looping over each input window file,
POOL_FEATURES extracts 8x8 RGB or grey-scale intensity patches in each
window for every possible ~25x~25 pixel offset.  Each 8x8 patch is
projected onto the dictionary and converted into a K-dimensional
histogram. The histogram descriptors are averaged together within 3x3
regions of the ~32x~32 window.  So the final descriptor for each ~32x~32
window is a 9*K dimensional vector.  9*K dimensional window descriptors for
all valid ~32x~32 windows not basically equal to the zero vector are
exported to windows_descriptors.hdf5.

*.  SVM_RECOG reads in 9xK dimensional features for N ~32x~32 positive
windows and N' ~32x~32 negative windows generated by POOL_FEATURES.  It
then uses Davis King's DLIB library to load the input samples along with
their positive and negative labels.  After the ordering of the input
samples is randomized, cross-correlation is performed in order to estimate
a reasonable value for a linear-SVM slack variable C.  DLIB then trains
binary decision and probabilistic decision functions. Serialized versions
of the binary and probabilistic decision functions are exported to output
binary files.

*.  Program DETECT_TEXT imports the dictionary generated by program
DICTIONARY, inverse square root of the whitening covariance matrix
generated by program WHITEN_DESCRIPTORS, and the probabilistic decision
function generated by program SVM_TEXT.  Looping over some input set of
testing image chips, this program then extracts 9K-dimensional feature
vectors and effectively dots them with the components within the linear SVM
classifier weight vector.  If the dotproduct exceeds a user-specified
threshold fraction, the input test image is classified as "text".
Confusion matrix results are calculated and written to text file output.

