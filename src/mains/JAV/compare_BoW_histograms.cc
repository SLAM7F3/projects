// ==========================================================================
// Program COMPARE_BoW_HISTOGRAMS imports a set of BoW histograms
// generated by program COMPUTE_BoW_HISTOGRAMS.  Looping over all
// imported histograms, it computes the overlap score for the ith HOG
// word as

// overlap_score_i = 1 - { |H^(1)_i - H^(2)_i| / (H^(1)_i + H^(2)_i) }

// For each HOG word, overlap scores for all (N_keyframes choose 2)
// keyframe pairs are exported to an output binary file labeled by the
// HOG word's index.  

//			  ./compare_BoW_histograms

// ==========================================================================
// Last updated on 12/28/13; 12/29/13; 12/30/13
// ==========================================================================

#include <cstdlib>
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <dlib/matrix.h>

#include "general/filefuncs.h"
#include "math/ltduple.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "math/Tensor.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   double min_overlap_score=-1;
   cout << endl << endl;
   cout << "Enter min overlap score to be exported to output comparison file:"
        << endl;
   cin >> min_overlap_score;

   bool keyframes_flag=true;
   bool different_clips_flag=true;

//   bool diff_over_sum_flag=true;
   bool diff_over_sum_flag=false;
//   bool sqrt_dotproduct_flag=true;
   bool sqrt_dotproduct_flag=false;
   bool sqrt_diff_over_sum_flag=true;
//   bool sqrt_diff_over_sum_flag=false;

// Note added on 12/29/13: We empirically found that
// sqrt_diff_over_sum comparison function yielded sigificantly worse
// cross validation results that the diff_over_sum_comparison
// function.  But coarse image matching results on early_Sep_2013 and
// w_transcript NewsHour summaries along with Boston Bombing video
// clips 1-25 were surprisingly good!

   string banner="diff_over_sum_flag = "+stringfunc::boolean_to_string(
      diff_over_sum_flag);
   outputfunc::write_big_banner(banner);
   banner="sqrt_dotproduct_flag = "+stringfunc::boolean_to_string(
      sqrt_dotproduct_flag);
   outputfunc::write_big_banner(banner);
   banner="sqrt_diff_over_sum_flag = "+stringfunc::boolean_to_string(
      sqrt_diff_over_sum_flag);
   outputfunc::write_big_banner(banner);

/*   
   string input_char;
   cout << "Enter 'k' to process just video keyframes:" << endl;
   cin >> input_char;
   if (input_char != "k")
   {
      keyframes_flag=false;
   }
   cout << "Enter 'w' to compare histograms within and not between clips:"
        << endl;
   cin >> input_char;
   if (input_char != "w")
   {
      different_clips_flag=true;
   }
*/

   timefunc::initialize_timeofday_clock();      

//   bool video_frames_input_flag=true;
   bool video_frames_input_flag=false;
   if (!video_frames_input_flag) keyframes_flag=false;

   string JAV_subdir;
   if (video_frames_input_flag)
   {
      string ImageEngine_subdir="/data/ImageEngine/";
      string BostonBombing_subdir=ImageEngine_subdir+"BostonBombing/";

      cout << "1: early September 2013 NewsWraps" << endl;
      cout << "2: October 2013 NewsWraps with transcripts" << endl;
      cout << "3: Boston Bombing YouTube clips 1 - 25" << endl;

      int video_corpus_ID;
      cout << "Enter video corpus ID:" << endl;
      cin >> video_corpus_ID;
   

      if (video_corpus_ID==1)
      {
         JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
      }
      else if (video_corpus_ID==2)
      {
         JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
      }
      else if (video_corpus_ID==3)
      {
         JAV_subdir=BostonBombing_subdir+"clips_1_thru_25/";
      }
      else
      {
         exit(-1);
      }
   }
   else
   {
      JAV_subdir="./bundler/tidmarsh/";
   }
   cout << "JAV_subdir = " << JAV_subdir << endl;


   string root_subdir=JAV_subdir;
   string images_subdir,keyframes_subdir;
   if (video_frames_input_flag)
   {
      images_subdir=root_subdir+"jpg_frames/";
      keyframes_subdir=images_subdir+"keyframes/";
   }
   else
   {
      images_subdir=root_subdir+"standard_sized_images/";
   }

   string BoW_histograms_subdir=root_subdir+"BoWs/";
   string BoW_comparisons_subdir=BoW_histograms_subdir+"comparisons/";
   if (min_overlap_score >= 0)
   {
      BoW_comparisons_subdir=BoW_histograms_subdir+"comparisons_"+
         stringfunc::number_to_string(min_overlap_score)+"/";
   }
   filefunc::dircreate(BoW_comparisons_subdir);

// For later identification of images which correspond to keyframes,
// store keyframes' clip and frame IDs within STL map keyframes_map:

   typedef map<DUPLE,string> KEYFRAMES_MAP;
   KEYFRAMES_MAP keyframes_map;

// independent DUPLE holds video image clip and frame ID
// dependent string holds video image's filename

   if (keyframes_flag)
   {
      vector<string> keyframe_filenames=filefunc::image_files_in_subdir(
         keyframes_subdir);

      for (unsigned int i=0; i<keyframe_filenames.size(); i++)
      {
         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
               filefunc::getbasename(keyframe_filenames[i])," _-");

// If input filename has form clip_0000_frame-00001.jpg, record clip's
// ID within STL vector:

         int clip_ID=-1;
         int frame_ID=-1;
         if (substrings.size()==4)
         {
            if (substrings[0]=="clip")
            {
               clip_ID=stringfunc::string_to_number(substrings[1]);
               frame_ID=stringfunc::string_to_number(substrings[3]);
               keyframes_map[DUPLE(clip_ID,frame_ID)]=keyframe_filenames[i];
            }
         }
      } // loop over index i labeling keyframe filenames
      cout << "keyframes_map.size() = " << keyframes_map.size() << endl;
   } // keyframes_flag conditional

// Import BoW histograms generated by program COMPUTE_BoW_HISTOGRAMS:

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("BoW_hist");
   vector<string> histogram_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,BoW_histograms_subdir);

   banner="Importing BoW histograms from text files:";
   outputfunc::write_banner(banner);

   int n_bins=-1;
   vector<string> hist_basenames;
   vector<double*> histogram_ptrs;
   for (unsigned int i=0; i<histogram_filenames.size(); i++)
   {
      outputfunc::update_progress_fraction(i,100,histogram_filenames.size());
      string basename=filefunc::getbasename(histogram_filenames[i]);

      if (keyframes_flag && keyframes_map.size() > 0)
      {
         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
               stringfunc::prefix(basename)," _-");
//         for (int s=0; s<substrings.size(); s++)
//         {
//            cout << " s = " << s << " substring[s] = " 
//                 << substrings[s] << endl;
//         }

// Search for image corresponding to current histogram within
// keyframes_map.  If a keyframe entry corresponding to the current
// image is not found, ignore current image:

         int clip_ID=-1;
         int frame_ID=-1;
         if (substrings.size()==4)
         {
            if (substrings[0]=="clip")
            {
               clip_ID=stringfunc::string_to_number(substrings[1]);
               frame_ID=stringfunc::string_to_number(substrings[3]);
               KEYFRAMES_MAP::iterator keyframe_iter=keyframes_map.find(
                  DUPLE(clip_ID,frame_ID));
               if (keyframe_iter==keyframes_map.end())
               {
                  continue;
               }
//               else
//               {
//                  cout << "clip_ID = " << clip_ID << " frame_ID = " << frame_//ID
//                       << " is a keyframe" << endl;
//               }
            }
         } // substrings.size() conditional
      } // keyframes_flag conditional

      vector<double> curr_bin_values=filefunc::ReadInNumbers(
         histogram_filenames[i]);
      hist_basenames.push_back(basename);
      
      n_bins=curr_bin_values.size();
      double* curr_histogram_ptr=new double[n_bins];
      histogram_ptrs.push_back(curr_histogram_ptr);

      double sqrd_norm=0;
      for (int b=0; b<n_bins; b++)
      {
         if (sqrt_dotproduct_flag)
         {
            (curr_histogram_ptr)[b]=sqrt(curr_bin_values[b]);
         }
         else
         {
            (curr_histogram_ptr)[b]=curr_bin_values[b];
         }
         sqrd_norm += sqr((curr_histogram_ptr)[b]);
      } // loop over index j labeling histogram bins
      double l2_denom=sqrt(sqrd_norm);
      
      if (sqrt_dotproduct_flag)
      {
         for (int b=0; b<n_bins; b++)
         {
            (curr_histogram_ptr)[b]=(curr_histogram_ptr)[b]/l2_denom;
         }
      } // sqrt_dotproduct_flag conditional

   } // loop over index i labeling input histogram files
   
   cout << endl;

   int n_histograms=hist_basenames.size();
   cout << "n_histograms = " << n_histograms << endl;
   cout << "n_bins = " << n_bins << endl;

   cout << endl;
   cout << "Computing HOG word overlaps:" << endl;
   cout << endl;

   int i_max=n_histograms;
   int j_max=i_max;
   int n_rows=i_max*(i_max-1)/2;
   int n_columns=5;

   int max_float_values=n_rows*n_columns;
   float* float_values=new float[max_float_values];

   int b_start=0;
   cout << "Enter starting HOG bin:" << endl;
   cin >> b_start;
   
   int b_stop=n_bins;
   for (int b=b_start; b<b_stop; b++)
   {
      double bin_frac=double(b-b_start)/(b_stop-b_start);
      outputfunc::print_elapsed_and_remaining_time(bin_frac);

      int counter=0;

/*
      dlib::matrix<float> comparison_results;
      comparison_results.set_size(n_rows,n_columns);
      int curr_row=0;
*/

      int n_histogram_comparisons=0;
      int n_thresholded_comparisons=0;
      int clip_ID_i,frame_ID_i,clip_ID_j,frame_ID_j;
      int image_ID_i,image_ID_j;
      vector<double> overlap_scores;
      for (int i=0; i<i_max-1; i++)
      {
         if (video_frames_input_flag)
         {
            clip_ID_i=stringfunc::string_to_number(
               hist_basenames[i].substr(5,4));
            frame_ID_i=stringfunc::string_to_number(
               hist_basenames[i].substr(16,5));
         }
         else
         {

// As of 12/30/13, we assume standard sized images have basenames
// the form pic00000.jpg:

            image_ID_i=stringfunc::string_to_number(
               hist_basenames[i].substr(3,5));
         }
         
         double* curr_histogram_ptr=histogram_ptrs[i];

//         cout << "basename_i = " << hist_basenames[i]
//              << " clip_ID_i = " << clip_ID_i 
//              << " frame_ID_i = " << frame_ID_i << endl;

         for (int j=i+1; j<j_max; j++)
         {
            if (video_frames_input_flag)
            {
               clip_ID_j=stringfunc::string_to_number(
                  hist_basenames[j].substr(5,4));

               if ( (clip_ID_i == clip_ID_j) && different_clips_flag) continue;
               if ( (clip_ID_i != clip_ID_j) && !different_clips_flag) 
                  continue;

               frame_ID_j=stringfunc::string_to_number(
                  hist_basenames[j].substr(16,5));
            }
            else
            {
               image_ID_j=stringfunc::string_to_number(
                  hist_basenames[j].substr(3,5));
            }
            
            double* next_histogram_ptr=histogram_ptrs[j];

//            cout << "basename_j = " << hist_basenames[j]
//                 << " clip_ID_j = " << clip_ID_j
//                 << " frame_ID_j = " << frame_ID_j << endl;

// Calculate overlap score between current and next histograms:

            float overlap_score=0;
            if (diff_over_sum_flag)
            {
               float numer=
                  curr_histogram_ptr[b]-next_histogram_ptr[b];
               float denom=
                  curr_histogram_ptr[b]+next_histogram_ptr[b];
               if (denom > 0)
               {
                  overlap_score=1-fabs(numer)/denom;
               }
               else
               {
                  overlap_score=1;
               }
            } 
            else if (sqrt_dotproduct_flag)
            {
               overlap_score=curr_histogram_ptr[b]*next_histogram_ptr[b];
            } 
            else if (sqrt_diff_over_sum_flag)
            {
               float sqrt_curr_hist=sqrt(curr_histogram_ptr[b]);
               float sqrt_next_hist=sqrt(next_histogram_ptr[b]);
                  
               float numer=sqrt_curr_hist-sqrt_next_hist;
               float denom=sqrt_curr_hist+sqrt_next_hist;
               if (denom > 0)
               {
                  overlap_score=1-fabs(numer)/denom;
               }
               else
               {
                  overlap_score=1;
               }
            } // overlap score computation conditional

            overlap_scores.push_back(overlap_score);

            n_histogram_comparisons++;
            if (overlap_score < min_overlap_score)
            {
               n_thresholded_comparisons++;
               continue;
            }

            if (video_frames_input_flag)
            {
               float_values[counter++]=overlap_score;
               float_values[counter++]=clip_ID_i;
               float_values[counter++]=frame_ID_i;
               float_values[counter++]=clip_ID_j;
               float_values[counter++]=frame_ID_j;
/*
               comparison_results(curr_row,0)=overlap_score;
               comparison_results(curr_row,1)=clip_ID_i;
               comparison_results(curr_row,2)=frame_ID_i;
               comparison_results(curr_row,3)=clip_ID_j;
               comparison_results(curr_row,4)=frame_ID_j;
               curr_row++;
*/
            }
            else
            {
               float_values[counter++]=overlap_score;
               float_values[counter++]=image_ID_i;
               float_values[counter++]=image_ID_j;
            }

         } // loop over index j 
      } // loop over index i 
      double thresholded_comparisons_frac=double(n_thresholded_comparisons)/
         n_histogram_comparisons;
      cout << "Thresholded comparisons frac = "
           << thresholded_comparisons_frac << endl;

/*
      prob_distribution overlap_score_prob(overlap_scores,100,0);
      overlap_score_prob.writeprobdists(false);
      cout << "Exported overlap score prob distribution" << endl;
      outputfunc::enter_continue_char();
*/

// Export overlap scores for current HOG word to output text file:

      string output_filename=BoW_comparisons_subdir+"image_BoWs_";
      output_filename += stringfunc::integer_to_string(b,4);
      if (different_clips_flag)
      {
         output_filename += ".comparison";
      }
      else
      {
         output_filename += "_sameclips.comparison";
      }
      
      if (keyframes_flag && video_frames_input_flag)
      {
         output_filename += ".keyframes";
      }

/*
      cout << "n_histograms = " << n_histograms << endl;
      cout << "(n_hists choose 2) = " << n_histograms*(n_histograms-1)/2
           << endl;
*/

      filefunc::ExportFloats(float_values,counter,output_filename);

/*
// Another thing that is worth knowing is that just about everything
// in dlib is serializable. So for example, you can save the
// learned_pfunct object to disk and recall it later like so:

      ofstream fout(output_filename.c_str(),ios::binary);
      dlib::serialize(comparison_results,fout);
      fout.close();
*/

      banner="Exported image BoW histogram comparison to "+output_filename;
      outputfunc::write_big_banner(banner);

   } // loop over index b labeling HOG words

   delete [] float_values;

   cout << "min_overlap_score = " << min_overlap_score << endl;
   cout << "At end of program COMPARE_BoW_HISTOGRAMS" << endl;
   outputfunc::print_elapsed_time();
}
