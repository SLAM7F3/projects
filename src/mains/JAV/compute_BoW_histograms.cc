// ====================================================================
// Program COMPUTE_BOW_HISTOGRAMS is a variant of the quick-n-dirty
// HOG BoW code which Davis King wrote in Dec 2013.  It imports the HOG
// dictionary generated by program BUILD_HOG_DICTIONARY.  It forceably
// resizes each input image to a standard width and height measured in
// pixels.  Looping over all files within images_subdir, it forms an
// image pyramid and projects each image onto the HOG dictionary
// basis.  COMPUTE_BOW_HISTOGRAM exports an (automatically)
// L1-normalized histogram of HOG BoW coefficients for each input
// image to output text files in a BoW histogram subdirectory.

// 			./compute_BoW_histograms

// ====================================================================
// Last updated on 12/30/13; 1/3/14; 1/9/14
// ====================================================================

#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#include <dlib/svm_threaded.h>
#include <dlib/gui_widgets.h>
#include <dlib/array.h>
#include <dlib/array2d.h>
#include <dlib/image_keypoint.h>
#include <dlib/image_processing.h>
#include <dlib/cmd_line_parser.h>
#include <dlib/data_io.h>

#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "time/timefuncs.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::exception;
using std::flush;
using std::ifstream;
using std::ios;
using std::ofstream;
using std::string;
using std::vector;

typedef dlib::hog_image<
4,4,1,8,dlib::hog_signed_gradient,dlib::hog_full_interpolation> feat_type;

void get_feats (
   const dlib::array2d<unsigned char>& img,
   const dlib::projection_hash& h,
   dlib::matrix<double,0,1>& hist
   )
{
   feat_type feat;
   feat.load(img);
   for (long r = 0; r < feat.nr(); ++r)
   {
      for (long c = 0; c < feat.nc(); ++c)
      {
         hist(h(feat(r,c)))++;
      }
   }
}

// ====================================================================
int main(int argc, char** argv)
{  
   timefunc::initialize_timeofday_clock();

// Import basic HOG BoW processing parameters:

   string gist_subdir="../gist/";
   string BoW_params_filename=gist_subdir+"BoW_params.dat";
   filefunc::ReadInfile(BoW_params_filename);
   int n_HOG_bins=stringfunc::string_to_number(filefunc::text_line[0]);

   bool video_frames_input_flag=
      stringfunc::string_to_boolean(filefunc::text_line[8]);
   cout << "video_frames_input_flag = " << video_frames_input_flag << endl;

   int standard_width,standard_height;
   vector<string> JAV_subdirs;
   if (video_frames_input_flag)
   {
      standard_width=stringfunc::string_to_number(filefunc::text_line[4]);
      standard_height=stringfunc::string_to_number(filefunc::text_line[5]);
   }
   else
   {
      standard_width=stringfunc::string_to_number(filefunc::text_line[6]);
      standard_height=stringfunc::string_to_number(filefunc::text_line[7]);
   }

   int video_corpus_ID=-1;
   string JAV_subdir;
   if (video_frames_input_flag)
   {
      string ImageEngine_subdir="/data/ImageEngine/";
      string BostonBombing_subdir=ImageEngine_subdir+"BostonBombing/";

      cout << "1: early September 2013 NewsWraps" << endl;
      cout << "2: October 2013 NewsWraps with transcripts" << endl;
      cout << "3: Boston Bombing YouTube clips 1 - 25" << endl;

      cout << "Enter video corpus ID:" << endl;
      cin >> video_corpus_ID;

      if (video_corpus_ID==1)
      {
         JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
      }
      else if (video_corpus_ID==2)
      {
         JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
      }
      else if (video_corpus_ID==3)
      {
         JAV_subdir=BostonBombing_subdir+"clips_1_thru_25/";
      }
      else
      {
         exit(-1);
      }
   }
   else
   {
      JAV_subdir="./bundler/tidmarsh/";
   }
   cout << "JAV_subdir = " << JAV_subdir << endl;

   string root_subdir=JAV_subdir;
   string images_subdir;
   if (video_frames_input_flag)
   {
      images_subdir=root_subdir+"jpg_frames/";
   }
   else
   {
      images_subdir=root_subdir+"standard_sized_images/";
   }

   string BoW_histograms_subdir=root_subdir+"BoWs/";
   filefunc::dircreate(BoW_histograms_subdir);

   vector<string> image_filenames=filefunc::image_files_in_subdir(
      images_subdir);

// Import HOG dictionary generated via program BUILD_HOG_DICTIONARY:

   string HOG_dictionary_subdir=
      "/home/cho/programs/c++/svn/projects/src/mains/JAV/HOG_dictionary/";
   string HOG_dictionary_filename=HOG_dictionary_subdir+"HOG_dictionary.dat";
   cout << "Importing HOG dictionary from "+
      HOG_dictionary_filename << endl;

   dlib::projection_hash h;
   ifstream fin(HOG_dictionary_filename.c_str(), ios::binary);
   dlib::deserialize(h, fin);

   if (h.num_hash_bins() != n_HOG_bins)
   {
      cout << "h.num_hash_bins() = " << h.num_hash_bins() << endl;
      cout << "n_HOG_bins = " << n_HOG_bins << endl;
      cout << "These 2 values should be equal!" << endl;
      exit(-1);
   }
      
   int n_images=image_filenames.size();
   for (int i=0; i<n_images; i++)
   {
      if (i%10==0)
      {
         double progress_frac=double(i)/image_filenames.size();
         cout << "Progress fraction = " << progress_frac << endl;
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }
      
// Check whether BoW histogram file for current image
// already exists.  If so, move on...

      string basename=filefunc::getbasename(image_filenames[i]);
      string prefix=stringfunc::prefix(basename);
      string BoW_histogram_filename=BoW_histograms_subdir+
         prefix+".BoW_hist";
         
      if (filefunc::fileexist(BoW_histogram_filename))
      {
         cout << "BoW histogram file already exists" << endl;
         continue;
      }

      string std_sized_image_filename="/tmp/std_sized_image_";
      if (video_corpus_ID > 0)
      {
         std_sized_image_filename += 
            stringfunc::number_to_string(video_corpus_ID);
      }
      std_sized_image_filename += ".jpg";
//      cout << "std_sized_image_filename = " << std_sized_image_filename 
//           << endl;

      videofunc::force_size_image(
         image_filenames[i],standard_width,standard_height,
         std_sized_image_filename);
      
      dlib::array2d<unsigned char> img, temp;
      dlib::load_image(img, std_sized_image_filename.c_str());
      filefunc::deletefile(std_sized_image_filename);

      dlib::matrix<double,0,1> hist(h.num_hash_bins());
      hist = 0;

      const int min_image_size=50*50;
      while (img.size() > min_image_size)
      {
         get_feats(img,h,hist);
         dlib::pyramid_down<4> pyr;
         pyr(img,temp); 
         temp.swap(img);
      }

/*
// L1-normalize histogram:

      double hist_sum=0;
      for (int i=0; i<hist.size(); i++)
      {
         hist_sum += hist(i);
      }
     cout << "Before L1 normalization, hist_sum = " << hist_sum << endl;

      for (int i=0; i<hist.size(); i++)
      {
         hist(i)=hist(i)/hist_sum;
      }
      hist_sum=0;
      for (int i=0; i<hist.size(); i++)
      {
         hist_sum += hist(i);
      }
      cout << "After L1 normalization, hist_sum = " << hist_sum << endl;
*/

// Export BoW histogram to output text file:

      ofstream BoW_stream;
      filefunc::openfile(BoW_histogram_filename,BoW_stream);
      BoW_stream << trans(hist) << endl;
      filefunc::closefile(BoW_histogram_filename,BoW_stream);
         
   } // loop over index i labeling input images
   string banner="Exported BoW histograms to "+BoW_histograms_subdir;
   outputfunc::write_banner(banner);

   banner="At end of program COMPUTE_BOW_HISTOGRAMS";
   outputfunc::write_big_banner(banner);
   outputfunc::print_elapsed_time();
}

