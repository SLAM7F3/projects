// ==========================================================================
// Program COMPARE_face_detections imports a set of face histograms
// generated by program COMPUTE_face_detections.  Looping over all
// imported histograms, it computes dotproducts between successive
// pairs.  The dotproducts are sorted in descending order and exported
// to an output text file with the corresponding pair's image
// filenames.

//			  ./compare_face_detections

// ==========================================================================
// Last updated on 12/12/13
// ==========================================================================

#include <cstdlib>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "math/constant_vectors.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "math/ltduple.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   bool keyframes_flag=true;
   bool different_clips_flag=false;
   bool adjacent_frames_flag=false;

   string input_char;
   cout << "Enter 'k' to process just video keyframes:" << endl;
   cin >> input_char;
   if (input_char != "k")
   {
      keyframes_flag=false;
   }
   cout << "Enter 'w' to compare histograms within and not between clips:"
        << endl;
   cin >> input_char;
   if (input_char != "w")
   {
      different_clips_flag=true;
   }

   cout << "Enter 'a' to compare histograms between temporal neighbor video frames:" << endl;
   cin >> input_char;
   if (input_char=="a")
   {
      adjacent_frames_flag=true;
   }

   string ImageEngine_subdir="/data/ImageEngine/";
//   string root_subdir=ImageEngine_subdir+"NewsWrap/";
//   string root_subdir=ImageEngine_subdir+
//      "BostonBombing/Nightline_YouTube2/transcripted/";
//   string root_subdir=ImageEngine_subdir+"BostonBombing/clip3/";
//   string root_subdir=
//      "/home/cho/programs/c++/svn/projects/src/mains/korea/NK/ground_videos/NorthKorea/";
//   string root_subdir=
//      "/data/ImageEngine/BostonBombing/clips_1_thru_133/clip34/";
//   string images_subdir=root_subdir;


//   string JAV_subdir="/data/video/JAV/NewsWraps/early_Sep_2013/";
   string JAV_subdir="/data/video/JAV/NewsWraps/w_transcripts/";
//   string JAV_subdir="/data/video/JAV/UIUC_Broadcast_News/";
   string root_subdir=JAV_subdir;
   string images_subdir=root_subdir+"jpg_frames/";
   string keyframes_subdir=images_subdir+"keyframes/";

// STL map keyframes_map holds (#small faces, #medium faces, #big faces)
// as function of keyframe clip and frame IDs:

   typedef map<DUPLE,threevector> KEYFRAMES_MAP;
   KEYFRAMES_MAP keyframes_map;
   KEYFRAMES_MAP::iterator keyframe_iter,next_keyframe_iter;

// independent DUPLE holds video image clip and frame ID
// dependent threevector holds (#small faces, #medium faces, #big faces)

   if (keyframes_flag)
   {
      vector<string> keyframe_filenames=filefunc::image_files_in_subdir(
         keyframes_subdir);

      for (int i=0; i<keyframe_filenames.size(); i++)
      {
         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
               filefunc::getbasename(keyframe_filenames[i])," _-");
//         for (int s=0; s<substrings.size(); s++)
//         {
//            cout << "i = " << i << " s = " << s << " substring[s] = " 
//                 << substrings[s] << endl;
//         }

// If input filename has form clip_0000_frame-00001.jpg, record clip's
// ID within STL vector:

         int clip_ID=-1;
         int frame_ID=-1;
         if (substrings.size()==4)
         {
            if (substrings[0]=="clip")
            {
               clip_ID=stringfunc::string_to_number(substrings[1]);
               frame_ID=stringfunc::string_to_number(substrings[3]);
               keyframes_map[DUPLE(clip_ID,frame_ID)]=Zero_vector;
            }
         }
      } // loop over index i labeling keyframe filenames
      
   } // keyframes_flag conditional
   cout << "keyframes_map.size() = " << keyframes_map.size() << endl;

   timefunc::initialize_timeofday_clock();      

// Import face bboxes generated by program HOG_DETECT:

   string banner="Importing face bboxes:";
   outputfunc::write_banner(banner);

   vector<string> image_filenames=filefunc::image_files_in_subdir(
      images_subdir);

   string faces_subdir=root_subdir+"faces/";
   string face_detections_filename=faces_subdir+"davis_face_bboxes.dat";
   vector<vector<double> > RowNumbers=filefunc::ReadInRowNumbers(
      face_detections_filename);

   ofstream tmpstream;
   string tmp_filename=faces_subdir+"face_comparisons.dat";
   filefunc::openfile(tmp_filename,tmpstream);

   ofstream delta_match_stream;
   string delta_match_filename=faces_subdir+"faces_delta_match.dat";
   filefunc::openfile(delta_match_filename,delta_match_stream);

   int width,height;
   const double small_bbox_frac_area=0.02;
   const double big_bbox_frac_area=0.1;
   for (int r=0; r<RowNumbers.size(); r++)
   {

// Each line within face_detections_filename should contain 6 entries.
// If not, skip it!

      if (RowNumbers[r].size() != 6) 
      {
         cout << "r = " << r << " RowNumbers[r].size() = "
              << RowNumbers[r].size() << endl;
         continue;
      }
      
      int image_index=RowNumbers[r].at(0);
      int bbox_index=RowNumbers[r].at(1);
      double Ulo=RowNumbers[r].at(2);
      double Uhi=RowNumbers[r].at(3);
      double Vlo=RowNumbers[r].at(4);
      double Vhi=RowNumbers[r].at(5);
      double bbox_area=(Uhi-Ulo)*(Vhi-Vlo);
      
      string curr_image_filename=image_filenames[image_index];
      imagefunc::get_image_width_height(curr_image_filename,width,height);
      double Umax=double(width)/double(height);
      double bbox_frac_area=bbox_area/(Umax*1);

      string image_basename=filefunc::getbasename(curr_image_filename);
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(
            filefunc::getbasename(image_basename)," _-");

// If input filename has form clip_0000_frame-00001.jpg, record clip's
// ID within STL vector:

      int clip_ID=-1;
      int frame_ID=-1;
      if (substrings.size()==4)
      {
         if (substrings[0]=="clip")
         {
            clip_ID=stringfunc::string_to_number(substrings[1]);
            frame_ID=stringfunc::string_to_number(substrings[3]);
            keyframe_iter=keyframes_map.find(DUPLE(clip_ID,frame_ID));
            if (keyframe_iter==keyframes_map.end()) continue;

            threevector face_bboxes_vec=keyframe_iter->second;
            if (bbox_frac_area < small_bbox_frac_area)
            {
               face_bboxes_vec += threevector(1,0,0);
            }
            else if (bbox_frac_area > big_bbox_frac_area)
            {
               face_bboxes_vec += threevector(0,0,1);
            }
            else
            {
               face_bboxes_vec += threevector(0,1,0);
            }
            keyframe_iter->second=face_bboxes_vec;
         } // substrings[0]=="clip" conditional
      } // substrings.size()==4 conditional
         
      tmpstream << "image = " << image_basename
                << " image_index = " << image_index
                << " bbox_index = " << bbox_index
                << " frac area = " << bbox_frac_area << endl;

   } // loop over index r labeling rows in face_detections_filename

   vector<int> clip_ID_i,clip_ID_j,frame_ID_i,frame_ID_j;
   vector<double> face_matching_scores;
   vector<string> keyframe_pair_basenames;

   for (keyframe_iter=keyframes_map.begin(); keyframe_iter != 
           keyframes_map.end(); keyframe_iter++)
   {
      DUPLE d=keyframe_iter->first;
      int clip_ID=d.first;
      int frame_ID=d.second;
      threevector faces_vec=keyframe_iter->second;
      int n_small_faces=faces_vec.get(0);
      int n_medium_faces=faces_vec.get(1);
      int n_big_faces=faces_vec.get(2);
      int n_faces=n_small_faces+n_medium_faces+n_big_faces;

      string keyframe_basename="clip_"+stringfunc::integer_to_string(
         clip_ID,4)+"_frame-"+stringfunc::integer_to_string(frame_ID,5);

      tmpstream << keyframe_basename 
                << " n_small = " << n_small_faces
                << " n_med = " << n_medium_faces 
                << " n_big = " << n_big_faces 
                << endl;

      next_keyframe_iter=keyframe_iter;
      next_keyframe_iter++;
      while (next_keyframe_iter != keyframes_map.end())
      {
         DUPLE next_d=next_keyframe_iter->first;
         int next_clip_ID=next_d.first;
         int next_frame_ID=next_d.second;
         threevector next_faces_vec=next_keyframe_iter->second;
         int next_n_small_faces=next_faces_vec.get(0);
         int next_n_medium_faces=next_faces_vec.get(1);
         int next_n_big_faces=next_faces_vec.get(2);
         int next_n_faces=next_n_small_faces+next_n_medium_faces+
            next_n_big_faces;
         
         string next_keyframe_basename=
            "clip_"+stringfunc::integer_to_string(next_clip_ID,4)+
            "_frame-"+stringfunc::integer_to_string(next_frame_ID,5);

         double face_delta_match=0;
         if (n_faces==0 && next_n_faces==0)
         {
            face_delta_match=0.03;
         }
         else if (n_medium_faces==next_n_medium_faces && n_medium_faces > 0)
         {
//            face_delta_match=0.1*n_medium_faces;
            face_delta_match=0.1;
         }
         else if (n_big_faces==next_n_big_faces && n_big_faces > 0)
         {
//            face_delta_match=0.1*n_big_faces;
            face_delta_match=0.1;
         }
         else if (n_medium_faces != next_n_medium_faces)
         {
            face_delta_match=-0.2*fabs(n_medium_faces-next_n_medium_faces);
         }
         else if (n_big_faces != next_n_big_faces)
         {
            face_delta_match=-0.1*fabs(n_big_faces-next_n_big_faces);
         }
         if (n_faces >= 2 && next_n_faces >= 2)
         {
            face_delta_match=0.1;
         }
         
         delta_match_stream << face_delta_match << "  "
                            << clip_ID << "  " << frame_ID << "  "
                            << next_clip_ID << "  " << next_frame_ID 
                            << endl;

//         face_matching_scores.push_back(face_matching_score);

         keyframe_pair_basenames.push_back(
            keyframe_basename+"  "+next_keyframe_basename);
         clip_ID_i.push_back(clip_ID);
         clip_ID_j.push_back(next_clip_ID);
         frame_ID_i.push_back(frame_ID);
         frame_ID_j.push_back(next_frame_ID);

         next_keyframe_iter++;
      } // loop over next_keyframe_iter

   } // loop over keyframe_iter

   filefunc::closefile(tmp_filename,tmpstream);
   filefunc::closefile(delta_match_filename,delta_match_stream);
  
/* 
   templatefunc::Quicksort_descending(
      face_matching_scores,clip_ID_i,clip_ID_j,frame_ID_i,frame_ID_j);
//      face_matching_scores,keyframe_pair_basenames);

   string output_filename=faces_subdir;
   if (different_clips_flag)
   {
      output_filename += "image_faces.comparison";
   }
   else if (adjacent_frames_flag)
   {
      output_filename += "image_faces_adjacent_frames.comparison";
   }
   else
   {
      output_filename += "image_faces_sameclips.comparison";
   }

   if (keyframes_flag)
   {
      output_filename += ".keyframes";
   }

   ofstream outstream;
   filefunc::openfile(output_filename,outstream);
   outstream << "# Dotproduct    Image_prefix   Image'_prefix   " 
             << endl << endl;

   for (int t=0; t<face_matching_scores.size(); t++)
   {
      if ( ((clip_ID_i[t] != clip_ID_j[t]) && different_clips_flag) ||
           ((clip_ID_i[t]==clip_ID_j[t]) && !different_clips_flag) )
      {
         if ( (adjacent_frames_flag && (frame_ID_j[t]==frame_ID_i[t]+1)) ||
              !adjacent_frames_flag )
         {
            string keyframe_basename_i="clip_"+
               stringfunc::integer_to_string(clip_ID_i[t],4)+"_frame-"+
               stringfunc::integer_to_string(frame_ID_i[t],5);
            string keyframe_basename_j="clip_"+
               stringfunc::integer_to_string(clip_ID_j[t],4)+"_frame-"+
               stringfunc::integer_to_string(frame_ID_j[t],5);
            outstream << face_matching_scores[t] << "   "
                      << keyframe_basename_i << "   "
                      << keyframe_basename_j << endl;
         }
      }
   } // loop over index t labeling face histogram dotproducts
   filefunc::closefile(output_filename,outstream);

*/

   banner="Exported image matching modifications to "+delta_match_filename;
   outputfunc::write_big_banner(banner);
   filefunc::closefile(delta_match_filename,delta_match_stream);
   
   cout << "At end of program COMPARE_FACE_DETECTIONS" << endl;
   outputfunc::print_elapsed_time();
}
