// ==========================================================================
// Program BUNDLER_PHOTOS reads in reconstructed XYZ points and
// cameras from files generated by MINI[BUNDLER]_CONVERT.  It converts
// the cameras from Noah's bundler coordinate system into
// georegistered coordinates.  TDP/OSGA files are exported to
// bundler_IO_subdir which display reconstructed camera positions.
// Package files containing reconstructed parameters need to generate
// 3D frusta for each camera are written. BUNDLER_PHOTOS also exports
// image vs package filename associations to
// bundler_IO_subdir/images_vs_packages.dat.

//  bundler_photos --region_filename ./bundler/kermit/packages/bundler_photos.pkg

// ==========================================================================
// Last updated on 8/12/13; 9/15/13; 12/4/13
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "geometry/plane.h"
#include "math/rotation.h"          
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "math/threevector.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(15);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   
   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// For GEO data processing, check whether bundler_IO_subdir contains
// "GEO/".  For Small UAV data processing, check whether
// bundler_IO_subdir contains "Puma":

   vector<string> substrings=stringfunc::decompose_string_into_substrings(
      bundler_IO_subdir,"/");
   bool GEO_processing_flag=false;
   bool Small_UAV_processing_flag=false;
   for (unsigned int s=0; s<substrings.size(); s++)
   {
//      cout << "s = " << s << " substring = " << substrings[s] << endl;
      if (substrings[s]=="GEO") GEO_processing_flag=true;
      if (substrings[s]=="Puma") Small_UAV_processing_flag=true;
   }

   string image_sizes_filename=passes_group.get_image_sizes_filename();
   cout << "image_sizes_filename = " << image_sizes_filename << endl;
   string bundle_filename=passes_group.get_bundle_filename();
   cout << "bundle_filename = " << bundle_filename << endl;

   double fitted_world_to_bundler_distance_ratio=
      passes_group.get_fitted_world_to_bundler_distance_ratio();
   cout << "world_to_bundler_ratio = " 
        << fitted_world_to_bundler_distance_ratio << endl;
   threevector fitted_bundler_trans=passes_group.get_bundler_translation();
   cout << "fitted_bundler_trans = " << fitted_bundler_trans << endl;
   double global_az=passes_group.get_global_az();
   double global_el=passes_group.get_global_el();
   double global_roll=passes_group.get_global_roll();
   cout << "global_az = " << global_az*180/PI << endl;
   cout << "global_el = " << global_el*180/PI << endl;
   cout << "global_roll = " << global_roll*180/PI << endl;
   threevector bundler_rotation_origin=
      passes_group.get_bundler_rotation_origin();
   cout << "bundler_rotation_origin = " << bundler_rotation_origin << endl;

// ------------------------------------------------------------------------
// Instantiate reconstructed photos:

   cout << "Instantiating photogroup:" << endl;
   photogroup* photogroup_ptr=new photogroup();

// FAKE FAKE:  Mon Aug 12, 2013 at 11:19 am
// Hardwire UTM zone within photogroup.  Eventually make this a
// passable parameter!

//   photogroup_ptr->set_UTM_zonenumber(-1);	// Boston/Lowell
   photogroup_ptr->set_UTM_zonenumber(19);	// Boston/Lowell
   photogroup_ptr->set_northern_hemisphere_flag(true);

   photogroup_ptr->reconstruct_bundler_cameras(
      bundler_IO_subdir,image_list_filename,image_sizes_filename,
      bundle_filename);

   string packages_subdir=bundler_IO_subdir+"packages/";
   cout << "packages_subdir = " << packages_subdir << endl;
   filefunc::dircreate(packages_subdir);

// ==========================================================================
// Loop over n photos starts here.  First convert reconstructed
// cameras from Noah's bundler coordinate system into georegistered
// coordinates.  Fit imageplane to reconstructed XYZ points for nth
// photo.  Then instantiate and write out package file for nth photo:

   vector<threevector> reconstructed_camera_posn;

   string camera_posns_filename=
      bundler_IO_subdir+"reconstructed_camera_posns.dat";
   ofstream outstream;
   filefunc::openfile(camera_posns_filename,outstream);
   outstream.precision(12);

//      double frustum_sidelength=1.0*fitted_world_to_bundler_distance_ratio;
   double frustum_sidelength=0.1;	// meters (raw bundler)
//      double frustum_sidelength=0.5;	// meters (raw bundler)
//      double frustum_sidelength=0.6;	// meters (raw bundler)
//      double frustum_sidelength=1;	// meters
//      double frustum_sidelength=2;	// meters
//      double frustum_sidelength=3;	// meters (plume)
//      double frustum_sidelength=5;	// meters  (Light hawk?)
//      double frustum_sidelength=10;	// meters
//      double frustum_sidelength=20;	// meters  (Sailplane flight #3)
//      double frustum_sidelength=100;  // meters (fitted HAFB 5-25-11 flight 1)
//      double frustum_sidelength=200;  // meters (GEO)
//      frustum_sidelength=basic_math::max(
//         frustum_sidelength,fitted_world_to_bundler_distance_ratio);

   cout << "GEO_processing_flag = " << GEO_processing_flag << endl;
   cout << "Small_UAV_processing_flag = "
        << Small_UAV_processing_flag << endl;

   if (GEO_processing_flag)
   {
      frustum_sidelength=200;	// meters
   }
   else if (Small_UAV_processing_flag)
   {
//      frustum_sidelength=1;	// meters
//      frustum_sidelength=10;	// meters
      frustum_sidelength=25;	// meters
   }
   else
   {
      cout << endl << endl;
      cout << "Enter sidelength in meters for frusta:" << endl;
      cout << "(Try 0.5 meters for raw bundler reconstructions and 3 meters for georegistered reconstructions)" << endl;
      cin >> frustum_sidelength;

   }

   double downrange_distance=-1;	// meters


// Instantiate STL map to hold associations between image and package
// filenames:

   typedef map<string,string> IMAGE_PACKAGE_MAP;
   IMAGE_PACKAGE_MAP image_package_map;

   int n_start=0;
   for (unsigned int n=n_start; n<photogroup_ptr->get_n_photos(); n++)
   {
//      cout << n << "  " << flush;
      if (n%100==0) cout << n/100 << "  " << flush;

      photograph* photograph_ptr=photogroup_ptr->get_photograph_ptr(n);
      camera* camera_ptr=photograph_ptr->get_camera_ptr();

//      camera_ptr->set_georegistered_flag(false);	// default
      camera_ptr->set_georegistered_flag(true);	// GEO,Puma VSFM

// Sailplane reconstruction (Dec 2010) method for converting bundler
// to world coordinates:

      camera_ptr->convert_bundler_to_world_coords(
         bundler_rotation_origin,
         global_az,global_el,global_roll,
         fitted_world_to_bundler_distance_ratio,
         fitted_bundler_trans);

      threevector camera_posn(camera_ptr->get_world_posn());
//      cout << "n = " << n 
//           << " converted camera_posn = " << camera_posn << endl;
//      outputfunc::enter_continue_char();

      if (photogroup_ptr->get_UTM_zonenumber() >= 0)
      {
         camera_ptr->set_geolocation(
            photogroup_ptr->get_northern_hemisphere_flag(),
            photogroup_ptr->get_UTM_zonenumber(),
            camera_posn.get(0),camera_posn.get(1),camera_posn.get(2));
      }

      const double TINY=0.001;
      if (camera_posn.magnitude() > TINY)
      {
         reconstructed_camera_posn.push_back(camera_posn);
      }

      double az,el,roll;
      camera_ptr->get_az_el_roll_from_Rcamera(az,el,roll);
//      cout << "az = " << az*180/PI << endl;
//      cout << "el = " << el*180/PI << endl;
//      cout << "roll = " << roll*180/PI << endl;

// Write out package file for current camera:

      int ndigits=4;
      string package_filename=packages_subdir+"photo_"+
         stringfunc::integer_to_string(n,ndigits)+".pkg";
      camera_ptr->write_camera_package_file(
         package_filename,photograph_ptr->get_ID(),
         photograph_ptr->get_filename(),
         frustum_sidelength,downrange_distance);

// Add image and package filenames to image_package_map:

      image_package_map[photograph_ptr->get_filename()]=package_filename;

      outstream << photograph_ptr->get_ID() << "  "
                << filefunc::getbasename(photograph_ptr->get_filename())
                << "  "
                << camera_posn.get(0) << "  "
                << camera_posn.get(1) << "  "
                << camera_posn.get(2) << endl;

   } // loop over index n labeling cameras
   cout << endl;
   
   filefunc::closefile(camera_posns_filename,outstream);

// Export TDP & OSGA files with reconstructed camera positions:

   string tdp_filename=bundler_IO_subdir+"reconstructed_camera_posns.tdp";
   tdpfunc::write_relative_xyz_data(tdp_filename,reconstructed_camera_posn);

   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv reconstructed_camera_posns.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);

// ---------------------------------------------------------------------
// Export text file containing package filenames:

   string packages_filename=packages_subdir+"package_filenames.dat";
   filefunc::openfile(packages_filename,outstream);

   IMAGE_PACKAGE_MAP::iterator iter;
   for (iter=image_package_map.begin(); iter != image_package_map.end(); 
        iter++)
   {
      outstream << iter->second << endl;
   }
   filefunc::closefile(packages_filename,outstream);

// ---------------------------------------------------------------------
// Export text file containing image vs package filename associations:

   string image_package_map_filename=bundler_IO_subdir+
      "images_vs_packages.dat";
   filefunc::openfile(image_package_map_filename,outstream);

   for (iter=image_package_map.begin(); iter != image_package_map.end(); 
        iter++)
   {
      outstream << iter->first << "    " << iter->second << endl;
   }
   filefunc::closefile(image_package_map_filename,outstream);
}

