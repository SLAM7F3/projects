// ==========================================================================
// Program NEW_SIFT_MATCHES first recovers the cameras which see XYZ
// points within Noah's raw reconstructed point cloud from
// /bundler_IO_subdir/RawXYZID_vs_cameraIDs.dat for the MIT2317 photo
// set.  It next reads in a set of raw XYZ points onto which Zach
// matches an n+1st photo.  NEW_SIFT_MATCHES concatenates these two
// lists to generate an edgelist for the n+1st image that specifies
// the nodes among the original n photos with which it has SIFT
// feature overlap.  The new photos's edgelist is written to
// individual_photo/edgelist_n+1.dat.

//  new_sift_matches --region_filename ./bundler/individual_photo/packages/peter_inputs.pkg

// ==========================================================================
// Last updated on 5/28/10; 5/30/10; 6/7/10
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "geometry/bounding_box.h"
#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(15);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   
   string orig_bundler_IO_subdir="./bundler/MIT2317/";
   string new_bundler_IO_subdir="./bundler/individual_photo/";

   string orig_bundle_filename=orig_bundler_IO_subdir+"bundle.out";
   cout << "original bundle_filename = " << orig_bundle_filename << endl;

// ------------------------------------------------------------------------
// Extract number of cameras n from original bundle file:

   filefunc::ReadInfile(orig_bundle_filename);

// Extract number of cameras and number of reconstructed XYZ points
// from first uncommented line in BUNDLER output file:

   vector<string> substrings=stringfunc::decompose_string_into_substrings(
      filefunc::text_line[0]);
   int n_cameras=stringfunc::string_to_number(substrings[0]);

// ------------------------------------------------------------------------
// Recover MIT2317 Photo IDs as a function of raw XYZ ID from file
// generated by BUNDLER_CONVERT and store results within STL map:

   string XYZID_vs_camera_IDs_filename=
      orig_bundler_IO_subdir+"RawXYZID_vs_cameraIDs.dat";
   cout << "XYZID_vs_camera_IDs_filename = " 
        << XYZID_vs_camera_IDs_filename << endl;

   typedef map<int,vector<int> > XYZID_PHOTOIDS_MAP;
   XYZID_PHOTOIDS_MAP* xyzid_photoids_map_ptr=
      new XYZID_PHOTOIDS_MAP;
   
   filefunc::ReadInfile(XYZID_vs_camera_IDs_filename);
   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> identities=
         stringfunc::string_to_numbers(filefunc::text_line[i]);
      int XYZ_ID=identities[0];
      vector<int> Photo_IDs;
      for (unsigned int j=1; j<identities.size(); j++)
      {
         Photo_IDs.push_back(identities[j]);
      }
      (*xyzid_photoids_map_ptr)[XYZ_ID]=Photo_IDs;
   } // loop over index labeling lines in XYZID_vs_camera_IDs_filename

// ==========================================================================
 
   string new_image_sift_matches_filename=new_bundler_IO_subdir+
      "new_image_sift_matches.dat";
   cout << "new_image_sift_matches_filename = " 
        << new_image_sift_matches_filename << endl;
   filefunc::ReadInfile(new_image_sift_matches_filename);

   int line_counter=0;
   int n_matches=stringfunc::string_to_number(
      filefunc::text_line[line_counter++]);

// Store number of matches between new image and "n" old images within
// STL vector new_image_matches:

   vector<int> new_image_matches;
   for (int i=0; i<n_cameras; i++)
   {
      new_image_matches.push_back(0);
   }

   for (int n=0; n<n_matches; n++)
   {
      vector<double> new_feature_inputs=stringfunc::string_to_numbers(
         filefunc::text_line[line_counter++]);
      int XYZ_ID=new_feature_inputs[0];
      cout << "n = " << n << " XYZ_ID = " << XYZ_ID << endl;

      XYZID_PHOTOIDS_MAP::iterator iter=xyzid_photoids_map_ptr->find(XYZ_ID);
      if (iter != xyzid_photoids_map_ptr->end())
      {
         vector<int> matching_PHOTO_IDs=iter->second;
         for (unsigned int j=0; j<matching_PHOTO_IDs.size(); j++)
         {
            int matching_photo_ID=matching_PHOTO_IDs[j];
            new_image_matches[matching_photo_ID] = 
               new_image_matches[matching_photo_ID]+1;
         }
      }
   } // loop over index n labeling sift matches from new image with Noah's point cloud
   
// Write out edge list for n+1st image after requiring number of
// matches for n+1st node to exceed some minimal threshold:
  
   string output_filename=new_bundler_IO_subdir+"edgelist_n+1.dat";
   ofstream outstream;
   filefunc::openfile(output_filename,outstream);

   outstream << "# NodeID  NodeID'  Edge weight" << endl;
   outstream << endl;

   int min_n_matches=5;
   //cout << "Enter minimum number of SIFT matches between new and old images:" << endl;
   //cin >> min_n_matches;

   int new_node_ID=n_cameras;
   for (unsigned int i=0; i<new_image_matches.size(); i++)
   {
      int curr_n_matches=new_image_matches[i];
      if (curr_n_matches > min_n_matches)
      {
         outstream << new_node_ID << " "
                   << i << " "
                   << curr_n_matches << endl;
      }
   }
   filefunc::closefile(output_filename,outstream);
}


