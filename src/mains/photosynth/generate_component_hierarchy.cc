// ========================================================================
// Program GENERATE_COMPONENT_HIERARCHY is a variant of
// GENERATE_PHOTO_HIERARCHY which we created for MALLET-based
// text document graph generation purposes.  It is called by
// mains/textsearch/POPULATE_GRAPH_DIRS for each text graph component
// corresponding to a fine topic.  GENERATE_COMPONENT_HIERARCHY reads
// in a graph edge list generated by SIFT_PARSER which establishes
// links between text documents within a particular fine topic.
// It also reads in graph clustering information output by the K-means
// algorithm.  GENERATE_COMPONENT_HIERARCHY writes out a set of SQL
// files which insert or update graphs, nodes, connected component and
// graph annotations for the text document graph pyramid.  
// ========================================================================
// Last updated on 5/26/13; 5/28/13; 5/29/13
// ========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "graphs/graphdbfuncs.h"
#include "graphs/graph_hierarchy.h"
#include "video/imagesdatabasefuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "video/photodbfuncs.h"
#include "video/photogroup.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "general/sysfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::map;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

   bool modify_IMAGERY_database_flag=true;
//   bool modify_IMAGERY_database_flag=false;
   if (modify_IMAGERY_database_flag)
   {
      cout << "modify_IMAGERY_database_flag = true" << endl;
   }
   else
   {
      cout << "modify_IMAGERY_database_flag = false" << endl;
   }
//   outputfunc::enter_continue_char(); // comment out for Reuters 43K

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();

// Instantiate postgis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_db_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(
         passes_group,GISlayer_IDs);
//   cout << "postgis_db_ptr = " << postgis_db_ptr << endl;

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";

// Pass current graph component ID and maximum child node ID as input
// parameters:

   int hierarchy_ID=passes_group.get_graph_hierarchy_ID();
   cout << "graph_hierarchy_ID = " << hierarchy_ID << endl;
   int campaign_ID=passes_group.get_campaign_ID();
   cout << "campaign_ID = " << campaign_ID << endl;
   int mission_ID=passes_group.get_mission_ID();
   cout << "mission_ID = " << mission_ID << endl;
   int graph_component_ID=passes_group.get_graph_component_ID();
   cout << "graph_component_ID = " << graph_component_ID << endl;
   int max_child_node_ID=passes_group.get_max_child_node_ID();
   cout << "max_child_node_ID = " << max_child_node_ID << endl;
//   outputfunc::enter_continue_char();

   if (hierarchy_ID < 0) exit(-1);

   int levelzero_graph_ID=0;
   graph_hierarchy graphs_pyramid(hierarchy_ID,levelzero_graph_ID);

// Initialize STL vectors n_total_nodes and n_total_links to hold
// total number of nodes and links from different connected graph
// components per graph level:

   int n_levels=3;
   int n_connected_components=1;

   vector<int> graph_ID,graph_level,parent_graph_ID;
   vector<int> n_total_nodes,n_total_links;
   graphdbfunc::retrieve_graphs_metadata_from_database(
      postgis_db_ptr,hierarchy_ID,n_levels,
      graph_ID,graph_level,parent_graph_ID,n_total_nodes,n_total_links);

   for (unsigned int level=0; level<n_total_nodes.size(); level++)
   {
      cout << "level = " << level 
           << " n_total_nodes = " << n_total_nodes[level]
           << " n_total_links = " << n_total_links[level]
           << endl;
   }
//    outputfunc::enter_continue_char();
   
// Import number of graph nodes per level and connected graph
// component from text file generated by program KMEANS_CLUSTERS:

   graph_hierarchy::COMPONENTS_LEVELS_MAP components_levels_map;

   string cluster_info_filename=graphs_subdir+"clusters_info.dat";
//   cout << "cluster_info_filename = " << cluster_info_filename << endl;
   filefunc::ReadInfile(cluster_info_filename);

// Export SQL commands which insert connected graph component
// information into connected_components table of IMAGERY database:

   string cc_filename=graphs_subdir+"update_all_ccs.sql";
   cout << "cc_filename = " << cc_filename << endl;
   ofstream ccstream;
   filefunc::openfile(cc_filename,ccstream);
   
   for (unsigned int i=3; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=
         stringfunc::string_to_numbers(filefunc::text_line[i]);
      int level=column_values[0];
      int graph_ID=level;
//      int connected_component_ID=column_values[1];
      int n_nodes=column_values[2];
      pair<int,int> p(graph_component_ID,level);

      twovector posn;
      string cc_label;
      vector<string> topic_labels;
      graph_hierarchy::NNODES_POSN_LABELS 
         nnodes_posn_labels(n_nodes,posn,cc_label,topic_labels);

      components_levels_map[p]=nnodes_posn_labels;

      cout << "level = " << level
           << " graph_component_ID = " << graph_component_ID
           << " n_nodes = " << n_nodes
           << endl;

      int n_links=-1;
      string SQL_cmd=
         graphdbfunc::generate_update_connected_component_SQL_command(
            hierarchy_ID,graph_ID,graph_component_ID,n_nodes,n_links);

      ccstream << SQL_cmd << endl;
   } // loop over index i labeling filefunc::text_line
   filefunc::closefile(cc_filename,ccstream);

   int zeroth_datum_ID=imagesdatabasefunc::get_datum_ID(
      postgis_db_ptr,campaign_ID,mission_ID,0);
   cout << "Zeroth datum ID = " << zeroth_datum_ID << endl;

   if (zeroth_datum_ID < 0)
   {
      cout << "Erroneous value for zeroth datum ID!" << endl;
      exit(-1);
   }

   string banner="Working on connected graph component ID "+
      stringfunc::number_to_string(graph_component_ID);
   outputfunc::write_banner(banner);

// Compute horizontal and vertical offsets for current connected
// component in graph gx,gy coordinates:

   double cc_row,cc_column;
   string cc_label;
   vector<string> topic_labels;
   if (!graphdbfunc::retrieve_connected_component_posn_labels_from_database(
      postgis_db_ptr,hierarchy_ID,levelzero_graph_ID,graph_component_ID,
      cc_row,cc_column,cc_label,topic_labels))
   {
      cout << "Error!  call to graphdbfunc::retrieve_cc_posn_labels_from_db()"
           << endl;
      cout << "failed" << endl;
      exit(-1);
   }

   double horiz_cc_separation=5; // dimensionless gxgy coords
   double vert_cc_separation=6;
   cc_label="Component "+cc_label;

   cout << "cc_row = " << cc_row
        << " cc_column = " << cc_column 
        << " cc_label = " << cc_label << endl;
   cout << "topic_labels.size() = " << topic_labels.size() << endl;

   twovector gxgy_offset(
      cc_column*horiz_cc_separation,-cc_row*vert_cc_separation);
   cout << "gxgy_offset = " << gxgy_offset << endl;

// Update nnodes_posn_labels with connected component position and
// label information for each graph level:

   for (int l=0; l<n_levels; l++)
   {
      pair<int,int> p(graph_component_ID,l);         
      graph_hierarchy::COMPONENTS_LEVELS_MAP::iterator iter=
         components_levels_map.find(p);
      if (iter==components_levels_map.end())
      {
         cout << "iter = end()!" << endl;
//         outputfunc::enter_continue_char();
         continue;
      }

      graph_hierarchy::NNODES_POSN_LABELS nnodes_posn_labels=iter->second;
      nnodes_posn_labels.second=gxgy_offset;
      nnodes_posn_labels.third=cc_label;
      nnodes_posn_labels.fourth=topic_labels;
      iter->second=nnodes_posn_labels;

      cout << "cc=" << iter->first.first
           << " level=" << iter->first.second
           << " nodes=" << iter->second.first
           << " gx=" << iter->second.second.get(0)
           << " gy=" << iter->second.second.get(1)
           << " label=" << iter->second.third 
           << endl;

//         for (int t=0; t<iter->second.fourth.size(); t++)
//         {
//            cout << "topic " << t << " = " << iter->second.fourth.at(t)
//                 << endl;
//         }
//         cout << endl;

   } // loop over index l labeling graph levels

   string connected_component_label="_C"+
      stringfunc::number_to_string(graph_component_ID);
//   cout << "connected_component_label = " << connected_component_label
//        << endl;

   string edgelist_filename=graphs_subdir+"connected_edgelist"+
      connected_component_label+".dat";

   graphs_pyramid.build_hierarchy(
      edgelist_filename,n_levels,zeroth_datum_ID,graphs_subdir,
      n_connected_components,graph_component_ID,max_child_node_ID,
      components_levels_map);

   graphs_pyramid.compute_all_ancestors();

   int minimal_edge_weights_threshold=50;
   graphs_pyramid.write_SQL_insert_node_and_link_commands(
      graphs_subdir,graph_component_ID,minimal_edge_weights_threshold,
      gxgy_offset,n_total_nodes,n_total_links);

//   if (connected_component < n_connected_components-1)
//      graphs_pyramid.destroy_hierarchy();

   graphs_pyramid.write_SQL_update_graph_commands(
      graphs_subdir,n_total_nodes,n_total_links);

   graphs_pyramid.concatenate_SQL_insert_and_update_files(
      graphs_subdir,n_levels,graph_component_ID,n_connected_components);

// Generate graph annotations containing label, number of nodes and
// topic keywords for current graph component:

   graphs_pyramid.write_SQL_insert_connected_component_annotation_commands(
      graphs_subdir,components_levels_map);

// Execute SQL insertion commands for graphs, nodes, links and
// connected components:

   if (modify_IMAGERY_database_flag)
   {
      string graphs_sql_filename=graphs_subdir+"update_all_graphs.sql";
      string nodes_sql_filename=graphs_subdir+"insert_all_nodes.sql";
      string links_sql_filename=graphs_subdir+"insert_all_links.sql";
      string ccs_sql_filename=graphs_subdir+"update_all_ccs.sql";
      string cc_annots_sql_filename=graphs_subdir+"insert_cc_annotations.sql";

      vector<string> sql_filenames;
      sql_filenames.push_back(graphs_sql_filename);
      sql_filenames.push_back(nodes_sql_filename);
//      sql_filenames.push_back(links_sql_filename);
      sql_filenames.push_back(ccs_sql_filename);
      sql_filenames.push_back(cc_annots_sql_filename);

      for (unsigned int s=0; s<sql_filenames.size(); s++)
      {
         string banner="Executing SQL commands in "+sql_filenames[s];
         outputfunc::write_banner(banner);
         filefunc::ReadInfile(sql_filenames[s]);
         postgis_db_ptr->set_SQL_commands(filefunc::text_line);
         postgis_db_ptr->execute_SQL_commands();
      } // loop over index s labeling sql command files

   } // modify_IMAGERY_database_flag conditional

}
