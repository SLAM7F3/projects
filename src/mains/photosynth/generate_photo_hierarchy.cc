// ========================================================================
// Program GENERATE_PHOTO_HIERARCHY reads in the graph edge list
// generated by SIFT_PARSER which establishes links between two
// photos if they share SIFT features in common.  It also reads in
// hierarchical graph clustering information generated by the Markov
// Cluster Algorithm or K-means algorithm.  GENERATE_PHOTO_HIERARCHY
// writes out a set of SQL files files corresponding to a graph
// pyramid. Each level within the graph pyramid contains node, edge
// and connected component information which can be parsed and
// visualized by Michael Yee's graph viewer.

//    generate_photo_hierarchy --region_filename ./bundler/MIT2317/packages/peter_inputs.pkg --GIS_layer ./packages/imagery_metadata.pkg

// ========================================================================
// Last updated on 5/26/13; 6/13/13; 7/24/13
// ========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "graphs/graphdbfuncs.h"
#include "graphs/graph_hierarchy.h"
#include "video/imagesdatabasefuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "video/photodbfuncs.h"
#include "video/photogroup.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "general/sysfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::map;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

//   bool modify_IMAGERY_database_flag=true;
   bool modify_IMAGERY_database_flag=false;
   if (modify_IMAGERY_database_flag)
   {
      cout << "modify_IMAGERY_database_flag = true" << endl;
   }
   else
   {
      cout << "modify_IMAGERY_database_flag = false" << endl;
   }
   outputfunc::enter_continue_char(); // comment out for Reuters 43K

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();

// Instantiate postgis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_db_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(
         passes_group,GISlayer_IDs);
//   cout << "postgis_db_ptr = " << postgis_db_ptr << endl;

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";
   int graph_component_ID=passes_group.get_graph_component_ID();

   int campaign_ID,mission_ID;
//   campaign_ID=6;	// Reuters 43K
//   mission_ID=3;	// Reuters 43K
   cout << "Enter campaign_ID:" << endl;
   cin >> campaign_ID;
   cout << "Enter mission_ID:" << endl;
   cin >> mission_ID;

   if (!imagesdatabasefunc::images_in_database(
      postgis_db_ptr,campaign_ID,mission_ID))
   {
      cout << "ERROR: No images corresponding to campaign_ID = "
           << campaign_ID << " and mission_ID = " << mission_ID
           << " exist in images table of IMAGERY database!" << endl;
      exit(-1);
   }

   vector<int> hierarchy_IDs;
   vector<string> hierarchy_descriptions;
   graphdbfunc::retrieve_hierarchy_IDs_from_database(
      postgis_db_ptr,hierarchy_IDs,hierarchy_descriptions);

   cout << "Existing graph hierarchies within IMAGERY database:" << endl;
   cout << endl;
   for (unsigned int h=0; h<hierarchy_IDs.size(); h++)
   {
      cout << "Hierarchy ID = " << hierarchy_IDs[h]
           << "  hierarchy description = " << hierarchy_descriptions[h] 
           << endl;
   }
   int next_available_hierarchy_ID=0;
   if (hierarchy_IDs.size() > 0)
      next_available_hierarchy_ID=hierarchy_IDs.back()+1;
   cout << endl;
   cout << "Next available hierarchy ID = " << next_available_hierarchy_ID
        << endl << endl;

   int hierarchy_ID=-1;
//   hierarchy_ID=10;	// Mallet version of Reuters 43K
   cout << "Enter ID for new graph hierarchy to be entered into IMAGERY database:" << endl;
   cin >> hierarchy_ID;

   if (hierarchy_ID < 0) exit(-1);

   string hierarchy_name;
//   hierarchy_name="Reuters43K_Mallet";	// Mallet version of Reuters 43K
   cout << "Enter name for new graph hierarchy:" << endl;
   cin >> hierarchy_name;

   int levelzero_graph_ID=0;
   graph_hierarchy graphs_pyramid(hierarchy_ID,levelzero_graph_ID);
   
// Import number of graph nodes per level and connected graph
// component from text file generated by program KMEANS_CLUSTERS:

   graph_hierarchy::COMPONENTS_LEVELS_MAP components_levels_map;

   string cluster_info_filename=graphs_subdir+"clusters_info.dat";
//   cout << "cluster_info_filename = " << cluster_info_filename << endl;
   filefunc::ReadInfile(cluster_info_filename);

   int n_levels=stringfunc::string_to_number(filefunc::text_line[0]);
   int n_connected_components=
      stringfunc::string_to_number(filefunc::text_line[1]);
   int max_child_node_ID=
      stringfunc::string_to_number(filefunc::text_line[2]);

   cout << "Number of graph levels = " << n_levels << endl;
   cout << "Number of connected graph components = " 
        << n_connected_components << endl;
   cout << "Maximum child node ID = " << max_child_node_ID << endl;

// Export SQL commands which insert connected graph component
// information into connected_components table of IMAGERY database:

   string cc_filename=graphs_subdir+"insert_all_ccs.sql";
   cout << "cc_filename = " << cc_filename << endl;
   ofstream ccstream;
   filefunc::openfile(cc_filename,ccstream);
   
   for (unsigned int i=3; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=
         stringfunc::string_to_numbers(filefunc::text_line[i]);
      int level=column_values[0];
      int graph_ID=level;
      int connected_component_ID=column_values[1];
      int n_nodes=column_values[2];
      pair<int,int> p(connected_component_ID,level);

      twovector posn;
      string cc_label;
      vector<string> topic_labels;

      graph_hierarchy::NNODES_POSN_LABELS 
         nnodes_posn_labels(n_nodes,posn,cc_label,topic_labels);

      components_levels_map[p]=nnodes_posn_labels;

      cout << "level = " << level
           << " connected_component_ID = " << connected_component_ID
           << " n_nodes = " << n_nodes
           << endl;

      int n_links=-1;
      string SQL_cmd=
         graphdbfunc::generate_insert_connected_component_SQL_command(
            hierarchy_ID,graph_ID,level,connected_component_ID,
            n_nodes,n_links);
      ccstream << SQL_cmd << endl;
   } // loop over index i labeling filefunc::text_line
   filefunc::closefile(cc_filename,ccstream);

   int zeroth_datum_ID=imagesdatabasefunc::get_datum_ID(
      postgis_db_ptr,campaign_ID,mission_ID,0);
   cout << "Zeroth datum ID = " << zeroth_datum_ID << endl;

   if (zeroth_datum_ID < 0)
   {
      cout << "Erroneous value for zeroth datum ID!" << endl;
      exit(-1);
   }

// Initialize STL vectors n_total_nodes and n_total_links to hold
// total number of nodes and links from different connected graph
// components per graph level:

   vector<int> n_total_nodes,n_total_links;
   for (int l=0; l<n_levels; l++)
   {
      n_total_nodes.push_back(0);
      n_total_links.push_back(0);
   }

   double horiz_cc_separation,vert_cc_separation;
   for (int connected_component=0; connected_component<n_connected_components; 
        connected_component++)
   {
      string banner="Working on connected graph component #"+
         stringfunc::number_to_string(connected_component);
      outputfunc::write_banner(banner);

// Compute horizontal and vertical offsets for current connected
// component in graph gx,gy coordinates:

      double cc_row=0;
      double cc_column=connected_component;
      string cc_label;
      vector<string> topic_labels;
      if (!graphdbfunc::retrieve_connected_component_posn_labels_from_database(
         postgis_db_ptr,hierarchy_ID,levelzero_graph_ID,connected_component,
         cc_row,cc_column,cc_label,topic_labels))
      {
         cc_row=0;
         cc_column=connected_component;
         horiz_cc_separation=1.5; // dimensionless gxgy coords
         cc_label="Component "+stringfunc::number_to_string(
            connected_component+1);
      }
      else
      {
         horiz_cc_separation=5; // dimensionless gxgy coords
         vert_cc_separation=6;
         cc_label="Component "+cc_label;
      }
      twovector gxgy_offset(
         cc_column*horiz_cc_separation,-cc_row*vert_cc_separation);

// Update nnodes_posn_labels with connected component position and
// label information for each graph level:

      for (int l=0; l<n_levels; l++)
      {
         pair<int,int> p(connected_component,l);         
         graph_hierarchy::COMPONENTS_LEVELS_MAP::iterator iter=
            components_levels_map.find(p);
         graph_hierarchy::NNODES_POSN_LABELS nnodes_posn_labels=iter->second;
         nnodes_posn_labels.second=gxgy_offset;
         nnodes_posn_labels.third=cc_label;
         nnodes_posn_labels.fourth=topic_labels;
         iter->second=nnodes_posn_labels;

//         cout << "cc=" << iter->first.first
//              << " level=" << iter->first.second
//              << " nodes=" << iter->second.first
//              << " gx=" << iter->second.second.get(0)
//              << " gy=" << iter->second.second.get(1)
//              << " label=" << iter->second.third 
//              << endl;

//         for (int t=0; t<iter->second.fourth.size(); t++)
//         {
//            cout << "topic " << t << " = " << iter->second.fourth.at(t)
//                 << endl;
//         }
//         cout << endl;

      } // loop over index l labeling graph levels

      string connected_component_label="_C"+
         stringfunc::number_to_string(connected_component);
      string edgelist_filename=graphs_subdir+"connected_edgelist"+
         connected_component_label+".dat";

      graphs_pyramid.build_hierarchy(
         edgelist_filename,n_levels,zeroth_datum_ID,graphs_subdir,
         n_connected_components,connected_component,max_child_node_ID,
         components_levels_map);

      graphs_pyramid.compute_all_ancestors();

      int minimal_edge_weights_threshold=50;
      graphs_pyramid.write_SQL_insert_node_and_link_commands(
         graphs_subdir,connected_component,minimal_edge_weights_threshold,
         gxgy_offset,n_total_nodes,n_total_links);

      if (connected_component < n_connected_components-1)
         graphs_pyramid.destroy_hierarchy();
  
   } // loop over connected_component index 

   graphs_pyramid.write_SQL_insert_graph_commands(
      graphs_subdir,n_total_nodes,n_total_links);

   graphs_pyramid.concatenate_SQL_insert_and_update_files(
      graphs_subdir,n_levels,graph_component_ID,n_connected_components);

// Generate graph annotations containing connected component labels
// and number of nodes only if graph(s) contain more than one
// connected component:

   if (n_connected_components > 1)
   {
      graphs_pyramid.write_SQL_insert_connected_component_annotation_commands(
         graphs_subdir,components_levels_map);
   }
   cout << "n_connected_components = " << n_connected_components << endl;

   int n_graphs=n_levels;
//   if (modify_IMAGERY_database_flag)
//   {
//      graphdbfunc::update_hierarchy_table(
//         postgis_db_ptr,hierarchy_ID,hierarchy_name,n_graphs,
//         n_levels,n_connected_components);
//   }
//   else
   {
      string SQL_cmd=graphdbfunc::generate_insert_graph_hierarchy_SQL_command(
         hierarchy_ID,hierarchy_name,n_graphs,n_levels,n_connected_components);

      string graph_hierarchy_sql_filename=
         graphs_subdir+"insert_graph_hierarchy.sql";
      ofstream sql_stream;
      filefunc::openfile(graph_hierarchy_sql_filename,sql_stream);
      sql_stream << SQL_cmd << endl;
      filefunc::closefile(graph_hierarchy_sql_filename,sql_stream);
   }

// Execute SQL insertion commands for graphs, nodes, links and
// connected components:

   if (modify_IMAGERY_database_flag)
   {
      string graphs_sql_filename=graphs_subdir+"insert_all_graphs.sql";
      string nodes_sql_filename=graphs_subdir+"insert_all_nodes.sql";
      string links_sql_filename=graphs_subdir+"insert_all_links.sql";
      string ccs_sql_filename=graphs_subdir+"insert_all_ccs.sql";

      vector<string> sql_filenames;
      sql_filenames.push_back(graphs_sql_filename);
      sql_filenames.push_back(nodes_sql_filename);
//      sql_filenames.push_back(links_sql_filename);
      sql_filenames.push_back(ccs_sql_filename);

      for (unsigned int s=0; s<sql_filenames.size(); s++)
      {
         string banner="Executing SQL commands in "+sql_filenames[s];
         outputfunc::write_banner(banner);
         filefunc::ReadInfile(sql_filenames[s]);
         postgis_db_ptr->set_SQL_commands(filefunc::text_line);
         postgis_db_ptr->execute_SQL_commands();
      } // loop over index s labeling sql command files

   } // modify_IMAGERY_database_flag conditional

}
