// ========================================================================
// Program PARENTS_EDGELIST reads in the graph edge list generated by
// BUNDLER_CONVERT which establishes links between two photos if they
// share SIFT features in common.  It also reads in photograph
// clustering information.  After forming a parents graph,
// PARENTS_EDGELIST exports the super graph's adjacency matrix as an
// edge list.  This program also outputs a sorted parent node
// centrality file.

// parents_edgelist --region_filename ./bundler/MIT2317/packages/peter_inputs.pkg

// ========================================================================
// Last updated on 2/9/10; 2/11/10; 2/12/10
// ========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "general/sysfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string image_sizes_filename=passes_group.get_image_sizes_filename();
   cout << "image_sizes_filename = " << image_sizes_filename << endl;

// Instantiate photogroup to hold Bundler photos:

   photogroup* photogroup_ptr=new photogroup;

   int n_photos_to_reconstruct=-1;
   photogroup_ptr->generate_bundler_photographs(
      bundler_IO_subdir,image_list_filename,image_sizes_filename,
      n_photos_to_reconstruct);

   int n_photos=photogroup_ptr->get_n_photos();
   cout << "n_photos = " << n_photos << endl;

// Fill STL map holding Noah's SIFT matches between input images:

   string edgelist_filename=bundler_IO_subdir+"edgelist.dat";
   cout << "edgelist_filename = " << edgelist_filename << endl;
   filefunc::ReadInfile(edgelist_filename);

   for (int i=0; i<filefunc::text_line.size(); i++)
   {
//      if (i%1000==0) cout << i << " " << flush;

      vector<double> curr_row_entries=
         stringfunc::string_to_numbers(filefunc::text_line[i]);
      int photo_ID_1=basic_math::round(curr_row_entries[0]);
      int photo_ID_2=basic_math::round(curr_row_entries[1]);
      int n_matches=basic_math::round(curr_row_entries[2]);

      if (!photogroup_ptr->node_in_graph(photo_ID_1))
      {
         photograph* photograph_ptr=new photograph();
         photograph_ptr->set_ID(photo_ID_1);
         photogroup_ptr->add_node(photograph_ptr);
      }

      if (!photogroup_ptr->node_in_graph(photo_ID_2))
      {
         photograph* photograph_ptr=new photograph();
         photograph_ptr->set_ID(photo_ID_2);
         photogroup_ptr->add_node(photograph_ptr);
      }

      photogroup_ptr->add_graph_edge(photo_ID_1,photo_ID_2,n_matches);
//      cout << "ID1 = " << photo_ID_1
//           << " ID2 = " << photo_ID_2
//           << " nmatches = " << n_matches << endl;

   } // loop over index i labeling lines in edgelist_filename
   cout << endl;

   cout << "photogroup_ptr->get_n_photos() = " 
        << photogroup_ptr->get_n_photos() << endl;
//   photogroup_ptr->compute_adjacency_matrix();

// Generate "parents" photogroup where each parent node represents a
// cluster in *photogroup_ptr.

   string graph_parents_filename=
      bundler_IO_subdir+"graph_parents_cluster.dat";
   cout << "graph_parents_filename = " << graph_parents_filename << endl;
   photogroup_ptr->read_cluster_info(graph_parents_filename);

   photogroup* parents_photogroup_ptr=photogroup_ptr->
      generate_cluster_photogroup();

// Write out adjacency matrix for parents graph as an edge list:

   string parents_edgelist_filename=
      bundler_IO_subdir+"parents_edgelist.dat";
   parents_photogroup_ptr->export_edgelist(parents_edgelist_filename,1);

// Calculate parents graph nodes' centrality using MCL algorithm:

   string graph_parents_centrality_filename=
      bundler_IO_subdir+"graph_parents_centrality.dat";
   string unix_cmd="mcx ctty -abc "+parents_edgelist_filename
      +" > "+graph_parents_centrality_filename;
   cout << "unix_cmd = " << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);

// Sort centrality results based upon parent graph node IDs:

   filefunc::ReadInfile(graph_parents_centrality_filename);
   vector<int> parent_node_ID;
   vector<double> centrality;
   for (int n=0; n<filefunc::text_line.size(); n++)
   {
      vector<double> substrings=stringfunc::string_to_numbers(
         filefunc::text_line[n]);
      parent_node_ID.push_back(substrings[0]);
      centrality.push_back(substrings[1]);
      node* parent_node_ptr=parents_photogroup_ptr->get_node_ptr(
         parent_node_ID.back());
      parent_node_ptr->set_centrality(centrality.back());
   } // loop over index n labeling lines in centrality file
   
   templatefunc::Quicksort(parent_node_ID,centrality);

// Output sorted centrality results:
   
   ofstream outstream;
   filefunc::openfile(graph_parents_centrality_filename,outstream);
   for (int n=0; n<parent_node_ID.size(); n++)
   {
      outstream << parent_node_ID[n] << "   " << centrality[n]
                << endl;
   }
   filefunc::closefile(graph_parents_centrality_filename,outstream);

}
