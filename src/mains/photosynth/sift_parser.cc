// ==========================================================================
// Program SIFT_PARSER reads in sift keyfiles generated by Noah
// Snavely's BUNDLER processing pipeline from
// bundler_IO_subdir/matches_buildpair.  It extracts sift matches
// from BUNDLER output. SIFT_PARSER outputs an edge list text file for
// the sift graph to bundler_IO_subdir/graphs/sift_edgelist.dat . 
// ==========================================================================
// Last updated on 2/6/12; 2/8/12; 2/21/12; 11/20/13
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "video/imagesdatabasefuncs.h"
#include "passes/PassesGroup.h"
#include "video/photodbfuncs.h"
#include "video/photogroup.h"
#include "video/sift_feature.h"
#include "video/sift_featuresgroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"


// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

//   int campaign_ID,mission_ID;
//   cout << "Enter campaign_ID:" << endl;
//   cin >> campaign_ID;
//   cout << "Enter mission_ID:" << endl;
//   cin >> mission_ID;

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string image_list_filename=passes_group.get_image_list_filename();
   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string image_sizes_filename=passes_group.get_image_sizes_filename();
   cout << "image_sizes_filename = " << image_sizes_filename << endl;
   string bundle_filename=passes_group.get_bundle_filename();
   cout << "bundle_filename = " << bundle_filename << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";
   filefunc::dircreate(graphs_subdir);

//   string sift_matches_subdir=bundler_IO_subdir+"sift_matches/";
   string sift_matches_subdir=bundler_IO_subdir+"matches_buildpair/";

// Instantiate reconstructed photos:

   cout << "Instantiating photogroup:" << endl;
   photogroup* photogroup_ptr=new photogroup();

   int n_photos_to_reconstruct=-1;
   photogroup_ptr->generate_bundler_photographs(
      bundler_IO_subdir,image_list_filename,image_sizes_filename,
      n_photos_to_reconstruct);

// ==========================================================================
// Parse SIFT matches generated by BUNDLER.  Generate SQL insert
// commands for sift_matches table in imagery database.  Write out
// edge list for matching SIFT features.
// ==========================================================================

   string banner="Parsing SIFT matches files generated by BUNDLER";
   outputfunc::write_big_banner(banner);

//   string SQL_filename=bundler_IO_subdir+"insert_SIFT_matches.sql";
//   filefunc::deletefile(SQL_filename);
//   ofstream SQL_stream;
//   filefunc::appendfile(SQL_filename,SQL_stream);

// Search through sift_matches_subdir for all match files:

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("txt");
   vector<string> match_files=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,sift_matches_subdir);
//   cout << "match_files.size() = " << match_files.size() << endl;

// Store all images contained within bundler's matches_buildpair
// output subdirectory inside an STL map:

   typedef map<int,int> IMAGE_ID_MAP;

// independent int = image ID
// dependent int = image frequency counter

   IMAGE_ID_MAP image_id_map;
   IMAGE_ID_MAP::iterator image_id_iter;

   vector<threevector> node_nodep_weight;
   
   for (unsigned int m=0; m<match_files.size(); m++)
   {
      string curr_matchfile=match_files[m];
      string separator_chars="-";
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         curr_matchfile,separator_chars);
      int image_ID1=stringfunc::string_to_number(substrings[1]);
      int image_ID2=stringfunc::string_to_number(substrings[2]);

// Record image_ID1 and image_ID2 within STL map:

      image_id_iter=image_id_map.find(image_ID1);
      if (image_id_iter==image_id_map.end())
      {
         image_id_map[image_ID1]=1;
      }
      else
      {
         image_id_iter->second=image_id_iter->second+1;
      }
      
      image_id_iter=image_id_map.find(image_ID2);
      if (image_id_iter==image_id_map.end())
      {
         image_id_map[image_ID2]=true;
      }
      else
      {
         image_id_iter->second=image_id_iter->second+1;
      }

      filefunc::ReadInfile(curr_matchfile);
      int n_matches=stringfunc::string_to_number(filefunc::text_line[0]);

      if (m%1000==0)
      {
         cout << m 
              << " match_files.size=" << match_files.size() 
              << " image_ID1=" << image_ID1
              << " image_ID2=" << image_ID2 
              << " n_matches=" << n_matches << endl;
      }
      
      node_nodep_weight.push_back(threevector(image_ID1,image_ID2,n_matches));
      
/*
      for (int j=1; j<=n_matches; j++)
      {
         vector<double> column_values=stringfunc::string_to_numbers(
            filefunc::text_line[j]);
         int sift_feature_ID1=column_values[0];
         int sift_feature_ID2=column_values[1];
//         cout << sift_feature_ID1 << "  " << sift_feature_ID2 << endl;

         string SQL_command=
            imagesdatabasefunc::generate_insert_sift_match_SQL_command(
               campaign_ID,mission_ID,image_ID1,sift_feature_ID1,
               campaign_ID,mission_ID,image_ID2,sift_feature_ID2);
         SQL_stream << SQL_command << endl;

      } // loop over index j labeling SIFT matches between image_ID1
	//   and image_ID2
 */

   } // loop over index m labeling SIFT match files

//   filefunc::closefile(SQL_filename,SQL_stream);

//   banner="Wrote SIFT feature matches to "+SQL_filename;
//   outputfunc::write_big_banner(banner);

// Generate SIFT feature edge list:

   string sift_edgelist_filename=graphs_subdir+"sift_edgelist.dat";
   ofstream outstream;
   filefunc::openfile(sift_edgelist_filename,outstream);
   outstream << "# Edge weight threshold = 0" << endl;
   outstream << "# NodeID  NodeID'  Edge weight" << endl << endl;
   for (unsigned int i=0; i<node_nodep_weight.size(); i++)
   {
      threevector curr_n_np_w(node_nodep_weight[i]);
      outstream << curr_n_np_w.get(0) << "  "
                << curr_n_np_w.get(1) << "  "
                << curr_n_np_w.get(2) << endl;
   }
   filefunc::closefile(sift_edgelist_filename,outstream);

   banner="Wrote SIFT edge list to "+sift_edgelist_filename;
   outputfunc::write_big_banner(banner);

// Export filenames for all images encountered within BUNDLER's
// matches_buildpair results subdirectory:

   string images_edgelist_filename=graphs_subdir+"images_edgelist.dat";
   filefunc::openfile(images_edgelist_filename,outstream);
   outstream << "# Images encountered in BUNDLER's matches_buildpair subdirectory" << endl;
   outstream << endl << endl;

   for (image_id_iter=image_id_map.begin(); image_id_iter !=
           image_id_map.end(); image_id_iter++)
   {
      int image_ID=image_id_iter->first;
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(image_ID);
      string image_filename=photo_ptr->get_filename();
      outstream << image_filename << endl;
   }
   filefunc::closefile(images_edgelist_filename,outstream);

   banner="Wrote images corresponding to SIFT edge list to "+
      images_edgelist_filename;
   outputfunc::write_big_banner(banner);

/*
   bool generate_SIFT_features_SQL_commands_flag=false;
   if (!generate_SIFT_features_SQL_commands_flag) exit(-1);

// ==========================================================================
// Parse SIFT features for each image input into BUNDLER:
// ==========================================================================

   SQL_filename="insert_SIFT_features.sql";
   filefunc::deletefile(SQL_filename);

   sift_featuresgroup* sift_featuresgroup_ptr=new sift_featuresgroup();

   for (int p=0; p<photogroup_ptr->get_n_photos(); p++)
   {
      photograph* curr_photo_ptr=photogroup_ptr->get_photograph_ptr(p);
      int photo_ID=curr_photo_ptr->get_ID();

      string curr_photo_filename=curr_photo_ptr->get_filename();
      string photo_basename=filefunc::getbasename(curr_photo_filename);
      string prefix=stringfunc::prefix(photo_basename);
//      cout << "p = " << p 
//           << " photo_filename = " << curr_photo_filename 
//           << " prefix = " << prefix 
//           << endl;
      string sift_features_subdir=bundler_IO_subdir+"sift_features/";
      string curr_gzipped_keyfile=sift_features_subdir+prefix+".key.gz";
   
      string unix_cmd="gunzip "+curr_gzipped_keyfile;
      cout << unix_cmd << endl;
      sysfunc::unix_command(unix_cmd);

      string curr_keyfile=stringfunc::erase_chars_after_first_substring(
         curr_gzipped_keyfile,".key");
//      cout << "curr_keyfile = " << curr_keyfile << endl;

      filefunc::ReadInfile(curr_keyfile);
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[0]);
   
      unix_cmd="gzip "+curr_keyfile;
      sysfunc::unix_command(unix_cmd);

      int line_number=0;
      int n_features=column_values[line_number++];
   
      for (int n=0; n<n_features; n++)
      {
         sift_feature* sift_feature_ptr=new sift_feature(n);
         sift_feature_ptr->set_photo_ID(photo_ID);

         column_values.clear();
         column_values=stringfunc::string_to_numbers(
            filefunc::text_line[line_number++]); 
         double u=column_values[0]/double(curr_photo_ptr->get_ydim());
         double v=1-column_values[1]/double(curr_photo_ptr->get_ydim());
         double theta=column_values[2];
         double scale=column_values[3];
         sift_feature_ptr->set_u_v_orientation_scale(u,v,theta,scale);

         vector<double> sift_descriptor;
         for (int i=0; i<7; i++)
         {
            column_values.clear();
            column_values=stringfunc::string_to_numbers(
               filefunc::text_line[line_number++]);

            for (int c=0; c<column_values.size(); c++)
            {
               sift_descriptor.push_back(column_values[c]);
            } // loop over index c
         } // loop over index i 

         sift_feature_ptr->set_descriptor(sift_descriptor);
//         cout << *sift_feature_ptr << endl;

         sift_featuresgroup_ptr->add_siftfeature(sift_feature_ptr);
      } // loop over index n labeling sift features

      sift_featuresgroup_ptr->write_SQL_insert_features_commands(
         photo_ID,SQL_filename);

   } // loop over index p labeling photos

   cout << "Total number of sift features = " 
        << sift_featuresgroup_ptr->count_all_sift_features() << endl;

*/

}
