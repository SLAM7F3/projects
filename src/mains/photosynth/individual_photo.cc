// ==========================================================================
// Program INDIVIDUAL_PHOTO reads in a bundler file generated by Zach
// and Karl for an n+1st reconstructed photo.  It converts between
// Noah's coordinate system and geocoordinates.  A package file
// "photo_new.pkg" containing reconstructed parameters needed to
// visualize the 3D frustum for new camera is written out.
// INDIVIDUAL_PHOTO also broadcasts an ActiveMQ message containing the
// reconstructed camera's geocoordinates for display within a Google
// Maps thin client.

//  individual_photo --region_filename ./bundler/karl/packages/peter_inputs.pkg

// ==========================================================================
// Last updated on 5/28/10; 6/17/10; 6/18/10
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "geometry/plane.h"
#include "math/rotation.h"          
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "math/threevector.h"
#include "track/tracks_group.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(15);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   
// Instantiate separate messengers for each Decorations group which
// needs to receive mail:

   string pass_filename="empty.xyzp";
   int pass_ID=passes_group.generate_new_pass(pass_filename);
   string broker_URL=passes_group.get_pass_ptr(pass_ID)->
      get_PassInfo_ptr()->get_ActiveMQ_hostname();
   cout << "ActiveMQ broker_URL = " << broker_URL << endl;

   string message_sender_ID="INDIVIDUAL_PHOTO";
   string GPS_message_queue_channel_name="viewer_update";
   Messenger GPS_messenger( 
      broker_URL, GPS_message_queue_channel_name,message_sender_ID);

   string bundler_IO_subdir="./bundler/individual_photo/";
   string image_list_filename=bundler_IO_subdir+"image_list.dat";
   cout << "image_list_filename = " << image_list_filename << endl;
   string image_sizes_filename=bundler_IO_subdir+"image_sizes.dat";
   cout << "image_sizes_filename = " << image_sizes_filename << endl;
   string bundle_filename=bundler_IO_subdir+"bundle.out";
   cout << "bundle_filename = " << bundle_filename << endl;

   double fitted_world_to_bundler_distance_ratio=
      passes_group.get_fitted_world_to_bundler_distance_ratio();
   cout << "world_to_bundler_ratio = " 
        << fitted_world_to_bundler_distance_ratio << endl;

   threevector fitted_bundler_trans=passes_group.get_bundler_translation();
   cout << "fitted_bundler_trans = " << fitted_bundler_trans << endl;

   double global_az=passes_group.get_global_az();
   double global_el=passes_group.get_global_el();
   double global_roll=passes_group.get_global_roll();
   cout << "global_az = " << global_az*180/PI << endl;
   cout << "global_el = " << global_el*180/PI << endl;
   cout << "global_roll = " << global_roll*180/PI << endl;
   
   threevector bundler_rotation_origin=
      passes_group.get_bundler_rotation_origin();
   cout << "bundler_rotation_origin = " << bundler_rotation_origin << endl;

// ------------------------------------------------------------------------
// Instantiate reconstructed photo:

   cout << "Instantiating photogroup:" << endl;
   photogroup* bundler_photogroup_ptr=new photogroup();

   int n_photos_to_reconstruct=-1;
   bundler_photogroup_ptr->reconstruct_bundler_cameras(
      bundler_IO_subdir,image_list_filename,image_sizes_filename,
      bundle_filename,n_photos_to_reconstruct);

   photogroup* photogroup_ptr=new photogroup(*bundler_photogroup_ptr);

   string packages_subdir=bundler_IO_subdir+"packages/";
   cout << "packages_subdir = " << packages_subdir << endl;
   filefunc::dircreate(packages_subdir);

// ==========================================================================
// First convert reconstructed camera from Noah's bundler coordinate
// system into georegistered coordinates.  Then instantiate and write
// out package file for new photo:

   photograph* photograph_ptr=photogroup_ptr->get_photograph_ptr(0);
   camera* camera_ptr=photograph_ptr->get_camera_ptr();

   camera_ptr->convert_bundler_to_world_coords(
      fitted_bundler_trans.get(0),
      fitted_bundler_trans.get(1),
      fitted_bundler_trans.get(2),
      bundler_rotation_origin,
      global_az,global_el,global_roll,
      fitted_world_to_bundler_distance_ratio);

   vector<threevector> reconstructed_camera_posn;
   threevector camera_posn(camera_ptr->get_world_posn());
   const double TINY=0.001;
   if (camera_posn.magnitude() > TINY)
   {
      reconstructed_camera_posn.push_back(camera_posn);
   }

//      double az,el,roll;
//      camera_ptr->get_az_el_roll_from_Rcamera(az,el,roll);
//      cout << "az = " << az*180/PI << endl;
//      cout << "el = " << el*180/PI << endl;
//      cout << "roll = " << roll*180/PI << endl;

   string package_filename=packages_subdir+"photo_new.pkg";

   double frustum_sidelength=1.0*fitted_world_to_bundler_distance_ratio;
   double downrange_distance=-1;	// meters

// Write out package file for current camera:

   camera_ptr->write_camera_package_file(
      package_filename,photograph_ptr->get_ID(),
      photograph_ptr->get_filename(),
      frustum_sidelength,downrange_distance);

// ==========================================================================
// Broadcast camera's reconstructed geoposition to Blue Force Tracker
// thin client for display against Google map background:

   tracks_group camera_tracks_group;
   int ID=1;
   track* camera_track_ptr=camera_tracks_group.generate_new_track(ID);
   camera_track_ptr->set_description("Reconstructed Camera");

// As of May 2010, Jennifer Drexler's blue force tracker thin client
// expects to receive longitude,latitude rather than easting,northing
// geocoordinates:  

   threevector camera_position=camera_ptr->get_world_posn();
   threevector camera_velocity=Zero_vector;

   bool northern_hemisphere_flag=true;
   int UTM_zonenumber=19;	// Boston area
   geopoint camera_geopoint(northern_hemisphere_flag,UTM_zonenumber,
                            camera_posn.get(0),camera_posn.get(1),
                            camera_posn.get(2));
   threevector curr_lla_posn(camera_geopoint.get_longitude(),
                             camera_geopoint.get_latitude(),
                             camera_geopoint.get_altitude());
   
   Clock clock;
   clock.current_local_time_and_UTC();

   colorfunc::Color camera_color=colorfunc::red;
   double curr_time=clock.secs_elapsed_since_reference_date(); 
   camera_track_ptr->set_posn_velocity(
      curr_time,curr_lla_posn,camera_velocity);
   string ID_label="Camera";
   camera_track_ptr->broadcast_statevector(
      curr_time,&GPS_messenger,camera_color,ID_label);

// ==========================================================================

   string script_filename="run_individual_viewbundler";
   ofstream outstream;
   filefunc::openfile(script_filename,outstream);

   string dirname="./";
   outstream << "cd " << dirname << endl;
   outstream << dirname+"viewbundler \\" << endl;

   string osga_subdir_name=
    "~/programs/c++/svn/projects/src/mains/photosynth/bundler/MIT2317/";
   string osga_filename=osga_subdir_name+"thresholded_xyz_points.osga";
   outstream << osga_filename << " \\" << endl;

// Explicitly check whether package file actually exists before
// writing it to the output script:

   if (filefunc::fileexist(package_filename))
   {
      outstream << "--region_filename "+package_filename+" \\" << endl;
   }

// For SIGMA demo purposes, display Boston TEC 2004 ladar point cloud
// along with Noah's MIT2317 reconstructed point cloud:

   if (filefunc::fileexist("/data/ladar/TEC/TEC_2004/Boston_Downtown_MSL_2004/fused_osga_tiles/tile.x1.y1_rgb.osga"))
   {
      outstream << "--region_filename /data/ladar/TEC/TEC_2004/Boston_Downtown_MSL_2004/fused_osga_tiles/*.osga \\" << endl;

   }

   outstream << "--image_list_filename "+image_list_filename+" \\" << endl;
   outstream << "--image_sizes_filename "+image_sizes_filename+" \\" << endl;
   outstream << "--initial_mode Manipulate_Fused_Data_Mode" << endl;

   filefunc::closefile(script_filename,outstream);

// Make output script executable:

   string unix_command_str="chmod a+x "+script_filename;
//   cout << "unix_command_str = " << unix_command_str << endl;
   sysfunc::unix_command(unix_command_str);

   string banner="Script file written to output file "+script_filename;
   outputfunc::write_big_banner(banner);
}


