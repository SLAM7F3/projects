// ==========================================================================
// Program REDGREEN is a specialized utility which we wrote in July
// 2012 for Andrew Silberfarb's RCO demo.  This program reads in a set
// of instantaneous visibility results generated by LOST from geotif
// files named ptwoDarray_OBSFRUSTUM_0_frame_N.tif.  The input geotifs
// have 3 possible "z" values corresponding to black, red and green
// colorings.  REDGREEN converts greyscale input tifs into
// colored version and exports the results to cropped geotif files.
// ==========================================================================
// Last updated on 7/23/12
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "image/imagefuncs.h"
#include "image/raster_parser.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   int n_frames;
   cout << "Enter number of frames to convert from greyscale to red-green coloring:" << endl;
   cin >> n_frames;

//   string subdir="./";
   string subdir="/data_second_disk/DTED/Iraq/geotif/Ptiles/";
   string input_filename_prefix="ptwoDarray_OBSFRUSTUM_0_frame_";

   for (int frame_number=0; frame_number < n_frames; frame_number++)
   {
      string input_filename=subdir+input_filename_prefix+
         stringfunc::number_to_string(frame_number)+".tif";
      cout << "input_filename = " << input_filename << endl;

      raster_parser* raster_parser_ptr=new raster_parser();
      raster_parser_ptr->set_n_channels(1);
      raster_parser_ptr->open_image_file(input_filename);

      raster_parser_ptr->fetch_raster_band(0);
      twoDarray* ztwoDarray_ptr=raster_parser_ptr->get_ztwoDarray_ptr();
      raster_parser_ptr->read_raster_data(ztwoDarray_ptr);
      cout << "*ztwoDarray_ptr = " << *ztwoDarray_ptr << endl;

// Find bounding box surrounding nontrivial part of input image:

      int px_min=POSITIVEINFINITY;
      int py_min=POSITIVEINFINITY;
      int px_max=NEGATIVEINFINITY;
      int py_max=NEGATIVEINFINITY;
      for (int py=0; py<ztwoDarray_ptr->get_ydim(); py++)
      {
         for (int px=0; px<ztwoDarray_ptr->get_xdim(); px++)
         {
            int z=ztwoDarray_ptr->get(px,py);
            if (z == 0) 
            {
               continue;
            }
            else if (z==32800 || z==65535)
            {
               px_min=basic_math::min(px_min,px);
               px_max=basic_math::max(px_max,px);
               py_min=basic_math::min(py_min,py);
               py_max=basic_math::max(py_max,py);
            }
         
//         cout << "px = " << px << " py = " << py
//              << " z = " << ztwoDarray_ptr->get(px,py) << endl;
         }
      }


      int xdim=ztwoDarray_ptr->get_xdim();
      int ydim=ztwoDarray_ptr->get_ydim();
      double xlo=ztwoDarray_ptr->get_xlo();
      double xhi=ztwoDarray_ptr->get_xhi();
      double ylo=ztwoDarray_ptr->get_ylo();
      double yhi=ztwoDarray_ptr->get_yhi();

      cout << "xdim = " << xdim << " xlo = " << xlo << " xhi = " << xhi 
           << endl;
      cout << "ydim = " << ydim << " ylo = " << ylo << " yhi = " << yhi 
           << endl;

      int reduced_xdim=px_max-px_min+1;
      int reduced_ydim=py_max-py_min+1;

      cout << "px_min = " << px_min << " px_max = " << px_max << endl;
      cout << "py_min = " << py_min << " py_max = " << py_max << endl;

      double new_xlo=xlo+double(px_min)/double(xdim)*(xhi-xlo);
      double new_xhi=xlo+double(px_max)/double(xdim)*(xhi-xlo);
      double new_ylo=ylo+double(ydim-py_max)/double(ydim)*(yhi-ylo);
      double new_yhi=ylo+double(ydim-py_min)/double(ydim)*(yhi-ylo);

      cout << "new_xlo = " << new_xlo << " new_xhi = " << new_xhi << endl;
      cout << "new_ylo = " << new_ylo << " new_yhi = " << new_yhi << endl;
   
      twoDarray* RtwoDarray_ptr=new twoDarray(reduced_xdim,reduced_ydim);
      twoDarray* GtwoDarray_ptr=new twoDarray(reduced_xdim,reduced_ydim);
      twoDarray* BtwoDarray_ptr=new twoDarray(reduced_xdim,reduced_ydim);
      twoDarray* AtwoDarray_ptr=new twoDarray(reduced_xdim,reduced_ydim);
      RtwoDarray_ptr->init_coord_system(new_xlo,new_xhi,new_ylo,new_yhi);
      GtwoDarray_ptr->init_coord_system(new_xlo,new_xhi,new_ylo,new_yhi);
      BtwoDarray_ptr->init_coord_system(new_xlo,new_xhi,new_ylo,new_yhi);
      AtwoDarray_ptr->init_coord_system(new_xlo,new_xhi,new_ylo,new_yhi);

      RtwoDarray_ptr->clear_values();
      GtwoDarray_ptr->clear_values();
      BtwoDarray_ptr->clear_values();
      AtwoDarray_ptr->initialize_values(1);

      for (int py=0; py<ztwoDarray_ptr->get_ydim(); py++)
      {
         for (int px=0; px<ztwoDarray_ptr->get_xdim(); px++)
         {
            int z=ztwoDarray_ptr->get(px,py);
            if (z == 0) 
            {
               continue;
            }

            double x,y;
            ztwoDarray_ptr->pixel_to_point(px,py,x,y);

            int qx,qy;
            if (!RtwoDarray_ptr->point_to_pixel(x,y,qx,qy)) continue;

            if (z==32800)
            {
               RtwoDarray_ptr->put(qx,qy,1);
            }
            else if (z==65535)
            {
               GtwoDarray_ptr->put(qx,qy,1);
            }
         
//         cout << "px = " << px << " py = " << py
//              << " z = " << ztwoDarray_ptr->get(px,py) << endl;
         }
      }
      raster_parser_ptr->close_image_file();

// Try to rub out mysterious horizontal and vertical black lines in
// output red-green imagery:

      imagefunc::median_filter(5,RtwoDarray_ptr);
      imagefunc::median_filter(5,GtwoDarray_ptr);

      string output_filename="instantaneous_visibility_frame_"+
         stringfunc::number_to_string(frame_number)+".tif";

      raster_parser_ptr->write_colored_raster_data(
         output_filename,raster_parser_ptr->get_specified_UTM_zonenumber(),
         raster_parser_ptr->get_northern_hemisphere_flag(),
         RtwoDarray_ptr,GtwoDarray_ptr,BtwoDarray_ptr,AtwoDarray_ptr);

      delete raster_parser_ptr;

   } // loop over frame_number 
}
