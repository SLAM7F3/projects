// ========================================================================
// Program CROP_BBOX is a special-purpose program which attempts to
// cull out the region within the HAFB video that roughly corresponds
// to the Dec 2004 HAFB "death-pass" ladar data.  It reads in
// interpolated bounding box information generated by program
// INTERP_BBOX.  Intensity information lying outside the bounding
// boxes are nulled in each image of the input video pass (which as of
// 9/21/05 we assume to be HAFB_overlap_corrected_grey.vid).

// We cluged together this program in order to minimize the number of
// features tracked outside the overlap region between the ladar and
// video data.
// ========================================================================
// Last updated on 11/15/05
// ========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "color/colorfuncs.h"
#include "image/drawfuncs.h"
#include "general/filefuncs.h"
#include "geometry/polygon.h"
#include "general/stringfuncs.h"
#include "templates/mytemplates.h"
#include "video/VidFile.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::string;
using std::vector;

// ========================================================================

int main(int argc, char* argv[])
{
   string input_filename=string(argv[1]);
   unsigned int dot_posn=input_filename.rfind("_corrected_grey.vid");
   string output_filename="bbox.vid";

   VidFile vid_in(input_filename);

   cout << "Total number of input frames = " << vid_in.getNumFrames() 
        << endl;

   int startFrame,endFrame,n_skip;
   cout << "Enter starting frame number:" << endl;
   cin >> startFrame;
//   startFrame=0;
   cout << "Enter ending frame number:" << endl;
   cin >> endFrame;
//   endFrame=288;
   cout << "Enter frame skip factor:" << endl;
   cin >> n_skip;
//   n_skip=1;

   VidFile vid_out;
   vid_out.New_8U(output_filename.c_str(),vid_in.getWidth(),
                  vid_in.getHeight(), (endFrame-startFrame)/n_skip+1, 1);

// We assume input represents 8-bit corrected grey video:

   unsigned char* pbyImgIn = 
      new unsigned char[vid_in.getWidth()*vid_in.getHeight()];
   unsigned char* pbyImgOut = 
      new unsigned char[vid_in.getWidth()*vid_in.getHeight()];
   vid_in.read_image(startFrame-1,pbyImgIn);
   vid_in.generate_RGBA_twoDarrays();

// Next read in interpolated bbox information:

//   string subdir="./bbox_data/";
//   string input_interp_filename=subdir+"interp_bbox_corners.txt";
   string bbox_corners_filename="bbox_corners.txt";
//   filefunc::ReadInfile(input_interp_filename);
   filefunc::ReadInfile(bbox_corners_filename);

   double X[3];
   vector<int> imagenumber;
   vector<twovector> bbox_corner[4];
   for (unsigned int i=0; i<filefunc::text_line.size(); i += 5)
   {
      stringfunc::string_to_n_numbers(3,filefunc::text_line[i],X);
      imagenumber.push_back(X[0]);

      stringfunc::string_to_n_numbers(3,filefunc::text_line[i+1],X);
      bbox_corner[0].push_back(twovector(X[0],X[1]));
      stringfunc::string_to_n_numbers(3,filefunc::text_line[i+2],X);
      bbox_corner[1].push_back(twovector(X[0],X[1]));
      stringfunc::string_to_n_numbers(3,filefunc::text_line[i+3],X);
      bbox_corner[2].push_back(twovector(X[0],X[1]));
      stringfunc::string_to_n_numbers(3,filefunc::text_line[i+4],X);
      bbox_corner[3].push_back(twovector(X[0],X[1]));
//      cout << "imagenumber = " << imagenumber.back() << endl;
//      cout << "corner0 = " << bbox_corner[0].back() << endl;
//      cout << "corner1 = " << bbox_corner[1].back() << endl;
//      cout << "corner2 = " << bbox_corner[2].back() << endl;
//      cout << "corner3 = " << bbox_corner[3].back() << endl;
   } // loop over index i labeling filtered GPS/IMU information

   for (int n = startFrame; n <= endFrame; n += n_skip)
   {
      cout << n << " " << flush;
      vid_in.read_image(n,pbyImgIn);
      vid_in.convert_charstar_array_to_RGBA_twoDarrays(pbyImgIn);

      vector<threevector> vertex;
      vertex.clear();
      for (int c=0; c<4; c++)
      {

// Recall that we must renormalize the "U" values to range from 0 to 1
// rather than from 0 to 1.3 before multiplying them by the number of
// pixels in the horizontal direction!  (The "V" values already range
// from 0 to 1...)

         const double max_U=1392.0/1040.0;
         double px = ( (bbox_corner[c])[n].get(0)/max_U ) *
            vid_in.getWidth();
         double py = (bbox_corner[c])[n].get(1) * vid_in.getHeight();
         vertex.push_back(threevector(px,py));
      }
      polygon bbox(vertex);
//      cout << "bbox = " << bbox << endl;

//      drawfunc::draw_polygon(bbox,255,vid_in.get_RGBA_twoDarray().first);
//      drawfunc::draw_polygon(bbox,255,vid_in.get_RGBA_twoDarray().second);
//      drawfunc::draw_polygon(bbox,255,vid_in.get_RGBA_twoDarray().third);

      drawfunc::color_polygon_exterior(
         bbox,0,vid_in.get_RGBA_twoDarray().first);
      drawfunc::color_polygon_exterior(
         bbox,0,vid_in.get_RGBA_twoDarray().second);
      drawfunc::color_polygon_exterior(
         bbox,0,vid_in.get_RGBA_twoDarray().third);

      unsigned char* bbox_Img=vid_in.convert_RGBAarrays_to_charstar_array(
         vid_in.getWidth(),vid_in.getHeight());
      videofunc::RGB_to_grey(
         bbox_Img, pbyImgOut, vid_in.getWidth(),vid_in.getHeight());
      delete [] bbox_Img;

      vid_out.WriteFrame(pbyImgOut, vid_in.getWidth());
   } // loop over index n labeling output frames
   cout << endl;

   vid_in.delete_RGBA_twoDarrays();

   delete pbyImgIn;
   delete pbyImgOut;
}
