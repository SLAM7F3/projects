// ==========================================================================
// Program EOTIF2TDP takes in a registered geotiff EO satellite image
// and generates a corresponding point cloud in TDP output format.

// 				eotif2tdp
// or

//			eotif2tdp Baghdad_2006_R1C4_0_0.tif 

// We wrote this specialized utility program in August 2008 when we
// discovered that the .osga files generated by osgdem for the Baghdad
// data set failed on the classified touch2y disks.  We believe that
// the classified touchy2 disks are flawed and not the programs nor
// the osgdem files (which both seem to work fine on other computers).
// So we had to resort to generating point cloud .osga files which
// hopefully will work on touchy2 in time for the Sept RCO sponsor review.

// We also empirically determined that this program can handle
// 4000x4000 subtiles.  Tiles larger than this size lead to
// out-of-memory errors.

// ==========================================================================
// Last updated on 3/29/07; 2/10/08; 8/31/08
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "gdal_priv.h"
#include "image/raster_parser.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "image/TwoDarray.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::string;
using std::vector;

// ==========================================================================
int main (int argc, char * argv[])
{
   std::set_new_handler(sysfunc::out_of_memory);
//   cout << "argc = " << argc << endl;
//   cout << "argv[0] = " << argv[0] << endl;
//   cout << "argv[1] = " << argv[1] << endl;

   raster_parser RasterParser;

   string image_filename;
   if (argc==2)
   {
      image_filename=argv[1];
   }
   else
   {
      cout << "Enter input EO geotiff file name:" << endl;
      cin >> image_filename;
   }
   cout << "image_filename = " << image_filename << endl;

//   string image_filename="bb_r1c3.tif";
//   string image_filename="copley.jpg";
//   image_filename="baghdad37.tif";
//   string image_filename="cats.jp2";
//   string image_filename="clewiston.jp2";

   string filename_prefix=stringfunc::prefix(image_filename);
   RasterParser.open_image_file(image_filename);

   twoDarray *RtwoDarray_ptr,*GtwoDarray_ptr,*BtwoDarray_ptr;
   for (int channel_ID=0; channel_ID<3; channel_ID++)
   {
      RasterParser.fetch_raster_band(channel_ID);

      if (channel_ID==0)
      {
         RtwoDarray_ptr=RasterParser.get_RtwoDarray_ptr();
         RasterParser.read_raster_data(RtwoDarray_ptr);
      }
      else if (channel_ID==1)
      {
         GtwoDarray_ptr=RasterParser.get_GtwoDarray_ptr();
         RasterParser.read_raster_data(GtwoDarray_ptr);
      }
      else if (channel_ID==2)
      {
         BtwoDarray_ptr=RasterParser.get_BtwoDarray_ptr();
         RasterParser.read_raster_data(BtwoDarray_ptr);
      }
   } // loop over channel_ID labeling RGB channels

// Write out TDP file:

   int mdim=RtwoDarray_ptr->get_mdim();
   int ndim=RtwoDarray_ptr->get_ndim();

   double x,y,z=0;
   vector<threevector>* vertices_ptr=new vector<threevector>;
   vertices_ptr->reserve(mdim*ndim);

   osg::Vec4ub RGBA;
   osg::Vec4ubArray* colors_ptr=new osg::Vec4ubArray;
   colors_ptr->reserve(mdim*ndim);

   for (int px=0; px<mdim; px++)
   {
      if (px%100==0) cout << px << " " << flush;
      for (int py=0; py<ndim; py++)
      {
         RtwoDarray_ptr->pixel_to_point(px,py,x,y);
         vertices_ptr->push_back(threevector(x,y,z));

         int r=RtwoDarray_ptr->get(px,py);
         int g=GtwoDarray_ptr->get(px,py);
         int b=BtwoDarray_ptr->get(px,py);
//         cout << "r = " << r << " g = " << g << " b = " << b << endl;
         unsigned char rchar=stringfunc::ascii_integer_to_unsigned_char(r);
         unsigned char gchar=stringfunc::ascii_integer_to_unsigned_char(g);
         unsigned char bchar=stringfunc::ascii_integer_to_unsigned_char(b);
         unsigned char achar=stringfunc::ascii_integer_to_unsigned_char(255);

         RGBA[0]=rchar;
         RGBA[1]=gchar;
         RGBA[2]=bchar;
         RGBA[3]=achar;
         colors_ptr->push_back(RGBA);
      } // loop over py index
   } // loop over px index
   cout << endl;

   delete RtwoDarray_ptr;
   delete GtwoDarray_ptr;
   delete BtwoDarray_ptr;

   string tdp_filename=filename_prefix+".tdp";
   cout << "Output tdp_filename = " << tdp_filename << endl;
   string UTMzone="38T";

   threevector zeroth_xyz=vertices_ptr->at(0);
   tdpfunc::write_relative_xyzrgba_data(
      tdp_filename,UTMzone,zeroth_xyz,vertices_ptr,colors_ptr);
} 

