// ==========================================================================
// Program SPURIOUS performs a "moderate fidelity" simulation of noise
// track generation in persistent surveillance video imagery.  We
// wrote this simulator to study the effect of the Kalman filter
// coasting time parameter upon spurious track number and lifetime.
// We have made reasonable efforts to use Group 99 tracking parameters
// (as of November 2005) and to reproduce basic detection and tracking
// results derived from 60 good Clewiston images.  In particular, the
// average raw detection rate per image (for those not excessively
// noisy images) equals 1200.  Moreover, the minimal track lifetime is
// forced to equal 5 images.  The instantaneous curvature of each
// track point is also limited so that the per-image false alarm
// average equals 16.  

// Simulation results generated by this program demonstrate that the
// density of false alarm tracks grows as tau_coast increases.  This
// is not surprising.  However, the number of false alarm tracks
// actually hits a maximum and then begins to decrease with increasing
// tau_coast.  This results from more and more small tracks being
// merged into longer ones as the coasting time goes up.  We also find
// that the average lifetime of spurious tracks increases, as does the
// standard deviation of those lifetimes.

// ==========================================================================
// Last updated on 7/29/06; 2/25/08; 9/3/09
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "math/genvector.h"
#include "datastructures/Hashtable.h"
#include "image/imagefuncs.h"
#include "kdtree/kdtreefuncs.h"
#include "image/myimage.h"
#include "templates/mytemplates.h"
#include "math/threevector.h"
#include "numrec/nrfuncs.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "track/track.h"
#include "image/TwoDarray.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ios;
using std::ifstream;
using std::ofstream;
using std::ostream;
using std::setw;
using std::string;
using std::vector;

// ==========================================================================
// Global constants and variables:

const double image_duration=0.5;	// sec
const double max_vehicle_speed=60 * 0.4469; // miles_per_hour -> meters/sec

vector<KDTree::KDTree<2,threevector>* > kdtree_ptrs;

// ==========================================================================
// Stand-alone methods
// ==========================================================================

// Method generate_KDtrees randomly positions false alarms for each
// image within a square "game board" of size (board_size)**2.  It
// then forms a KDtree to hold the alarm posns for each image.  Unique
// integer IDs associated with each false alarm are stored in the 3rd
// entry of each threevector in alarm_posn.  Finally, this method appends
// an individual image's KDtree to global STL vector *kdtree_ptrs for
// later inter-image comparison purposes:

void generate_KDtrees(int n_images)
{
   const double board_size=3000;	// meters

   int alarm_ID=0;
   for (int imagenumber=0; imagenumber < n_images; imagenumber++)
   {
      int n_alarms=1200;
      vector<threevector> alarm_posn;
      for (int n=0; n<n_alarms; n++)
      {
         double curr_x=board_size*nrfunc::ran1();
         double curr_y=board_size*nrfunc::ran1();
         alarm_posn.push_back(threevector(curr_x,curr_y,alarm_ID++));
      } // loop over index n labeling false alarms
      KDTree::KDTree<2, threevector>* curr_kdtree_ptr=
         kdtreefunc::generate_2D_kdtree(alarm_posn);
      kdtree_ptrs.push_back(curr_kdtree_ptr);
//         cout << "curr_kdtree = " << *(kdtree_ptrs.back()) << endl;
   } // loop over imagenumber index
}

// --------------------------------------------------------------------------
// Method find_current_alarms takes in some imagenumber.  It returns
// the 2D locations of all false alarms corresponding to the input
// time in output STL vector alarm_posn. 

void find_current_alarms(int curr_imagenumber,vector<threevector>& alarm_posn)
{
   KDTree::KDTree<2, threevector>* curr_kdtree_ptr=
      kdtree_ptrs[curr_imagenumber];

   vector<KDTree::__Node<threevector>*, 
      std::allocator<KDTree::__Node<threevector>*> > 
      KDTree_nodes=curr_kdtree_ptr->fill_nodes_vector();

   alarm_posn.clear();
   for (unsigned int l=0; l<KDTree_nodes.size(); l++)
   {
      KDTree::__Node<threevector>* curr_leafnode_ptr=KDTree_nodes[l];
      threevector curr_alarm_posn(*(curr_leafnode_ptr->get_value_ptr()));
      alarm_posn.push_back(curr_alarm_posn);
   }
}

// --------------------------------------------------------------------------
double imagenumber_to_time(int imagenumber)
{
   return imagenumber*image_duration;
}

double time_to_imagenumber(double t)
{
   return basic_math::round(t/image_duration);
}

// --------------------------------------------------------------------------
// Method initialize_tracks instantiates tracks and enters them into
// hashtable *track_table_ptr based upon detections in the input
// image:

void initialize_tracks(int imagenumber,int& track_ID,
                       Hashtable<track*>* track_table_ptr,
                       const vector<int>& matched_alarm_ID)
{
   double curr_t=imagenumber_to_time(imagenumber);

   vector<threevector> alarm_posn;
   find_current_alarms(imagenumber,alarm_posn);
   for (int i=0; i<alarm_posn.size(); i++)
   {

// First make sure current alarm ID does not match any of those
// matched_alarm_ID which have previously been linked to existing
// tracks:

      bool create_new_track_flag=true;
      int curr_alarm_ID=basic_math::round(alarm_posn[i].get(2));
      for (int m=0; m<matched_alarm_ID.size(); m++)
      {
         if (curr_alarm_ID==matched_alarm_ID[m])
         {
            create_new_track_flag=false;
            break;
         }
      }

      if (create_new_track_flag)
      {
         track* T_ptr=new track(track_ID);
         T_ptr->set_XYZ_coords(curr_t,alarm_posn[i]);
         track_table_ptr->insert_key(track_ID,T_ptr);
         track_ID++;
      }
      
   } // loop over index i labeling alarm posns in very first image
}

// --------------------------------------------------------------------------
// Method find_future_nearby_neighbors takes in some alarm's current
// location as well as the number of some subsequent image in which it
// looks for partner alarm detections.  It searches over the future
// image's KDtree for all alarms located within some maximum radius.

void find_future_nearby_neighbors(
   int curr_imagenumber,const threevector& curr_posn,
   int future_imagenumber,vector<threevector>& future_nearby_posn)
{

   double delta_t=imagenumber_to_time(future_imagenumber-curr_imagenumber);
   double max_vehicle_travel_dist=max_vehicle_speed*delta_t;

   KDTree::KDTree<2,threevector>* next_kdtree_ptr=
      kdtree_ptrs[future_imagenumber];

   vector<threevector> candidate_future_nearby_posn;
   kdtreefunc::sorted_nodes_within_range(
      next_kdtree_ptr,curr_posn,max_vehicle_travel_dist,
      candidate_future_nearby_posn);

   for (int n=0; n<candidate_future_nearby_posn.size(); n++)
   {
      double sqrd_2D_separation=
         sqr(candidate_future_nearby_posn[n].get(0)-curr_posn.get(0))+
         sqr(candidate_future_nearby_posn[n].get(1)-curr_posn.get(1));
      if (sqrd_2D_separation < sqr(max_vehicle_travel_dist))
      {
         future_nearby_posn.push_back(candidate_future_nearby_posn[n]);
      } // separation < max_vehicle_travel_dist
   }
}

// --------------------------------------------------------------------------
// Method prune_tracks_with_temporal_gaps deletes from hashtable
// *track_table_ptr all tracks with temporal gaps exceeding the Kalman
// filter coasting time:

void prune_tracks_with_temporal_gaps(
   int track_ID,double tau_coast,Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->max_temporal_gap() > tau_coast)
         {
            delete curr_track_ptr;
            track_table_ptr->delete_key(i);
         }
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method prune_short_tracks searches for tracks in hashtable
// *track_table_ptr which were created at times more than
// min_track_lifetime ago in the past.  It deletes those whose
// lifetimes are less than min_track_lifetime.

void prune_short_tracks(
   double curr_t,int track_ID,double min_track_lifetime,
   Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         double elapsed_time_since_track_start=curr_t-
            curr_track_ptr->get_earliest_time();
         if (elapsed_time_since_track_start > min_track_lifetime && 
             curr_track_ptr->temporal_duration() < min_track_lifetime)
         {
            delete curr_track_ptr;
            track_table_ptr->delete_key(i);
         }
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method test_for_closed_tracks searches for tracks in hashtable
// *track_table_ptr whose latest entries differ from the current time
// by more than the input delta_t.  Such tracks should be closed, and
// no further detections should be added to them even if they lie near
// their last position.  Instead, new tracks should be instantiated.

void test_for_closed_tracks(
   double curr_t,int track_ID,double delta_t,
   Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         curr_track_ptr->close_track_test(curr_t,delta_t);
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method prune_short_tracks searches for closed tracks in hashtable
// *track_table_ptr.  It deletes those whose lifetimes are less than
// min_track_lifetime.

void prune_short_closed_tracks(
   int track_ID,double min_track_lifetime,
   Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            if (curr_track_ptr->temporal_duration() < min_track_lifetime)
            {
               delete curr_track_ptr;
               track_table_ptr->delete_key(i);
            }
         }
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method write_out_closed_tracks returns the number of closed tracks
// contained within hashtable *track_table_ptr.

int write_out_closed_tracks(
   int track_ID,Hashtable<track*>* track_table_ptr,int n_images)
{
   int n_closed_tracks=0;
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
//            cout << *curr_track_ptr << endl;
            n_closed_tracks++;
         }
      }
   } // loop over index i labeling tracks
   cout << "Total number of tracks = "
        << track_table_ptr->size() << endl;
   cout << "Number of closed tracks = " << n_closed_tracks << endl;
   cout << "Total tracks/n_images = " 
        << double(track_table_ptr->size())/double(n_images)
        << endl;
   cout << "Closed tracks/n_images ratio  = " 
        << double (n_closed_tracks)/double(n_images) << endl;
   return n_closed_tracks;
}

// --------------------------------------------------------------------------
// Method save_individual_tracks_to_file

void save_individual_tracks_to_file(
   double tau_coast,int track_ID,Hashtable<track*>* track_table_ptr,
   int n_images,ofstream& outstream)
{
   int n_closed_tracks=0;
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            const double xlo=0;
            const double xhi=600;
            const double ylo=0;
            const double yhi=600;
            threevector latest_posn=curr_track_ptr->get_latest_posn();
            if (latest_posn.get(0) < xhi && latest_posn.get(1) < yhi)
            {
               cout << *curr_track_ptr << endl;
            }
            
            n_closed_tracks++;
         }
      }
   } // loop over index i labeling tracks

   double closed_tracks_per_image=double(n_closed_tracks)/
      double(n_images);
   double total_tracks_per_image=
      double(track_table_ptr->size())/double(n_images);

//   outstream << tau_coast << "   "  << closed_tracks_per_image;
//   outstream << tau_coast << "   " << total_tracks_per_image << endl;
}

// --------------------------------------------------------------------------
// Method compute_avg_track_properties averages over all closed tracks
// and computes integrated track length, lifetime and speed.

void compute_avg_track_properties(
   int track_ID,Hashtable<track*>* track_table_ptr)
{
   int n_tracks=0;
   double avg_track_length=0;
   double avg_track_lifetime=0;
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
//            cout << "Closed track ID = " << curr_track_ptr->get_ID()
//                 << " length = " << curr_track_ptr->total_length() 
//                 << " speed (mph) = " << curr_track_ptr->avg_speed()
//                 << endl;
            avg_track_length += curr_track_ptr->total_length();
            avg_track_lifetime += curr_track_ptr->temporal_duration();
            n_tracks++;
         }
      }
   } // loop over index i labeling tracks
   avg_track_length /= double(n_tracks);
   avg_track_lifetime /= double(n_tracks);
   cout << "Avg track length = " << avg_track_length << endl;
   cout << "Avg track lifetime = " << avg_track_lifetime << endl;
   cout << "Avg track speed = " << avg_track_length/avg_track_lifetime 
        << endl;
}

// --------------------------------------------------------------------------
// Method save_avg_track_properties generates metafile output using
// tau_coast as the independent variable and mean +/- std_dev of track
// lifetime as the dependent variable.

void save_avg_track_properties(
   int track_ID,double tau_coast,int n_images,
   Hashtable<track*>* track_table_ptr,ofstream& outstream)
{
   vector<double> track_length;
   vector<double> track_lifetime;
   double total_time=imagenumber_to_time(n_images);
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            if (curr_track_ptr->get_earliest_time() > 0.25*total_time &&
                curr_track_ptr->get_latest_time() < 0.75*total_time)
            {
               track_length.push_back(curr_track_ptr->total_length());
               track_lifetime.push_back(curr_track_ptr->temporal_duration());
            }
         }
      }
   } // loop over index i labeling tracks
   double mu_track_length=mathfunc::mean(track_length);
   double sigma_track_length=mathfunc::std_dev(track_length);
   double mu_track_lifetime=mathfunc::mean(track_lifetime);
   double sigma_track_lifetime=mathfunc::std_dev(track_lifetime);
   cout << "track length = " << mu_track_length 
        << " +/- " << sigma_track_length << endl;
   cout << "track lifetime = " << mu_track_lifetime 
        << " +/- " << sigma_track_lifetime << endl;
   
   outstream << tau_coast << "   "  << mu_track_lifetime << endl;
   outstream << tau_coast << "   "  << mu_track_lifetime+sigma_track_lifetime 
             << endl;
   outstream << tau_coast << "   "  << mu_track_lifetime-sigma_track_lifetime 
             << endl;
   outstream << endl;
}

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Open file to hold results:

   string output_filename="results.txt";
   ofstream outstream;
   filefunc::openfile(output_filename,outstream);

// Initialize constant simulation parameters:

   const int n_iter=1;
//   const int n_iter=3;
//   const int n_iter=15;

   const double board_size=3000;	// meters

//   const int n_images=20;
//   const int n_images=40;
//   int n_images=60;
   int n_images=100;
//   int n_images=300;
//   int n_images=400;

//   cout << "Enter number of images:" << endl;
//   cin >> n_images;

//   double tau_coast=1*image_duration;
//   double tau_coast=3*image_duration;
//   cout << "Enter tau_coast measured in numbers of images:" << endl;
//   cin >> tau_coast;
//   tau_coast *= image_duration;

// On 12/30/05, Dan Greisokh told us that the Clewiston data was
// processed in November with the requirement that tracks last for at
// least 5 images:

//   double min_track_lifetime=5*image_duration;
   double min_track_lifetime=25*image_duration;
//   cout << "Enter min track lifetime measured in images:" << endl;
//   cin >> min_track_lifetime;
//   min_track_lifetime *= image_duration;

// Maximum allowed track heading angle change = max_omega*delta_time:

   double max_omega=5*PI/180.0;	// rads/sec
//   cout << "Enter omega in degs/sec:" << endl;
//   cin >> max_omega;
//   max_omega *= PI/180.0;

// ==========================================================================
// Main loop over simulations starts here:

   for (int iter=0; iter<n_iter; iter++)
   {
      string banner="Starting simulation "+stringfunc::number_to_string(iter)
         +":";
      outputfunc::write_banner(banner);

      generate_KDtrees(n_images);
      Hashtable<track*>* track_table_ptr=new Hashtable<track*>(100000);

      int track_ID=0;

      double tau_coast=iter*image_duration;
//      tau_coast=3*image_duration;
//      tau_coast=12*image_duration;
      tau_coast=15*image_duration;
//      cout << "tau_coast = " << iter << " images " << endl;
//      cout << "Enter tau_coast in images:" << endl;
//      cin >> tau_coast;
//      tau_coast *= image_duration;

// --------------------------------------------------------------------------
// Loop over image numbers starts here:

      for (int imagenumber=0; imagenumber < n_images; imagenumber++)
      {
         double curr_t=imagenumber_to_time(imagenumber);

// Employ "greedy algorithm" to match up as many existing tracks in
// hashtable with new detections in current image:

         vector<int> matched_alarm_ID;
         for (int i=0; i<track_ID; i++)
         {
            Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
            if (currnode_ptr != NULL)
            {
               track* track_ptr=currnode_ptr->get_data();
               if (!track_ptr->get_track_closed())
               {
                  double latest_track_time=track_ptr->get_latest_time();
                  threevector latest_track_posn=track_ptr->get_latest_posn();

                  vector<threevector> nearby_curr_alarm;
                  nearby_curr_alarm.clear();
                  
                  find_future_nearby_neighbors(
                     time_to_imagenumber(latest_track_time),latest_track_posn,
                     imagenumber,nearby_curr_alarm);
                  if (nearby_curr_alarm.size() > 0)
                  {
                     double delta_time=curr_t-latest_track_time;
                     double max_theta=max_omega*delta_time;
                     double min_dotproduct=cos(max_theta);

// Loop over possible current nearby detections which could extend
// track #i.  If some nearby detection has not already been attached
// to some other track, attach it to track #i and then add that
// detection to the exclusion list contained in STL vector
// matched_alarm_ID:

                     for (int n=0; n<nearby_curr_alarm.size(); n++)
                     {
                        int nearby_curr_alarm_ID=basic_math::round(
                           nearby_curr_alarm[n].get(2));

                        bool nearby_alarm_previously_matched=false;
                        for (int m=0; m<matched_alarm_ID.size(); m++)
                        {
                           if (nearby_curr_alarm_ID==matched_alarm_ID[m])
                           {
                              nearby_alarm_previously_matched=true;
                           }
                        } // loop over index m labeling previously
			  //  matched alarms

                        if (!nearby_alarm_previously_matched)
                        {

// Compute dotproduct between track's latest heading and its potential
// new heading.  Reject candidate nearby alarm if heading swerves by
// too much over too short a time interval:

                           bool acceptable_heading_flag=true;
                           threevector u_hat;
                           if (track_ptr->get_latest_heading(u_hat))
                           {
                              twovector v(
                                 (nearby_curr_alarm[n]-latest_track_posn));
                              twovector v_hat(v.unitvector());
                           
                              double dotproduct=u_hat.dot(v_hat);
                              if (dotproduct < min_dotproduct)
                              {
                                 acceptable_heading_flag=false;
                              }
                           }

// Check the instantaneous speed and do not include
// nearby_curr_alarm[n] into the current track unless it passes this
// final sanity check:

                           bool acceptable_speed_flag=true;
                           if (acceptable_heading_flag)
                           {
                              twovector delta_posn=nearby_curr_alarm[n]-
                                 latest_track_posn;
                              double curr_sqr_speed=
                                 delta_posn.sqrd_magnitude()/delta_time;
                              if (curr_sqr_speed > sqr(max_vehicle_speed))
                              {
                                 acceptable_speed_flag=false;
                              }
                           }
                         
                           if (acceptable_heading_flag &&
                               acceptable_speed_flag)
                           {
                              track_ptr->set_XYZ_coords(
                                 curr_t,nearby_curr_alarm[n]);    
                              matched_alarm_ID.push_back(
                                 nearby_curr_alarm_ID);
                              
                              break;
                           } // accetable heading conditional
                           
                        } // nearby alarm not previously matched conditional
                     } // loop over index n labeling nearby current alarms
                  } // nearby_curr_alarm.size() > 0 conditional
               } // track not closed conditional
               
            } // currnode_ptr != NULL conditional
         } // loop over index i labeling track_IDs

//         cout << endl;

// Close tracks whose latest temporal entry occured more than
// tau_coast ago.  No further detections should be added to such
// tracks.  Instead, new detections in the vicinity of the latest
// entry in closed tracks should be used to start new tracks.

         test_for_closed_tracks(
            curr_t,track_ID,tau_coast,track_table_ptr);

// Once a track is closed, check its total lifetime.  Prune any closed
// track whose lifetime is less than min_track_lifetime.

         prune_short_closed_tracks(track_ID,min_track_lifetime,
                                     track_table_ptr);

         initialize_tracks(imagenumber,track_ID,track_table_ptr,
                           matched_alarm_ID);

// Write out surviving tracks:

         cout << imagenumber << " " << flush;

         if (imagenumber==n_images-1)
         {
            cout << endl;
            int n_closed_tracks=write_out_closed_tracks(
               track_ID,track_table_ptr,n_images);
            save_individual_tracks_to_file(
               tau_coast,track_ID,track_table_ptr,n_images,outstream);
         }
         
      } // loop over imagenumber index

// Write out average integrated lengths, lifetimes and speeds for
// surviving tracks:

      compute_avg_track_properties(track_ID,track_table_ptr);
//      save_avg_track_properties(
//         track_ID,tau_coast,n_images,track_table_ptr,outstream);


// Traverse kdtree_ptrs STL vector and delete each dynamically
// allocated KDtree before proceeding to next simulation:

      for (int k=0; k<kdtree_ptrs.size(); k++)
      {
         delete kdtree_ptrs[k];
      }
      kdtree_ptrs.clear();

// Loop over all nodes in *track_table_ptr and explicitly delete each
// of their dynamically generated tracks.  Then delete the hashtable
// itself:

      for (int i=0; i<track_ID; i++)
      {
         Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
         if (currnode_ptr != NULL)
         {
            delete currnode_ptr->get_data();
         }
      } // loop over index i 
      delete track_table_ptr;

   } // loop over iter index labeling simulation
   
   outstream << endl;
   
   filefunc::closefile(output_filename,outstream);
   
}
