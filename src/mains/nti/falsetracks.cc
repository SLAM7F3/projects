// ==========================================================================
// Program FALSE_TRACKS performs a "moderate fidelity" simulation of
// noise track generation in persistent surveillance video imagery.
// We wrote this simulator to study the effect of the Kalman filter
// coasting time parameter upon spurious track number and lifetime.
// We have made reasonable efforts to use Group 99 tracking parameters
// (as of November 2005) and to reproduce basic detection and tracking
// results derived from 60 good Clewiston images.  In particular, the
// average raw detection rate per image (for those not excessively
// noisy images) equals 1200.  Moreover, the minimal track lifetime is
// forced to equal 5 images.  The instantaneous curvature of each
// track point is also limited so that the per-image false alarm
// average equals 16.

// Simulation results generated by this program demonstrate that the
// density of false alarm tracks initially grows as tau_coast
// increases.  This is not surprising.  However, the number of false
// alarm tracks actually hits a maximum and then begins to decrease
// with increasing tau_coast.  This simply results from more and more
// small tracks being merged into longer ones as the coasting time
// goes up.  We also find that the average lifetime of spurious tracks
// increases, as does the standard deviation of those lifetimes.

// On 1/1/06, we ran 10 simulations of spurious tracks generated with
// tau_coast=15 images (7.5 secs) and min_track_lifetime = 25 images.
// We found that 95% of such tracks would be rejected as bogus
// vehicles via collisions with buildings in a suburban Lowell type
// setting.

// ==========================================================================
// Last updated on 1/1/06
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "threeDgraphics/draw3Dfuncs.h"
#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "math/genvector.h"
#include "datastructures/Hashtable.h"
#include "image/imagefuncs.h"
#include "kdtree/kdtreefuncs.h"
#include "ladar/ladarfuncs.h"
#include "image/myimage.h"
#include "templates/mytemplates.h"
#include "math/threevector.h"
#include "numrec/nrfuncs.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "track/track.h"
#include "image/TwoDarray.h"
#include "urban/urbanfuncs.h"
#include "urban/urbanimage.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ios;
using std::ifstream;
using std::ofstream;
using std::ostream;
using std::setw;
using std::string;
using std::vector;

// ==========================================================================
// Global constants and variables:

const double image_duration=0.5;	// sec
const double max_vehicle_speed=60 * 0.4469; // miles_per_hour -> meters/sec

vector<KDTree::KDTree<2,threevector>* > kdtree_ptrs;

// ==========================================================================
// Stand-alone methods
// ==========================================================================

// Method generate_KDtrees randomly positions false alarms for each
// image within a square "game board" of size (board_size)**2.  It
// then forms a KDtree to hold the alarm posns for each image.  Unique
// integer IDs associated with each false alarm are stored in the 3rd
// entry of each threevector in alarm_posn.  Finally, this method appends
// an individual image's KDtree to global STL vector *kdtree_ptrs for
// later inter-image comparison purposes:

void generate_KDtrees(int n_images)
{
   const double board_size=3000;	// meters

   int alarm_ID=0;
   for (int imagenumber=0; imagenumber < n_images; imagenumber++)
   {
      int n_alarms=1200;
      vector<threevector> alarm_posn;
      for (int n=0; n<n_alarms; n++)
      {
         double curr_x=board_size*nrfunc::ran1();
         double curr_y=board_size*nrfunc::ran1();
         alarm_posn.push_back(threevector(curr_x,curr_y,alarm_ID++));
      } // loop over index n labeling false alarms
      KDTree::KDTree<2, threevector>* curr_kdtree_ptr=
         kdtreefunc::generate_twovector_kdtree(alarm_posn);
      kdtree_ptrs.push_back(curr_kdtree_ptr);
//         cout << "curr_kdtree = " << *(kdtree_ptrs.back()) << endl;
   } // loop over imagenumber index
}

// --------------------------------------------------------------------------
// Method find_current_alarms takes in some imagenumber.  It returns
// the 2D locations of all false alarms corresponding to the input
// time in output STL vector alarm_posn. 

void find_current_alarms(int curr_imagenumber,vector<threevector>& alarm_posn)
{
   KDTree::KDTree<2, threevector>* curr_kdtree_ptr=
      kdtree_ptrs[curr_imagenumber];

   vector<KDTree::_Node<threevector>*, 
      std::allocator<KDTree::_Node<threevector>*> > 
      KDTree_nodes=curr_kdtree_ptr->fill_nodes_vector();

   alarm_posn.clear();
   for (unsigned int l=0; l<KDTree_nodes.size(); l++)
   {
      KDTree::_Node<threevector>* curr_leafnode_ptr=KDTree_nodes[l];
      threevector curr_alarm_posn(*(curr_leafnode_ptr->get_value_ptr()));
      alarm_posn.push_back(curr_alarm_posn);
   }
}

// --------------------------------------------------------------------------
double imagenumber_to_time(int imagenumber)
{
   return imagenumber*image_duration;
}

double time_to_imagenumber(double t)
{
   return basic_math::round(t/image_duration);
}

// --------------------------------------------------------------------------
// Method initialize_tracks instantiates tracks and enters them into
// hashtable *track_table_ptr based upon detections in the input
// image:

void initialize_tracks(int imagenumber,int& track_ID,
                       Hashtable<track*>* track_table_ptr,
                       const vector<int>& matched_alarm_ID)
{
   double curr_t=imagenumber_to_time(imagenumber);

   vector<threevector> alarm_posn;
   find_current_alarms(imagenumber,alarm_posn);
   for (int i=0; i<alarm_posn.size(); i++)
   {

// First make sure current alarm ID does not match any of those
// matched_alarm_ID which have previously been linked to existing
// tracks:

      bool create_new_track_flag=true;
      int curr_alarm_ID=basic_math::round(alarm_posn[i].e[2]);
      for (int m=0; m<matched_alarm_ID.size(); m++)
      {
         if (curr_alarm_ID==matched_alarm_ID[m])
         {
            create_new_track_flag=false;
            break;
         }
      }

      if (create_new_track_flag)
      {
         track* T_ptr=new track(track_ID);
         T_ptr->set_XYZ_coords(curr_t,alarm_posn[i]);
         track_table_ptr->insert_key(track_ID,T_ptr);
         track_ID++;
      }
      
   } // loop over index i labeling alarm posns in very first image
}

// --------------------------------------------------------------------------
// Method find_future_nearby_neighbors takes in some alarm's current
// location as well as the number of some subsequent image in which it
// looks for partner alarm detections.  It searches over the future
// image's KDtree for all alarms located within some maximum radius.

void find_future_nearby_neighbors(
   int curr_imagenumber,const threevector& curr_posn,
   int future_imagenumber,vector<threevector>& future_nearby_posn)
{

   double delta_t=imagenumber_to_time(future_imagenumber-curr_imagenumber);
   double max_vehicle_travel_dist=max_vehicle_speed*delta_t;

   KDTree::KDTree<2,threevector>* next_kdtree_ptr=
      kdtree_ptrs[future_imagenumber];

   vector<threevector> candidate_future_nearby_posn;
   kdtreefunc::sorted_nodes_within_range(
      next_kdtree_ptr,curr_posn,max_vehicle_travel_dist,
      candidate_future_nearby_posn);

   for (int n=0; n<candidate_future_nearby_posn.size(); n++)
   {
      double sqrd_2D_separation=
         sqr(candidate_future_nearby_posn[n].e[0]-curr_posn.e[0])+
         sqr(candidate_future_nearby_posn[n].e[1]-curr_posn.e[1]);
      if (sqrd_2D_separation < sqr(max_vehicle_travel_dist))
      {
         future_nearby_posn.push_back(candidate_future_nearby_posn[n]);
      } // separation < max_vehicle_travel_dist
   }
}

// --------------------------------------------------------------------------
// Method prune_tracks_with_temporal_gaps deletes from hashtable
// *track_table_ptr all tracks with temporal gaps exceeding the Kalman
// filter coasting time:

void prune_tracks_with_temporal_gaps(
   int track_ID,double tau_coast,Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->max_temporal_gap() > tau_coast)
         {
            delete curr_track_ptr;
            track_table_ptr->delete_key(i);
         }
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method prune_short_tracks searches for tracks in hashtable
// *track_table_ptr which were created at times more than
// min_track_lifetime ago in the past.  It deletes those whose
// lifetimes are less than min_track_lifetime.

void prune_short_tracks(
   double curr_t,int track_ID,double min_track_lifetime,
   Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         double elapsed_time_since_track_start=curr_t-
            curr_track_ptr->get_earliest_time();
         if (elapsed_time_since_track_start > min_track_lifetime && 
             curr_track_ptr->temporal_duration() < min_track_lifetime)
         {
            delete curr_track_ptr;
            track_table_ptr->delete_key(i);
         }
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method test_for_closed_tracks searches for tracks in hashtable
// *track_table_ptr whose latest entries differ from the current time
// by more than the input delta_t.  Such tracks should be closed, and
// no further detections should be added to them even if they lie near
// their last position.  Instead, new tracks should be instantiated.

void test_for_closed_tracks(
   double curr_t,int track_ID,double delta_t,
   Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         curr_track_ptr->close_track_test(curr_t,delta_t);
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method prune_short_tracks searches for closed tracks in hashtable
// *track_table_ptr.  It deletes those whose lifetimes are less than
// min_track_lifetime.

void prune_short_closed_tracks(
   int track_ID,double min_track_lifetime,
   Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            if (curr_track_ptr->temporal_duration() < min_track_lifetime)
            {
               delete curr_track_ptr;
               track_table_ptr->delete_key(i);
            }
         }
      }
   } // loop over index i labeling tracks
}

// --------------------------------------------------------------------------
// Method write_out_closed_tracks returns the number of closed tracks
// contained within hashtable *track_table_ptr.

int write_out_closed_tracks(
   int track_ID,Hashtable<track*>* track_table_ptr,int n_images)
{
   int n_closed_tracks=0;
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
//            cout << *curr_track_ptr << endl;
            n_closed_tracks++;
         }
      }
   } // loop over index i labeling tracks
   cout << "Total number of tracks = "
        << track_table_ptr->size() << endl;
   cout << "Number of closed tracks = " << n_closed_tracks << endl;
   cout << "Total tracks/n_images = " 
        << double(track_table_ptr->size())/double(n_images)
        << endl;
   cout << "Closed tracks/n_images ratio  = " 
        << double (n_closed_tracks)/double(n_images) << endl;
   return n_closed_tracks;
}

// --------------------------------------------------------------------------
// Method save_individual_tracks_to_file

void save_individual_tracks_to_file(
   double tau_coast,int track_ID,Hashtable<track*>* track_table_ptr,
   int n_images,ofstream& outstream)
{
   int n_closed_tracks=0;
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            const double xlo=0;
            const double xhi=600;
            const double ylo=0;
            const double yhi=600;
            threevector latest_posn;
            curr_track_ptr->get_latest_coords(latest_posn);
            if (latest_posn.get(0) < xhi && latest_posn.get(1) < yhi)
            {
               cout << *curr_track_ptr << endl;
            }
            
            n_closed_tracks++;
         }
      }
   } // loop over index i labeling tracks

   double closed_tracks_per_image=double(n_closed_tracks)/
      double(n_images);
   double total_tracks_per_image=
      double(track_table_ptr->size())/double(n_images);

//   outstream << tau_coast << "   "  << closed_tracks_per_image;
//   outstream << tau_coast << "   " << total_tracks_per_image << endl;
}

// --------------------------------------------------------------------------
// Method compute_avg_track_properties averages over all closed tracks
// and computes integrated track length, lifetime and speed.

void compute_avg_track_properties(
   int track_ID,Hashtable<track*>* track_table_ptr)
{
   int n_tracks=0;
   double avg_track_length=0;
   double avg_track_lifetime=0;
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
//            cout << "Closed track ID = " << curr_track_ptr->get_ID()
//                 << " length = " << curr_track_ptr->total_length() 
//                 << " speed (mph) = " << curr_track_ptr->avg_speed()
//                 << endl;
            avg_track_length += curr_track_ptr->total_length();
            avg_track_lifetime += curr_track_ptr->temporal_duration();
            n_tracks++;
         }
      }
   } // loop over index i labeling tracks
   avg_track_length /= double(n_tracks);
   avg_track_lifetime /= double(n_tracks);
   cout << "Avg track length = " << avg_track_length << endl;
   cout << "Avg track lifetime = " << avg_track_lifetime << endl;
   cout << "Avg track speed = " << avg_track_length/avg_track_lifetime 
        << endl;
}

// --------------------------------------------------------------------------
// Method save_avg_track_properties generates metafile output using
// tau_coast as the independent variable and mean +/- std_dev of track
// lifetime as the dependent variable.

void save_avg_track_properties(
   int track_ID,double tau_coast,int n_images,
   Hashtable<track*>* track_table_ptr,ofstream& outstream)
{
   vector<double> track_length;
   vector<double> track_lifetime;
   double total_time=imagenumber_to_time(n_images);
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            if (curr_track_ptr->get_earliest_time() > 0.25*total_time &&
                curr_track_ptr->get_latest_time() < 0.75*total_time)
            {
               track_length.push_back(curr_track_ptr->total_length());
               track_lifetime.push_back(curr_track_ptr->temporal_duration());
            }
         }
      }
   } // loop over index i labeling tracks
   double mu_track_length=mathfunc::mean(track_length);
   double sigma_track_length=mathfunc::std_dev(track_length);
   double mu_track_lifetime=mathfunc::mean(track_lifetime);
   double sigma_track_lifetime=mathfunc::std_dev(track_lifetime);
   cout << "track length = " << mu_track_length 
        << " +/- " << sigma_track_length << endl;
   cout << "track lifetime = " << mu_track_lifetime 
        << " +/- " << sigma_track_lifetime << endl;
   
   outstream << tau_coast << "   "  << mu_track_lifetime << endl;
   outstream << tau_coast << "   "  << mu_track_lifetime+sigma_track_lifetime 
             << endl;
   outstream << tau_coast << "   "  << mu_track_lifetime-sigma_track_lifetime 
             << endl;
   outstream << endl;
}


// --------------------------------------------------------------------------
// Method compute_track_collisions_with_ladar_buildings

double compute_track_collisions_with_ladar_buildings(
   int track_ID,const parallelogram* data_bbox_ptr,
   twoDarray* ztwoDarray_ptr,Hashtable<track*>* track_table_ptr,
   string xyzp_filename)
{
   const double ds=min(
      ztwoDarray_ptr->get_deltax(),ztwoDarray_ptr->get_deltay());
   const colorfunc::Color house_color=colorfunc::cyan;
   const double house_color_value=colorfunc::color_to_value(house_color);
   vector<threevector> interp_posn;

   int n_paths_in_bbox=0;
   int n_obstructed_paths_in_bbox=0;
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            
// Require that either track's starting and stopping points lie inside
// data bounding box:

            if (data_bbox_ptr->point_inside(
               threevector(curr_track_ptr->get_earliest_posn())) &&
                data_bbox_ptr->point_inside(
                   threevector(curr_track_ptr->get_latest_posn())))
            {
               n_paths_in_bbox++;

               bool twoD_flag=true;
               curr_track_ptr->compute_segments(twoD_flag);
               curr_track_ptr->interpolated_posns(ds,interp_posn);

               bool obstructed_path_flag=false;
               for (int j=0; j<interp_posn.size(); j++)
               {
                  twovector XY(interp_posn[j]);
                  int px,py;
                  ztwoDarray_ptr->point_to_pixel(XY.get(0),XY.get(1),px,py);
                  double pixel_color=ztwoDarray_ptr->get(px,py);
               
                  if (nearly_equal(pixel_color,house_color_value))
                  {
                     obstructed_path_flag=true;
                     break;
                  }
               } // loop over index j labeling interpolated posn along 
		 //  *curr_track_ptr
               if (obstructed_path_flag) n_obstructed_paths_in_bbox++;

//               double annotation_value=0.4;
//               if (obstructed_path_flag) annotation_value=0.02;
//               draw3Dfunc::draw_track(curr_track_ptr,xyzp_filename,
//                                      annotation_value);
               
            } // earliest or latest posn inside data bbox
         } // closed track conditional
      } // currnode_ptr != NULL conditional
   } // loop over index i labeling possible tracks

   double obstruction_percentage=double(n_obstructed_paths_in_bbox)/
      double(n_paths_in_bbox)*100;
   cout << "Number paths in bbox = " << n_paths_in_bbox << endl;
   cout << "Number obstructed paths in bbox = " 
        << n_obstructed_paths_in_bbox << endl;
   cout << "Obstructed path percentage = " << obstruction_percentage
        << endl << endl;

   return obstruction_percentage;
}

// --------------------------------------------------------------------------
// Method draw_3D_tracks

void draw_3D_tracks(
   int track_ID,string networks_filename,
   const parallelogram* data_bbox_ptr,Hashtable<track*>* track_table_ptr)
{
   for (int i=0; i<track_ID; i++)
   {
      Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
      if (currnode_ptr != NULL)
      {
         track* curr_track_ptr=currnode_ptr->get_data();
         if (curr_track_ptr->get_track_closed())
         {
            
// Require that either track's starting and stopping points lie inside
// data bounding box:

            if (data_bbox_ptr->point_inside(
               threevector(curr_track_ptr->get_earliest_posn())) &&
                data_bbox_ptr->point_inside(
                   threevector(curr_track_ptr->get_latest_posn())))
            {
               bool twoD_flag=true;
               curr_track_ptr->compute_segments(twoD_flag);

               double annotation_value=0.4;
//               if (obstructed_path_flag) annotation_value=0.02;
               draw3Dfunc::draw_track(curr_track_ptr,networks_filename,
                                      annotation_value);

               
            } // earliest or latest posn inside data bbox
         } // closed track conditional
      } // currnode_ptr != NULL conditional
   } // loop over index i labeling possible tracks

}

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Read in ladar feature information:

   bool input_param_file;
   int ninputlines,currlinenumber;
   string inputline[200];

   filefunc::parameter_input(
      argc,argv,input_param_file,inputline,ninputlines);
   currlinenumber=0;

// Read in contents of partially processed binary xyzp file:

   cout << "Enter refined feature image:" << endl;
   urbanimage cityimage;

// Chimney footprint dimensions:

   const double delta_x=0.3;	// meters
   const double delta_y=0.3;	// meters
   cityimage.initialize_image(input_param_file,inputline,currlinenumber);
   cityimage.parse_and_store_input_data(delta_x,delta_y,true,false,false);
   cityimage.compute_data_bbox(cityimage.z2Darray_ptr,false);

// Eliminate junk nearby edges of data bounding box:

   parallelogram* data_bbox_ptr=cityimage.get_data_bbox_ptr();
   ladarfunc::crop_data_inside_bbox(0.01,cityimage.get_data_bbox_ptr(),
                                    cityimage.z2Darray_ptr);
   ladarfunc::crop_data_inside_bbox(0.01,cityimage.get_data_bbox_ptr(),
                                    cityimage.get_p2Darray_ptr());

   twoDarray* ztwoDarray_ptr=cityimage.z2Darray_ptr;
   twoDarray const *features_twoDarray_ptr=cityimage.get_p2Darray_ptr();
   twoDarray const *features_and_heights_twoDarray_ptr=
      urbanfunc::color_feature_heights(
         ztwoDarray_ptr,features_twoDarray_ptr);

//   string features_filename=cityimage.imagedir+"features.xyzp";   
//   xyzpfunc::write_xyzp_data(
//      ztwoDarray_ptr,features_twoDarray_ptr,features_filename);
//   draw3Dfunc::append_fake_xyzp_points_in_twoDarray_middle(
//      features_twoDarray_ptr,features_filename);

   double xhi=ztwoDarray_ptr->get_xhi();
   double xlo=ztwoDarray_ptr->get_xlo();
   double yhi=ztwoDarray_ptr->get_yhi();
   double ylo=ztwoDarray_ptr->get_ylo();

   cout << "xhi = " << xhi << " xlo = " << xlo << endl;
   cout << "yhi = " << yhi << " ylo = " << ylo << endl;

// ==========================================================================
// Buildings network restoration
// ==========================================================================

// Read in previously saved buildings network information from ascii
// text file:

   string bldgs_text_filename=cityimage.imagedir+"buildings_network.txt";
   cityimage.set_buildings_network_ptr(
      urbanfunc::readin_buildings_network_from_textfile(bldgs_text_filename));
//   cout << "total number of buildings = " 
//        << cityimage.get_buildings_network_ptr()->size()
//        << endl;

// ==========================================================================
// Draw buildings network results
// ==========================================================================

   double delta_z=3;	// meters
//   draw3Dfunc::draw_thick_lines=true;		// default
   draw3Dfunc::draw_thick_lines=false;	// for poster
   draw3Dfunc::ds=0.02;			// for poster
   draw3Dfunc::delta_phi=10*PI/180;		// for poster

   string networks_filename=cityimage.imagedir+"networks.xyzp";   
   filefunc::deletefile(networks_filename);

// Draw 3D buildings network:

   outputfunc::write_banner("Drawing 3D buildings network:");
   urbanfunc::draw_3D_buildings(
      cityimage.get_buildings_network_ptr(),
      networks_filename,0.64,false);
   draw3Dfunc::append_fake_xyzp_points_in_twoDarray_middle(
      ztwoDarray_ptr,networks_filename,false);

// Initialize all ztwoDarray entries with some dummy value.  Then
// create binary mask of house footprints in ztwoDarray.  We will
// subsequently perform a brute force search along each track's path
// for masked footprint pixel values.  If any are encountered during
// the track's lifetime, the track must have encountered an
// impenetrable building.  It is then marked as a collision track...

   ztwoDarray_ptr->initialize_values(5);
   ladarfunc::null_data_outside_bbox(data_bbox_ptr,ztwoDarray_ptr);
   urbanfunc::draw_3D_buildings(
      cityimage.get_buildings_network_ptr(),ztwoDarray_ptr);

// ==========================================================================

// Initialize constant simulation parameters:

//   const int n_iter=1;
//   const int n_iter=3;
   const int n_iter=10;

   const double board_size=3000;	// meters

//   const int n_images=20;
//   const int n_images=40;
//   int n_images=60;
   int n_images=100;
//   int n_images=300;
//   int n_images=400;

//   cout << "Enter number of images:" << endl;
//   cin >> n_images;

//   double tau_coast=1*image_duration;
//   double tau_coast=3*image_duration;
//   cout << "Enter tau_coast measured in numbers of images:" << endl;
//   cin >> tau_coast;
//   tau_coast *= image_duration;

// On 12/30/05, Dan Greisokh told us that the Clewiston data was
// processed in November with the requirement that tracks last for at
// least 5 images:

//   double min_track_lifetime=5*image_duration;
   double min_track_lifetime=25*image_duration;
//   cout << "Enter min track lifetime measured in images:" << endl;
//   cin >> min_track_lifetime;
//   min_track_lifetime *= image_duration;

// Maximum allowed track heading angle change = max_omega*delta_time:

   double max_omega=5*PI/180.0;	// rads/sec
//   cout << "Enter omega in degs/sec:" << endl;
//   cin >> max_omega;
//   max_omega *= PI/180.0;

// ==========================================================================
// Main loop over simulations starts here:

   vector<double> obstruction_percentage;
   for (int iter=0; iter<n_iter; iter++)
   {
      string banner="Starting simulation "+stringfunc::number_to_string(iter)
         +":";
      outputfunc::write_banner(banner);

      generate_KDtrees(n_images);
      Hashtable<track*>* track_table_ptr=new Hashtable<track*>(100000);

      int track_ID=0;

      double tau_coast=iter*image_duration;
//      tau_coast=3*image_duration;
//      tau_coast=12*image_duration;
      tau_coast=15*image_duration;
//      cout << "tau_coast = " << iter << " images " << endl;
//      cout << "Enter tau_coast in images:" << endl;
//      cin >> tau_coast;
//      tau_coast *= image_duration;

// --------------------------------------------------------------------------
// Loop over image numbers starts here:

      for (int imagenumber=0; imagenumber < n_images; imagenumber++)
      {
         double curr_t=imagenumber_to_time(imagenumber);

// Employ "greedy algorithm" to match up as many existing tracks in
// hashtable with new detections in current image:

         vector<int> matched_alarm_ID;
         for (int i=0; i<track_ID; i++)
         {
            Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
            if (currnode_ptr != NULL)
            {
               track* track_ptr=currnode_ptr->get_data();
               if (!track_ptr->get_track_closed())
               {
                  threevector latest_track_posn;
                  double latest_track_time=basic_math::round(
                     track_ptr->get_latest_coords(latest_track_posn));

                  vector<threevector> nearby_curr_alarm;
                  nearby_curr_alarm.clear();
                  
                  find_future_nearby_neighbors(
                     time_to_imagenumber(latest_track_time),latest_track_posn,
                     imagenumber,nearby_curr_alarm);
                  if (nearby_curr_alarm.size() > 0)
                  {
                     double delta_time=curr_t-latest_track_time;
                     double max_theta=max_omega*delta_time;
                     double min_dotproduct=cos(max_theta);

// Loop over possible current nearby detections which could extend
// track #i.  If some nearby detection has not already been attached
// to some other track, attach it to track #i and then add that
// detection to the exclusion list contained in STL vector
// matched_alarm_ID:

                     for (int n=0; n<nearby_curr_alarm.size(); n++)
                     {
                        int nearby_curr_alarm_ID=basic_math::round(
                           nearby_curr_alarm[n].e[2]);

                        bool nearby_alarm_previously_matched=false;
                        for (int m=0; m<matched_alarm_ID.size(); m++)
                        {
                           if (nearby_curr_alarm_ID==matched_alarm_ID[m])
                           {
                              nearby_alarm_previously_matched=true;
                           }
                        } // loop over index m labeling previously
			  //  matched alarms

                        if (!nearby_alarm_previously_matched)
                        {

// Compute dotproduct between track's latest heading and its potential
// new heading.  Reject candidate nearby alarm if heading swerves by
// too much over too short a time interval:

                           bool acceptable_heading_flag=true;
                           threevector u_hat;
                           if (track_ptr->get_latest_heading(u_hat))
                           {
                              twovector v(
                                 (nearby_curr_alarm[n]-latest_track_posn));
                              twovector v_hat(v.unitvector());
                           
                              double dotproduct=u_hat.dot(v_hat);
                              if (dotproduct < min_dotproduct)
                              {
                                 acceptable_heading_flag=false;
                              }
                           }

// Check the instantaneous speed and do not include
// nearby_curr_alarm[n] into the current track unless it passes this
// final sanity check:

                           bool acceptable_speed_flag=true;
                           if (acceptable_heading_flag)
                           {
                              twovector delta_posn=nearby_curr_alarm[n]-
                                 latest_track_posn;
                              double curr_sqr_speed=
                                 delta_posn.sqrd_magnitude()/delta_time;
                              if (curr_sqr_speed > sqr(max_vehicle_speed))
                              {
                                 acceptable_speed_flag=false;
                              }
                           }
                         
                           if (acceptable_heading_flag &&
                               acceptable_speed_flag)
                           {
                              track_ptr->set_XYZ_coords(
                                 curr_t,nearby_curr_alarm[n]);    
                              matched_alarm_ID.push_back(
                                 nearby_curr_alarm_ID);
                              
                              break;
                           } // accetable heading conditional
                           
                        } // nearby alarm not previously matched conditional
                     } // loop over index n labeling nearby current alarms
                  } // nearby_curr_alarm.size() > 0 conditional
               } // track not closed conditional
               
            } // currnode_ptr != NULL conditional
         } // loop over index i labeling track_IDs

//         cout << endl;

// Close tracks whose latest temporal entry occured more than
// tau_coast ago.  No further detections should be added to such
// tracks.  Instead, new detections in the vicinity of the latest
// entry in closed tracks should be used to start new tracks.

         test_for_closed_tracks(
            curr_t,track_ID,tau_coast,track_table_ptr);

// Once a track is closed, check its total lifetime.  Prune any closed
// track whose lifetime is less than min_track_lifetime.

         prune_short_closed_tracks(track_ID,min_track_lifetime,
                                     track_table_ptr);

         initialize_tracks(imagenumber,track_ID,track_table_ptr,
                           matched_alarm_ID);

// Write out surviving tracks:

         cout << imagenumber << " " << flush;

      } // loop over imagenumber index

//      draw_3D_tracks(
//         track_ID,networks_filename,data_bbox_ptr,track_table_ptr);

// Compute collisions between tracks in hashtable and houses in ladar
// image:

      obstruction_percentage.push_back(
         compute_track_collisions_with_ladar_buildings(
            track_ID,data_bbox_ptr,ztwoDarray_ptr,track_table_ptr,
            networks_filename));

// Write out average integrated lengths, lifetimes and speeds for
// surviving tracks:

//      compute_avg_track_properties(track_ID,track_table_ptr);

// Traverse kdtree_ptrs STL vector and delete each dynamically
// allocated KDtree before proceeding to next simulation:

      for (int k=0; k<kdtree_ptrs.size(); k++)
      {
         delete kdtree_ptrs[k];
      }
      kdtree_ptrs.clear();

// Loop over all nodes in *track_table_ptr and explicitly delete each
// of their dynamically generated tracks.  Then delete the hashtable
// itself:

      for (int i=0; i<track_ID; i++)
      {
         Mynode<track*>* currnode_ptr=track_table_ptr->retrieve_key(i);
         if (currnode_ptr != NULL)
         {
            delete currnode_ptr->get_data();
         }
      } // loop over index i 
      delete track_table_ptr;

   } // loop over iter index labeling simulation

   cout << "Obstruction percentages:" << endl;
   templatefunc::printVector(obstruction_percentage);
   double mean_percentage=mathfunc::mean(obstruction_percentage);
   cout << "Mean percentage of eliminated spurious paths = "
        << mean_percentage << endl;
}
