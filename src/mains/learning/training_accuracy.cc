// ==========================================================================
// Program TRAINING_ACCURACY imports some
// caffe.bin.local-All-Series.pcho.log.INFO file generated by Deeplab
// caffe run on a GPU machine.  It plots the 3 accuracy values as a
// function of their relative iteration number.

//			       training_accuracy

// ==========================================================================
// Last updated on 9/11/15
// ==========================================================================

#include  <algorithm>
#include  <fstream>
#include  <iostream>
#include  <map>
#include  <set>
#include  <string>
#include  <vector>

#include "math/basic_math.h"
#include "general/filefuncs.h"
#include "plot/metafile.h"
#include "math/mypolynomial.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

int main(int argc, char* argv[])
{
   cout.precision(8);

   string log_filename="./data/caffe_log2.dat";
//   string log_filename="./data/caffe_log3.dat";
//   string log_filename="./data/20150902_flp.dat";
   bool strip_comments_flag = false;
   filefunc::ReadInfile(log_filename, strip_comments_flag);
   cout << "filefunc::text_line.size() = " << filefunc::text_line.size() 
        << endl;

   vector<double> relative_iter;
   vector<double> accuracy_0, accuracy_1, accuracy_2;
   for(unsigned int i = 0; i < filefunc::text_line.size(); i++)
   {
      vector<string> substrings = stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);

      if(substrings.size() < 11) continue;
      if(substrings[4] != "Train" || substrings[5] != "net" || substrings[6] !=
         "output")
      {
         continue;
      }

      double curr_accuracy = stringfunc::string_to_number(substrings[10]);
//      cout << "curr_accuracy = " << curr_accuracy << endl;
      
      if(substrings[7] == "#0:")
      {
         accuracy_0.push_back(curr_accuracy);
         relative_iter.push_back(10 * relative_iter.size());
      }
      else if(substrings[7] == "#1:")
      {
         accuracy_1.push_back(curr_accuracy);
      }
      else if(substrings[7] == "#2:")
      {
         accuracy_2.push_back(curr_accuracy);
      }

   } // loop over index i labeling imported logfile text lines

   cout << "Relative_iter.size = " << relative_iter.size() << endl;
   cout << "accuracy_0.size = " << accuracy_0.size() << endl;

   double chisq0, chisq1, chisq2;
   mypolynomial a0_poly(1);
   mypolynomial a1_poly(1);
   mypolynomial a2_poly(1);
   a0_poly.fit_coeffs(relative_iter, accuracy_0, chisq0);
   a1_poly.fit_coeffs(relative_iter, accuracy_1, chisq1);
   a2_poly.fit_coeffs(relative_iter, accuracy_2, chisq2);

   cout << "a0_poly = " << a0_poly << endl;
   cout << "a1_poly = " << a1_poly << endl;
   cout << "a2_poly = " << a2_poly << endl;

   vector<double> rel_iter;
   rel_iter.push_back(relative_iter.front());
   rel_iter.push_back(relative_iter.back());
   
   vector<double> linear_fit0, linear_fit1, linear_fit2;
   linear_fit0.push_back(a0_poly.value(rel_iter.front()));
   linear_fit0.push_back(a0_poly.value(rel_iter.back()));

   linear_fit1.push_back(a1_poly.value(rel_iter.front()));
   linear_fit1.push_back(a1_poly.value(rel_iter.back()));

   linear_fit2.push_back(a2_poly.value(rel_iter.front()));
   linear_fit2.push_back(a2_poly.value(rel_iter.back()));

// Plot accuracies versus relative iteration numbers

   metafile accuracy_metafile;
   accuracy_metafile.set_thickness(2);

   string meta_filename="accuracy";
   accuracy_metafile.set_parameters(
      meta_filename,"Training accuracy",
      "Relative Deeplab iteration number","Accuracy",
      0, relative_iter.back());
   accuracy_metafile.openmetafile();
   accuracy_metafile.write_header();
   accuracy_metafile.write_curve(relative_iter, accuracy_0, colorfunc::red);
   accuracy_metafile.write_curve(relative_iter, accuracy_1, colorfunc::blue);
   accuracy_metafile.write_curve(relative_iter, accuracy_2, colorfunc::green);

   accuracy_metafile.write_curve(rel_iter, linear_fit0, colorfunc::pink);
   accuracy_metafile.write_curve(rel_iter, linear_fit1, colorfunc::cyan);
   accuracy_metafile.write_curve(rel_iter, linear_fit2, colorfunc::yegr);

   accuracy_metafile.closemetafile();
}

