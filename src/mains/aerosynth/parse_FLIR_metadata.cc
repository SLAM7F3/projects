// ========================================================================
// Program PARSE_FLIR_METADATA reads in the metadata ascii file generated by
// Ross Anderson's program which ran on the Mac-Mini along with the
// FLIR for Twin Otter flights.  It extracts aircraft GPS, aircraft
// orientation and FLIR pointing information from this metadata file.
// After manipulating and reformating the input metadata, this program
// exports it to output files aircraft_metadata.txt and camera_metadata.txt.

//			    run_parse_FLIR_metadata

// ========================================================================
// Last updated on 4/22/13; 5/7/13; 5/10/13
// ========================================================================

#include <iostream>
#include <set>
#include <string>
#include <vector>

#include "geometry/bounding_box.h"
#include "video/camerafuncs.h"
#include "math/constant_vectors.h"
#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "astro_geo/geopoint.h"
#include "passes/PassesGroup.h"
#include "math/rotation.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
//    int videopass_ID=passes_group.get_videopass_ID();
//   cout << "videopass_ID = " << videopass_ID << endl;
   string image_list_filename=passes_group.get_image_list_filename();
//   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << endl;
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

   string metadata_filename;
   cout << endl;
   cout << "Enter name of Ross Anderson's FLIR metadata file:" << endl;
   cin >> metadata_filename;
   metadata_filename=bundler_IO_subdir+metadata_filename;
   cout << "metadata_filename = " << metadata_filename << endl;
   
// GEO flights:

//   string bundler_IO_subdir="bundler/GEO/20120105_1402/";
//   string metadata_filename=bundler_IO_subdir+"circle_orbit1a.txt";
//   string metadata_subdir="bundler/GEO/20120105_1330/";
//   string metadata_filename=metadata_subdir+"flir_flight2_merged_20120105.txt";
//   string metadata_subdir="bundler/GEO/20120105_1130/";
//   string metadata_filename=metadata_subdir+"20120105_1130.txt";

// Thunderstorm spiral 4 Weds night flight-1 with border intruders:

//   string metadata_subdir=
//      "/media/TS_Spiral4/Thunderstorm/Analog_Data/ops-5-11-11/flight-1/20110511_211231/";
//   string metadata_filename=metadata_subdir+"20110511_211231.txt";

//   string metadata_subdir=
//      "/media/TS_Spiral4/Thunderstorm/Analog_Data/ops-5-11-11/flight-1/20110511_234525/";
//   string metadata_filename=metadata_subdir+"20110511_234525.txt";

   

//   string metadata_subdir=
//      "/home/cho/programs/c++/svn/projects/src/mains/geo/";
//   string metadata_filename=metadata_subdir+"Jan05_5deg.txt";
//   string metadata_filename=metadata_subdir+"Jan05_flyby.txt";
//   string metadata_filename=metadata_subdir+"Jan5_5deg.txt";
//   string metadata_filename=metadata_subdir+"July28_5deg.txt";
//   string metadata_filename=metadata_subdir+"pass4_5deg.txt";
//   string metadata_filename=metadata_subdir+"pass15_5deg.txt";
//   string metadata_filename=metadata_subdir+"pass4_30deg.txt";
//   string metadata_filename=metadata_subdir+"pass15_30deg.txt";
//   string metadata_filename=metadata_subdir+"20110730_103902_pass4.txt";
//   string metadata_subdir=
//      "/home/cho/programs/c++/svn/projects/src/mains/thunderstorm/GrandCanyon/FLIR/";
//   string metadata_filename=metadata_subdir+"20110514_145833.txt";
//   string metadata_subdir=
//      "/home/cho/programs/c++/svn/projects/src/mains/TOC11/FLIR_metadata/";
//   string metadata_filename=metadata_subdir+"20110525_091610.txt";

   filefunc::ReadInfile(metadata_filename);

/*
// Hi-defn FLIR image size in pixels:
      
   const int n_horiz_pixels=1280;
   const int n_vert_pixels=720;
   double aspect_ratio=double(n_horiz_pixels)/double(n_vert_pixels);
//	aspect_ratio=1.77777 for hi-defn FLIR images
*/

// Cropped low-defn FLIR image size in pixels:

   const int n_horiz_pixels=704;
   const int n_vert_pixels=359-15;		// Jan 2012 GEO analog imagery
//   const int n_vert_pixels=359;		// GEO pass 15
   double aspect_ratio=double(n_horiz_pixels)/double(n_vert_pixels);
//	aspect_ratio=1.9610 for lo-defn FLIR images

/*
// Ignore any flight path points lying outside a bounding box:

// HAFB:

   double min_easting=310870-6*1000;
   double min_northing=4701756-3*1000;
   double max_easting=315796+3*1000;
   double max_northing=4705068+3*1000;


// Grand Canyon

   double min_easting=375046;
   double min_northing=3975435;
   double max_easting=437255;
   double max_northing=4017568;


   bounding_box bbox(min_easting,max_easting,min_northing,max_northing);
*/

   int n_waypoints=filefunc::text_line.size();
   vector<threevector> GPS_position;

// Extract GPS flight path:

   ofstream aircraft_metadata_stream,camera_stream;
   string aircraft_metadata_filename=bundler_IO_subdir+"aircraft_metadata.txt";
   string camera_metadata_filename=bundler_IO_subdir+"camera_metadata.txt";
   filefunc::openfile(aircraft_metadata_filename,aircraft_metadata_stream);
   filefunc::openfile(camera_metadata_filename,camera_stream);
   
   aircraft_metadata_stream.precision(12);
   camera_stream.precision(10);

   aircraft_metadata_stream << "# Frame		     Epoch secs      Easting	      Northing   Alt(m)	   Yaw		Pitch		Roll"
                            << endl;
   aircraft_metadata_stream << endl;

   camera_stream << "# Frame	 		HFOV		VFOV	   CAM_AZ	CAM_EL		CAM_ROLL" << endl;
   camera_stream << endl;

   cout << "n_waypoints = " << n_waypoints << endl;

   Clock clock;
   geopoint curr_waypoint,prev_waypoint;
   vector<threevector> candidate_tgt_posns;
   for (int i=0; i<n_waypoints; i++)
   {
//      cout << "i = " << i << " n_waypoints = " << n_waypoints 
//           << " i/n_waypoints = "
//           << double(i)/double(n_waypoints) << endl;
      
      vector<string> column_values=
         stringfunc::decompose_string_into_substrings(
            filefunc::text_line[i],",");

      if (column_values.size() < 10) continue;
      if (!stringfunc::is_number(column_values[5])) continue;

      vector<string> date_time_substrings=
         stringfunc::decompose_string_into_substrings(
         column_values[0],"_");

      string YYYYMMDD=date_time_substrings[0];
      string HHMMSS=date_time_substrings[1];

      int year,month,day,hour,minute;
      double secs;
      clock.parse_YYYYMMDD_string(YYYYMMDD,year,month,day);
      clock.parse_HHMMSS_string(HHMMSS,hour,minute,secs);
      const int hour_offset_to_UTC=4;	// Boston
      int UTC_hour=hour+hour_offset_to_UTC;
      clock.set_UTC_time(year,month,day,UTC_hour,minute,secs);
//      double elapsed_secs=clock.secs_elapsed_since_reference_date();
      
// FAKE FAKE:  Sunday Jun 19, 2011 at 8:47 am
// Next line for testing only

// Time for 5-25-11 Otter flying in from west side of HAFB and
// circling around LL for first time:

//      if (elapsed_secs < 1306329484.18 || elapsed_secs > 1306329818.2)
//         continue;

// Time for 5-25-11 Otter flying around Credit Union:

//      if (elapsed_secs < 1306330240 || elapsed_secs > 1306330445.23)
//         continue;

      string curr_frame_filename=column_values[0];
      double curr_az=stringfunc::string_to_number(column_values[1]);
      double curr_el=stringfunc::string_to_number(column_values[2]);
      double curr_heading=stringfunc::string_to_number(column_values[8]);
      double curr_pitch=stringfunc::string_to_number(column_values[9]);
      double curr_roll=stringfunc::string_to_number(column_values[10]);
      double curr_FOV_U=stringfunc::string_to_number(column_values[3]);
      double curr_latitude=stringfunc::string_to_number(column_values[5]);
      double curr_longitude=stringfunc::string_to_number(column_values[6]);
      double curr_altitude=stringfunc::string_to_number(column_values[7]);
//      cout << "curr_frame_filename = " << curr_frame_filename << endl;

      prev_waypoint=curr_waypoint;
      curr_waypoint=geopoint(curr_longitude,curr_latitude,curr_altitude);
      if (i==0) continue;
      
      double curr_easting=curr_waypoint.get_UTM_easting();
      double curr_northing=curr_waypoint.get_UTM_northing();
//      if (!bbox.point_inside(curr_easting,curr_northing)) continue;
      double prev_easting=prev_waypoint.get_UTM_easting();
      double prev_northing=prev_waypoint.get_UTM_northing();
      double prev_altitude=prev_waypoint.get_altitude();

      threevector curr_GPS_posn(curr_easting,curr_northing,curr_altitude);
      GPS_position.push_back(curr_GPS_posn);

// Compute instantaneous velocity vector's direction vector v_hat via
// finite differencing:

      threevector v_hat(
         curr_easting-prev_easting,curr_northing-prev_northing,
         curr_altitude-prev_altitude);
      v_hat.put(2,0);
      if (v_hat.magnitude() > 0)
      {
         v_hat=v_hat.unitvector();	// velocity pointing direction
//         double phi=atan2(v_hat.get(1),v_hat.get(0));
      }
      
// On 29 Sep 2011, we empirically determined the following procedure
// for converting "az", "el", "heading", "pitch", and "roll" from Ross'
// metadata file into an accurate 3D FLIR pointing vector f_hat:

      double phi_h=-90-curr_heading;
      phi_h=basic_math::phase_to_canonical_interval(phi_h,-180,180);
      double curr_yaw=phi_h-90; 
	// measured from north according to right hand rule wrt +z_hat
      phi_h *= PI/180;

//      cout << i << "  velocity dir: " 
//           << v_hat.get(0) << " , "
//           << v_hat.get(1) << " , "
//           << v_hat.get(2) << endl;

// Work with basis set l_hat (aircraft left), b_hat (aircraft behind)
// and t_hat (aircraft top).  Note l_hat x b_hat = t_hat . 

// Firstly, right-hand rotate aircraft coordinate system about z_hat
// by angle phi_h:

      threevector h_hat0(cos(phi_h),sin(phi_h),0); // heading dir vector

      threevector b_hat0=-h_hat0;	// backwards = -heading dir vector
      threevector t_hat0=z_hat;			// "top" pointing direction
      threevector l_hat0=b_hat0.cross(t_hat0);  // LHS pointing dir

// Secondly, pitch aircraft coordinate system about r_hat=-l_hat:

      double cos_pitch=cos(-curr_pitch*PI/180);
      double sin_pitch=sin(-curr_pitch*PI/180);

      threevector l_hat=l_hat0;
      threevector t_hat=cos_pitch*t_hat0+sin_pitch*b_hat0;
      threevector b_hat=-sin_pitch*t_hat0+cos_pitch*b_hat0;

// Finally, roll aircraft coordinate system about h_hat=-b_hat:

      double cos_roll=cos(-curr_roll*PI/180);
      double sin_roll=sin(-curr_roll*PI/180);

      threevector b_hat_prime=b_hat;
      threevector l_hat_prime=cos_roll*l_hat+sin_roll*t_hat;
      threevector t_hat_prime=-sin_roll*l_hat+cos_roll*t_hat;

      l_hat=l_hat_prime;
      b_hat=b_hat_prime;
      t_hat=t_hat_prime;

      double cos_az=cos(curr_az*PI/180);
      double sin_az=sin(curr_az*PI/180);
      double cos_el=cos(curr_el*PI/180);
      double sin_el=sin(curr_el*PI/180);

      threevector U_hat=-sin_az*b_hat+cos_az*l_hat;
      threevector V_hat=-sin_el*cos_az*b_hat-sin_el*sin_az*l_hat+cos_el*t_hat;
      threevector f_hat=cos_el*cos_az*b_hat+cos_el*sin_az*l_hat+sin_el*t_hat;
      threevector W_hat=-f_hat;

//      cout << "U_hat = " << U_hat << endl;
//      cout << "V_hat = " << V_hat << endl;
//      cout << "w_hat = " << W_hat << endl;

//      cout << "FLIR dir: " 
//           << f_hat.get(0) << ", "
//           << f_hat.get(1) << ", "
//           << f_hat.get(2) << endl << endl;
//      cout << "(U_hat x V_hat) . f_hat = " << (U_hat.cross(V_hat)).dot(f_hat)
//           << endl;

      double f,curr_FOV_V;
      curr_FOV_U *= PI/180;
      camerafunc::f_and_vert_FOV_from_horiz_FOV_and_aspect_ratio(
         curr_FOV_U,aspect_ratio,f,curr_FOV_V);
//      cout << "f = " << f
//           << " FOV_V = " << curr_FOV_V*180/PI << endl;

      rotation R,R1;
      R=R.rotation_taking_pqr_to_uvw(-y_hat,z_hat,-x_hat,U_hat,V_hat,W_hat);

      double frustum_az,frustum_el,frustum_roll;
      R.az_el_roll_from_rotation(frustum_az,frustum_el,frustum_roll);
//      cout << "frustum_az = " << frustum_az*180/PI
//           << " frustum_el = " << frustum_el*180/PI
//           << " frustum_roll = " << frustum_roll*180/PI << endl;

//      R1=R.rotation_from_az_el_roll(frustum_az,frustum_el,frustum_roll);

      aircraft_metadata_stream 
         << curr_frame_filename << "  "
         << clock.secs_elapsed_since_reference_date() << "  "
         << curr_easting << "  "
         << curr_northing << "  "
         << curr_altitude << "  "
         << curr_yaw << "  "
         << curr_pitch << "  "
         << curr_roll 
         << endl;

      camera_stream 
         << curr_frame_filename << "  "
         << curr_FOV_U*180/PI << "  "
         << curr_FOV_V*180/PI << "  "
         << frustum_az*180/PI << "  "
         << frustum_el*180/PI << "  "
         << frustum_roll*180/PI << "  "
         << endl;

/*
      databasefunc::insert_aircraft_metadata(
         gis_database* gis_database_ptr,int frame_ID,
         double epoch_time,std::string frame_prefix,
         double longitude,double latitude,double altitude,
         double yaw,double pitch,double roll)
*/

      
   } // loop over index i labeling waypoints

   filefunc::closefile(aircraft_metadata_filename,aircraft_metadata_stream);
   filefunc::closefile(camera_metadata_filename,camera_stream);

   string banner="Aircraft metadata written to "+aircraft_metadata_filename;
   outputfunc::write_big_banner(banner);
   banner="Camera metadata written to "+camera_metadata_filename;
   outputfunc::write_big_banner(banner);
   
}


