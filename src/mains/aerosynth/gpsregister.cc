// ==========================================================================
// Program GPSREGISTER reads in reconstructed camera positions
// generated by BUNDLER_PHOTOS.  It also reads in GPS track positions
// output by FLIR_metadata or LH_metadata. This program translates the
// bundler camera track so that its center-of-mass matches the GPS
// track's.  It rescales the bundler track so that its standard
// deviation matches the GPS track's.  The best-fit rotation which
// matches corresponding bundler and GPS track points is then calculated.

// GPSREGISTER generates TDP files for the initial Bundler camera
// track, the GPS track and the corrected Bundler camera track.  It
// also prints out the translation, scaling and rotation parameters
// which can be fed into program GENERATE_PETER_INPUTS and PLY2TDP in
// order to georegister Bundler's sparse and Furukawa's dense point
// cloud scene reconstructions.



//    ./GPSregister --region_filename ./bundler/sailplane_flight3/packages/peter_inputs.pkg


// 		!!! GPSREGISTER is DEPRECATED compared to GPSFIT !!!


// ==========================================================================
// Last updated on 1/26/11; 6/19/11; 6/22/11
// ==========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "astro_geo/geopoint.h"
#include "passes/PassesGroup.h"
#include "geometry/plane.h"
#include "math/rotation.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(15);

//   const double meters_per_ft=0.3048;

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   
   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string bundler_camera_posns_filename=bundler_IO_subdir+
      "reconstructed_camera_posns.dat";
   filefunc::ReadInfile(bundler_camera_posns_filename);

// First read in camera positions generated by program BUNDLER_PHOTOS.
// Store bundler camera positions within STL vector
// bundler_camera_posn:

   vector<string> photo_filename;
   vector<threevector> bundler_camera_posn;

   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      string curr_photo_filename=substrings[1];
      photo_filename.push_back(curr_photo_filename);

      double x=stringfunc::string_to_number(substrings[2]);
      double y=stringfunc::string_to_number(substrings[3]);
      double z=stringfunc::string_to_number(substrings[4]);
      threevector curr_camera_posn(x,y,z);
      bundler_camera_posn.push_back(curr_camera_posn);

//      cout << "i = " << i
//           << " filename = " << photo_filename.back()
//           << " bundler camera posn = " << bundler_camera_posn.back()
//           << endl;
   } // loop over index i labeling lines within bundler_camera_posns_filename

/*
// Create TDP file with raw, initial bundler's camera track from bundler.out:

   string reconstructed_camera_posns_tdp_filename=
      bundler_IO_subdir+"reconstructed_camera_posns.tdp";
   tdpfunc::write_relative_xyz_data(
   reconstructed_camera_posns_tdp_filename,bundler_camera_posn);
   string unix_cmd="lodtree "+reconstructed_camera_posns_tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv reconstructed_camera_posns.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
*/

// Set UTM zone and compute UTC time offset:

   bool northern_hemisphere_flag=true;
//   int UTM_zonenumber=14;	// Lubbock, TX
   int UTM_zonenumber=19;	// Boston-Lowell

   Clock clock;
   clock.set_daylight_savings_flag(true);
//   int offset=clock.compute_UTM_zone_time_offset(UTM_zonenumber);

// Next read in camera positions extracted from GPS track file.
// Convert from lon-lat to UTM geocoordinates.  Store GPS camera
// positions as values within STL map *GPStrack_map_ptr with photo
// filenames as keys:

//   string GPStrack_subdir=
//      "/home/cho/svn/Documents/tech_challenge/field_tests/game_day/";
//   string GPStrack_filename=GPStrack_subdir+"sailplane_mission95.flight3";
//   string GPStrack_filename=bundler_IO_subdir+"aircraft_GPS.dat";
//   string GPStrack_filename=bundler_IO_subdir+"HAFB_5-25-flight1_GPS.txt";
   string GPStrack_filename=bundler_IO_subdir+"HAFB_5-25-flight1_CreditUnion_GPS.txt";

   filefunc::ReadInfile(GPStrack_filename);
   vector<threevector> GPS_posn;

   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);
      threevector curr_GPS_posn(
         column_values[2],column_values[3],column_values[4]);
      GPS_posn.push_back(curr_GPS_posn);
      cout << "i = " << i << " GPS_posn = " << GPS_posn.back() << endl;
   }

// Create TDP file with GPS track:

/*
   string GPS_tdp_filename=bundler_IO_subdir+"GPS_flightpath.tdp";
   tdpfunc::write_relative_xyz_data(GPS_tdp_filename,GPS_posn);
   unix_cmd="lodtree "+GPS_tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv GPS_flightpath.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);
*/

   cout << "GPS_posn.size() = " << GPS_posn.size() << endl;
   cout << "bundler_camera_posn.size() = " << bundler_camera_posn.size() 
        << endl;

// Calculate GPS and reconstructed camera position COMs:

   threevector GPS_COM,bundler_COM;
   for (unsigned int i=0; i<GPS_posn.size(); i++)
   {
      GPS_COM += GPS_posn[i];
   } 
   GPS_COM /= GPS_posn.size();

   for (unsigned int i=0; i<bundler_camera_posn.size(); i++)
   {
      bundler_COM += bundler_camera_posn[i];
   } 
   bundler_COM /= bundler_camera_posn.size();

// Compute center-of-mass locations from Bundler and GPS camera
// positions.  Store translation needed to align Bundler's COM
// with GPS COM:

   cout << "GPS_COM = " << GPS_COM << endl;
   cout << "bundler_COM = " << endl;
   cout << "bundler_rotation_origin_X=" << bundler_COM.get(0) << ";" << endl;
   cout << "bundler_rotation_origin_Y=" << bundler_COM.get(1) << ";" << endl;
   cout << "bundler_rotation_origin_Z=" << bundler_COM.get(2) << ";" << endl;
   cout << endl;

   threevector trans=GPS_COM-bundler_COM;
   cout << "Translation to map bundler to GPS coordinates:" << endl << endl;
   cout << "bundler_translation_X=" << trans.get(0) << ";" << endl;
   cout << "bundler_translation_Y=" << trans.get(1) << ";" << endl;
   cout << "bundler_translation_Z=" << trans.get(2) << ";" << endl << endl;
   
// Translate reconstructed Bundler camera positions so that
// their COM aligns with (0,0,0):

   for (unsigned int i=0; i<bundler_camera_posn.size(); i++)
   {
      bundler_camera_posn[i] -= bundler_COM;
   }

// Reconstructed camera positions at the beginning and end of a video
// sequence tend to be the most uncertain.  So we'll fit for the best
// rotation which maps reconstructed camera positions to GPS readings
// only for some middle fraction of the reconstructed frusta:

   double frac_to_ignore=0.05;
   int i_start=bundler_camera_posn.size()*frac_to_ignore;
   int i_stop=bundler_camera_posn.size()*(1-frac_to_ignore);

// Translate GPS camera positions so that its COM aligns with
// (0,0,0). Then for each input photo, compute corresponding direction
// vectors towards realigned Bundler and GPS camera positions.  Store
// unit vectors in STL vectors rhat_bundler and rhat_GPS.  Also
// compute ratio of GPS to Bundler radii to for each camera position
// and store within STL vector scale_factors:

   vector<double> scale_factors;
   vector<threevector> rhat_bundler,rhat_GPS;
   
   for (int i=i_start; i<i_stop; i++)
   {
      double curr_frac=double(i)/bundler_camera_posn.size();
      int i_GPS=basic_math::round(GPS_posn.size()*curr_frac);
      i_GPS=basic_math::min(i_GPS,int(GPS_posn.size()-1));

      threevector curr_GPS_posn(GPS_posn[i_GPS]);
      curr_GPS_posn -= GPS_COM;
      rhat_GPS.push_back(curr_GPS_posn.unitvector());
      double curr_GPS_r=curr_GPS_posn.magnitude();

      rhat_bundler.push_back(bundler_camera_posn[i].unitvector());
      double curr_bundler_r=(bundler_camera_posn[i]).magnitude();

      double curr_scale=curr_GPS_r/curr_bundler_r;

//      cout << "i = " << i 
//           << " name = " << photo_filename[i]
//           << " GPS_r = " << curr_GPS_r
//           << " bundler_r = " << curr_bundler_r 
//           << " ratio = " << curr_scale << endl;
      
      scale_factors.push_back(curr_scale);
   } // loop over index i labeling reconstructed BUNDLER camera positions

// Compute mean and standard deviation of radial scale factors.  Mean
// yields global scale factor which needs to be applied to Bundler
// camera positions in order so that their distribution's standard
// deviation matches that of measured GPS camera positions:

   double mu_scale=mathfunc::mean(scale_factors);
   double sigma_scale=mathfunc::std_dev(scale_factors);
   cout << "Scale from bundler to GPS = " << mu_scale 
        << " +/- " << sigma_scale << endl << endl;
   cout << "sigma/mu = " << sigma_scale/mu_scale << endl;
   cout << "fitted_world_to_bundler_distance_ratio =" 
        << mu_scale << ";" << endl << endl;

// Compute rotation which maps Bundler's camera position direction
// vectors onto those for measured GPS camera positions:

   rotation R;
   R.rotation_between_ray_bundles(rhat_GPS,rhat_bundler);

   double az,el,roll;
   R.az_el_roll_from_rotation(az,el,roll);

   cout << "Angles to rotate bundler to GPS coordinates:" << endl << endl;
   cout << "global_az = " << az*180/PI << ";" << endl;
   cout << "global_el = " << el*180/PI << ";" << endl;
   cout << "global_roll = " << roll*180/PI << ";" << endl << endl;
   outputfunc::enter_continue_char();

// Rotate reconstructed Bundler camera positions so that they align in
// direction with GPS camera positions:

   rhat_bundler.clear();
   rhat_GPS.clear();
   for (unsigned int i=0; i<bundler_camera_posn.size(); i++)
   {
      bundler_camera_posn[i]=R*bundler_camera_posn[i];
      rhat_bundler.push_back(bundler_camera_posn[i].unitvector());

      double curr_frac=double(i)/bundler_camera_posn.size();
      int i_GPS=basic_math::round(GPS_posn.size()*curr_frac);
      i_GPS=basic_math::min(i_GPS,int(GPS_posn.size()-1));

      threevector curr_GPS_posn(GPS_posn[i_GPS]);
      curr_GPS_posn -= GPS_COM;
      rhat_GPS.push_back(curr_GPS_posn.unitvector());

      double dotproduct=rhat_GPS.back().dot(rhat_bundler.back());
      double theta=acos(dotproduct);

      cout << "i = " << i 
           << " dotprod = " << dotproduct 
           << " theta = " << theta*180/PI << endl;
   } // loop over index i labeling reconstructed BUNDLER camera positions

// Rescale and translate reconstructed Bundler camera positions so
// that they match GPS camera positions':

   string residual_filename="residuals.dat";
   ofstream outstream;
   filefunc::openfile(residual_filename,outstream);

   for (unsigned int i=0; i<bundler_camera_posn.size(); i++)
   {
      bundler_camera_posn[i] *= mu_scale;
      bundler_camera_posn[i] += GPS_COM;
      
      geopoint bundler_geolocation(
         northern_hemisphere_flag,UTM_zonenumber,
         bundler_camera_posn[i].get(0),bundler_camera_posn[i].get(1),
         bundler_camera_posn[i].get(2));
      
//      cout << photo_filename[i] << "  "
//           << bundler_geolocation.get_longitude() << "  "
//           << bundler_geolocation.get_latitude() << "  "
//           << bundler_geolocation.get_altitude()/meters_per_ft
//           << endl;

      double curr_frac=double(i)/bundler_camera_posn.size();
      int i_GPS=basic_math::round(GPS_posn.size()*curr_frac);
      i_GPS=basic_math::min(i_GPS,int(GPS_posn.size()-1));
      threevector curr_GPS_posn(GPS_posn[i_GPS]);

      threevector delta=bundler_camera_posn[i]-curr_GPS_posn;
      outstream << i << "  " 
                << " GPS_X = " << curr_GPS_posn.get(0)
                << " GPS_Y = " << curr_GPS_posn.get(1)
                << " GPS_Z = " << curr_GPS_posn.get(2)
                << " reconX = " << bundler_camera_posn[i].get(0) 
                << " reconY = " << bundler_camera_posn[i].get(1) 
                << " reconZ = " << bundler_camera_posn[i].get(2) 
                << "  dx = " << delta.get(0) 
                << "  dy = " << delta.get(1) 
                << "  dz = " << delta.get(2) 
                << endl;
   }
   filefunc::closefile(residual_filename,outstream);

// Create TDP file with fitted bundler camera posisions:

   string fitted_bundler_camera_posns_tdp_filename=
      bundler_IO_subdir+"fitted_bundler_camera_posns.tdp";
   tdpfunc::write_relative_xyz_data(
      fitted_bundler_camera_posns_tdp_filename,bundler_camera_posn);
   string unix_cmd="lodtree "+fitted_bundler_camera_posns_tdp_filename;
   sysfunc::unix_command(unix_cmd);
   unix_cmd="mv fitted_bundler_camera_posns.osga "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);


}

