// ==========================================================================
// Program GPSFIT reads in reconstructed camera posns generated by
// Noah Snavely's BUNDLER program in some arbitrary 3D coordinate
// system.  It also reads in a text file containing actual GPS
// locations for the camera generated by program
// INTERPOLATE_FLIR_METADATA.  The two input files are assumed to be
// in precise correspondence.  GPSFIT applies B. Horn's closed-form
// least-squares fitting procedure to compute the global rotation,
// translation and scaling needed to transform the bundler camera path
// into the GPS path.  It reports the average residual
// between the transformed and measured paths.  This program also
// exports the transformed path as a TDP and OSGA file.

//  gpsfit --region_filename ./bundler/HAFB/5-25-flight1/packages/peter_inputs.pkg

// ==========================================================================
// Last updated on 7/8/11; 2/28/13; 5/13/13
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "bundler/bundlerfuncs.h"
#include "math/constant_vectors.h"
#include "general/filefuncs.h"
#include "math/fourvector.h"
#include "passes/PassesGroup.h"
#include "math/rotation.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "math/threevector.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(10);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);
   string image_list_filename=passes_group.get_image_list_filename();
   cout << " image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// Read in "left" and "right" coordinate system points:

   vector<threevector> left_points,right_points;

   string bundler_filename=bundler_IO_subdir+
      "unfitted_reconstructed_camera_posns.dat";
   string GPS_filename=bundler_IO_subdir+"interp_GPS_waypoints.txt";

   bundlerfunc::read_left_right_points(
      bundler_filename,GPS_filename,left_points,right_points);

   threevector left_COM,right_COM;
   double az,el,roll,scale;
   threevector trans_Horn,trans_Peter;
   double median_residual_dist,quartile_width;
   bundlerfunc::RANSAC_fit_rotation_translation_scale(
      left_points,right_points,left_COM,right_COM,
      az,el,roll,scale,trans_Horn,trans_Peter,
      median_residual_dist,quartile_width);

   vector<threevector> transformed_left_points;
   double avg_residual=bundlerfunc::compute_avg_residual(
      left_points,right_points,transformed_left_points,
      az,el,roll,scale,trans_Horn);

   outputfunc::enter_continue_char();

// Generate TDP file containing geoaligned bundler camera path:

   string tdp_filename="geoaligned_camera_path.tdp";
   tdpfunc::write_relative_xyz_data(tdp_filename,transformed_left_points);

   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);
}
