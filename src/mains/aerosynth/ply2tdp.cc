// ==========================================================================
// This specialized version of program PLY2TDP reads in translation,
// scaling and rotation parameters derived by comparing raw Bundler
// and GPS track points via program GPSREGISTER.  It applies these
// transformations to an input PLY file generated by Furukawa's PMVS
// code applied to Noah's Bundler output.  The resulting
// georegistered, colored point cloud is written to output TDP & OSGA
// files.

// ply2tdp --region_filename ./bundler/sailplane_flight3/packages/peter_inputs.pkg

// ==========================================================================
// Last updated on 6/18/13; 12/3/13; 12/4/13
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "bundler/bundlerfuncs.h"
#include "general/filefuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

   bool georegistered_flag=true;
//   bool georegistered_flag=false;

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string pmvs_subdir=bundler_IO_subdir+"pmvs/";
   string pmvs_models_subdir=pmvs_subdir+"models/";
   cout << "pmvs_models_subdir = " << pmvs_models_subdir << endl;

   double fitted_world_to_bundler_distance_ratio=
      passes_group.get_fitted_world_to_bundler_distance_ratio();
   cout.precision(12);
   cout << "world_to_bundler_ratio = " 
        << fitted_world_to_bundler_distance_ratio << endl;

   threevector fitted_bundler_trans=passes_group.get_bundler_translation();
   cout << "fitted_bundler_trans = " << fitted_bundler_trans << endl;

   double global_az=passes_group.get_global_az();
   double global_el=passes_group.get_global_el();
   double global_roll=passes_group.get_global_roll();
   cout << "global_az = " << global_az*180/PI << endl;
   cout << "global_el = " << global_el*180/PI << endl;
   cout << "global_roll = " << global_roll*180/PI << endl;
   
   rotation global_R;
   global_R=global_R.rotation_from_az_el_roll(
      global_az,global_el,global_roll);
//   cout << "global_R = " << global_R << endl;

   threevector bundler_rotation_origin=
      passes_group.get_bundler_rotation_origin();
   cout << "bundler_rotation_origin = " << bundler_rotation_origin << endl;

// Read in XYZ-RGB points from PLY file generated by Furukawa's PMVS
// codes:

   string ply_filename=pmvs_models_subdir+"pmvs_options.txt.ply";
//   cout << "Enter input PLY filename:" << endl;
//   cin >> ply_filename;
   
   filefunc::ReadInfile(ply_filename);
   cout << "filefunc::text_line.size() = "
        << filefunc::text_line.size() << endl;

   vector<double> X,Y,Z;
   vector<int> R,G,B;
   for (unsigned int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      if (substrings.size()==6 || substrings.size()>=9)
      {
         double x=stringfunc::string_to_number(substrings[0]);
         double y=stringfunc::string_to_number(substrings[1]);
         double z=stringfunc::string_to_number(substrings[2]);

// Recall Noah's initial coordinate system needs to be grossly
// manipulated so that ground scenes lie approximately in XY plane:

// 	X_Peter = -X_Noah
// 	Y_Peter= Z_Noah
// 	Z_Peter = Y_Noah


         threevector curr_xyz;
         if (georegistered_flag)
         {
            curr_xyz=threevector(x,y,z);
         }
         else
         {
            curr_xyz=threevector(-x,z,y);
         }
         bundlerfunc::rotate_scale_translate_bundler_XYZ(
            curr_xyz,bundler_rotation_origin,
            fitted_world_to_bundler_distance_ratio,
            fitted_bundler_trans,global_R);

         X.push_back(curr_xyz.get(0));
         Y.push_back(curr_xyz.get(1));
         Z.push_back(curr_xyz.get(2));

         int r,g,b;
         if (substrings.size()==6)
         {
            r=stringfunc::string_to_number(substrings[3]);
            g=stringfunc::string_to_number(substrings[4]);
            b=stringfunc::string_to_number(substrings[5]);
         }
         else if (substrings.size()>=9)
         {
            r=stringfunc::string_to_number(substrings[6]);
            g=stringfunc::string_to_number(substrings[7]);
            b=stringfunc::string_to_number(substrings[8]);
         }
         R.push_back(r);
         G.push_back(g);
         B.push_back(b);
      }
   }

//   cout << "X.size() = " << X.size() << endl;
//   cout << "Y.size() = " << Y.size() << endl;
//   cout << "Z.size() = " << Z.size() << endl;
//   cout << "R.size() = " << R.size() << endl;
//   cout << "G.size() = " << G.size() << endl;
//   cout << "B.size() = " << B.size() << endl;

   string UTMzone="";
   string tdp_filename=stringfunc::prefix(ply_filename)+".tdp";
   tdpfunc::write_relative_xyzrgba_data(UTMzone,tdp_filename,X,Y,Z,R,G,B);

   string banner="Exported transformed PLY point cloud to TDP file "+
      tdp_filename;
   outputfunc::write_banner(banner);

   string unix_cmd="lodtree "+tdp_filename;
   sysfunc::unix_command(unix_cmd);

   string basename=filefunc::getbasename(tdp_filename);
   string prefix=stringfunc::prefix(basename);
   string osga_filename=prefix+".osga";
   unix_cmd="mv "+osga_filename+" "+bundler_IO_subdir;
   sysfunc::unix_command(unix_cmd);

   osga_filename=bundler_IO_subdir+osga_filename;

   banner="Exported transformed PLY point cloud to OSGA file "+
      osga_filename;
   outputfunc::write_big_banner(banner);
}
