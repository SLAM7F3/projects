// ==========================================================================
// Program EXTRACT_OGDF_LAYOUT reads in a Graph Modeling Language
// (GML) file generated by OGDF_LAYOUT.  For each node within the GML
// file, EXTRACT_OGDF_LAYOUT recovers its ID as well as its 2D X and Y
// positions calculated by OGDF.  This program generates text file
// "graph_XY_coords.fm3_layout" containing these outputs normalized to
// range within [0,1] which can be read in by GRAPHJSON.

// 			      extract_OGDF_layout

// ==========================================================================
// Last updated on 2/6/12; 2/21/12; 2/22/12; 5/26/13
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   using std::cout;
   using std::endl;
   using std::flush;
   using std::ios;
   using std::ofstream;
   using std::ostream;
   using std::string;
   using std::vector;

   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";

// Pass current graph component ID as input parameter:

   int graph_component_ID=passes_group.get_graph_component_ID();
   cout << "graph_component_ID = " << graph_component_ID << endl;

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("gml");
   vector<string> gml_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,graphs_subdir);
   
   int n_connected_components=gml_filenames.size();
   for (int connected_component=0; connected_component<
           n_connected_components; connected_component++)
   {
      string connected_component_label="_C"+stringfunc::number_to_string(
         graph_component_ID+connected_component);

      string gml_filename=graphs_subdir+"graph_layout"+
         connected_component_label+".gml";
      string banner="Parsing input GML file "+gml_filename;
      outputfunc::write_banner(banner);
      filefunc::ReadInfile(gml_filename);

      vector<int> node_ID;
      vector<double> X,Y;
      for (unsigned int i=0; i<filefunc::text_line.size(); i++)
      {
         vector<string> substrings=
            stringfunc::decompose_string_into_substrings(
            filefunc::text_line[i]);
         if (substrings[0]=="label")
         {
            int node_ID_length=substrings[1].size()-2;
            int curr_node_ID=stringfunc::string_to_number(
               substrings[1].substr(1,node_ID_length));
            node_ID.push_back(curr_node_ID);
         }
         if (substrings[0]=="x")
         {
            X.push_back(stringfunc::string_to_number(substrings[1]));
         }
         if (substrings[0]=="y")
         {
            Y.push_back(stringfunc::string_to_number(substrings[1]));
         }
      } // loop over index i labeling text lines

      double x_max=mathfunc::maximal_value(X);
      double x_min=mathfunc::minimal_value(X);
      double y_max=mathfunc::maximal_value(Y);
      double y_min=mathfunc::minimal_value(Y);

      cout << "x_max = " << x_max << " x_min = " << x_min << endl;
      cout << "y_max = " << y_max << " y_min = " << y_min << endl;


// Sort imageID STL vector while making corresponding modifications to
// X and Y STL vectors:

      banner="Sorting imageID, X and Y STL vectors:";
      outputfunc::write_banner(banner);

      templatefunc::Quicksort(node_ID,X,Y);

      string output_filename=graphs_subdir+
         "graph_XY_coords"+connected_component_label+".fm3_layout";
      ofstream outstream;
      filefunc::openfile(output_filename,outstream);
      outstream << "# Image_ID  gX       gY" << endl << endl;
      for (unsigned int i=0; i<node_ID.size(); i++)
      {
         outstream << node_ID[i] << "   "
                   << X[i]/x_max << "   " 
                   << Y[i]/y_max << endl;
      }
      filefunc::closefile(output_filename,outstream);

      banner="Wrote out "+output_filename;
      outputfunc::write_banner(banner);

   } // loop over connected_component index 
}
