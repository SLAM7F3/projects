// ==========================================================================
// Program KMEANS_CLUSTERS reads in the gx-gy layout for a SIFT graph
// generated by program EXTRACT_OGDF_LAYOUT and the edge list
// generated by program SIFT_PARSER.  It first modifies the layout by
// migrating nodes towards each other depending upon their SIFT edge
// weight.  The modified gx-gy node coordinates are written out to 
// "graph_XY_coords.modified_fm3_layout".  

// KMEANS_CLUSTERS next computes the minimum number of nodes which
// should appear in the highest level of a graph hierarchy pyramid.
// It queries the user to enter the desired number of levels within
// the pyramid.

// KMEANS_CLUSTERS then uses the K-means++ algorithm of David Arthur
// from Stanford to compute a uniform sequence of parent, grandparent,
// great-grandparent, etc nodes for the specified number of pyramid
// levels.  It exports pyramided clustering results to
// level_0l_clusters_Kmeans.dat text files.

// ==========================================================================
// Last updated on 1/31/13; 5/26/13; 7/22/13; 11/13/15
// ==========================================================================

#include <algorithm>
#include <iomanip>
#include <map>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "graphs/graph_hierarchy.h"
#include "cluster/KMeans.h"
#include "numrec/nrfuncs.h"
#include "passes/PassesGroup.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "math/threevector.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ios;
using std::map;
using std::pair;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";

// Pass current graph component ID as input parameter:

   int graph_component_ID=passes_group.get_graph_component_ID();
   cout << "graph_component_ID = " << graph_component_ID << endl;

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("gml");
   vector<string> gml_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,graphs_subdir);

   graph_hierarchy::COMPONENTS_LEVELS_MAP components_levels_map;

// -------------------------------------------------------------------------
// Loop over connected components starts here:
// -------------------------------------------------------------------------

   int max_child_node_ID=-1;
   int n_connected_components=gml_filenames.size();
   if (n_connected_components == 0)
   {
      n_connected_components = 1;
   }
   
   int n_levels=-1;
//   int n_levels=3;	// Reuters 43K documents
   for (int connected_component=0; connected_component<n_connected_components; 
        connected_component++)
   {
      cout << "=================================================" << endl;
      cout << "connected_component = " << connected_component << endl;
      string connected_component_label="_C"+stringfunc::number_to_string(
         graph_component_ID+connected_component);

// Read in XY layout for photos generated by FMMM algorithm:

      string XY_layout_filename=graphs_subdir+
         "graph_XY_coords"+connected_component_label+".fm3_layout";
      filefunc::ReadInfile(XY_layout_filename);

      typedef map<int,twovector> NODE_ID_XY_MAP;
      NODE_ID_XY_MAP* node_id_xy_map_ptr=new NODE_ID_XY_MAP;

      for (unsigned int i=0; i<filefunc::text_line.size(); i++)
      {
         vector<double> column_values=stringfunc::string_to_numbers(
            filefunc::text_line[i]);
         int node_ID=column_values[0];
         max_child_node_ID=basic_math::max(max_child_node_ID,node_ID);
         (*node_id_xy_map_ptr)[node_ID]=
            twovector(column_values[1],column_values[2]);
      }

// --------------------------------------------------------------------
// Migrate together any 2 nodes in graph gx,gy space together which
// have some non-zero SIFT edge weight.  

// Read in connected edgelist which contains SIFT weights between
// photo nodes:

      string edgelist_filename=graphs_subdir+"connected_edgelist"+
         connected_component_label+".dat";
      bool edge_weights_imported = filefunc::ReadInfile(edgelist_filename);

      if(edge_weights_imported)
      {
         vector<double> sift_weights;
         vector<threevector> NNW; // nodeID, nodeID', edge weight
         double lowest_weight=POSITIVEINFINITY;
         for (unsigned int i=0; i<filefunc::text_line.size(); i++)
         {
            vector<double> column_values=stringfunc::string_to_numbers(
               filefunc::text_line[i]);
            sift_weights.push_back(column_values[2]);
            lowest_weight=basic_math::min(lowest_weight,sift_weights.back());
            NNW.push_back(
               threevector(column_values[0],column_values[1],column_values[2]));
         }
         cout << "lowest edge weight = " << lowest_weight << endl;
         cout << "Node Node' edge_weight.size() = " << NNW.size() << endl;

         int n_output_bins=100;
         prob_distribution prob(sift_weights,n_output_bins,lowest_weight);

         const int n_migrations=1;
//   const int n_migrations=5; // 5 is definitely way too many migrations!
         for (int migration_iter=0; migration_iter < n_migrations; 
              migration_iter++)
         {
            for (unsigned int i=0; i<NNW.size(); i++)
            {
               if (i%1000==0) cout << i/1000 << " " << flush;
               int node1_ID=NNW[i].get(0);
               int node2_ID=NNW[i].get(1);
               double curr_sift_weight=NNW[i].get(2);

               NODE_ID_XY_MAP::iterator iter1=node_id_xy_map_ptr->find(
                  node1_ID);
               if (iter1==node_id_xy_map_ptr->end()) continue;
               twovector XY1(iter1->second);
      
               NODE_ID_XY_MAP::iterator iter2=node_id_xy_map_ptr->find(
                  node2_ID);
               if (iter2==node_id_xy_map_ptr->end()) continue;
               twovector XY2(iter2->second);
      
               int prob_bin=prob.get_bin_number(curr_sift_weight);
               double curr_pcum=prob.get_pcum(prob_bin);
//      cout << "i = " << i 
//           << " sift weight = " << sift_weights[i]
//           << " pcum = " << curr_pcum << endl;

               twovector new_XY1=XY1+curr_pcum*(XY2-XY1);
               twovector new_XY2=XY2+curr_pcum*(XY1-XY2);

               (*node_id_xy_map_ptr)[node1_ID]=new_XY1;
               (*node_id_xy_map_ptr)[node2_ID]=new_XY2;
            } // loop over index i 
         } // loop over migration_iteration
         cout << endl;

// Export modified graph node XY coordinates to output file:

         vector<int> node_ID;
         vector<twovector> Gxy;
         for (NODE_ID_XY_MAP::iterator itr=node_id_xy_map_ptr->begin();
              itr != node_id_xy_map_ptr->end(); ++itr)
         {
            node_ID.push_back(itr->first);
            Gxy.push_back(itr->second);
         }
         templatefunc::Quicksort(node_ID,Gxy);

         string modified_XY_layout_filename=
            graphs_subdir+"graph_XY_coords"+connected_component_label
            +".modified_fm3_layout";
         ofstream gxystream;
         filefunc::openfile(modified_XY_layout_filename,gxystream);
         gxystream << "# Node   Gx     Gy" << endl << endl;
   
         for (unsigned int i=0; i<node_ID.size(); i++)
         {
            gxystream << node_ID[i] << "   "
                      << Gxy[i].get(0) << "   "
                      << Gxy[i].get(1) << "   "
                      << endl;
         }
         filefunc::closefile(modified_XY_layout_filename,gxystream);

      } // edge_weights_imported conditional

// --------------------------------------------------------------------
// Hierarchical clustering starts here...

      const int dim=2;
      int n_nodes=node_id_xy_map_ptr->size();
      int power_of_ten=basic_math::round(trunclog(n_nodes));
      int n_10_levels=basic_math::round(log10(power_of_ten));
      int min_n_nodes=n_nodes/pow(10,n_10_levels-1);
      const int min_n_nodes_before_clustering=15;

      cout << "n_nodes = " << n_nodes 
           << " power_of_ten = " << power_of_ten << endl;
      cout << "n_10_levels = " << n_10_levels 
           << " min_n_nodes = " << min_n_nodes
           << endl << endl;
   
      if (n_levels < 0)
      {
         cout << "Enter desired number (>= 2) of evenly-spaced levels within graph hierarchy pyramid:" 
              << endl;
         cin >> n_levels;

         if (n_levels < 2)
         {
            cout << "Error: Number of levels must be greater than or equal to 2!"
                 << endl;
            exit(-1);
         }
      }

      vector<int> k_clusters;
      if (n_levels==2)
      {
         k_clusters.push_back(n_nodes);
         k_clusters.push_back(1);
      }
      else if (n_nodes <= min_n_nodes_before_clustering)
      {
         k_clusters.push_back(n_nodes);
         for (int l=1; l<n_levels; l++)
         {
            k_clusters.push_back(1);
         }
      }
      else
      {
//         double frac_power=double(n_10_levels-1)/double(n_levels-1);
         double frac_power=double(n_10_levels)/double(n_levels-1);

// Make sure frac_power never goes negative!

         frac_power=basic_math::max(0.0,frac_power);

         double f=pow(10,-frac_power);
//         cout << "frac_power = " << frac_power << endl;
//         cout << "f = " << f << endl;

         double curr_frac=1;
         for (int l=0; l<n_levels; l++)
         {
            int n_clusters=n_nodes*curr_frac;
            n_clusters=basic_math::max(n_clusters,1);
            k_clusters.push_back(n_clusters);
            cout << "level = " << l
                 << " curr_frac = " << curr_frac 
                 << " n_clusters = " << k_clusters.back() << endl;
            curr_frac *= f;
         }
         cout << endl;
      }

      graph_hierarchy::NNODES_POSN_LABELS nnodes_posn_labels;

      vector<threevector> cyl_center;
      for (int l=0; l<n_levels; l++)
      {
         int k=k_clusters[l];
         cout << "level = " << l << " k_clusters = " << k << endl;
         pair<int,int> p(connected_component,l);

         nnodes_posn_labels.first=k;
         components_levels_map[p]=nnodes_posn_labels;
//         components_levels_map[p]=k;

         if (l==0) continue;

//         cout << "k = " << k << endl;
//         cout << "n_nodes = " << n_nodes << endl;
         double* points_ptr=new double[n_nodes*dim];
         double* cluster_centers_ptr=new double[k*dim];
         int* assignments_ptr=new int[n_nodes];

         int counter=0;
         vector<int> node_ID;
         cyl_center.clear();
      
         for (NODE_ID_XY_MAP::iterator itr=node_id_xy_map_ptr->begin();
              itr != node_id_xy_map_ptr->end(); ++itr)
         {
            node_ID.push_back(itr->first);
            twovector curr_XY=itr->second;

            double curr_x=curr_XY.get(0);
            double curr_y=curr_XY.get(1);
            cyl_center.push_back(threevector(curr_x,curr_y));
            points_ptr[dim*counter+0]=curr_x;
            points_ptr[dim*counter+1]=curr_y;
            counter++;
         } // loop over NODE_ID_XY_MAP iterator

         if (k < n_nodes && n_nodes > min_n_nodes_before_clustering)
         {

// Perform K-means++ clustering on nodes:

            int n_attempts=100;
            RunKMeansPlusPlus(
               n_nodes,k,dim,points_ptr,n_attempts,
               cluster_centers_ptr,assignments_ptr);
         }
         else
         {

// Assign cth node to cth cluster:

            for (int c=0; c<k; c++)
            {
               cluster_centers_ptr[dim*c+0]=points_ptr[dim*c+0];
               cluster_centers_ptr[dim*c+1]=points_ptr[dim*c+1];
               assignments_ptr[c]=c;
            }
         }
         
         typedef map<int,vector<int> > CLUSTER_ID_NODE_IDS_MAP;
         CLUSTER_ID_NODE_IDS_MAP* cluster_id_node_ids_map_ptr=
            new CLUSTER_ID_NODE_IDS_MAP;

         for (int c=0; c<counter; c++)
         {
            int curr_assignment=assignments_ptr[c];
            int curr_node_ID=node_ID[c];
//         cout << "level = " << l
//              << " node = " << curr_node_ID
//              << " assignment = " << curr_assignment << endl;

            CLUSTER_ID_NODE_IDS_MAP::iterator iter=
               cluster_id_node_ids_map_ptr->
               find(curr_assignment);
            if (iter != cluster_id_node_ids_map_ptr->end())
            {
               iter->second.push_back(curr_node_ID);
            }
            else
            {
               vector<int> V;
               V.push_back(curr_node_ID);
               (*cluster_id_node_ids_map_ptr)[curr_assignment]=V;
            }
         } // loop over index c labeling counter

// Sort clusters according to the number of nodes they contain:

         vector<int> cluster_sizes;
         vector< vector<int> > clusters;
      
         for (CLUSTER_ID_NODE_IDS_MAP::iterator iter=
                 cluster_id_node_ids_map_ptr
                 ->begin(); iter != cluster_id_node_ids_map_ptr->end(); iter++)
         {
            vector<int> curr_cluster=iter->second;
            cluster_sizes.push_back(curr_cluster.size());
            clusters.push_back(curr_cluster);

         }
         delete cluster_id_node_ids_map_ptr;

         templatefunc::Quicksort_descending(cluster_sizes,clusters);

// Export node clusters to level_0l_clusters.dat output file:

         string output_filename=graphs_subdir+
            "level_0"+stringfunc::number_to_string(l)+"_clusters_Kmeans"+
            connected_component_label+".dat";
         ofstream outstream ;
         filefunc::openfile(output_filename,outstream);
         for (unsigned int c=0; c<clusters.size(); c++)
         {
            vector<int> curr_cluster=clusters[c];
            for (unsigned int i=0; i<curr_cluster.size(); i++)
            {
               outstream << curr_cluster[i] << "  ";
            }
            outstream << endl;
         }
         filefunc::closefile(output_filename,outstream);

         string clusters_filename=graphs_subdir+
            "level_0"+stringfunc::number_to_string(l)+"_clusters"+
            connected_component_label+".dat";
         string unix_cmd="cp "+output_filename+" "+clusters_filename;
//      cout << "unix_cmd = " << unix_cmd << endl;
         sysfunc::unix_command(unix_cmd);

         delete [] points_ptr;
         delete [] cluster_centers_ptr;
         delete [] assignments_ptr;

      } // loop over index l labeling level
   } // loop over connected component index 

// -------------------------------------------------------------------------
// Loop over connected components ends here
// -------------------------------------------------------------------------

   cout << "max child node ID = " << max_child_node_ID << endl;

// Export number of graph nodes per level and connected graph
// component to output text file:

   string clusters_info_filename=graphs_subdir+"clusters_info.dat";
   ofstream outstream;
   filefunc::openfile(clusters_info_filename,outstream);

   outstream << n_levels << " # Number of graph levels" << endl;
   outstream << n_connected_components 
             << " # Number of graph connected components " << endl;
   outstream << max_child_node_ID << " # Maximum child node ID" << endl;
   outstream << endl;

   outstream << "# Level  component  n_clusters" << endl;
   outstream << endl;

   for (int level=0; level < n_levels; level++)
   {
      for (int connected_component=0; connected_component<
              n_connected_components; connected_component++)
      {
         pair<int,int> p(connected_component,level);
         
         graph_hierarchy::COMPONENTS_LEVELS_MAP::iterator iter=
            components_levels_map.find(p);
         int k_clusters=iter->second.first;
//         int k_clusters=iter->second;

         outstream << level << "         "
                   << connected_component << "         "
                   << k_clusters << endl;
         
      } // loop over connected_component index
      outstream << endl;
   } // loop over level index
   
   filefunc::closefile(clusters_info_filename,outstream);

   string banner=
      "Wrote number of clusters per level and connected component to "+
      clusters_info_filename;
   outputfunc::write_big_banner(banner);
}
