// ==========================================================================
// Program GENERATE_SINGLETON_CLUSTERS reads in cluster text files
// generated by the Markov Clustering Algorithm (MCL).  It first finds
// the maximum child node ID.  GENERATE_SINGLETON_CLUSTERS then
// rescans all the cluster text files and identifies those nodes whose
// IDs are absent.  These correspond to images which Bundler never
// included into any SIFT match pair.  This program exports
// level_0l_clusters_CXX.dat files (for level l=1 and 2) which
// includes a single singleton node ID entry.  It also writes out
// connected_edgelist_CXX.dat files containing the single node ID
// (repeated twice) along with a -1 edge weight.  Finally, this
// program creates a graph_XY_coords_CXX.fm3_layout file containing
// gx=gy=0.5 graph coordinates for the single node.

// We wrote this program in Aug 2012 in order to force all NewsWrap
// video nodes to appear in some connected component for timeline
// display purposes.

// ==========================================================================
// Last updated on 8/25/12; 8/27/12; 4/16/13
// ==========================================================================

#include <map>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "graphs/graph_hierarchy.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";

   vector<string> allowed_suffixes;
   allowed_suffixes.push_back("gml");
   vector<string> gml_filenames=
      filefunc::files_in_subdir_matching_specified_suffixes(
         allowed_suffixes,graphs_subdir);

// -------------------------------------------------------------------------
// Loop over connected components starts here:
// -------------------------------------------------------------------------

   int max_child_node_ID=-1;
   int n_connected_components=gml_filenames.size();

   for (int connected_component=0; connected_component<
           n_connected_components; connected_component++)
   {
      string connected_component_label="_C"+stringfunc::number_to_string(
         connected_component);
      string cluster_filename=graphs_subdir+"level_01_clusters"
         +connected_component_label+".dat";
      filefunc::ReadInfile(cluster_filename);

      for (unsigned int c=0; c<filefunc::text_line.size(); c++)
      {
         vector<double> node_IDs=stringfunc::string_to_numbers(
            filefunc::text_line[c]);
         for (unsigned int n=0; n<node_IDs.size(); n++)
         {
            max_child_node_ID=basic_math::max(
               max_child_node_ID,int(node_IDs[n]));
         } // loop over index n
      } // loop over index c
   } // loop over connected_component index

   cout << "max child node ID = " << max_child_node_ID << endl;

// Identify video frame nodes whose IDs do NOT appear in any
// level_01_clusters_mcl_CXX.dat file:

   vector<bool> node_ID_exists_flag;
   for (int i=0; i<=max_child_node_ID; i++)
   {
      node_ID_exists_flag.push_back(false);
   }

   for (int connected_component=0; connected_component<
           n_connected_components; connected_component++)
   {
      string connected_component_label="_C"+stringfunc::number_to_string(
         connected_component);
      string cluster_filename=graphs_subdir+"level_01_clusters"
         +connected_component_label+".dat";
      filefunc::ReadInfile(cluster_filename);

      for (unsigned int c=0; c<filefunc::text_line.size(); c++)
      {
         vector<double> node_IDs=stringfunc::string_to_numbers(
            filefunc::text_line[c]);
         for (unsigned int n=0; n<node_IDs.size(); n++)
         {
            node_ID_exists_flag[int(node_IDs[n])]=true;
         } // loop over index n
      } // loop over index c
   } // loop over connected_component index

// Create level_0l_clusters_CXX.dat files for singleton nodes which
// did NOT appear within Bundler's edge list:

   int n_singletons=0;
   int connected_component=n_connected_components;
   for (unsigned int i=0; i<node_ID_exists_flag.size(); i++)
   {
      if (!node_ID_exists_flag[i])
      {
         int curr_node_ID=i;
         cout << "Generating connected component containing singleton node with ID = " << curr_node_ID << endl;
         string connected_component_label="_C"+stringfunc::number_to_string(
            connected_component++);

         int n_levels=3;
         for (int l=1; l<n_levels; l++)
         {
            string cluster_filename=graphs_subdir+"level_0"+
               stringfunc::number_to_string(l)+
               "_clusters"+connected_component_label+".dat";
            ofstream cluster_stream;
            filefunc::openfile(cluster_filename,cluster_stream);
            cluster_stream << i << endl;
            filefunc::closefile(cluster_filename,cluster_stream);
         }

         string edgelist_filename=graphs_subdir+"connected_edgelist"
            +connected_component_label+".dat";
         ofstream edgelist_stream;
         filefunc::openfile(edgelist_filename,edgelist_stream);
         edgelist_stream << "# NodeID  NodeID'  Edge weight" << endl;
         edgelist_stream << curr_node_ID << "        " 
                         << curr_node_ID << "        "
                         << -1 << endl;
         edgelist_stream << endl;
         filefunc::closefile(edgelist_filename,edgelist_stream);

         string graph_XY_coords_filename=graphs_subdir+
            "graph_XY_coords"+connected_component_label+".fm3_layout";
         ofstream graph_XY_coords_stream;
         filefunc::openfile(graph_XY_coords_filename,graph_XY_coords_stream);
         graph_XY_coords_stream << "# Image_ID  gX       gY" << endl;
         graph_XY_coords_stream << endl;
         graph_XY_coords_stream << curr_node_ID << "  0.5      0.5" << endl;
         filefunc::closefile(graph_XY_coords_filename,graph_XY_coords_stream);

         n_singletons++;
      }
   }
   cout << "n_singleton connected components = " << n_singletons << endl;
   
}
