// ==========================================================================
// Program MCL_CLUSTERS reads in cluster text files generated by the
// Markov Clustering Algorithm (MCL).  It finds the maximum child node
// ID and counts number of nodes per cluster.  MCL_CLUSTERS exports
// cluster metadata to output text file clusters_info.dat.
// ==========================================================================
// Last updated on 3/10/12; 8/25/12; 2/28/13
// ==========================================================================

#include <algorithm>
#include <map>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "graphs/graph_hierarchy.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ios;
using std::map;
using std::pair;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";

   string substring="level_01_clusters_C";
   vector<string> level_01_clusters_filenames=
      filefunc::files_in_subdir_matching_substring(
         graphs_subdir,substring);
   

   graph_hierarchy::COMPONENTS_LEVELS_MAP components_levels_map;

// -------------------------------------------------------------------------
// Loop over connected components starts here:
// -------------------------------------------------------------------------

   int max_child_node_ID=-1;
   int n_connected_components=level_01_clusters_filenames.size();
   int n_levels=3;
   for (int l=1; l<n_levels; l++)
   {
      for (int connected_component=0; connected_component<
              n_connected_components; connected_component++)
      {
         string connected_component_label="_C"+stringfunc::number_to_string(
            connected_component);

         string cluster_filename=graphs_subdir+"level_0"+
            stringfunc::number_to_string(l)+
            "_clusters"+connected_component_label+".dat";
         filefunc::ReadInfile(cluster_filename);
         int n_clusters=filefunc::text_line.size();

         int n_nodes=0;
         for (unsigned int c=0; c<filefunc::text_line.size(); c++)
         {
            vector<double> node_IDs=stringfunc::string_to_numbers(
               filefunc::text_line[c]);
            n_nodes += node_IDs.size();
            for (unsigned int n=0; n<node_IDs.size(); n++)
            {
               max_child_node_ID=basic_math::max(
                  max_child_node_ID,int(node_IDs[n]));
            } // loop over index n
         } // loop over index c

         if (l==1)
         {
            pair<int,int> p(connected_component,0);
            graph_hierarchy::NNODES_POSN_LABELS npl;
            npl.first=n_nodes;
            components_levels_map[p]=npl;
         }

         pair<int,int> p(connected_component,l);
         graph_hierarchy::NNODES_POSN_LABELS npl;
         npl.first=n_clusters;
         components_levels_map[p]=npl;

//         cout << "l = " << l
//              << " connected_component = " << connected_component
//              << endl;
//         cout << "cluster_filename = " << cluster_filename << endl;
//         cout << "n_clusters = " << n_clusters << endl;
//         cout << "max_child_node_ID = " << max_child_node_ID << endl;

      } // loop over connected_component index
   } // loop over index l labeling graph level

   cout << "max child node ID = " << max_child_node_ID << endl;

// Identify video frame nodes whose IDs do NOT appear in any
// level_01_clusters_mcl_CXX.dat file:

   vector<bool> node_ID_exists_flag;
   for (int i=0; i<=max_child_node_ID; i++)
   {
      node_ID_exists_flag.push_back(false);
   }

   for (int connected_component=0; connected_component<
           n_connected_components; connected_component++)
   {
      string connected_component_label="_C"+stringfunc::number_to_string(
         connected_component);

      string cluster_filename=graphs_subdir+"level_01_clusters"
         +connected_component_label+".dat";
      filefunc::ReadInfile(cluster_filename);

      for (unsigned int c=0; c<filefunc::text_line.size(); c++)
      {
         vector<double> node_IDs=stringfunc::string_to_numbers(
            filefunc::text_line[c]);
         for (unsigned int n=0; n<node_IDs.size(); n++)
         {
            node_ID_exists_flag[int(node_IDs[n])]=true;
         } // loop over index n
      } // loop over index c
   } // loop over connected_component index

   int n_singletons=node_ID_exists_flag.size();
   for (unsigned int i=0; i<node_ID_exists_flag.size(); i++)
   {
      if (!node_ID_exists_flag[i])
      {
         cout << "node with ID = " << i << " doesn't exist in any cc" 
              << endl;
      }
   }
   cout << "n_singletons = " << n_singletons << endl;
   
// Export number of graph nodes per level and connected graph
// component to output text file:

   string clusters_info_filename=graphs_subdir+"clusters_info.dat";
   ofstream outstream;
   filefunc::openfile(clusters_info_filename,outstream);

   outstream << n_levels << " # Number of graph levels" << endl;
   outstream << n_connected_components 
             << " # Number of graph connected components " << endl;
   outstream << max_child_node_ID << " # Maximum child node ID" << endl;
   outstream << endl;

   outstream << "# Level  component  n_clusters  n_clusters_sum" << endl;
   outstream << endl;

   for (int level=0; level < n_levels; level++)
   {
      int k_clusters_sum=0;
      for (int connected_component=0; connected_component<
              n_connected_components; connected_component++)
      {
         pair<int,int> p(connected_component,level);
         
         graph_hierarchy::COMPONENTS_LEVELS_MAP::iterator iter=
            components_levels_map.find(p);
         int k_clusters=iter->second.first;
         k_clusters_sum += k_clusters;

         outstream << level << "         "
                   << connected_component << "         "
                   << k_clusters << "         "
                   << k_clusters_sum 
                   << endl;
         
      } // loop over connected_component index
      outstream << endl;
   } // loop over level index
   
   filefunc::closefile(clusters_info_filename,outstream);

   string banner=
      "Wrote number of clusters per level and connected component to "+
      clusters_info_filename;
   outputfunc::write_big_banner(banner);
}
