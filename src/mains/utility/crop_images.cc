 // ========================================================================
// Program CROP_IMAGES utilizes ImageMagick's conversion program to
// crop PNG, JPEG, RGB, etc images down to specified, uniform widths
// and heights measured in pixels.  It also strengthens red and
// diminishes blue color content for AVI movie making purposes.  Input
// frames are assumed to be named such as frame_nnn.jpg

// 				crop_images

// ========================================================================
// Last updated on 2/28/10; 1/23/11; 9/2/11
// ========================================================================

#include <iostream>
#include <string>
#include "image/imagefuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::string;

// ==========================================================================
int main( int argc, char** argv )
{
   int start_image,stop_image;
   cout << "Enter starting image number:" << endl;
   cin >> start_image;
   cout << "Enter stopping image number:" << endl;
   cin >> stop_image;

   string basefilename;
   cout << "Enter base filename:" << endl;
   cin >> basefilename;
  
   string imagedir="./";
   cout << "Enter subdir containing all images:"<< endl;
   cin >> imagedir;

   string input_suffix="jpg";
//   string input_suffix="png";
   string output_suffix="jpg";
//   string output_suffix="png";

// On touchy2, we determined xoffset,yoffset and xstop,ystop values
// using GIMP.  Just read off cursor's position from GIMP's lower left
// corner:

// Important note:  As of April 2009, we strongly suspect based upon
// several rounds of trial and error that the width and height of the
// cropped image must be perfect multiples of 4 in order for any AVI
// movie generated by MKMPEG4 to successfully play inside of
// powerpoint!

// Offset location = image's upper left pixel:

   int xoffset=158;	
   int yoffset=71;
   int xstop=1083;
   int ystop=801;

/*
   const int xoffset=30;	// Raven front camera
   const int yoffset=0;
   int xstop=677;
   int ystop=480;

   const int xoffset=333;   // Values appropriate for Jan 2010 RASR 
   const int yoffset=65;   // gstreets sequence collected with DVI2USB grabber

   int xstop=1746;    // Values appropriate for Mar 2010 Gmap sequence 
   int ystop=1025;     // clip collected with DVI2USB frame grabber

   const int xoffset=13;   // Values appropriate for Jan 2010 RASR 
   const int yoffset=135;   // gstreets sequence collected with DVI2USB grabber

   int xstop=1082;    // Values appropriate for Mar 2010 Gmap sequence 
   int ystop=996;     // clip collected with DVI2USB frame grabber

   const int xoffset=0;   // Values appropriate for Jan 2010 RASR 
   const int yoffset=24;   // gstreets sequence collected with DVI2USB grabber

   int xstop=1076;    // Values appropriate for Mar 2010 Gmap sequence 
   int ystop=824;     // clip collected with DVI2USB frame grabber
*/

//   int xstop=1596;    // Values appropriate for Mar 2010 photo tour sequence 
//   int ystop=1000;     // clip collected with DVI2USB frame grabber

//   int xstop=1076;    // Values appropriate for Feb 2010 Marriott sequence 
//   int ystop=824;     // clip collected with DVI2USB frame grabber

//   int xstop=1596;    // Values appropriate for Jan 2010 RASR sequence 
//   int ystop=628;     // clip collected with DVI2USB frame grabber

//   int xstop=1572;    // Values appropriate for Aug 2009 1K NYC propagator 
//   int ystop=616;     // clip collected with DVI2USB frame grabber

//   int xstop=1588;    // Values appropriate for July 2009 1K NYC propagator 
//   int ystop=616;     // clip collected with DVI2USB frame grabber

//   int xstop=1072;    // Values appropriate for July 2009 1K NYC photo
//   int ystop=828;     // reconstruction collected with DVI2USB frame grabber

//   int xstop=1920;    // Values appropriate for Apr 2009 photosynth w social
//   int ystop=832;     // network sequence collected with DVI2USB frame grabber

//   int xstop=1096;    // Values appropriate for Apr 2009 UAV w road
//   int ystop=828;     // network sequence collected with DVI2USB frame grabber

//   int xstop=1637;	   // Values appropriate for Mar 2009 Boston panorama
//   int ystop=853;	   // sequences collected with DVI2USB frame grabber

//   int xstop=1591;	   // Values appropriate for Mar 2009 range selection
//   int ystop=620;	   // sequences collected with DVI2USB frame grabber

//   int xstop=852;	   // Values appropriate for Dec 2008 Bluegrass
//   int ystop=418;	   // sequences shot with video camera

//   int xstop=890;	   // Values appropriate for Dec 2008 Bluegrass
//   int ystop=470;	   // sequences shot with video camera
//   int xstop=845;	   // Values appropriate for Dec 2008 Bluegrass
//   int ystop=567;	   // sequences shot with video camera
//   int xstop=890;	   // Values appropriate for Dec 2008 Bluegrass
//   int ystop=465;	   // sequences shot with video camera
//   int xstop=800;	   // Values appropriate for Dec 2008 Bluegrass
//   int ystop=514;	   // sequences shot with video camera
//   int xstop=750;
//   int ystop=750;
   int width=xstop-xoffset;
   int height=ystop-yoffset;

//   const int n_digits=1;
//   const int n_digits=2;
//   const int n_digits=3;
   const int n_digits=4;
//   const int n_digits=5;
//   const int n_digits=6;

   int image_skip=1;
//   int image_skip=2;
//   int image_skip=25;


   genmatrix* RGB_transform_ptr=new genmatrix(3,3);
   RGB_transform_ptr->clear_values();
//   RGB_transform_ptr->put(0,0,1.25);
//   RGB_transform_ptr->put(1,1,1.0);
//   RGB_transform_ptr->put(2,2,0.80);

//   RGB_transform_ptr->put(0,0,1.05);
//   RGB_transform_ptr->put(1,1,1.0);
//   RGB_transform_ptr->put(2,2,0.95);

   RGB_transform_ptr->put(0,0,1.1);
   RGB_transform_ptr->put(1,1,1.0);
   RGB_transform_ptr->put(2,2,0.9);

   for (int i=start_image; i<=stop_image; i += image_skip)
   {
      string input_filename=basefilename
         +stringfunc::integer_to_string(i,n_digits)+"."+input_suffix;
      input_filename=imagedir+input_filename;
      string output_filename=basefilename
         +stringfunc::integer_to_string(i,n_digits)+"."+output_suffix;
      output_filename=imagedir+output_filename;

      cout << "Cropping file = " << input_filename << endl;
      imagefunc::crop_image(input_filename,output_filename,
      width,height,xoffset,yoffset);
//      imagefunc::recolor_image(filename,RGB_transform_ptr);
//      imagefunc::crop_and_recolor_image(
//         input_filename,width,height,xoffset,yoffset,RGB_transform_ptr);
   }

   delete RGB_transform_ptr;
}
