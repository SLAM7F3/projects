// ==========================================================================
// Program TRUTH_TRACKS is a specialized version of TRUTH_VELOCITIES.
// It outputs truth track times relative to t_start (secs), Eastings
// and Northings relative to a hardwired Lubbock grid origin (meters),
// and Vx & Vy in meters/sec.  We wrote this little utility in order
// to give Luca B. sanitized versions of a few truth tracks.
// ==========================================================================
// Last updated on 6/27/08
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "filter/filterfuncs.h"
#include "astro_geo/geopoint.h"
#include "math/mathfuncs.h"
#include "filter/piecewise_linear_vector.h"
#include "general/outputfuncs.h"
#include "osg/osgGIS/postgis_database.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ofstream;
using std::string;
using std::vector;

//   1 m/s = 2.23693 miles/hour

const double meters_per_second_to_miles_per_hour=2.236936;
const double max_reasonable_speed_in_mph=95;

double compute_velocity_az(double phi)
{
   double az=90-phi;   // measured relative to north rather than east
   az=basic_math::phase_to_canonical_interval(az,0,360);
   return az;
}

twovector compute_forward_velocity(
   int n,const vector<double>& t, 
   const vector<double>& X,const vector<double>& Y)
{
   double forward_Vx=(X[n+1]-X[n])/(t[n+1]-t[n]);
   double forward_Vy=(Y[n+1]-Y[n])/(t[n+1]-t[n]);
   double forward_speed=sqrt(sqr(forward_Vx)+sqr(forward_Vy));
   double forward_phi=atan2(forward_Vy,forward_Vx)*180/PI;
   return twovector(forward_speed,compute_velocity_az(forward_phi));
}

twovector compute_backward_velocity(
   int n,const vector<double>& t, 
   const vector<double>& X,const vector<double>& Y)
{
   double backward_Vx=(X[n]-X[n-1])/(t[n]-t[n-1]);
   double backward_Vy=(Y[n]-Y[n-1])/(t[n]-t[n-1]);
   double backward_speed=sqrt(sqr(backward_Vx)+sqr(backward_Vy));
   double backward_phi=atan2(backward_Vy,backward_Vx)*180/PI;
   return twovector(backward_speed,compute_velocity_az(backward_phi));
}

twovector simply_compute_velocity(
   int n,const vector<double>& t, 
   const vector<double>& X,const vector<double>& Y)
{
   double instantaneous_Vx=(X[n+1]-X[n-1])/(t[n+1]-t[n-1]);
   double instantaneous_Vy=(Y[n+1]-Y[n-1])/(t[n+1]-t[n-1]);
   double instantaneous_speed=sqrt(sqr(instantaneous_Vx)+
                                   sqr(instantaneous_Vy));
   double instantaneous_phi=atan2(instantaneous_Vy,instantaneous_Vx)*180/PI;

// Perform sanity check on instanteous speed in order to identify bad
// GPS data points:

   if (instantaneous_speed*meters_per_second_to_miles_per_hour > 
      max_reasonable_speed_in_mph)
   {
      twovector forward_velocity=compute_forward_velocity(n,t,X,Y);
      twovector backward_velocity=compute_backward_velocity(n,t,X,Y);

      double Delta_t=t[n]-t[0];
//      cout << "Delta_t = " << Delta_t
//           << " i_speed = " << instantaneous_speed 
//           << " f_speed = " << forward_speed
//           << " b_speed = " << backward_speed
//           << endl;

      if (forward_velocity.get(0) < backward_velocity.get(0))
      {
         instantaneous_speed=forward_velocity.get(0);
         instantaneous_phi=forward_velocity.get(1);
      }
      else
      {
         instantaneous_speed=backward_velocity.get(0);
         instantaneous_phi=backward_velocity.get(1);
      }

//      cout << "new speed mph = " 
//           << instantaneous_speed*meters_per_second_to_miles_per_hour
//           << endl;
   }

   return twovector(
      instantaneous_speed,compute_velocity_az(instantaneous_phi));
}

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
      
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(10);

// Open Postgres database containing Bluegrass track information:

   string hostname="localhost";
   string database_name="bluegrass_dsa2";
   string username="postgres";
   postgis_database* tracks_database_ptr=new postgis_database(
      hostname,database_name,username);

   if (!tracks_database_ptr->get_connection_status_flag())
   {
      cout << "Tracks database not opened" << endl;
      exit(-1);
   }

// Iteratively read in results generated by Delsey for Query #1 from a
// flat file.  

//    string query1_results_filename="final_ids_and_dates.dat";
   string query1_results_filename="mini_ids_and_dates.dat";
//   string query1_results_filename="track_ids_and_dates.dat";
//   string query1_results_filename="track_ids_and_dates_10.dat";
//   string query1_results_filename="track_ids_and_dates_50.dat";
//   string query1_results_filename="track_ids_and_dates_40.dat";
//   string query1_results_filename="track_ids_and_dates_20.dat";
//   string query1_results_filename="track_ids_and_dates_10b.dat";
//   string query1_results_filename="track_ids_and_dates_10c.dat";
//   string query1_results_filename="track_ids_and_dates_rest.dat";
   filefunc::ReadInfile(query1_results_filename);
   for (int iter=0; iter<filefunc::text_line.size(); iter++)
   {
      outputfunc::write_big_banner(
         "Iteration "+stringfunc::number_to_string(iter));
      
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[iter]);
      string entity_id_str=substrings[0];
      string vehicle_label_str=substrings[1];
      string day_str=substrings[2];

      int day=stringfunc::string_to_number(day_str);
      if (day != 27) continue;

      cout << "vehicle_label = " << vehicle_label_str << endl;
      cout << "day = " << day_str << endl;

// Run Query #1 to get the list of tracks to run through:

/*
  string select_command=
  "select a.id as entity_id, a.value as vehicle_id, EXTRACT(DAY FROM c.dt_start) as day_of_month, count(*) as n_track_points";
   
  select_command += " from attribute as a, entity as e, coverage as c";
  select_command += " where a.id = e.id";
  select_command += " and e.id = c.id";
  select_command += " and a.name = 'id_bg'";
  select_command += " and e.type = 'vehicle'";
  select_command += " group by entity_id, vehicle_id, day_of_month";
  select_command += " order by vehicle_id, day_of_month";
*/

// Query #2 will return data in an input format suitable for your C++
// velocity calculation routines.  Loop thru vehicle tracks and run it
// once for each track, making substitutions as indicated

      string select_command = 
         "select extract(EPOCH FROM dt_start) as time, y(geometry) as lat,";
      select_command += 
         "x(geometry) as lon from coverage where name = 'gps' ";
      select_command += 
         "and id = (select id from attribute where name='id_bg'";

      select_command += "and value='"+vehicle_label_str+"')";
      select_command += " and dt_start >= '2007-09-"+day_str+" 16:00:00-00'";
      select_command += " and dt_start <= '2007-09-"+day_str+" 17:00:00-00'";
//      select_command += " and dt_start >= '2007-09-"+day_str+" 00:00:00-05'";
//      select_command += " and dt_start <= '2007-09-"+day_str+" 23:59:59-05'";
      select_command += " order by time";
//      cout << "select_command = " << select_command << endl;

      vector<string> commands;
      commands.push_back(select_command);

      tracks_database_ptr->set_SQL_commands(commands);
      tracks_database_ptr->execute_SQL_commands();

      Genarray<string>* field_array_ptr=tracks_database_ptr->
         get_field_array_ptr();
//      cout << "*field_array_ptr = " << *field_array_ptr << endl;

      vector<double> orig_t,latitude,longitude,orig_X,orig_Y;
      for (int i=0; i<field_array_ptr->get_mdim(); i++)
      {
         bool valid_database_entry=true;
         orig_t.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,0)));
         latitude.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,1)));
         longitude.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,2)));
      } // loop over index i labeling time 

   
//      for (int i=0; i<orig_t.size(); i++)
//      {
//         cout << orig_t[i] << "  "
//              << latitude[i] << "  "
//              << longitude[i] << endl;
//      }

// Start processing track info pulled from database:

      vector<threevector> posn;
      for (int i=0; i<orig_t.size(); i++)
      {
         const int specified_UTM_zonenumber=14;	// Lubbock, TX
         geopoint curr_geopoint(longitude[i],latitude[i],0,
                                specified_UTM_zonenumber);

         const double altitude=0;
         threevector curr_posn(curr_geopoint.get_UTM_easting(),
                               curr_geopoint.get_UTM_northing(),
                               altitude);
         posn.push_back(curr_posn);
         orig_X.push_back(curr_posn.get(0));
         orig_Y.push_back(curr_posn.get(1));
//         cout << i << "  "
//              << orig_t[i] << "  "
//              << longitude[i] << "  "
//              << latitude[i] << "  "
//              << curr_posn.get(0) << "  "
//              << curr_posn.get(1) << "  "
//              << endl;
      }

// Resample initial irregularly time-spaced GPS positions onto a
// regular temporal grid:

      piecewise_linear_vector track_piecewise(orig_t,posn);
      vector<double> t_reg,X,Y;
      vector<threevector> posn_reg;

      double t_start=orig_t[0];
      double t_stop=orig_t.back();
      double delta_t=1;	// secs
//      double delta_t=2.5;	// secs
      int n_timesteps=(t_stop-t_start)/delta_t+1;
      cout << "t_start = " << t_start << " t_stop = " << t_stop
           << " n_timesteps = " << n_timesteps << endl;

      for (int n=0; n<n_timesteps; n++)
      {
         double curr_t=t_start+n*delta_t;
         t_reg.push_back(curr_t);
         threevector curr_posn=track_piecewise.value(curr_t);
         posn_reg.push_back(curr_posn);
         X.push_back(curr_posn.get(0));
         Y.push_back(curr_posn.get(1));
         
//         cout << n << "  "
//              << t_reg.back() << "  "
//              << posn_reg.back().get(0) << "  "
//              << posn_reg.back().get(1) << "  "
//              << endl;
      }

// Set std_dev of gaussian filter to 2 secs which seems like a
// reasonable time scale for vehicle velocity changes:

      double std_dev=2;	// secs
      int nsize=filterfunc::gaussian_filter_size(std_dev,delta_t);
      int deriv_order=1;
      vector<double> filter=filterfunc::gaussian_filter(
         nsize,deriv_order,std_dev,delta_t);

      for (int i=0; i<filter.size(); i++)
      {
         filter[i]=-delta_t*filter[i];
//         cout << "i = " << i
//              << " filter[i] = " << filter[i] << endl;
      }

// Perform brute-force convolution of 1st derivative of gaussian with
// resampled truth track positions:

      vector<double> Vx_filtered,Vy_filtered;
      bool wrap_around_input_values=false;
      filterfunc::brute_force_filter(
         X,filter,Vx_filtered,wrap_around_input_values);
      filterfunc::brute_force_filter(
         Y,filter,Vy_filtered,wrap_around_input_values);

// Since derivative computation at very beginning and end of time
// sequence is corrupted, we simply copy the initial and final
// reasonable Vx and Vy values into these extremal bins:

      int n_endpoints=filter.size()/2;
      for (int n=0; n<n_endpoints; n++)
      {
         Vx_filtered[n]=Vx_filtered[n_endpoints];
         Vy_filtered[n]=Vy_filtered[n_endpoints];
         Vx_filtered[n_timesteps-1-n]=Vx_filtered[n_timesteps-1-n_endpoints];
         Vy_filtered[n_timesteps-1-n]=Vy_filtered[n_timesteps-1-n_endpoints];
      }

// Compute speed and velocity direction angles (measured wrt east in
// degrees).  Store results within STL vector velocity_mag_and_dir:


// Measure truth track Eastings & Northings relative to the Lubbock
// grid origin:

         const threevector Lubbock_grid_origin(
            214492.974265,3700955.23891,946.471009101);


      Clock clock;
      vector<threevector> velocity_mag_and_dir;
      for (int n=0; n<n_timesteps; n++)
      {
         clock.convert_elapsed_secs_to_date(t_reg[n]);

         double speed=sqrt(sqr(Vx_filtered[n])+sqr(Vy_filtered[n]));

//         cout << n << "  "
         cout << t_reg[n]-t_start << "  "
//              << clock.YYYY_MM_DD_H_M_S() << " "
              << X[n]-Lubbock_grid_origin.get(0) << "  "
              << Y[n]-Lubbock_grid_origin.get(1) << "  "
              << Vx_filtered[n] << " "
              << Vy_filtered[n] << " "
//                 << speed*meters_per_second_to_miles_per_hour << " "
              << endl;
//            outputfunc::enter_continue_char();
//            speed=instantaneous_speed;

      } // loop over index n labeling time steps

   } // loop over iter for each row in track_ids_and_dates.dat file

   tracks_database_ptr->disconnect();
}

   
