// ==========================================================================
// Program TRUTH_VELOCITIES is a specialized utility for computing
// Bluegrass truth vehicle velocity vectors.  It first reads in track
// metadata from a flat file previously generated by Delsey.  It then
// iterates over each Bluegrass truth track which are generally
// irregularly sampled in time.

// The program regrids each raw truth track's data onto a regularly
// sampled piecewise_linear object.  This program next instantiates a
// 1st derivative of a gaussian filter and performs a brute-force
// convolution with the regularly resampled truth track.  After
// instantaneous speeds and velocity directions are calculated at the
// regularly sampled times, a 2nd piecewise linear object is
// instantiated in order to interpolate their values onto the original
// irregularly-spaced time samples.  

// Finally, the velocity information is inserted into a new database
// table created by Delsey via a SQL call.

// ==========================================================================
// Last updated on 6/19/08; 6/20/08; 6/25/08; 6/26/08; 7/12/08
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>
#include "astro_geo/Clock.h"
#include "general/filefuncs.h"
#include "filter/filterfuncs.h"
#include "astro_geo/geopoint.h"
#include "math/mathfuncs.h"
#include "filter/piecewise_linear_vector.h"
#include "general/outputfuncs.h"
#include "osg/osgGIS/postgis_database.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ofstream;
using std::string;
using std::vector;

//   1 m/s = 2.23693 miles/hour

const double meters_per_second_to_miles_per_hour=2.236936;
const double max_reasonable_speed_in_mph=95;

double compute_velocity_az(double phi)
{
   double az=90-phi;   // measured relative to north rather than east
   az=basic_math::phase_to_canonical_interval(az,0,360);
   return az;
}

twovector compute_forward_velocity(
   int n,const vector<double>& t, 
   const vector<double>& X,const vector<double>& Y)
{
   double forward_Vx=(X[n+1]-X[n])/(t[n+1]-t[n]);
   double forward_Vy=(Y[n+1]-Y[n])/(t[n+1]-t[n]);
   double forward_speed=sqrt(sqr(forward_Vx)+sqr(forward_Vy));
   double forward_phi=atan2(forward_Vy,forward_Vx)*180/PI;
   return twovector(forward_speed,compute_velocity_az(forward_phi));
}

twovector compute_backward_velocity(
   int n,const vector<double>& t, 
   const vector<double>& X,const vector<double>& Y)
{
   double backward_Vx=(X[n]-X[n-1])/(t[n]-t[n-1]);
   double backward_Vy=(Y[n]-Y[n-1])/(t[n]-t[n-1]);
   double backward_speed=sqrt(sqr(backward_Vx)+sqr(backward_Vy));
   double backward_phi=atan2(backward_Vy,backward_Vx)*180/PI;
   return twovector(backward_speed,compute_velocity_az(backward_phi));
}

twovector simply_compute_velocity(
   int n,const vector<double>& t, 
   const vector<double>& X,const vector<double>& Y)
{
   double instantaneous_Vx=(X[n+1]-X[n-1])/(t[n+1]-t[n-1]);
   double instantaneous_Vy=(Y[n+1]-Y[n-1])/(t[n+1]-t[n-1]);
   double instantaneous_speed=sqrt(sqr(instantaneous_Vx)+
                                   sqr(instantaneous_Vy));
   double instantaneous_phi=atan2(instantaneous_Vy,instantaneous_Vx)*180/PI;

// Perform sanity check on instanteous speed in order to identify bad
// GPS data points:

   if (instantaneous_speed*meters_per_second_to_miles_per_hour > 
      max_reasonable_speed_in_mph)
   {
      twovector forward_velocity=compute_forward_velocity(n,t,X,Y);
      twovector backward_velocity=compute_backward_velocity(n,t,X,Y);

//      double Delta_t=t[n]-t[0];
//      cout << "Delta_t = " << Delta_t
//           << " i_speed = " << instantaneous_speed 
//           << " f_speed = " << forward_speed
//           << " b_speed = " << backward_speed
//           << endl;

      if (forward_velocity.get(0) < backward_velocity.get(0))
      {
         instantaneous_speed=forward_velocity.get(0);
         instantaneous_phi=forward_velocity.get(1);
      }
      else
      {
         instantaneous_speed=backward_velocity.get(0);
         instantaneous_phi=backward_velocity.get(1);
      }

//      cout << "new speed mph = " 
//           << instantaneous_speed*meters_per_second_to_miles_per_hour
//           << endl;
   }

   return twovector(
      instantaneous_speed,compute_velocity_az(instantaneous_phi));
}

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
      
   std::set_new_handler(sysfunc::out_of_memory);
   cout.precision(10);

// Open Postgres database containing Bluegrass track information:

   string hostname="localhost";
   string database_name="bluegrass_dsa2";
   string username="postgres";
   postgis_database* tracks_database_ptr=new postgis_database(
      hostname,database_name,username);

   if (!tracks_database_ptr->get_connection_status_flag())
   {
      cout << "Tracks database not opened" << endl;
      exit(-1);
   }

// Iteratively read in results generated by Delsey for Query #1 from a
// flat file.  

//    string query1_results_filename="final_ids_and_dates.dat";
//   string query1_results_filename="mini_ids_and_dates.dat";
   string query1_results_filename="track_ids_and_dates_clean.dat";
//   string query1_results_filename="track_ids_and_dates.dat";
//   string query1_results_filename="track_ids_and_dates_10.dat";
//   string query1_results_filename="track_ids_and_dates_50.dat";
//   string query1_results_filename="track_ids_and_dates_40.dat";
//   string query1_results_filename="track_ids_and_dates_20.dat";
//   string query1_results_filename="track_ids_and_dates_10b.dat";
//   string query1_results_filename="track_ids_and_dates_10c.dat";
//   string query1_results_filename="track_ids_and_dates_rest.dat";
   filefunc::ReadInfile(query1_results_filename);

   for (unsigned int iter=0; iter<filefunc::text_line.size(); iter++)
   {
      outputfunc::write_big_banner(
         "Iteration "+stringfunc::number_to_string(iter));

      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[iter]);
      string entity_id_str=substrings[0];
      string vehicle_label_str=substrings[1];
      string epoch_start_str=substrings[2];
      string epoch_stop_str=substrings[3];
      string n_track_points_str=substrings[4];
//      string day_str=substrings[2];
      cout << "entity_id = " << entity_id_str << endl;
      cout << "vehicle_label = " << vehicle_label_str << endl;
//      cout << "day = " << day_str << endl;
      cout << "epoch_start = " << epoch_start_str << endl;
      cout << "epoch_stop = " << epoch_stop_str << endl;
      cout << "n_track_points = " << n_track_points_str << endl;

// Run Query #1 to get the list of tracks to run through:

/*
  string select_command=
  "select a.id as entity_id, a.value as vehicle_id, EXTRACT(DAY FROM c.dt_start) as day_of_month, count(*) as n_track_points";
   
  select_command += " from attribute as a, entity as e, coverage as c";
  select_command += " where a.id = e.id";
  select_command += " and e.id = c.id";
  select_command += " and a.name = 'id_bg'";
  select_command += " and e.type = 'vehicle'";
  select_command += " group by entity_id, vehicle_id, day_of_month";
  select_command += " order by vehicle_id, day_of_month";
*/

// Query #2 will return data in an input format suitable for your C++
// velocity calculation routines.  Loop thru vehicle tracks and run it
// once for each track, making substitutions as indicated

      string select_command = 
         "select extract(EPOCH FROM dt_start) as time, y(geometry) as lat,";
      select_command += 
         "x(geometry) as lon from coverage where name = 'gps' ";
      select_command += 
         "and id = (select id from attribute where name='id_bg'";

      select_command += "and value='"+vehicle_label_str+"') ";
//      select_command += " and dt_start >= '2007-09-"+day_str+" 16:00:00-00'";
//      select_command += " and dt_start <= '2007-09-"+day_str+" 17:00:00-00'";
//      select_command += " and dt_start >= '2007-09-"+day_str+" 00:00:00-05'";
//      select_command += " and dt_start <= '2007-09-"+day_str+" 23:59:59-05'";
      select_command += 
         "and dt_start >= (select TIMESTAMP WITH TIME ZONE 'epoch' + "
         +epoch_start_str+" * INTERVAL '1 second') ";
      select_command += 
         "and dt_start <= (select TIMESTAMP WITH TIME ZONE 'epoch' + "
         +epoch_stop_str+ " * INTERVAL '1 second') ";
      select_command += " order by time";
//      cout << "select_command = " << select_command << endl;

      vector<string> commands;
      commands.push_back(select_command);

      tracks_database_ptr->set_SQL_commands(commands);
      tracks_database_ptr->execute_SQL_commands();

      Genarray<string>* field_array_ptr=tracks_database_ptr->
         get_field_array_ptr();
//      cout << "*field_array_ptr = " << *field_array_ptr << endl;

      vector<double> orig_t,latitude,longitude,orig_X,orig_Y;
      for (unsigned int i=0; i<field_array_ptr->get_mdim(); i++)
      {
//         bool valid_database_entry=true;
         orig_t.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,0)));
         latitude.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,1)));
         longitude.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,2)));
      } // loop over index i labeling time 

   
//      for (int i=0; i<orig_t.size(); i++)
//      {
//         cout << orig_t[i] << "  "
//              << latitude[i] << "  "
//              << longitude[i] << endl;
//      }

// Start processing track info pulled from database:

      vector<threevector> posn;
      for (unsigned int i=0; i<orig_t.size(); i++)
      {
         const int specified_UTM_zonenumber=14;	// Lubbock, TX
         geopoint curr_geopoint(longitude[i],latitude[i],0,
                                specified_UTM_zonenumber);

         const double altitude=0;
         threevector curr_posn(curr_geopoint.get_UTM_easting(),
                               curr_geopoint.get_UTM_northing(),
                               altitude);
         posn.push_back(curr_posn);
         orig_X.push_back(curr_posn.get(0));
         orig_Y.push_back(curr_posn.get(1));
//         cout << i << "  "
//              << orig_t[i] << "  "
//              << longitude[i] << "  "
//              << latitude[i] << "  "
//              << curr_posn.get(0) << "  "
//              << curr_posn.get(1) << "  "
//              << endl;
      }

// Resample initial irregularly time-spaced GPS positions onto a
// regular temporal grid:

      piecewise_linear_vector track_piecewise(orig_t,posn);
      vector<double> t_reg,X,Y;
      vector<threevector> posn_reg;

      double t_start=orig_t[0];
      double t_stop=orig_t.back();
//   double delta_t=1;	// secs
      double delta_t=2.5;	// secs
      int n_timesteps=(t_stop-t_start)/delta_t+1;
//      cout << "t_start = " << t_start << " t_stop = " << t_stop
//           << " n_timesteps = " << n_timesteps << endl;

      for (int n=0; n<n_timesteps; n++)
      {
         double curr_t=t_start+n*delta_t;
         t_reg.push_back(curr_t);
         threevector curr_posn=track_piecewise.value(curr_t);
         posn_reg.push_back(curr_posn);
         X.push_back(curr_posn.get(0));
         Y.push_back(curr_posn.get(1));
         
//         cout << n << "  "
//              << t_reg.back() << "  "
//              << posn_reg.back().get(0) << "  "
//              << posn_reg.back().get(1) << "  "
//              << endl;
      }

// Set std_dev of gaussian filter to 2 secs which seems like a
// reasonable time scale for vehicle velocity changes:

      double std_dev=2;	// secs
      int nsize=filterfunc::gaussian_filter_size(std_dev,delta_t);
      int deriv_order=1;
      vector<double> filter=filterfunc::gaussian_filter(
         nsize,deriv_order,std_dev,delta_t);

      for (unsigned int i=0; i<filter.size(); i++)
      {
         filter[i]=-delta_t*filter[i];
//         cout << "i = " << i
//              << " filter[i] = " << filter[i] << endl;
      }

// Perform brute-force convolution of 1st derivative of gaussian with
// resampled truth track positions:

      vector<double> Vx_filtered,Vy_filtered;
      bool wrap_around_input_values=false;
      filterfunc::brute_force_filter(
         X,filter,Vx_filtered,wrap_around_input_values);
      filterfunc::brute_force_filter(
         Y,filter,Vy_filtered,wrap_around_input_values);

// Since derivative computation at very beginning and end of time
// sequence is corrupted, we simply copy the initial and final
// reasonable Vx and Vy values into these extremal bins:

      int n_endpoints=filter.size()/2;
      for (int n=0; n<n_endpoints; n++)
      {
         Vx_filtered[n]=Vx_filtered[n_endpoints];
         Vy_filtered[n]=Vy_filtered[n_endpoints];
         Vx_filtered[n_timesteps-1-n]=Vx_filtered[n_timesteps-1-n_endpoints];
         Vy_filtered[n_timesteps-1-n]=Vy_filtered[n_timesteps-1-n_endpoints];
      }

// Compute speed and velocity direction angles (measured wrt east in
// degrees).  Store results within STL vector velocity_mag_and_dir:

      Clock clock;
      vector<threevector> velocity_mag_and_dir;
      for (int n=0; n<n_timesteps; n++)
      {
         clock.convert_elapsed_secs_to_date(t_reg[n]);

         double speed=sqrt(sqr(Vx_filtered[n])+sqr(Vy_filtered[n]));
         double phi=atan2(Vy_filtered[n],Vx_filtered[n])*180/PI;
         double azimuth=compute_velocity_az(phi);
         threevector curr_velocity_mag_dir(speed,azimuth);
         
/*
         threevector curr_velocity_mag_dir;
         if (n==0)
         {
            curr_velocity_mag_dir=compute_forward_velocity(n,t_reg,X,Y);
         }
         else if (n==n_timesteps-1)
         {
            curr_velocity_mag_dir=compute_backward_velocity(n,t_reg,X,Y);
         }
         else
         {
            curr_velocity_mag_dir=simply_compute_velocity(n,t_reg,X,Y);

//            cout << n << "  "
//                 << t_reg[n] << "  "
//                 << clock.YYYY_MM_DD_H_M_S() << " "
//                 << X[n] << "  "
//                 << Y[n] << "  "
//                 << Vx_filtered[n] << " "
//                 << Vy_filtered[n] << " "
//                 << speed*meters_per_second_to_miles_per_hour << " "
//                 << endl;
//            outputfunc::enter_continue_char();
//            speed=instantaneous_speed;
         } //  1 <= n <= n_timesteps-2
*/

         velocity_mag_and_dir.push_back(curr_velocity_mag_dir);
//         cout << n << "  "
//           << t_reg[n] << "  "
//              << clock.YYYY_MM_DD_H_M_S() << " "
//           << X[n] << "  "
//           << Y[n] << "  "
//              << Vx_filtered[n] << " "
//              << Vy_filtered[n] << " "
//              << speed*meters_per_second_to_miles_per_hour << " "
//              << phi
//		<< azimuth
//              << endl;
      } // loop over index n labeling time steps
      velocity_mag_and_dir[0]=velocity_mag_and_dir[1];
      velocity_mag_and_dir[n_timesteps-1]=velocity_mag_and_dir[n_timesteps-2];

// Instantiate 2nd piecewise_linear object holding filtered velocity
// magnitudes and directions:

      piecewise_linear_vector velocity_piecewise(t_reg,velocity_mag_and_dir);

// Store velocity magnitudes and directions into new database table:

//   vector<double> orig_t,latitude,longitude;

// -- speed = m/s, azimuth = decimal degrees clockwise from north

//    string entity_id_str="3ae1712c-1ede-4b77-8222-f10bd249c22c";	// V157
      string name="gps";

      for (unsigned int i=0; i<orig_t.size(); i++)
//      for (int i=0; i<5; i++)
      {
         double curr_orig_t=orig_t[i];
//          double Delta_t=curr_orig_t-orig_t[0];
         threevector curr_velocity_mag_and_dir=
            velocity_piecewise.value(curr_orig_t);
//         cout << i << "  "
//              << curr_orig_t << "  "
//              << curr_velocity_mag_and_dir.get(0) << "  "
//              << curr_velocity_mag_and_dir.get(1) 
//              << endl;

// Perform last-gasp sanity check on speeds:

         bool bad_point_flag=false;
         double speed_mph=curr_velocity_mag_and_dir.get(0)*
            meters_per_second_to_miles_per_hour;
         if (speed_mph > max_reasonable_speed_in_mph)
         {

// FAKE FAKE:  for bad point detection comment out next line...
// Thur, Jun 26 at 1:15 pm...

//            curr_velocity_mag_and_dir=
//               simply_compute_velocity(i,orig_t,orig_X,orig_Y);
            bad_point_flag=true;
         }
         speed_mph=curr_velocity_mag_and_dir.get(0)*
            meters_per_second_to_miles_per_hour;

// Following strings will actually vary with loop iteration:
   
         string curr_time_str=stringfunc::number_to_string(curr_orig_t);
         string longitude_str=stringfunc::number_to_string(longitude[i],6);
         string latitude_str=stringfunc::number_to_string(latitude[i],6);
         string speed_str=stringfunc::number_to_string(
            curr_velocity_mag_and_dir.get(0));
         string azimuth_str=stringfunc::number_to_string(
            curr_velocity_mag_and_dir.get(1));

         string speed_warning="";
         if (speed_mph > max_reasonable_speed_in_mph)
         {
            speed_warning = " *** ";
         }

         if (bad_point_flag)
         {
            cout << "t = " << curr_time_str
                 << " long = " << longitude_str
                 << " lat = " << latitude_str 
                 << " speed (mph) = " << speed_mph
//                 <<  speed_warning 
//                 << " speed = " << speed_str
//                 << " az = " << azimuth_str 
                 << endl;
         }
         
//         cout << "Delta t = " << Delta_t
//         cout << "t = " << curr_time_str
//              << " long = " << longitude_str
//              << " lat = " << latitude_str 
//              << " X = " << posn[i].get(0)
//              << " Y = " << posn[i].get(1)
//              << " speed_mph = " << speed_mph
//              <<  speed_warning 
//              << " speed = " << speed_str
//              << " az = " << azimuth_str 
//              << endl;

         string insert_command=
            "insert into coverage_track (id, name, dt, speed, azimuth, geometry) ";
         insert_command += "values ( ";
         insert_command += "'"+entity_id_str+"','"+name+"', ";
         insert_command += "(select TIMESTAMP WITH TIME ZONE 'epoch' + ";
         insert_command += curr_time_str+" * INTERVAL '1 second'),";
         insert_command += speed_str+","+azimuth_str+",";
         insert_command += "GeomFromEWKT('SRID=4326;POINT("+
            longitude_str+" "+latitude_str+")') );";
//         cout << "insert_command = " << insert_command << endl;
      
         commands.clear();
         commands.push_back(insert_command);

         tracks_database_ptr->set_SQL_commands(commands);
         tracks_database_ptr->execute_SQL_commands();

      } // loop over index i labeling original times

   } // loop over iter for each row in track_ids_and_dates.dat file

   tracks_database_ptr->disconnect();
}

   
