// ========================================================================
// Program EXTRACT_FEATURES imports LMDB database files generated by
// caffe's file extraction binary.  It retrieves each "gist-like"
// global descriptor and exports their contents to output text file
// "global_features.dat".

//			./extract_features

// ========================================================================
// Last updated on 2/10/16; 2/12/16; 2/14/16
// ========================================================================

#include <iostream>
#include <string>
#include <vector>
#include <lmdb++.h>
#include "caffe/proto/caffe.pb.h"
#include "math/basic_math.h"
#include "general/filefuncs.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

// ------------------------------------------------------------------
// Method extract_normalized_feature_vectors() retrieves feature
// descriptors stored within the input lmdb database.  It computes the
// l2-magnitude of each descriptor and returns feature vectors with
// unit l2-norm within an STL vector of vectors.

int extract_normalized_feature_vectors(
   lmdb::txn& rtxn, lmdb::dbi &dbi, vector<vector<float> >& feature_vectors)
{
   string key, value;
   int n_feature_dims = 0;
   auto cursor = lmdb::cursor::open(rtxn, dbi);

   while (cursor.get(key, value, MDB_NEXT)) 
   {
      caffe::Datum curr_datum;
      curr_datum.ParseFromString(value);
      vector<float> curr_feature_vector;
      n_feature_dims = curr_datum.channels();
      double sqrd_mag = 0;
      for (int j = 0; j < n_feature_dims; j++)
      {
         double curr_data_value = curr_datum.float_data(j);

// Recall Andrej Karpathy's hint: We need to apply "ReLU" operation to
// fc7 feature vectors!

         if(curr_data_value < 0)
         {
            cout << "curr_data_value = " << curr_data_value << endl;
            curr_data_value = 0;
         }
         
         curr_feature_vector.push_back(curr_data_value);
         sqrd_mag += sqr(curr_data_value);
      }
      double mag = sqrt(sqrd_mag);
      for (int j = 0; j < n_feature_dims; ++j)
      {

        if(j < 10)
        {
           cout << "j = " << j << " feature_vec[j] = "
                << curr_feature_vector[j] << endl;
        }
         curr_feature_vector[j] = curr_feature_vector[j] / mag;
      } // loop over index j
      cout << endl;
      feature_vectors.push_back(curr_feature_vector);
   }

   cursor.close();

   return n_feature_dims;
}

// ------------------------------------------------------------------

int main() 
{
   string software_subdir = "/home/pcho/software/";
   string caffe_subdir = software_subdir+"caffe_custom/";
   string _temp_subdir = caffe_subdir+"examples/_temp/";
   //   string features_subdir = "features_roadsigns2/140K/";
   string features_subdir = "features_roadsigns2/4_chips/";
  
/*
  cout << "Enter relative path to subdir of ./examples/_temp/ " << endl;
  cout << " containing extracted caffe features in lmdb database format: " << endl;
   cout << "  (e.g. features_tidmarsh )" << endl;

   
   cin >> features_subdir;
*/

   filefunc::add_trailing_dir_slash(features_subdir);
   features_subdir = _temp_subdir+features_subdir;
   cout << "Full features_subdir = " << features_subdir << endl;

   string files_list = features_subdir + "file_list.txt";
   filefunc::ReadInfile(files_list);

   // Create and open the LMDB environment:

   auto env = lmdb::env::create();
   env.set_mapsize(1UL * 1024UL * 1024UL *  1024UL); // 1 GiB 
   env.open(features_subdir.c_str(), 0, 0664);
   
   // Fetch key/value pairs in a read-only transaction: 

   auto rtxn = lmdb::txn::begin(env, nullptr, MDB_RDONLY);
   auto dbi = lmdb::dbi::open(rtxn, nullptr);

   timefunc::initialize_timeofday_clock();

   vector<vector<float> > feature_vectors;
   int n_feature_dims = extract_normalized_feature_vectors(
      rtxn, dbi, feature_vectors);
   int n_feature_vectors = feature_vectors.size();
   cout << "n_feature_dims = " << n_feature_dims << endl;
   cout << "n_feature_vectors = " << n_feature_vectors << endl;
   outputfunc::print_elapsed_time();

   rtxn.abort();

// Open text file for extracted features:

   string banner="Exporting features:";
   outputfunc::write_banner(banner);
   string features_filename = features_subdir + "global_features.dat";
   ofstream features_stream;
   filefunc::openfile(features_filename, features_stream);

   features_stream << n_feature_vectors << " " << n_feature_dims << endl;
   for(int f = 0; f <  n_feature_vectors; f++)
   {
      for(int i = 0; i < n_feature_dims; i++)
      {
         features_stream << feature_vectors[f].at(i) << " ";
      }
      features_stream << endl;
   } // loop over index f labeling feature vectors

   filefunc::closefile(features_filename, features_stream);

   banner="Exported features to "+features_filename;
   outputfunc::write_banner(banner);
}
