// ====================================================================
// Program GENERATE_DEEPLAB_INPUTS imports an XML file generated by
// Davis King's IMGLAB program that contains bounding boxes around
// objects (e.g. human faces) for some set of trained images.  Each
// annotated image is decomposed into a set of tiles with pixel
// dimensions deeplab_tile_size x deeplab_tile_size.  Border tiles are
// padded as necessary with zero values so that an integer number of
// tiles are generated for each input image.  

// For each tile, a mask written to an 8-bit greyscale PNG file
// is created whose background value = 0 and foreground value = 1 [,
// 2, 3, 4...].  Exported image tiles become inputs to Deeplab's
// CNN, while the masks become inputs to Deeplab's loss function.
// GENERATE_DEEPLAB_INPUTS also writes out text files containing
// associations between image tiles and masks.  It randomly shuffles
// the associations and then splits them into training and testing
// sets.

/*

~/programs/c++/svn/projects/src/mains/machine_learning/deeplab/generate_deeplab_inputs \
all_images.xml

*/

// ====================================================================
// Last updated on 1/5/16; 1/6/16; 1/10/16; 1/13/16; 5/6/16
// ====================================================================

#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include <dlib/array.h>
#include <dlib/array2d.h>
#include <dlib/gui_widgets.h>
#include <dlib/image_processing.h>
#include <dlib/cmd_line_parser.h>
#include <dlib/data_io.h>

#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::exception;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

int main(int argc, char** argv)
{  
   timefunc::initialize_timeofday_clock(); 

//    bool visualize_masks_flag = true;
   bool visualize_masks_flag = false;
   
// Recall image chips and masks should equal 321x321 in pixel size
// in order to meet deeplab's GPU card and batch size memory
// requirements:

   int deeplab_tile_size = 321;	

   string basedir = "/data/TrainingImagery/faces/";
   string deeplab_inputs_subdir = basedir+"deeplab_inputs/";
   string tiles_subdir=deeplab_inputs_subdir+"tiles/";
   string full_masks_subdir=deeplab_inputs_subdir+"full_masks/";
   string eightbit_masks_subdir=deeplab_inputs_subdir+"eightbit_masks/";
   filefunc::dircreate(deeplab_inputs_subdir);
   filefunc::dircreate(tiles_subdir);
   filefunc::dircreate(eightbit_masks_subdir);
   if (visualize_masks_flag) filefunc::dircreate(full_masks_subdir);

   dlib::command_line_parser parser;
   parser.parse(argc, argv);

   dlib::array<dlib::array2d<unsigned char> > images;
   vector<vector<dlib::rectangle> > object_locations;

   if (parser.number_of_arguments() != 1)
   {
      cout << "Specify XML file with training data!" << endl;
      return 1;
   }

   dlib::image_dataset_file img_dataset_file(parser[0]);
   cout << "image_dataset_file.filename = " << img_dataset_file.get_filename()
        << endl;
   dlib::image_dataset_metadata::dataset data;
   dlib::image_dataset_metadata::load_image_dataset_metadata(
      data, img_dataset_file.get_filename());

   // 3rd argument below is label entered with bboxes
   // 4th argument below is true only when we want to ignore all images
   // with NO bboxes

// FAKE FAKE: Tues Jan 5, 2016 Need to generalize this next line!
// Should read in object class labels from Davis' XML file and store
// in an STL vector of strings...

   string bbox_label="face";

//   bool ignore_images_w_no_bboxes_flag=true;
   bool ignore_images_w_no_bboxes_flag=false;
   vector<vector<dlib::rectangle> > ignored_bboxes=
      dlib::load_image_dataset(
         images, object_locations, parser[0], bbox_label.c_str(),
         ignore_images_w_no_bboxes_flag);

   cout << "images.size(): " << images.size() << endl;
   cout << "object_locations.size() = " << object_locations.size()
        << endl;

   // Compute median bbox aspect ratio:

   int n_objects = 0;
   vector<double> aspect_ratios;
   for (unsigned int i=0; i<object_locations.size(); i++)
   {
      n_objects += object_locations[i].size();
      for (unsigned int r=0; r<object_locations[i].size(); r++)
      {
         int width=object_locations[i].at(r).width();
         int height=object_locations[i].at(r).height();
         aspect_ratios.push_back(double(width)/double(height));
      } // loop over index r labeling bboxes for ith training image
   } // loop over index i labeling training images
   cout << "Number of object bboxes = " << n_objects << endl;

   double median_bbox_aspect_ratio=mathfunc::median_value(aspect_ratios);
   cout << "Median bbox aspect ratio = "
        << median_bbox_aspect_ratio << endl;

   // Next command flips images plus their manually selected bboxes.
   // Training set is doubled by this procedure:

//   bool enforce_left_right_symmetry_flag=true;
   bool enforce_left_right_symmetry_flag=false;
   if (enforce_left_right_symmetry_flag)
   {
      dlib::add_image_left_right_flips(
         images,object_locations,ignored_bboxes);
   }

// Export text file containing class names for labeled objects.
// Recall Deeplab expects zeroth class corresponds to background:

   string object_classes_filename=deeplab_inputs_subdir+"object_names.classes";
   ofstream outstream;
   filefunc::openfile(object_classes_filename, outstream);
   outstream << "__background__" << endl;
   outstream << bbox_label << endl;
   filefunc::closefile(object_classes_filename, outstream);

// Store pairs of tile and corresponding mask filenames within an STL
// map:

   typedef pair<string, string> STRING_PAIR;
   typedef std::map<int, vector<STRING_PAIR> > IMAGE_TILES_MAP;
// independent int: image ID
// dependent vector<string,string > : pairs of tile and mask filenames associated with image

   IMAGE_TILES_MAP image_tiles_map;
   IMAGE_TILES_MAP::iterator image_tiles_map_iter;

//   dlib::image_window win;
   unsigned int n_images = images.size();
   unsigned int istart = 0;
   unsigned istop = n_images;
   if(visualize_masks_flag)
   {	
      istop = 5;
      cout << "Only visualize masks for images < istop = " << istop << endl;
   }
   n_images = istop - istart + 1;

   for (unsigned int i = istart; i < istop; i++)
   {
//      Put the image and training bboxes into the window.
//      win.clear_overlay();
//      win.set_image(images[i]);
//      win.add_overlay(object_locations[i],dlib::rgb_pixel(0,255,0));

      cout << "Processing image " << i << " of " << n_images << endl;

      string currimage_filename = data.images[i].filename;
//      cout << "  currimage_filename = " << currimage_filename << endl;

      int xdim = dlib::num_columns(images[i]);
      int ydim = dlib::num_rows(images[i]);
//      cout << "  xdim = " << xdim << " ydim = " << ydim << endl;

      int nx_tiles = xdim / deeplab_tile_size + 1;
      int ny_tiles = ydim / deeplab_tile_size + 1;
//      cout << "  nx_tiles = " << nx_tiles << " ny_tiles = " << ny_tiles
//           << endl;

      unsigned int n_rectangles = object_locations[i].size();
//      cout << "  n_rectangles = " << n_rectangles << endl;

      texture_rectangle curr_tr(currimage_filename, NULL);
      if(curr_tr.get_VideoType() == texture_rectangle::unknown) continue;
      unsigned int img_width = curr_tr.getWidth();
      unsigned int img_height = curr_tr.getHeight();

      texture_rectangle mask_tr(currimage_filename, NULL);
      mask_tr.clear_all_RGB_values();

      if(i%20 == 0)
      {
         double progress_frac = double(i)/double(n_images);
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }

      int max_pdim = 2500;
      if(xdim > max_pdim || ydim > max_pdim)
      {
         cout << "Skipping very large input image" << endl;
         continue;
      }
      
// Paint rectangle regions with mask value:

      int mask_R, mask_G, mask_B;
      if(visualize_masks_flag)
      {
         mask_R = mask_G = mask_B = 128;  
      }
      else
      {
         mask_R = mask_G = mask_B = 1;
      }

      for(unsigned r = 0; r < n_rectangles; r++)
      {
         dlib::rectangle curr_rect = object_locations[i].at(r);
         unsigned int px_min = curr_rect.left();
         unsigned int px_max = curr_rect.right();
         unsigned int py_min = curr_rect.top();
         unsigned int py_max = curr_rect.bottom();

         for(unsigned int py = py_min; py < py_max; py++)
         {
            for(unsigned int px = px_min; px < px_max; px++)
            {
               mask_tr.set_pixel_RGB_values(px, py, mask_R, mask_G, mask_B);
            }
         }
      }

      if (visualize_masks_flag)
      {
         string mask_filename=full_masks_subdir+"mask_"
            +stringfunc::integer_to_string(i,5)+".png";
         mask_tr.write_curr_subframe(
            0, img_width-1, 0, img_height-1,mask_filename);
      }

// On 1/4/16, we learned from Tho that tiles should generally be
// padded so that deleterious border effects upon classification are
// minimized.  We won't worry about this issue for now...

      for(int nx = 0; nx < nx_tiles; nx++)
      {
         string nx_label = stringfunc::integer_to_string(nx, 2);
         unsigned int px_start = nx * deeplab_tile_size;
         unsigned int px_stop = px_start + deeplab_tile_size - 1;
         for(int ny = 0; ny < ny_tiles; ny++)
         {
            string ny_label = stringfunc::integer_to_string(ny, 2);
            unsigned int py_start = ny * deeplab_tile_size;
            unsigned int py_stop = py_start + deeplab_tile_size - 1;
            string image_label = stringfunc::integer_to_string(i,5);
            string curr_tile_filename = tiles_subdir+"tile_"+image_label+"_"+
               nx_label+"_"+ny_label+".jpg";
            curr_tr.write_curr_subframe(px_start, px_stop, py_start, py_stop,
                                        curr_tile_filename);
//            cout << "Exported "+curr_tile_filename << endl;

// Within this innner loop, py = 0 corresponds to the *bottom* row of
// the full image.  Now 
            
            vector<vector<unsigned char> > byte_array;

            for(unsigned int py = py_start; py <= py_stop; py++)
            {
               vector<unsigned char> curr_byte_row;
               for(unsigned int px = px_start; px <= px_stop; px++)
               {

// Set mask values for pixels lying outside borders of current image
// equal to background value 0:

                  unsigned char curr_char = 0;
                  if(visualize_masks_flag)
                  {
                     curr_char = 255;
                  }

                  if(px < img_width && py < img_height)
                  {
                     mask_tr.get_pixel_RGB_values(
                        px, img_height - 1 - py, mask_R, mask_G, mask_B);

// Recall get_pixel_RGB_values() returns a negative value if input pixel
// coordinates are invalid!

                     if(mask_R >= 0)
                     {
                        curr_char = mask_R;
                     }
                  }

                  if (int(curr_char) >= 2 && !visualize_masks_flag)
                  {
                     cout << "px = " << px << " py = " << py 
                          << " curr_char = " << int(curr_char) << endl;
                  }
                  
                  curr_byte_row.push_back( curr_char );
               }
               byte_array.push_back(curr_byte_row);
            }

// Recall zeroth row fed into write_8bit_greyscale_pngfile() must
// correspond to TOP row of the image to be exported to output PNG
// file:
            
            vector<vector<unsigned char > > flipped_byte_array;
            for(unsigned int py = 0; py < byte_array.size(); py++)
            {
               vector<unsigned char> curr_byte_row = 
                  byte_array.at(byte_array.size() - 1 - py);
               flipped_byte_array.push_back(curr_byte_row);
            }
            
            string deeplab_mask_filename = 
               eightbit_masks_subdir+"mask_"+image_label+"_"+
               nx_label+"_"+ny_label+".png";
            videofunc::write_8bit_greyscale_pngfile(
               flipped_byte_array, deeplab_mask_filename);

// Save correspondence between image tile and image mask to STL map:

            int posn = deeplab_inputs_subdir.size() - 1;
            string reduced_tile_filename=curr_tile_filename.substr(
               posn,curr_tile_filename.size()-posn);
            string reduced_mask_filename=deeplab_mask_filename.substr(
               posn,deeplab_mask_filename.size()-posn);

            STRING_PAIR P;
            P.first = reduced_tile_filename;
            P.second = reduced_mask_filename;

            image_tiles_map_iter = image_tiles_map.find(i);
            if(image_tiles_map_iter == image_tiles_map.end()){
              vector<STRING_PAIR> V;
              V.push_back(P);
              image_tiles_map[i] = V;
            }
            else{
              vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
              V_ptr->push_back(P);
            }

         } // loop over index ny labeling vertical tile index
      } // loop over index nx labeling horizontal tile index
   } // loop over index i labeling images

   cout << "image_tiles_map.size() = " << image_tiles_map.size() << endl;

// Take first 80% of randomized image IDs for training and last 20%
// for testing:

   vector<int> random_seq = mathfunc::random_sequence(
      istart, istop, istop - istart + 1);


/*
   const double testing_frac = 0.2;
   int max_testing_samples = 500;
   int n_testing = basic_math::min(int(testing_frac * n_tiles), 
                                   max_testing_samples);
   int n_training = n_tiles - n_testing;
*/

//   const double training_frac = 0.8;
   const double training_frac = 0.9;
   unsigned int n_training = training_frac * n_images;
   cout << "n_training = " << n_training << endl;

   string images_masks_training_filename=deeplab_inputs_subdir+
      "images_masks_training.txt";
   filefunc::openfile(images_masks_training_filename, outstream);   

   for(unsigned int i = 0; i < n_training; i++)
   {
      int curr_image_ID = random_seq[i];
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end()) continue;
      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
      }
   }
   filefunc::closefile(images_masks_training_filename, outstream);

   string images_masks_testing_filename=deeplab_inputs_subdir+
      "images_masks_testing.txt";
   filefunc::openfile(images_masks_testing_filename, outstream);   

   for(unsigned int i = n_training; i < n_images; i++)
   {
      int curr_image_ID = random_seq[i];
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end()) continue;
      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
      }
   }
   filefunc::closefile(images_masks_testing_filename, outstream);

// Recall several authors stress that training and validation data
// sets should be randomized!  As John Wood pointed out, we can use
// the linux utility "shuf" to generate random permutations:

   string shuffled_images_masks_training_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_training.txt";
   string unix_cmd = "shuf "+images_masks_training_filename+" > "+
      shuffled_images_masks_training_filename;
   sysfunc::unix_command(unix_cmd);

   string shuffled_images_masks_testing_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_testing.txt";
   unix_cmd = "shuf "+images_masks_testing_filename+" > "+
      shuffled_images_masks_testing_filename;
   sysfunc::unix_command(unix_cmd);
}

