// ==========================================================================
// Program TRAINING_PERFORMANCE imports a caffe.bin.INFO file generated by
// Deeplab caffe run on a GPU machine.  It plots the 3 accuracy values
// and loss as functions of training epoch number for the training
// set.  It further plots 3 accuracy values as functions of training
// epoch number for the validation set.

//			   training_performance

// ==========================================================================
// Last updated on 10/20/15; 10/21/15; 1/6/15; 1/9/15
// ==========================================================================

#include  <algorithm>
#include  <fstream>
#include  <iostream>
#include  <map>
#include  <set>
#include  <string>
#include  <vector>

#include "math/basic_math.h"
#include "general/filefuncs.h"
#include "plot/metafile.h"
#include "math/mypolynomial.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;


void generate_line_fits(
   const vector<double>& relative_iter, const mypolynomial& a_poly,
   vector<double>& rel_iter, vector<double>& linear_fit)
{
   rel_iter.clear();
   rel_iter.push_back(relative_iter.front());
   rel_iter.push_back(relative_iter.back());
   
   linear_fit.clear();
   linear_fit.push_back(a_poly.value(rel_iter.front()));
   linear_fit.push_back(a_poly.value(rel_iter.back()));
}

// ==========================================================================

int main(int argc, char* argv[])
{
   cout.precision(8);

   int n_images_per_epoch = 2000;	// fast, mini training
//   int n_images_per_epoch = 20000;	// "full" training
   cout << "Enter number of training images per epoch (e.g. 2000 for mini, 20000 for full)"
	<< endl;
   cin >> n_images_per_epoch;

// "Batch" size for training data specified within
// config/vgg128_large_fov/train.prototxt

   int n_images_per_iteration = 30;	

   double n_iters_per_epoch = n_images_per_epoch / n_images_per_iteration; 
					// 66 iters = 1 epoch for 2K images

   double validation_frac = 0.2; //  20% of all labeled images are reserved for validation
   int n_training_images = n_images_per_epoch;
   int n_validation_images = validation_frac / (1 - validation_frac) * n_training_images;

   cout << "n_images_per_epoch = " << n_images_per_epoch << endl;
   cout << "n_images_per_iteration = " << n_images_per_iteration << endl;
   cout << "n_iters_per_epoch = " << n_iters_per_epoch << endl;
   cout << "20 epochs = " << 20 * n_iters_per_epoch << " iterations" << endl;
					// 1333 iters for 2K images

   string log_filename="/data/deeplab/caffe.bin.INFO";
   bool strip_comments_flag = false;
   filefunc::ReadInfile(log_filename, strip_comments_flag);
   cout << "filefunc::text_line.size() = " << filefunc::text_line.size() 
        << endl;

   string solver_type="SGD";
   double curr_epoch, base_learning_rate = -1;
   vector<double> training_epoch;
   vector<double> validation_iter, validation_epoch;
   vector<double> training_accuracy_0, training_accuracy_1, 
      training_accuracy_2;
   vector<double> validation_accuracy_0, validation_accuracy_1, 
      validation_accuracy_2;
   vector<double> loss;
   for(unsigned int i = 0; i < filefunc::text_line.size(); i++)
   {
      vector<string> substrings = stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);

      if(substrings[0] == "base_lr:"){
	base_learning_rate = stringfunc::string_to_number(substrings[1]);
      }
      else if(substrings[0] == "solver_type:"){
	solver_type = substrings[1];
      }

      if(substrings.size() < 8) continue;

      if(substrings[4] == "Iteration"){
	int curr_iteration_number = stringfunc::string_to_number(
           substrings[5]);
	curr_epoch = curr_iteration_number / n_iters_per_epoch;
      }

      if(substrings[6] == "loss" && substrings[7] == "=")
      {
	double curr_loss = stringfunc::string_to_number(substrings[8]);
	loss.push_back(curr_loss);
      }
      else if(substrings[4] == "Train" && substrings[5] == "net" 
	      && substrings[6] == "output")
      {
	double curr_accuracy = stringfunc::string_to_number(substrings[10]);
//      cout << "curr_accuracy = " << curr_accuracy << endl;
      
	if(substrings[7] == "#0:")
	{
	  training_accuracy_0.push_back(curr_accuracy);
	  training_epoch.push_back(curr_epoch);
	}
	else if(substrings[7] == "#1:")
	{
	  training_accuracy_1.push_back(curr_accuracy);
	}
	else if(substrings[7] == "#2:")
	{
	  training_accuracy_2.push_back(curr_accuracy);
	}
      }
      else if (substrings[4] == "Test" && substrings[5] == "net" 
               && substrings[6] == "output")
      {
	double curr_accuracy = stringfunc::string_to_number(substrings[10]);
//      cout << "curr_accuracy = " << curr_accuracy << endl;
      
	if(substrings[7] == "#0:")
	{
	  validation_accuracy_0.push_back(curr_accuracy);
	  validation_epoch.push_back(curr_epoch);
	}
	else if(substrings[7] == "#1:")
	{
	  validation_accuracy_1.push_back(curr_accuracy);
	}
	else if(substrings[7] == "#2:")
	{
	  validation_accuracy_2.push_back(curr_accuracy);
	}
      }

   } // loop over index i labeling imported logfile text lines

//   cout << "training_epoch.size = " << training_epoch.size() << endl;
//   cout << "training_accuracy_0.size = " << training_accuracy_0.size() << endl;
//   cout << "validation_epoch.size = " << validation_epoch.size() << endl;
//   cout << "validation_accuracy_0.size = " << validation_accuracy_0.size() << endl;
//   cout << "loss.sizes = " << loss.size() << endl;

   /*

// Try fitting polyline with single "knee" to training accuracy
// metrics:

   double min_chisq0_tot, min_chisq1_tot, min_chisq2_tot, min_chisq3_tot;
   min_chisq0_tot = min_chisq1_tot = min_chisq2_tot = min_chisq3_tot = 
      POSITIVEINFINITY;

   vector<double> rel_epoch_before_0, rel_epoch_after_0;
   vector<double> rel_epoch_before_1, rel_epoch_after_1;
   vector<double> rel_epoch_before_2, rel_epoch_after_2;
   vector<double> rel_epoch_before_3, rel_epoch_after_3;

   vector<double> linear_fit_before_0, linear_fit_after_0;
   vector<double> linear_fit_before_1, linear_fit_after_1;
   vector<double> linear_fit_before_2, linear_fit_after_2;
   vector<double> linear_fit_before_3, linear_fit_after_3;

   double knee_frac_start = 0.05;
   double knee_frac_stop = 0.95;
   double knee_frac_step = 0.025;
   for(double knee_frac = knee_frac_start; knee_frac < knee_frac_stop; 
       knee_frac += knee_frac_step)
   {
      int n_samples = training_epoch.size();
      int n_samples_before = knee_frac * n_samples;
      vector<double> training_epoch_before, training_epoch_after;
      vector<double> accuracy0_before, accuracy0_after;
      vector<double> accuracy1_before, accuracy1_after;
      vector<double> accuracy2_before, accuracy2_after;
      vector<double> accuracy3_before, accuracy3_after;

      for(int n = 0; n < n_samples_before; n++)
      {
         training_epoch_before.push_back(training_epoch[n]);
         accuracy0_before.push_back(training_accuracy_0[n]);
         accuracy1_before.push_back(training_accuracy_1[n]);
         accuracy2_before.push_back(training_accuracy_2[n]);
         accuracy3_before.push_back(loss[n]);
      }
      for(int n = n_samples_before; n < n_samples; n++)
      {
         training_epoch_after.push_back(training_epoch[n]);
         accuracy0_after.push_back(training_accuracy_0[n]);
         accuracy1_after.push_back(training_accuracy_1[n]);
         accuracy2_after.push_back(training_accuracy_2[n]);
         accuracy3_after.push_back(loss[n]);
      }

      mypolynomial a0_before_poly(1), a0_after_poly(1);
      mypolynomial a1_before_poly(1), a1_after_poly(1);
      mypolynomial a2_before_poly(1), a2_after_poly(1);
      mypolynomial a3_before_poly(1), a3_after_poly(1);
      double chisq0_before, chisq1_before, chisq2_before, chisq3_before;
      double chisq0_after, chisq1_after, chisq2_after, chisq3_after;

      a0_before_poly.fit_coeffs(training_epoch_before, accuracy0_before, 
                                chisq0_before);
      a1_before_poly.fit_coeffs(training_epoch_before, accuracy1_before, 
                                chisq1_before);
      a2_before_poly.fit_coeffs(training_epoch_before, accuracy2_before, 
                                chisq2_before);
      a3_before_poly.fit_coeffs(training_epoch_before, accuracy3_before, 
                                chisq3_before);

      a0_after_poly.fit_coeffs(training_epoch_after, accuracy0_after, 
                               chisq0_after);
      a1_after_poly.fit_coeffs(training_epoch_after, accuracy1_after, 
                               chisq1_after);
      a2_after_poly.fit_coeffs(training_epoch_after, accuracy2_after, 
                               chisq2_after);
      a3_after_poly.fit_coeffs(training_epoch_after, accuracy3_after, 
                               chisq3_after);


      double chisq0_tot = chisq0_before + chisq0_after;
      double chisq1_tot = chisq1_before + chisq1_after;
      double chisq2_tot = chisq2_before + chisq2_after;
      double chisq3_tot = chisq3_before + chisq3_after;
      if(chisq0_tot < min_chisq0_tot)
      {
         min_chisq0_tot = chisq0_tot;
         generate_line_fits(
            training_epoch_before, a0_before_poly,
            rel_epoch_before_0, linear_fit_before_0);
         generate_line_fits(
            training_epoch_after, a0_after_poly,
            rel_epoch_after_0, linear_fit_after_0);

      }
      if(chisq1_tot < min_chisq1_tot)
      {
         min_chisq1_tot = chisq1_tot;
         generate_line_fits(
            training_epoch_before, a1_before_poly,
            rel_epoch_before_1, linear_fit_before_1);
         generate_line_fits(
            training_epoch_after, a1_after_poly,
            rel_epoch_after_1, linear_fit_after_1);
      }
      if(chisq2_tot < min_chisq2_tot)
      {
         min_chisq2_tot = chisq2_tot;
         generate_line_fits(
            training_epoch_before, a2_before_poly,
            rel_epoch_before_2, linear_fit_before_2);
         generate_line_fits(
            training_epoch_after, a2_after_poly,
            rel_epoch_after_2, linear_fit_after_2);
      }
      if(chisq3_tot < min_chisq3_tot)
      {
         min_chisq3_tot = chisq3_tot;
         generate_line_fits(
            training_epoch_before, a3_before_poly,
            rel_epoch_before_3, linear_fit_before_3);
         generate_line_fits(
            training_epoch_after, a3_after_poly,
            rel_epoch_after_3, linear_fit_after_3);
      }

   } // loop over knee_frac
   */

// Plot training accuracies versus training epoch number

   metafile training_metafile;
   training_metafile.set_thickness(2);
   training_metafile.set_legend_flag(true);

   string learning_curves_subdir="./learning_curves/";
   filefunc::dircreate(learning_curves_subdir);
   string lr_str = "_lr_"+stringfunc::number_to_string(base_learning_rate);
   string training_imgs_str = "_"+stringfunc::number_to_string(n_training_images/1000)+"K_training_imgs";
   string meta_filename=learning_curves_subdir+"training_performance"+training_imgs_str+lr_str+"_"+solver_type;

   training_metafile.set_parameters(
      meta_filename,"Segmentation accuracy vs model training",
      "Training epoch from initial VGG-trained caffe model",
      "Training metrics",
      0, training_epoch.back(), 0.0, 1.0, 0.2, 0.1);

   string n_images_str = stringfunc::number_to_string(n_training_images)+" training images";
   string base_learning_rate_str = "Base learning rate = "+stringfunc::number_to_string(base_learning_rate);
   string solver_str = solver_type+" solver";
   string subtitle = n_images_str + "; "+base_learning_rate_str+"; "+solver_str;
   training_metafile.set_subtitle(subtitle);
   
   training_metafile.openmetafile();
   training_metafile.write_header();

   training_metafile.set_legendlabel("Confusion matrix: Diag sum / All sum");
   training_metafile.write_curve(training_epoch, training_accuracy_0, colorfunc::red);

   training_metafile.set_legendlabel("Pixel mean Intersection / Union");
   training_metafile.write_curve(training_epoch, training_accuracy_2, colorfunc::green);

   training_metafile.set_legendlabel("Average class recall");
   training_metafile.write_curve(training_epoch, training_accuracy_1, colorfunc::blue);

   training_metafile.set_legendlabel("Loss");
   training_metafile.write_curve(training_epoch, loss, colorfunc::orange);

   training_metafile.set_legendlabel("");
/*
   training_metafile.write_curve(rel_epoch_before_0, linear_fit_before_0, 
      colorfunc::pink);
   training_metafile.write_curve(rel_epoch_after_0, linear_fit_after_0, 
      colorfunc::pink);

   training_metafile.write_curve(rel_epoch_before_1, linear_fit_before_1, 
      colorfunc::cyan);
   training_metafile.write_curve(rel_epoch_after_1, linear_fit_after_1, 
      colorfunc::cyan);

   training_metafile.write_curve(rel_epoch_before_2, linear_fit_before_2, 
      colorfunc::yegr);
   training_metafile.write_curve(rel_epoch_after_2, linear_fit_after_2, 
      colorfunc::yegr);

   training_metafile.write_curve(rel_epoch_before_3, linear_fit_before_3, 
      colorfunc::red);
   training_metafile.write_curve(rel_epoch_after_3, linear_fit_after_3, 
      colorfunc::red);
*/

   training_metafile.closemetafile();

   string banner="Exported metafile "+meta_filename+".meta";
   outputfunc::write_banner(banner);

   string unix_cmd="meta_to_jpeg "+meta_filename;
   sysfunc::unix_command(unix_cmd);

   banner="Exported "+meta_filename+".jpg";
   outputfunc::write_banner(banner);

// Plot validation accuracies versus training epoch number

   metafile validation_metafile;
   validation_metafile.set_thickness(2);
   validation_metafile.set_legend_flag(true);

   string validation_imgs_str;
   if(n_validation_images/1000 >= 1){
     validation_imgs_str = "_"+stringfunc::number_to_string(n_validation_images/1000)+"K_validation_imgs";
   }
   else{
     validation_imgs_str = "_"+stringfunc::number_to_string(n_validation_images)+"_validation_imgs";
   }
   meta_filename=learning_curves_subdir+"validation_performance"+validation_imgs_str+lr_str+"_"+solver_type;

   validation_metafile.set_parameters(
      meta_filename,"Segmentation accuracy vs model training",
      "Training epoch from initial VGG-trained caffe model",
      "Validation metrics",
      0, training_epoch.back(), 0.0, 1.0, 0.2, 0.1);

   n_images_str = stringfunc::number_to_string(n_validation_images)+" validation images";
   subtitle = n_images_str + "; "+base_learning_rate_str+"; "+solver_str;
   validation_metafile.set_subtitle(subtitle);

   validation_metafile.openmetafile();
   validation_metafile.write_header();

   validation_metafile.set_legendlabel("Confusion matrix: Diag sum / All sum");
   validation_metafile.write_curve(validation_epoch, validation_accuracy_0, colorfunc::red);

   validation_metafile.set_legendlabel("Average class recall");
   validation_metafile.write_curve(validation_epoch, validation_accuracy_1, colorfunc::blue);

   validation_metafile.set_legendlabel("Pixel mean Intersection / Union");
   validation_metafile.write_curve(validation_epoch, validation_accuracy_2, colorfunc::green);

   validation_metafile.set_legendlabel("");

   validation_metafile.closemetafile();

   banner="Exported metafile "+meta_filename+".meta";
   outputfunc::write_banner(banner);

   unix_cmd="meta_to_jpeg "+meta_filename;
   sysfunc::unix_command(unix_cmd);

   banner="Exported "+meta_filename+".jpg";
   outputfunc::write_banner(banner);

}

