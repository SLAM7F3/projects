// ==========================================================================
// Program GENERATE_TSNE_OUTPUT produces a metafile plot of the T-SNE
// layout for 2500 MNIST digits in 2-dimensions.  It imports a binary
// results file generated by C++ binary BH_TSNE_tsne.  (BH_TSNE in
// turn imports a binary data file generated by program
// GENERATE_TSNE_INPUT.)  2D points from the results outputs are
// colored according to their associated labels.  Clusters of MNIST
// digits are then clearly visible.

// GENERATE_TSNE_OUTPUT exports a colored 3D pointcloud in TDP/OSGA format.
// It also exports a 2D metafile.  Finally, it outputs a text layout file 
// which can be ingested via the ImageSearch pipeline.
// ==========================================================================
// Last updated on 11/1/15; 11/2/15; 11/3/15; 11/13/15
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "math/constants.h"
#include "general/filefuncs.h"
#include "plot/metafile.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "math/threevector.h"

using std::ifstream;
using std::ofstream;

int main (int argc, char* argv[])
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::string;
   using std::vector;

   string mnist_data_subdir = "/data/peter_stuff/imagery/mnist_data/";
   string training_labels_filename = mnist_data_subdir+
      "train-labels-idx1-ubyte";

// First import labels for MNIST thumbnails:

   ifstream binary_stream;
   filefunc::open_binaryfile(training_labels_filename, binary_stream);

   unsigned char curr_char;
   int magic_number, n_thumbnails;
   filefunc::readobject(binary_stream, magic_number);
   filefunc::readobject(binary_stream, n_thumbnails);

   magic_number = filefunc::swap_int32(magic_number);
   n_thumbnails = filefunc::swap_int32(n_thumbnails);

   cout << "magic_number = " << magic_number << endl;
   cout << "n_thumbnails = " << n_thumbnails << endl;

   vector<int> labels;
   for(int i = 0; i < n_thumbnails; i++)
   {
      filefunc::readobject(binary_stream, curr_char);

      int curr_label = static_cast<int>(curr_char);
      labels.push_back(curr_label);
//      cout << "i = " << i << " label = " << curr_label << endl;
   }
   filefunc::closefile(training_labels_filename, binary_stream);   

/*
   string mnist_subdir = "./mnist_2500/";
   string labels_filename = mnist_subdir+"mnist2500_labels.txt";


// First import integer labels for each input MNIST digit:

   filefunc::ReadInfile(labels_filename);
   int n_labels = filefunc::text_line.size();
   cout << "n_labels = " << n_labels << endl;

   vector<int> labels;
   for(int i = 0; i < n_labels; i++)
   {
      string curr_label=filefunc::text_line[i];
      labels.push_back(stringfunc::string_to_number(curr_label));
   }
*/

// Next import projected 2D coordinates for MNIST digits generated by
// T-SNE algorithm:

   string input_binary_filename=mnist_data_subdir+"result.dat";
//   string input_binary_filename=mnist_subdir+"result.dat";
   filefunc::open_binaryfile(input_binary_filename, binary_stream);

   int n_points, n_reduced_dims;
   filefunc::readobject(binary_stream, n_points);
   filefunc::readobject(binary_stream, n_reduced_dims);

   vector<double> X, Y;
   double min_X = POSITIVEINFINITY;
   double max_X = NEGATIVEINFINITY;
   double min_Y = POSITIVEINFINITY;
   double max_Y = NEGATIVEINFINITY;

   for(int p = 0; p < n_points; p++)
   {
      double curr_X, curr_Y;
      filefunc::readobject(binary_stream, curr_X);
      filefunc::readobject(binary_stream, curr_Y);

      min_X = basic_math::min(min_X, curr_X);
      max_X = basic_math::max(max_X, curr_X); 
      min_Y = basic_math::min(min_Y, curr_Y);
      max_Y = basic_math::max(max_Y, curr_Y);
      X.push_back(curr_X);
      Y.push_back(curr_Y);
//      cout << "p = " << p << " label = " << labels[p]
//           << " X = " << X.back()
//           << " Y = " << Y.back() << endl;
   }
   cout << "min_X = " << min_X << " max_X = " << max_X << endl;
   cout << "min_Y = " << min_Y << " max_Y = " << max_Y << endl;

   filefunc::closefile(input_binary_filename, binary_stream);   

// Generate XYZ point cloud colored according to MNIST class labels:

   unsigned char max_char=stringfunc::ascii_integer_to_unsigned_char(255);
   unsigned char min_char=stringfunc::ascii_integer_to_unsigned_char(0);
   osg::Vec4ub red_RGBA(max_char,min_char,min_char,max_char);
   osg::Vec4ub green_RGBA(min_char,max_char,min_char,max_char);
   osg::Vec4ub blue_RGBA(min_char,min_char,max_char,max_char);
   osg::Vec4ub white_RGBA(max_char,max_char,max_char,max_char);

   vector<threevector>* points_vertices_ptr=new vector<threevector>;
   osg::Vec4ubArray* points_colors_ptr=new osg::Vec4ubArray;

   for(unsigned int i = 0; i < X.size(); i++)
   {
      points_vertices_ptr->push_back(threevector(X[i],Y[i]));
      colorfunc::Color curr_color = colorfunc::get_color(labels[i]);
      colorfunc::RGB curr_RGB = colorfunc::get_RGB_values(curr_color);
      osg::Vec4ub curr_RGBA(
         static_cast<unsigned char>(255 * curr_RGB.first), 
         static_cast<unsigned char>(255 * curr_RGB.second), 
         static_cast<unsigned char>(255 * curr_RGB.third), 
         max_char);
      points_colors_ptr->push_back(curr_RGBA);
   }
   
// Export 3D point cloud:

   string points_tdp_filename="mnist_points.tdp";
   tdpfunc::write_relative_xyzrgba_data(
      points_tdp_filename,"",
      points_vertices_ptr->at(0),
      points_vertices_ptr,points_colors_ptr);
   string unix_cmd="lodtree "+points_tdp_filename;
   sysfunc::unix_command(unix_cmd);
   string points_osga_filename="mnist_points.osga";

   string banner="Exported "+points_osga_filename;
   outputfunc::write_banner(banner);

// Generate metafile output whose markers are colored according to
// MNIST class labels:

   metafile curr_metafile;
   
//   string meta_filename=mnist_subdir+"mnist_2500";
//   string title="TSNE layout for MNIST 2500";
   string meta_filename=mnist_data_subdir+"mnist_60K";
   string title="TSNE layout for MNIST 60K";
   string x_label="X";
   string y_label="Y";

   curr_metafile.set_legend_flag(true);
   curr_metafile.set_parameters(
      meta_filename,title,x_label,y_label,
      min_X, max_X, min_Y, max_Y);

   curr_metafile.openmetafile();
   curr_metafile.write_header();

   for(unsigned int i = 0; i < labels.size(); i++){
     curr_metafile.set_legendlabel(stringfunc::number_to_string(labels[i]));
   }
   curr_metafile.write_markers(labels,X,Y);
   curr_metafile.closemetafile();

   banner="Exported metafile "+meta_filename+".meta";
   outputfunc::write_banner(banner);

// Generate graph_XY_coords layout file for ImageSearch Tool display
// purposes:

   string layout_filename="graph_XY_coords.fm3_layout";
   ofstream layout_stream;
   filefunc::openfile(layout_filename, layout_stream);
   layout_stream << "# Image_ID   gX     gY " << endl << endl;

   for(unsigned int i = 0; i < X.size(); i++)
   {
      int image_ID = i;
      double gX = (X[i] - min_X)/(max_X - min_X);
      double gY = (Y[i] - min_Y)/(max_Y - min_Y);
      layout_stream << image_ID << "   " << gX << "   " << gY << endl;
   }
   filefunc::closefile(layout_filename, layout_stream);

   banner="Exported graph layout file "+layout_filename;
   outputfunc::write_banner(banner);
}

