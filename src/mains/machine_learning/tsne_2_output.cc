// ==========================================================================
// Program TSNE_2_META produces a metafile plot of the T-SNE 2D
// layout for high dimensional image feature vectors.  It
// imports a binary results file generated by C++ binary BH_TSNE.
// TSNE_2_META also generates graph_XY_coords layout file for
// ImageSearch Tool display purposes.
// ==========================================================================
// Last updated on 11/3/15; 11/13/15; 11/24/15; 11/25/15
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "math/constants.h"
#include "general/filefuncs.h"
#include "plot/metafile.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "osg/osg3D/tdpfuncs.h"
#include "math/threevector.h"

using std::ifstream;
using std::ofstream;

int main (int argc, char* argv[])
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::string;
   using std::vector;

// Import projected 2D coordinates for feature vectors generated by
// T-SNE algorithm:

   string temp_subdir = "./caffe/examples/_temp/";
//   string features_subdir = temp_subdir + "features_flowers/";
//   string features_subdir = temp_subdir + "features_animals/";
//   string features_subdir = temp_subdir + "features_NewsWrap/";
   string features_subdir = temp_subdir + "features_NewsWrap_thumbnails/";

// Import image filenames:

   string files_list = features_subdir + "file_list.txt";
   filefunc::ReadInfile(files_list);
   vector<string> image_prefixes;
   for(unsigned int i = 0; i < filefunc::text_line.size(); i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      string curr_image_prefix = stringfunc::prefix(filefunc::getbasename(
                                                       substrings[0]));
      image_prefixes.push_back(curr_image_prefix);
   }

   string input_tsne_filename=features_subdir+"result.dat";
   ifstream binary_stream;
   filefunc::open_binaryfile(input_tsne_filename, binary_stream);

   int n_points, n_reduced_dims;
   filefunc::readobject(binary_stream, n_points);
   filefunc::readobject(binary_stream, n_reduced_dims);

   cout << "n_points = " << n_points << endl;
   cout << "n_reduced_dims = " << n_reduced_dims << endl;
   outputfunc::enter_continue_char();

   vector<double> X, Y;
   double min_X = POSITIVEINFINITY;
   double max_X = NEGATIVEINFINITY;
   double min_Y = POSITIVEINFINITY;
   double max_Y = NEGATIVEINFINITY;

   for(int p = 0; p < n_points; p++)
   {
      double curr_X, curr_Y;
      filefunc::readobject(binary_stream, curr_X);
      filefunc::readobject(binary_stream, curr_Y);

      min_X = basic_math::min(min_X, curr_X);
      max_X = basic_math::max(max_X, curr_X); 
      min_Y = basic_math::min(min_Y, curr_Y);
      max_Y = basic_math::max(max_Y, curr_Y);
      X.push_back(curr_X);
      Y.push_back(curr_Y);
      cout << "p = " << p 
           << " X = " << X.back()
           << " Y = " << Y.back() << endl;
   }
   cout << "min_X = " << min_X << " max_X = " << max_X << endl;
   cout << "min_Y = " << min_Y << " max_Y = " << max_Y << endl;

   filefunc::closefile(input_tsne_filename, binary_stream);   

/*
// Generate XYZ point cloud colored according to MNIST class labels:

   unsigned char max_char=stringfunc::ascii_integer_to_unsigned_char(255);
   unsigned char min_char=stringfunc::ascii_integer_to_unsigned_char(0);
   osg::Vec4ub red_RGBA(max_char,min_char,min_char,max_char);
   osg::Vec4ub green_RGBA(min_char,max_char,min_char,max_char);
   osg::Vec4ub blue_RGBA(min_char,min_char,max_char,max_char);
   osg::Vec4ub white_RGBA(max_char,max_char,max_char,max_char);

   vector<threevector>* points_vertices_ptr=new vector<threevector>;
   osg::Vec4ubArray* points_colors_ptr=new osg::Vec4ubArray;

   for(unsigned int i = 0; i < X.size(); i++)
   {
      points_vertices_ptr->push_back(threevector(X[i],Y[i]));
      colorfunc::Color curr_color = colorfunc::get_color(labels[i]);
      colorfunc::RGB curr_RGB = colorfunc::get_RGB_values(curr_color);
      osg::Vec4ub curr_RGBA(
         static_cast<unsigned char>(255 * curr_RGB.first), 
         static_cast<unsigned char>(255 * curr_RGB.second), 
         static_cast<unsigned char>(255 * curr_RGB.third), 
         max_char);
      points_colors_ptr->push_back(curr_RGBA);
   }
   
// Export 3D point cloud:

   string points_tdp_filename="mnist_points.tdp";
   tdpfunc::write_relative_xyzrgba_data(
      points_tdp_filename,"",
      points_vertices_ptr->at(0),
      points_vertices_ptr,points_colors_ptr);
   string unix_cmd="lodtree "+points_tdp_filename;
   sysfunc::unix_command(unix_cmd);
   string points_osga_filename="mnist_points.osga";

   string banner="Exported "+points_osga_filename;
   outputfunc::write_banner(banner);
*/

// Generate metafile output:

   metafile curr_metafile;
   string meta_filename=features_subdir+"features";
   string title="TSNE layout for feature vectors";
   string x_label="X";
   string y_label="Y";

   curr_metafile.set_legend_flag(true);
   curr_metafile.set_parameters(
      meta_filename,title,x_label,y_label,
      min_X, max_X, min_Y, max_Y);

   curr_metafile.openmetafile();
   curr_metafile.write_header();
   curr_metafile.write_markers(X,Y);

   for(unsigned int i = 0; i < image_prefixes.size(); i++)
   {
      string extraline = "text "+stringfunc::number_to_string(X[i]) + " "
         + stringfunc::number_to_string(Y[i])+" '"+image_prefixes[i]+"'";
      curr_metafile.add_extraline(extraline);
   }
   curr_metafile.add_extralines();
   curr_metafile.closemetafile();

   string banner="Exported metafile "+meta_filename+".meta";
   outputfunc::write_banner(banner);
   string unix_cmd = "meta_to_jpeg "+meta_filename;
   sysfunc::unix_command(unix_cmd);

// Generate graph_XY_coords layout file for ImageSearch Tool display
// purposes:

   string layout_filename=features_subdir+"graph_XY_coords.fm3_layout";
   ofstream layout_stream;
   filefunc::openfile(layout_filename, layout_stream);
   layout_stream << "# Image_ID   gX     gY " << endl << endl;

   for(unsigned int i = 0; i < X.size(); i++)
   {
      int image_ID = i;
      double gX = (X[i] - min_X)/(max_X - min_X);
      double gY = (Y[i] - min_Y)/(max_Y - min_Y);
      layout_stream << image_ID << "   " << gX << "   " << gY << endl;
   }
   filefunc::closefile(layout_filename, layout_stream);

   banner="Exported graph layout file "+layout_filename;
   outputfunc::write_banner(banner);
}

