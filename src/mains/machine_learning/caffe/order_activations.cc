// ========================================================================
// Program ORDER_ACTIVATIONS imports raw activation statistics for
// each FACENET neuron generated by program NN_PATHS.  For each
// network layer, activations are reordered according to their
// stimulation frequencies.  The new ordering for nodes is exported to
// an output text file.

//                         ./order_activations

// ========================================================================
// Last updated on 8/24/16; 8/25/16
// ========================================================================

#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "image/imagefuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

int main(int argc, char** argv) 
{
   string imagechips_subdir = "./vis_facenet/node_images/";
   string activations_subdir = imagechips_subdir + "activations/";
   string activations_filename = activations_subdir+"activations.dat";

   string ordered_activations_filename=activations_subdir+
      "ordered_activations.dat";
   ofstream outstream;
   filefunc::openfile(ordered_activations_filename, outstream);

   vector< vector<double> > row_numbers = 
      filefunc::ReadInRowNumbers(activations_filename);

   vector<int> old_global_node_ID, node_ID, new_node_ID;
   vector<double> stimulation_frac, median_activation, quartile_activation;

// First count total number of nodes and number of nodes per network
// layer:

   vector<int> n_layer_nodes;
   n_layer_nodes.push_back(3);  // Zeroth input data layer has 3 RGB channels
   int n_total_nodes = n_layer_nodes.back();

   cout << "Layer 0 has "
        << n_layer_nodes.back() << " nodes " << endl;


   int prev_layer = -1;
   int n_nodes_per_layer = 0;
   for(unsigned int r = 0; r < row_numbers.size(); r++)
   {
      int curr_layer = row_numbers.at(r).at(0);
      if (r > 0)
      {
         if(curr_layer != prev_layer)
         {
            n_layer_nodes.push_back(n_nodes_per_layer);
            cout << "Layer " << prev_layer+1
                 << " has " << n_layer_nodes.back() << " nodes " << endl;
            n_nodes_per_layer = 0;
         }
      }
      n_nodes_per_layer++;
      n_total_nodes++;
      prev_layer = curr_layer;
   }
   n_layer_nodes.push_back(n_nodes_per_layer);
   cout << "Layer = " << prev_layer
        << " has " << n_layer_nodes.back() << " nodes " << endl;
   cout << "Total number of network nodes = " << n_total_nodes << endl;
   

   outstream << "# ====================================================="
             << endl;
   outstream << "# Nodes ordered by their test image stimulation frequency"
             << endl;
   outstream << "# ====================================================="
             << endl;
   outstream << "# Layer  Old local   Old global New local    New global  Stimul  Median  Quartile" << endl;
   outstream << "# ID     node ID     node ID    node ID      node ID     freq    act     act" << endl;
   outstream << "# ====================================================="
             << endl << endl;

// First print out 3 input RGB channels:

   int n_RGB_channels = 3;
   prev_layer = -1;

   for(unsigned int i = 0; i < n_RGB_channels; i++)
   {
      double stimul_frac = 1.0;
      double median_activation = 1.0;
      double quartile_activation = 0.5;
      outstream << prev_layer+1 << "    "
                << i << "    "
                << i << "    "
                << i << "    "
                << i << "    "
                << stimul_frac << "    "
                << median_activation << "    "
                << quartile_activation << endl;
   }
   outstream << endl;

   prev_layer = 0;
   int local_node_ID = 0;
   int RGB_data_offset = 3;
   int node_counter = 0 + RGB_data_offset;
   int new_global_node_ID = 0 + RGB_data_offset;
   for(unsigned int r = 0; r < row_numbers.size(); r++)
   {
//      for(unsigned int c = 0 ; c < row_numbers.at(r).size(); c++)
//      {
//         cout << row_numbers.at(r).at(c) << "  ";
//      }

      if(r == row_numbers.size() -1)
      {
         old_global_node_ID.push_back(node_counter++);
         node_ID.push_back(row_numbers.at(r).at(1));
         new_node_ID.push_back(local_node_ID++);
         stimulation_frac.push_back(row_numbers.at(r).at(2));
         median_activation.push_back(row_numbers.at(r).at(3));
         quartile_activation.push_back(row_numbers.at(r).at(4));
      }

      int curr_layer = row_numbers.at(r).at(0);
      if((r > 0 && curr_layer != prev_layer) || r == row_numbers.size() - 1)
      {
         outstream << "# ====================================================="
                   << endl << endl;
         templatefunc::Quicksort_descending(
            stimulation_frac, old_global_node_ID, node_ID, 
            median_activation, quartile_activation);

         for(unsigned int i = 0; i < node_ID.size(); i++)
         {
            outstream << prev_layer+1 << "    "
                      << node_ID[i] << "    "
                      << old_global_node_ID[i] << "    "
                      << new_node_ID[i] << "    "
                      << new_global_node_ID++ << "    "
                      << stimulation_frac[i] << "    "
                      << median_activation[i] << "    "
                      << quartile_activation[i] << endl;
         }
         outstream << endl;

         stimulation_frac.clear();
         old_global_node_ID.clear();
         node_ID.clear();
         new_node_ID.clear();
         local_node_ID = 0;
         median_activation.clear();
         quartile_activation.clear();
      }
      prev_layer = curr_layer;

      old_global_node_ID.push_back(node_counter++);
      node_ID.push_back(row_numbers.at(r).at(1));
      new_node_ID.push_back(local_node_ID++);
      stimulation_frac.push_back(row_numbers.at(r).at(2));
      median_activation.push_back(row_numbers.at(r).at(3));
      quartile_activation.push_back(row_numbers.at(r).at(4));

   } // loop over index r labeling rows in activations_filename

   filefunc::closefile(ordered_activations_filename, outstream);
   string banner="Exported ordered activations to "+
      ordered_activations_filename;
   outputfunc::write_banner(banner);
}

   
