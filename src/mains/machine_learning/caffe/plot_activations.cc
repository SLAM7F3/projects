// ========================================================================
// Program PLOT_ACTIVATIONS imports the ordered_activations.dat text
// file generated by program ORDER_ACTIVATIONS.  It generates
// probability densities for each layers' node stimulation frequency
// fractions.  

//                         ./plot_activations
// ========================================================================
// Last updated on 9/5/16
// ========================================================================

#include "general/filefuncs.h"
#include "math/genmatrix.h"
#include "image/imagefuncs.h"
#include "math/ltduple.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

int main(int argc, char** argv) 
{
   string imagechips_subdir = "./vis_facenet/node_images/";
   string activations_subdir = imagechips_subdir + "activations/";
   string ordered_activations_filename=activations_subdir+
      "ordered_activations.dat";

   vector< vector<double> > row_numbers = 
      filefunc::ReadInRowNumbers(ordered_activations_filename);

   vector<int> old_global_node_ID, node_ID, new_node_ID;
   vector<double> stimulation_frac, median_activation, quartile_activation;

// First count total number of nodes and number of nodes per network
// layer:

   int n_total_nodes = 0;
   vector<int> n_layer_nodes;
   vector<int> layer_IDs;
   layer_IDs.push_back(0);

   int n_nodes_per_layer = 0;
   int curr_layer = -1;
   for(unsigned int r = 0; r < row_numbers.size(); r++)
   {
      curr_layer = row_numbers.at(r).at(0);
      if (r > 0)
      {
         if(curr_layer != layer_IDs.back())
         {
            n_layer_nodes.push_back(n_nodes_per_layer);
            cout << "Layer " << layer_IDs.back()
                 << " has " << n_layer_nodes.back() << " nodes " << endl;
            n_nodes_per_layer = 0;
            layer_IDs.push_back(curr_layer);
         }
      }
      n_nodes_per_layer++;
      n_total_nodes++;
   }

   layer_IDs.push_back(curr_layer);
   n_layer_nodes.push_back(n_nodes_per_layer);
   cout << "Layer " << layer_IDs.back()
        << " has " << n_layer_nodes.back() << " nodes " << endl;
   cout << "Total number of network nodes = " << n_total_nodes << endl;


   int curr_node = 0;
   int prev_layer = layer_IDs.front();
   vector<double> stimul_frequency;
   while (curr_node < n_total_nodes)
   {
      curr_layer = row_numbers.at(curr_node).at(0);

      if (curr_layer > prev_layer || curr_node == n_total_nodes - 1)
      {
// Compute statistics for curr_layer activations

         int nbins = 50;
         prob_distribution prob_stimul_freq(stimul_frequency,nbins,0);
         string layer_str = stringfunc::number_to_string(prev_layer);
         if(curr_node == n_total_nodes - 1)
         {
            layer_str = stringfunc::number_to_string(curr_layer);
         }
         
         string curr_stimul_freq_filename="stimul_freq_density_"+layer_str+
            ".meta";
         prob_stimul_freq.set_title(
            "Stimulation frequency for nodes in layer "+
            layer_str);
         prob_stimul_freq.set_xlabel("Stimulation frequency fraction");
         prob_stimul_freq.set_xmin(0);
         prob_stimul_freq.set_xmax(1);
         prob_stimul_freq.set_xtic(0.2);
         prob_stimul_freq.set_xsubtic(0.1);
         prob_stimul_freq.set_densityfilenamestr(curr_stimul_freq_filename);
         prob_stimul_freq.write_density_dist(false,true);
         prev_layer = curr_layer;
         stimul_frequency.clear();
      }

      double curr_stimul_freq = row_numbers.at(curr_node).at(5);
      stimul_frequency.push_back(curr_stimul_freq);
      curr_node++;
   } // while curr_node < n_total_nodes 
}

   
