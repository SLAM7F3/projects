// ====================================================================
// Program PREPARE_DEEPLAB_INPUTS imports an XML file generated by
// Davis King's IMGLAB program that contains bounding boxes around
// objects (e.g. human faces) for some set of trained images.  Each
// annotated image is decomposed into a set of tiles with pixel
// dimensions deeplab_tile_size x deeplab_tile_size.  Border tiles are
// padded as necessary with zero values so that an integer number of
// tiles are generated for each input image.  

// For each tile, a mask written to an 8-bit greyscale PNG file
// is created whose background value = 0 and foreground value = 1 [,
// 2, 3, 4...].  Exported image tiles become inputs to Deeplab's
// CNN, while the masks become inputs to Deeplab's loss function.

// PREPARE_DEEPLAB_INPUTS also writes out text files containing
// associations between image tiles and masks.  It randomly shuffles
// the associations and then splits them into training, validation and
// testing sets.

/*

// From within subdirectory containing all input images (e.g. 
/data/TrainingImagery/faces/images/ ), chant

~/programs/c++/svn/projects/src/mains/faces/prepare_deeplab_inputs \
all_images.xml

*/

// ====================================================================
// Last updated on 5/9/16; 5/11/16; 5/13/16; 5/16/16
// ====================================================================

#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include <dlib/array.h>
#include <dlib/array2d.h>
#include <dlib/gui_widgets.h>
#include <dlib/image_processing.h>
#include <dlib/data_io.h>

#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::exception;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

int main(int argc, char** argv)
{  
   timefunc::initialize_timeofday_clock(); 

//   bool visualize_masks_flag = true;
   bool visualize_masks_flag = false;
   
// Recall image chips and masks should equal 321x321 in pixel size
// in order to meet deeplab's GPU card and batch size memory
// requirements:

   int deeplab_tile_size = 321;	

   string faces_rootdir = "/data/TrainingImagery/faces/";
   string labeled_data_subdir=faces_rootdir+"labeled_data/";   
   
   int faces_ID = -1;
   cout << "Enter faces ID (-1 for default):" << endl;
   cin >> faces_ID;
   string faces_subdir=labeled_data_subdir+"faces";
   if(faces_ID >= 0)
   {
      faces_subdir += "_"+stringfunc::integer_to_string(faces_ID,2);
   }
   filefunc::add_trailing_dir_slash(faces_subdir);

   string training_images_subdir=
      faces_subdir+"training_images/augmented_notfaces3/";
//      faces_subdir+"training_images/augmented_half/";
//      faces_subdir+"training_images/augmented_double/";
//   string training_images_subdir=
//      faces_subdir+"training_images/augmented_half/";
//   string training_images_subdir=faces_subdir+"training_images/";
   string validation_images_subdir=faces_subdir+"validation_images/";
   string testing_images_subdir=faces_subdir+"testing_images/";

   string training_xml_filename=training_images_subdir+"training_images.xml";
   string validation_xml_filename=validation_images_subdir+
      "validation_images.xml";

   string deeplab_inputs_subdir=faces_subdir+"deeplab_inputs/";
   string tiles_subdir=deeplab_inputs_subdir+"tiles/";
   string full_masks_subdir=deeplab_inputs_subdir+"full_masks/";
   string eightbit_masks_subdir=deeplab_inputs_subdir+"eightbit_masks/";
   filefunc::dircreate(deeplab_inputs_subdir);
   filefunc::dircreate(deeplab_inputs_subdir);
   filefunc::dircreate(tiles_subdir);
   filefunc::dircreate(eightbit_masks_subdir);
   if (visualize_masks_flag) filefunc::dircreate(full_masks_subdir);

//   dlib::array<dlib::array2d<unsigned char> > training_images, 
//      validation_images;
//   vector<vector<dlib::rectangle> > training_object_locations, 
//      validation_object_locations;
   vector<vector<dlib::image_dataset_metadata::box> > training_object_bboxes,
      validation_object_bboxes;

   dlib::image_dataset_metadata::dataset training_dataset;
   dlib::image_dataset_metadata::dataset validation_dataset;
   dlib::image_dataset_metadata::load_image_dataset_metadata(
      training_dataset, training_xml_filename);
   dlib::image_dataset_metadata::load_image_dataset_metadata(
      validation_dataset, validation_xml_filename);

// FAKE FAKE: Tues Jan 5, 2016 Need to generalize this next line!
// Should read in object class labels from Davis' XML file and store
// in an STL vector of strings...

   string bbox_label="face";

// Export text file containing class names for labeled objects.
// Recall Deeplab expects zeroth class corresponds to background:

   string object_classes_filename=deeplab_inputs_subdir+"object_names.classes";
   ofstream outstream;
   filefunc::openfile(object_classes_filename, outstream);
   outstream << "__background__" << endl;
   outstream << bbox_label << endl;
   filefunc::closefile(object_classes_filename, outstream);

   int n_training_images = training_dataset.images.size();
   vector<string> training_image_basenames, validation_image_basenames;
   for(int n = 0; n < n_training_images; n++)
   {
      training_image_basenames.push_back(training_dataset.images[n].filename);
      vector<dlib::image_dataset_metadata::box> bboxes;
      for(unsigned int b = 0; b < training_dataset.images[n].boxes.size(); b++)
      {
         bboxes.push_back(training_dataset.images[n].boxes[b]);
      }
      training_object_bboxes.push_back(bboxes);
   }

   int n_validation_images = validation_dataset.images.size();
   for(int n = 0; n < n_validation_images; n++)
   {
      validation_image_basenames.push_back(
         validation_dataset.images[n].filename);
      vector<dlib::image_dataset_metadata::box> bboxes;
      for(unsigned int b = 0; b < validation_dataset.images[n].boxes.size(); 
          b++)
      {
         bboxes.push_back(validation_dataset.images[n].boxes[b]);
      }
      validation_object_bboxes.push_back(bboxes);
   }

   int n_images = n_training_images + n_validation_images;
   int istart = 0;
   int istop = n_images;
   if(visualize_masks_flag)
   {	
      istop = 5;
      cout << "Only visualize masks for images < istop = " << istop << endl;
   }

   cout << "n_images =  " << n_images << endl;
   cout << "istart = " << istart << " istop = " << istop << endl;
   cout << "training_object_bboxes.size() = " 
        << training_object_bboxes.size() << endl;
   cout << "validation_object_bboxes.size() = " 
        << validation_object_bboxes.size() << endl;

// Store pairs of tile and corresponding mask filenames within an STL
// map:

   typedef pair<string, string> STRING_PAIR;
   typedef std::map<int, vector<STRING_PAIR> > IMAGE_TILES_MAP;
// independent int: image ID
// dependent vector<string,string > : pairs of tile and mask filenames associated with image

   IMAGE_TILES_MAP image_tiles_map;
   IMAGE_TILES_MAP::iterator image_tiles_map_iter;

   for (int i = istart; i < istop; i++)
   {
      cout << "Processing image " << i 
           << " : istop = " << istop << endl;

      string currimage_filename;
      vector<dlib::image_dataset_metadata::box> curr_object_bboxes;

      if(i < n_training_images)
      {
         int i_train = i;
         currimage_filename = training_images_subdir+
            training_dataset.images[i_train].filename;
         curr_object_bboxes = training_object_bboxes[i_train];
      }
      else
      {
         int i_valid = i - n_training_images;
         currimage_filename = validation_images_subdir+
            validation_dataset.images[i_valid].filename;
         curr_object_bboxes = validation_object_bboxes[i_valid];
      }
//      cout << "  currimage_filename = " << currimage_filename << endl;
      if(!filefunc::fileexist(currimage_filename)) continue;

      texture_rectangle curr_tr(currimage_filename, NULL);
      if(curr_tr.get_VideoType() == texture_rectangle::unknown) continue;
      if(curr_tr.getNchannels() != 3) 
      {
         cout << "Skipping currimage_filename = " << currimage_filename 
              << endl;
         cout << "n_channels = " << curr_tr.getNchannels() << endl;
         continue;
      }
      
      unsigned int img_width = curr_tr.getWidth();
      unsigned int img_height = curr_tr.getHeight();
      unsigned int max_pdim = 2 * 2400;
      if(img_width > max_pdim || img_height > max_pdim)
      {
         cout << "Skipping currimage_filename = " << currimage_filename 
              << endl;
         cout << "img_width = " << img_width 
              << " img_height = " << img_height 
              << " max pixel dim = " << max_pdim << endl;
         continue;
      }


      int nx_tiles = img_width / deeplab_tile_size + 1;
      int ny_tiles = img_height / deeplab_tile_size + 1;
//      cout << "  nx_tiles = " << nx_tiles << " ny_tiles = " << ny_tiles
//           << endl;

      texture_rectangle mask_tr(currimage_filename, NULL);
      mask_tr.clear_all_RGB_values();

      if(i%100 == 0)
      {
         double progress_frac = double(i)/double(n_images);
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }

// Paint rectangle regions with mask value:

      int mask_R, mask_G, mask_B;
      if(visualize_masks_flag)
      {
         mask_R = mask_G = mask_B = 128;  
      }
      else
      {
         mask_R = mask_G = mask_B = 1;
      }

      unsigned int n_bboxes = curr_object_bboxes.size();
//      cout << "  n_bboxes = " << n_bboxes << endl;
      for(unsigned b = 0; b < n_bboxes; b++)
      {
         dlib::image_dataset_metadata::box curr_bbox = 
            curr_object_bboxes.at(b);
         dlib::rectangle curr_rect = curr_bbox.rect;
         unsigned int px_min = curr_rect.left();
         unsigned int px_max = curr_rect.right();
         unsigned int py_min = curr_rect.top();
         unsigned int py_max = curr_rect.bottom();

         for(unsigned int py = py_min; py < py_max; py++)
         {
            for(unsigned int px = px_min; px < px_max; px++)
            {
               mask_tr.set_pixel_RGB_values(px, py, mask_R, mask_G, mask_B);
            }
         }
      }

      if (visualize_masks_flag)
      {
         string mask_filename=full_masks_subdir+"mask_"
            +stringfunc::integer_to_string(i,5)+".png";
         mask_tr.write_curr_subframe(
            0, img_width-1, 0, img_height-1,mask_filename);
      }

// On 1/4/16, we learned from Tho that tiles should generally be
// padded so that deleterious border effects upon classification are
// minimized.  We won't worry about this issue for now...

      for(int nx = 0; nx < nx_tiles; nx++)
      {
         string nx_label = stringfunc::integer_to_string(nx, 2);
         unsigned int px_start = nx * deeplab_tile_size;
         unsigned int px_stop = px_start + deeplab_tile_size - 1;
         for(int ny = 0; ny < ny_tiles; ny++)
         {
            string ny_label = stringfunc::integer_to_string(ny, 2);
            unsigned int py_start = ny * deeplab_tile_size;
            unsigned int py_stop = py_start + deeplab_tile_size - 1;
            string image_label = stringfunc::integer_to_string(i,5);
            string curr_tile_filename = tiles_subdir+"tile_"+image_label+"_"+
               nx_label+"_"+ny_label+".jpg";
            curr_tr.write_curr_subframe(px_start, px_stop, py_start, py_stop,
                                        curr_tile_filename);
//            cout << "Exported "+curr_tile_filename << endl;

// Within this innner loop, py = 0 corresponds to the *bottom* row of
// the full image.  Now 
            
            vector<vector<unsigned char> > byte_array;

            for(unsigned int py = py_start; py <= py_stop; py++)
            {
               vector<unsigned char> curr_byte_row;
               for(unsigned int px = px_start; px <= px_stop; px++)
               {

// Set mask values for pixels lying outside borders of current image
// equal to background value 0:

                  unsigned char curr_char = 0;
                  if(visualize_masks_flag)
                  {
                     curr_char = 255;
                  }

                  if(px < img_width && py < img_height)
                  {
                     mask_tr.get_pixel_RGB_values(
                        px, img_height - 1 - py, mask_R, mask_G, mask_B);

// Recall get_pixel_RGB_values() returns a negative value if input pixel
// coordinates are invalid!

                     if(mask_R >= 0)
                     {
                        curr_char = mask_R;
                     }
                  }

                  if (int(curr_char) >= 2 && !visualize_masks_flag)
                  {
                     cout << "px = " << px << " py = " << py 
                          << " curr_char = " << int(curr_char) << endl;
                  }
                  
                  curr_byte_row.push_back( curr_char );
               }
               byte_array.push_back(curr_byte_row);
            }

// Recall zeroth row fed into write_8bit_greyscale_pngfile() must
// correspond to TOP row of the image to be exported to output PNG
// file:
            
            vector<vector<unsigned char > > flipped_byte_array;
            for(unsigned int py = 0; py < byte_array.size(); py++)
            {
               vector<unsigned char> curr_byte_row = 
                  byte_array.at(byte_array.size() - 1 - py);
               flipped_byte_array.push_back(curr_byte_row);
            }
            
            string deeplab_mask_filename = 
               eightbit_masks_subdir+"mask_"+image_label+"_"+
               nx_label+"_"+ny_label+".png";
            videofunc::write_8bit_greyscale_pngfile(
               flipped_byte_array, deeplab_mask_filename);

// Save correspondence between image tile and image mask to STL map:

            int posn = deeplab_inputs_subdir.size() - 1;
            string reduced_tile_filename=curr_tile_filename.substr(
               posn,curr_tile_filename.size()-posn);
            string reduced_mask_filename=deeplab_mask_filename.substr(
               posn,deeplab_mask_filename.size()-posn);

            STRING_PAIR P;
            P.first = reduced_tile_filename;
            P.second = reduced_mask_filename;

            image_tiles_map_iter = image_tiles_map.find(i);
            if(image_tiles_map_iter == image_tiles_map.end()){
              vector<STRING_PAIR> V;
              V.push_back(P);
              image_tiles_map[i] = V;
            }
            else{
              vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
              V_ptr->push_back(P);
            }

         } // loop over index ny labeling vertical tile index
      } // loop over index nx labeling horizontal tile index
   } // loop over index i labeling training + validation images

   cout << "image_tiles_map.size() = " << image_tiles_map.size() << endl;

   string images_masks_training_filename=deeplab_inputs_subdir+
      "images_masks_training.txt";
   filefunc::openfile(images_masks_training_filename, outstream);   

   for(int i = 0; i < n_training_images; i++)
   {
      int curr_image_ID = i;
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end()) continue;
      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
      }
   }
   filefunc::closefile(images_masks_training_filename, outstream);

   string images_masks_validation_filename=deeplab_inputs_subdir+
      "images_masks_validation.txt";
   filefunc::openfile(images_masks_validation_filename, outstream);   

   for(int i = n_training_images; i < n_training_images + n_validation_images;
       i++)
   {
      int curr_image_ID = i;
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end()) continue;
      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
      }
   }
   filefunc::closefile(images_masks_validation_filename, outstream);

// Recall several authors stress that training and validation data
// sets should be randomized!  As John Wood pointed out, we can use
// the linux utility "shuf" to generate random permutations:

   string shuffled_images_masks_training_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_training.txt";
   string unix_cmd = "shuf "+images_masks_training_filename+" > "+
      shuffled_images_masks_training_filename;
   sysfunc::unix_command(unix_cmd);

   string shuffled_images_masks_validation_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_validation.txt";
   unix_cmd = "shuf "+images_masks_validation_filename+" > "+
      shuffled_images_masks_validation_filename;
   sysfunc::unix_command(unix_cmd);

   string banner="Exported shuffled training and validation image + masks sets to "+
      faces_subdir;
   outputfunc::write_banner(banner);
}

