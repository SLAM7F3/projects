// ====================================================================
// Program GENERATE_BBOX_TILES imports an XML file generated by Davis
// King's IMGLAB program that contains bounding boxes around objects
// (e.g. human faces) for some set of trained images.  Given an input
// image, the median pixel width is first calculated for all its
// bboxes.  If the median bbox width < 27 { > 54 } pixels, we work
// with a double-sized {half-sized} version of the input image and
// rescale its bounding boxes by a factor of two.

// Each bounding box becomes a seed for an image tile with pixel
// dimensions deeplab_tile_size x deeplab_tile_size.  If the bbox has
// pixel dimensions less than deeplab_tile_size x deeplab_tile_size,
// the tile is randomly positioned so as to include the entire bbox.
// Otherwise, the tile contains some random part of the bbox contents.
// The user is initially queried to enter the number of image tiles to
// generate per bounding box.  The user also supplies the number of
// deeplab tiles to generate for images containing zero bounding
// boxes.

// For each deeplab tile, a mask written to an 8-bit greyscale PNG
// file is created whose background value = 0 and foreground value = 1
// [, 2, 3, 4...].  Exported image tiles become inputs to Deeplab's
// DNN, while the masks become inputs to Deeplab's loss function.

// GENERATE_BBOX_TILES also writes out text files containing
// associations between image tiles and masks.  It randomly shuffles
// the associations and then splits them into training, validation and
// testing sets.

//                       ./generate_bbox_tiles

// ====================================================================
// Last updated on 6/14/16; 6/15/16; 6/19/16; 6/29/16; 7/20/16
// ====================================================================

#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include <dlib/array.h>
#include <dlib/array2d.h>
#include <dlib/gui_widgets.h>
#include <dlib/image_processing.h>
#include <dlib/data_io.h>

#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "math/mathfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/outputfuncs.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "video/videofuncs.h"
#include "time/timefuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::exception;
using std::flush;
using std::ifstream;
using std::ios;
using std::map;
using std::ofstream;
using std::pair;
using std::string;
using std::vector;

void free_tr_ptrs(texture_rectangle* full_tr_ptr, 
                  texture_rectangle* double_tr_ptr, 
                  texture_rectangle* half_tr_ptr)
{
   delete full_tr_ptr;
   delete double_tr_ptr;
   delete half_tr_ptr;
}

// ====================================================================

int main(int argc, char** argv)
{  
   bool object_classification = false;
   bool vertical_classification = false;
   bool horizontal_classification = false;
   bool quadrant_classification = false;

   cout << "Enter 'o' to perform full object classification:" << endl;
   cout << "Enter 'v' to perform vertical half object classification:" << endl;
   cout << "Enter 'h' to perform horizontal half object classification:" 
        << endl;
   cout << "Enter 'q' to perform quadrant object classification:" << endl;

   string classification_str;
   cin >> classification_str;

   if (classification_str == "o")
   {
      object_classification = true;
   }
   else if (classification_str == "v")
   {
      vertical_classification = true;
   }
   else if (classification_str == "h")
   {
      horizontal_classification = true;
   }
   else if (classification_str == "q")
   {
      quadrant_classification = true;
   }
   else
   {
      cout << "Incorrect input" << endl;
      exit(-1);
   }

   enum bbox_size 
   {
      small, medium, large
   };

// As of 6/4/16, we strongly believe use_scaled_training_data_flag
// should ALWAYS equal true!

   bool use_scaled_training_data_flag = true;   // As of Jun 4, 
//   bool use_scaled_training_data_flag = false;

   bool augment_data_flag = true;   
//   bool augment_data_flag = false;

// Increasing tinting threshold --> less color tinting in exported tiles
//   double tinting_threshold = 0;     // default before June 5
   double tinting_threshold = 0.2;     // default as of Jun 14
//   double tinting_threshold = 0.50;

   bool rgb2grey_flag = true;		       // default as of Jun 14
//   bool rgb2grey_flag = false;
   double rgb2grey_threshold = 0.1;            // default as of Jun 14
//   double rgb2grey_threshold = 0.12;         // default as of June 5

// Increasing noise_threshold --> less noise introduced into exported tiles
//   double noise_threshold = 0.0;	     // default before June 5
   double noise_threshold = 0.5;             // default as of Jun 14
//   double noise_threshold = 1.0;  // Effectively disable gaussian noise

   timefunc::initialize_timeofday_clock(); 
//    nrfunc::init_time_based_seed();

//   bool visualize_masks_flag = true;
   bool visualize_masks_flag = false;
   cout << "visualize_masks_flag = " << visualize_masks_flag << endl;

// Recall image chips and masks should equal 321x321 in pixel size
// in order to meet deeplab's GPU card and batch size memory
// requirements:
   
   const int deeplab_tile_size = 321;	
//   const int max_tiles_per_image = 20;        // default in Jun 2016
   const int max_tiles_per_image = 40;		// default as of Jul 20, 2016
//   const int max_tiles_per_image = 50;

   string faces_rootdir = "/data/TrainingImagery/faces/";
   string labeled_data_subdir=faces_rootdir+"labeled_data/";   

   int faces_ID = -1;
   cout << "Enter faces ID (-1 for default):" << endl;
   cin >> faces_ID;
   string faces_subdir=labeled_data_subdir+"faces";
   if(faces_ID >= 0)
   {
      faces_subdir += "_"+stringfunc::integer_to_string(faces_ID,2);
   }
   filefunc::add_trailing_dir_slash(faces_subdir);

   bool ignore_faces_flag = false;
   bool ignore_hands_flag = false;

   string input_str;
/*
   cout << "Enter f to set ignore_faces_flag to true" << endl;
   cin >> input_str;
   if(input_str == "f") ignore_faces_flag = true;
*/

   cout << "Enter h to set ignore_hands_flag to true" << endl;
   cin >> input_str;
   if(input_str == "h") ignore_hands_flag = true;

   int n_tiles_per_positive_sample0_bbox = 0;
   if(!ignore_faces_flag)
   {
      cout << "Enter number of tiles to generate per positive example #0 (e.g. face) bbox:" 
           << endl;
      cin >> n_tiles_per_positive_sample0_bbox;
   }
   
   int n_tiles_per_positive_sample1_bbox = 0;
   if(!ignore_hands_flag)
   {
      cout << "Enter number of tiles to generate per positive example #1 (e.g. hand) bbox:" 
           << endl;
      cin >> n_tiles_per_positive_sample1_bbox;
   }
   
   int n_tile_repetitions_per_negative_example = 2;
//   cout << "Enter number of tile repetitions to be performed for negative examp images with no bboxes:"
//        << endl;
//   cin >> n_tiles_repetitions_per_negative_example;

   string training_images_subdir=faces_subdir+"training_images/";
   string fullsized_training_images_subdir=training_images_subdir
      +"fullsized/";
   string doublesized_training_images_subdir=training_images_subdir
      +"doublesized/";
   string halfsized_training_images_subdir=training_images_subdir
      +"halfsized/";

   string validation_images_subdir=faces_subdir+"validation_images/";
   string fullsized_validation_images_subdir=validation_images_subdir
      +"fullsized/";
   string doublesized_validation_images_subdir=validation_images_subdir
      +"doublesized/";
   string halfsized_validation_images_subdir=validation_images_subdir
      +"halfsized/";

   string testing_images_subdir=faces_subdir+"testing_images/";

   string training_xml_filename=training_images_subdir+"training_images.xml";
   string validation_xml_filename=validation_images_subdir+
      "validation_images.xml";
   string testing_xml_filename=testing_images_subdir+"testing_images.xml";

   string deeplab_inputs_basedir = "deeplab_inputs";
   cout << "Enter basename for output deeplab subdirectory" << endl;
   cout << "  (e.g. Jun19_only_faces_deeplab)" << endl;
   cin >> deeplab_inputs_basedir;
   filefunc::add_trailing_dir_slash(deeplab_inputs_basedir);

   string deeplab_inputs_subdir=faces_subdir+deeplab_inputs_basedir;
   string tiles_subdir=deeplab_inputs_subdir+"tiles/";
   string entire_masks_subdir=deeplab_inputs_subdir+"full_masks/";
   string eightbit_masks_subdir=deeplab_inputs_subdir+"eightbit_masks/";
   filefunc::dircreate(deeplab_inputs_subdir);
   filefunc::dircreate(tiles_subdir);
   filefunc::dircreate(eightbit_masks_subdir);

   if (visualize_masks_flag) filefunc::dircreate(entire_masks_subdir);
   dlib::image_dataset_metadata::dataset training_dataset;
   dlib::image_dataset_metadata::dataset validation_dataset;
   dlib::image_dataset_metadata::dataset testing_dataset;

   dlib::image_dataset_metadata::load_image_dataset_metadata(
      training_dataset, training_xml_filename);
   dlib::image_dataset_metadata::load_image_dataset_metadata(
      validation_dataset, validation_xml_filename);
   dlib::image_dataset_metadata::load_image_dataset_metadata(
      testing_dataset, testing_xml_filename);

// Store unique bbox labels within an STL map:

   int object_class_ID = 0;
   typedef std::map<std::string, int> LABELS_MAP;
   LABELS_MAP labels_map;
   LABELS_MAP::iterator labels_map_iter;

// independent string: bbox label
// dependent int : object class ID

// Import bounding boxes for training and validation data sets:

   vector<vector<dlib::image_dataset_metadata::box> > training_object_bboxes,
      validation_object_bboxes, testing_object_bboxes;

   int n_training_images = training_dataset.images.size();
   int n_training_bboxes = 0;
   vector<string> training_image_basenames, validation_image_basenames,
      testing_image_basenames;
   for(int n = 0; n < n_training_images; n++)
   {
      training_image_basenames.push_back(training_dataset.images[n].filename);
      vector<dlib::image_dataset_metadata::box> bboxes;
      for(unsigned int b = 0; b < training_dataset.images[n].boxes.size(); b++)
      {
         dlib::image_dataset_metadata::box curr_box = 
            training_dataset.images[n].boxes[b];
         string curr_label = curr_box.label;

         labels_map_iter = labels_map.find(curr_label);
         if(labels_map_iter == labels_map.end())
         {
            labels_map[curr_label] = object_class_ID;
            object_class_ID++;
         }
         
         bboxes.push_back(curr_box);
         n_training_bboxes++;
      }
      training_object_bboxes.push_back(bboxes);
   } // loop over index n labeling training images
   int n_object_classes = labels_map.size();
   cout << "n_object_classes = " << n_object_classes << endl;

   int n_validation_images = validation_dataset.images.size();
   int n_validation_bboxes = 0;
   for(int n = 0; n < n_validation_images; n++)
   {
      validation_image_basenames.push_back(
         validation_dataset.images[n].filename);
      vector<dlib::image_dataset_metadata::box> bboxes;
      for(unsigned int b = 0; b < validation_dataset.images[n].boxes.size(); 
          b++)
      {
         bboxes.push_back(validation_dataset.images[n].boxes[b]);
         n_validation_bboxes++;
      }
      validation_object_bboxes.push_back(bboxes);
   } // loop over index n labeling validation images

   cout << "validation_object_bboxes.size() = "
        << validation_object_bboxes.size() << endl;

   int n_testing_images = testing_dataset.images.size();
   int n_testing_bboxes = 0;
   for(int n = 0; n < n_testing_images; n++)
   {
      testing_image_basenames.push_back(
         testing_dataset.images[n].filename);
      vector<dlib::image_dataset_metadata::box> bboxes;
      for(unsigned int b = 0; b < testing_dataset.images[n].boxes.size(); 
          b++)
      {
         bboxes.push_back(testing_dataset.images[n].boxes[b]);
         n_testing_bboxes++;
      }
      testing_object_bboxes.push_back(bboxes);
   } // loop over index n labeling testing images

// Export text file containing class names for labeled objects.
// Recall Deeplab expects zeroth class corresponds to background:

   string object_classes_filename=deeplab_inputs_subdir+"object_names.classes";
   ofstream outstream;
   filefunc::openfile(object_classes_filename, outstream);
   outstream << "__background__" << endl;

   if(object_classification)
   {

// Import object class labels from Davis' XML file:

      for(labels_map_iter = labels_map.begin(); 
          labels_map_iter != labels_map.end(); labels_map_iter++)
      {
         string bbox_label = labels_map_iter->first;
         cout << "bbox label = " << bbox_label << endl;
         outstream << bbox_label << endl;
      }
   }
   else if (vertical_classification)
   {
      outstream << "top_half" << endl;
      outstream << "bottom_half" << endl;
   }
   else if (horizontal_classification)
   {
      outstream << "left_half" << endl;
      outstream << "right_half" << endl;
   }
   else if (quadrant_classification)
   {
      outstream << "top_left" << endl;
      outstream << "top_right" << endl;
      outstream << "bottom_left" << endl;
      outstream << "bottom_right" << endl;
   }
   filefunc::closefile(object_classes_filename, outstream);

   int n_positive_example_tiles = 0;
   int n_negative_example_tiles = 0;

   int n_total_images = n_training_images + n_validation_images 
      + n_testing_images;
   int istart = 0;

// As of Sun Jun 19, 2016, we no longer want to send any nontrivial
// number of validation images into Deeplab.  Deeplab "testing"
// results generated on validation images are nearly worthless, and it
// takes time to perform such "testing".  Moreover, we don't want to
// risk inadvertently having validation images incorporated into the
// training model.  

//   int istop = n_training_images + n_validation_images;
   int istop = n_training_images + 2;

   if(visualize_masks_flag)
   {	
      istop = 10;
      cout << "Only visualize masks for images < istop = " << istop << endl;
   }

   cout << "n_total_images =  " << n_total_images << endl;
   cout << "n_training_images = " << n_training_images << endl;
   cout << "n_validation_images = " << n_validation_images << endl;
   cout << "n_testing_images = " << n_testing_images << endl;
   cout << "istart = " << istart << " istop = " << istop << endl;
   cout << "n_training_bboxes = " << n_training_bboxes << endl;
   cout << "n_validation_bboxes = " << n_validation_bboxes << endl;
   cout << "n_testing_bboxes = " << n_testing_bboxes << endl;
   cout << endl;

   ofstream metastream;
   string metadata_filename=deeplab_inputs_subdir+"training.metadata";
   filefunc::openfile(metadata_filename, metastream);

   metastream << faces_subdir << endl;
   metastream << timefunc::getcurrdate() << endl << endl;
   metastream << "n_total_images =  " << n_total_images << endl;
   metastream << "n_training_images = " << n_training_images << endl;
   metastream << "n_validation_images = " << n_validation_images << endl;
   metastream << "n_testing_images = " << n_testing_images << endl;
   metastream << "istart = " << istart << " istop = " << istop << endl;
   metastream << "n_training_bboxes = " << n_training_bboxes << endl;
   metastream << "n_validation_bboxes = " << n_validation_bboxes << endl;
   metastream << "n_testing_bboxes = " << n_testing_bboxes << endl;

   if(object_classification)
   {
      cout << "Full object classification" << endl;
      metastream << "Full object classification" << endl;

      for(labels_map_iter = labels_map.begin(); 
          labels_map_iter != labels_map.end(); labels_map_iter++)
      {
         string bbox_label = labels_map_iter->first;
         metastream << "  " << bbox_label << endl;
      }
   }
   else if(vertical_classification)
   {
      cout << "Vertical half object classification" << endl;
      metastream << "Vertical half object classification" << endl;
   }
   else if(horizontal_classification)
   {
      cout << "Horizontal half object classification" << endl;
      metastream << "Horizontal half object classification" << endl;
   }
   else if(quadrant_classification)
   {
      cout << "Quadrant object classification" << endl;
      metastream << "Quadrant object classification" << endl;
   }

   cout << "Use scaled training data flag = " << use_scaled_training_data_flag
        << endl;
   metastream << "Use scaled training data flag = " 
              << use_scaled_training_data_flag << endl;
   cout << "Augmented data flag = " << augment_data_flag << endl;
   metastream << "Augmented data flag = " << augment_data_flag << endl;
   cout << "Tinting threshold = " << tinting_threshold << endl;
   metastream << "Tinting threshold = " << tinting_threshold << endl;
   cout << "RGB --> greyscale flag = " << rgb2grey_flag << endl;
   metastream << "RGB --> greyscale flag = " << rgb2grey_flag << endl;
   cout << "Noise threshold = " << noise_threshold << endl;
   metastream << "Noise threshold = " << noise_threshold << endl;
   cout << "Ignore faces flag = " << ignore_faces_flag << endl;
   metastream << "Ignore faces flag = " << ignore_faces_flag << endl;
   cout << "Ignore hands flag = " << ignore_hands_flag << endl;
   metastream << "Ignore hands flag = " << ignore_hands_flag << endl;
   
   cout << "Visualize masks flag = " << visualize_masks_flag << endl;
   metastream << "Visualize masks flag = " << visualize_masks_flag << endl;
   metastream << "Number of tile samples per positive example #0 (face) bbox = " 
              << n_tiles_per_positive_sample0_bbox << endl;
   metastream << "Number of tile samples per positive example #1 (hand) bbox = " 
              << n_tiles_per_positive_sample1_bbox << endl;

   metastream << "Max tiles per image = " 
              << max_tiles_per_image << endl;

// Store pairs of tile and corresponding mask filenames within an STL
// map:

   typedef pair<string, string> STRING_PAIR;
   typedef std::map<int, vector<STRING_PAIR> > IMAGE_TILES_MAP;
// independent int: image index
// dependent vector<string,string > : pairs of tile and mask filenames associated with image

   IMAGE_TILES_MAP image_tiles_map;
   IMAGE_TILES_MAP::iterator image_tiles_map_iter;
   vector<int> object_mask_values;
   int lowerhalf_mask_value, upperhalf_mask_value;
   int top_right_mask_value, top_left_mask_value, bottom_right_mask_value, 
      bottom_left_mask_value;

   if(visualize_masks_flag)
   {
      for(int i = 0; i < n_object_classes; i++)
      {
         int curr_mask_value = 256.0 * (i + 1) / double(n_object_classes + 1); 
         object_mask_values.push_back(curr_mask_value);
      }
      lowerhalf_mask_value = 86;
      upperhalf_mask_value = 170;

      top_left_mask_value = 51;
      top_right_mask_value = 102;
      bottom_left_mask_value = 153;
      bottom_right_mask_value = 204;
   }
   else
   {
      for(int i = 0; i < n_object_classes; i++)
      {
         int curr_mask_value = i + 1;
         object_mask_values.push_back(curr_mask_value);
      }
      lowerhalf_mask_value = 1;
      upperhalf_mask_value = 2;

      top_left_mask_value = 1;
      top_right_mask_value = 2;
      bottom_left_mask_value = 3;
      bottom_right_mask_value = 4;
   }

// ----------------------------------------------------------------------
// Loop over training and validation images starts here
// ----------------------------------------------------------------------

   int total_tile_counter = 0;
   int xdim, ydim; // Pixel width and height of FULLIMAGE 
   for (int i = istart; i < istop; i++)
   {
      if(i%20 == 0)
      {
         cout << "Processing image " << i 
              << " : istop = " << istop << endl;
         cout << "n_positive_example_tiles = " << n_positive_example_tiles
              << endl;
         cout << "n_negative_example_tiles = " << n_negative_example_tiles
              << endl;
         cout << endl;
      }

      string image_label_str;
      string curr_fullimage_filename, curr_doubleimage_filename,
         curr_halfimage_filename;
      vector<dlib::image_dataset_metadata::box> curr_object_bboxes;

      bbox_size median_bbox_size = medium;
      if(i < n_training_images)
      {
         int i_train = i;
         curr_fullimage_filename = fullsized_training_images_subdir+
            training_image_basenames[i];
         curr_doubleimage_filename = doublesized_training_images_subdir+
            "doublesized_"+training_image_basenames[i];
         curr_halfimage_filename = halfsized_training_images_subdir+
            "halfsized_"+training_image_basenames[i];

         vector<string> substrings = 
            stringfunc::decompose_string_into_substrings(
               training_image_basenames[i_train], "_.");
         image_label_str = substrings[1];

         if(!use_scaled_training_data_flag)
         {
            curr_doubleimage_filename = curr_fullimage_filename;
            curr_halfimage_filename = curr_fullimage_filename;
         }
         curr_object_bboxes = training_object_bboxes[i_train];

         imagefunc::get_image_width_height(
            curr_fullimage_filename, xdim, ydim);

// Extract median pixel width for all bboxes within current image.
// Then reset median_bbox_size to small or large if median pixel width
// is less than 27 or greater than 54 pixels:

         int n_bboxes = curr_object_bboxes.size();
//         cout << "n_bboxes = " << n_bboxes << endl;
         if(n_bboxes > 0)
         {
            vector<double> bbox_widths;
            for(int b = 0; b < n_bboxes; b++)
            {
               dlib::image_dataset_metadata::box curr_bbox = 
                  curr_object_bboxes.at(b);
               dlib::rectangle curr_rect = curr_bbox.rect;
               int px_min = curr_rect.left();
               int px_max = curr_rect.right();
               px_min = basic_math::max(0, px_min);
               px_max = basic_math::min(xdim - 1, px_max);
               bbox_widths.push_back(px_max - px_min);
            }
            double median_bbox_width = mathfunc::median_value(bbox_widths);
//            cout << "median_bbox_width = " << median_bbox_width << endl;

            if(median_bbox_width < 27)
            {
               median_bbox_size = small;
            }
            else if (median_bbox_width > 54)
            {
               median_bbox_size = large;
            }
         } // n_bboxes > 0 conditional
      }
      else
      {
         int i_valid = i - n_training_images;
         curr_fullimage_filename = fullsized_validation_images_subdir+
            validation_image_basenames[i_valid];
         curr_doubleimage_filename = doublesized_validation_images_subdir+
            "doublesized_"+validation_image_basenames[i_valid];
         curr_halfimage_filename = halfsized_validation_images_subdir+
            "halfsized_"+validation_image_basenames[i_valid];

         vector<string> substrings = 
            stringfunc::decompose_string_into_substrings(
               validation_image_basenames[i_valid], "_.");
         image_label_str = substrings[1];
         curr_object_bboxes = validation_object_bboxes[i_valid];
      } // i < n_training_images conditional

      texture_rectangle* curr_tr_ptr = NULL;
      texture_rectangle* full_tr_ptr = NULL;
      texture_rectangle* half_tr_ptr = NULL;
      texture_rectangle* double_tr_ptr = NULL;

      if(median_bbox_size == medium)
      {
         if(!filefunc::fileexist(curr_fullimage_filename)) 
         {
            cout << "No curr_fullimage_filename = "
                 << curr_fullimage_filename << endl;

            free_tr_ptrs(full_tr_ptr, double_tr_ptr, half_tr_ptr);
            continue;
         }
         full_tr_ptr = new texture_rectangle(curr_fullimage_filename, NULL); 
         curr_tr_ptr = full_tr_ptr;
      }
      else if(median_bbox_size == small)
      {
         if(!filefunc::fileexist(curr_doubleimage_filename)) 
         {
//            cout << "No curr_doubleimage_filename = "
//                 << curr_doubleimage_filename << endl;
            free_tr_ptrs(full_tr_ptr, double_tr_ptr, half_tr_ptr);
            continue;
         }
         double_tr_ptr=new texture_rectangle(curr_doubleimage_filename,NULL); 
         curr_tr_ptr = double_tr_ptr;
      }
      else if(median_bbox_size == large)
      {
         if(!filefunc::fileexist(curr_halfimage_filename)) 
         {
//            cout << "No curr_halfimage_filename = "
//                 << curr_halfimage_filename << endl;
            free_tr_ptrs(full_tr_ptr, double_tr_ptr, half_tr_ptr);
            continue;
         }
         half_tr_ptr = new texture_rectangle(curr_halfimage_filename, NULL); 
         curr_tr_ptr = half_tr_ptr;
      }

      if(curr_tr_ptr->get_VideoType() == texture_rectangle::unknown) 
      {
         free_tr_ptrs(full_tr_ptr, double_tr_ptr, half_tr_ptr);
         continue;
      }
      
      if(curr_tr_ptr->getNchannels() != 3) 
      {
         free_tr_ptrs(full_tr_ptr, double_tr_ptr, half_tr_ptr);
         continue;
      }
      
//      cout << "median_bbox_size = " << median_bbox_size << endl;
//      cout << "texture rectangle filename = " 
//           << curr_tr_ptr->get_video_filename() << endl;
      int img_width = curr_tr_ptr->getWidth();
      int img_height = curr_tr_ptr->getHeight();
//      cout << "img_width = " << img_width << " img_height = " << img_height
//           << endl;

      texture_rectangle *tr2_ptr = new texture_rectangle(
         img_width, img_height, 1, 3, NULL);
      texture_rectangle mask_tr(img_width, img_height, 1, 3, NULL);
      mask_tr.clear_all_RGB_values();

      if(i%50 == 0)
      {
         double progress_frac = double(i-istart)/double(istop-istart);
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
      }

// Paint rectangle regions with mask values:

      int mask_value = 0;
      int n_bboxes = curr_object_bboxes.size();
      int n_face_bboxes = 0;
      int n_hand_bboxes = 0;
      for(int b = 0; b < n_bboxes; b++)
      {
         dlib::image_dataset_metadata::box curr_bbox = 
            curr_object_bboxes.at(b);
         string curr_bbox_label = curr_bbox.label;

// FAKE FAKE:  Hack as of Tues Jun 14

         if(curr_bbox_label == "face") n_face_bboxes++;
         if(curr_bbox_label == "hand") n_hand_bboxes++;
         if(ignore_faces_flag && curr_bbox_label == "face") continue;
         if(ignore_hands_flag && curr_bbox_label == "hand") continue;

         int mask_value = -1;
         labels_map_iter = labels_map.find(curr_bbox.label);
         if(labels_map_iter == labels_map.end())
         {
            cout << "Error:  curr_bbox.label = " << curr_bbox.label
                 << " not found in labels_map ! " << endl;
            exit(-1);
         }
         else
         {
            int object_ID = labels_map_iter->second;
            mask_value = object_mask_values.at(object_ID);
         }

         dlib::rectangle curr_rect = curr_bbox.rect;
         int px_min = curr_rect.left();
         int px_max = curr_rect.right();
         int py_min = curr_rect.top();
         int py_max = curr_rect.bottom();
         px_min = basic_math::max(0, px_min);
         px_max = basic_math::min(xdim - 1, px_max);
         py_min = basic_math::max(0, py_min);
         py_max = basic_math::min(ydim - 1, py_max);
         
         if(median_bbox_size == small)
         {
            px_min *= 2;
            px_max *= 2;
            py_min *= 2;
            py_max *= 2;
         }
         else if (median_bbox_size == large)
         {
            px_min /= 2;
            px_max /= 2;
            py_min /= 2;
            py_max /= 2;
         }

         int px_mean = 0.5 * (px_min + px_max);
         int py_mean = 0.5 * (py_min + py_max);
         
         for(int py = py_min; py < py_max; py++)
         {
            for(int px = px_min; px < px_max; px++)
            {
               if (vertical_classification)
               {
                  if(py < py_mean)
                  {
                     mask_value = lowerhalf_mask_value;
                  }
                  else
                  {
                     mask_value = upperhalf_mask_value;
                  }
               }
               else if (horizontal_classification)
               {
                  if(px < px_mean)
                  {
                     mask_value = lowerhalf_mask_value;
                  }
                  else
                  {
                     mask_value = upperhalf_mask_value;
                  }
               }
               else if (quadrant_classification)
               {
                  if(px < px_mean && py < py_mean)
                  {
                     mask_value = top_left_mask_value;
                  }
                  else if (px < px_mean && py >= py_mean)
                  {
                     mask_value = bottom_left_mask_value;
                  }
                  else if(px >= px_mean && py < py_mean)
                  {
                     mask_value = top_right_mask_value;
                  }
                  else if (px >= px_mean && py >= py_mean)
                  {
                     mask_value = bottom_right_mask_value;
                  }
               }

// As of 6/3/16, we assume mask values are ORDERED by importance.  So
// a lower-valued mask value can be overwritten by a higher-valued
// mask value, but not vice-versa.  For example, we generally want
// face mask values to be overwritten by hand mask values but not
// vice-versa:

               int prev_mask_value;
               mask_tr.get_pixel_RGB_values(
                  px, py, prev_mask_value, prev_mask_value, prev_mask_value);
               if(mask_value > prev_mask_value)
               {
                  mask_tr.set_pixel_RGB_values(
                     px, py, mask_value, mask_value, mask_value);
               }
               
            }
         }
      } // loop over index b labeling bboxes for current image

      if (visualize_masks_flag)
      {
         string mask_filename=entire_masks_subdir+"mask_"
            +image_label_str+".png";
//         cout << "mask_filename = " << mask_filename << endl;
         mask_tr.write_curr_subframe(
            0, img_width-2, 0, img_height-2,mask_filename);
      }

// On 1/4/16, we learned from Tho that tiles should generally be
// padded so that deleterious border effects upon classification are
// minimized.  We won't worry about this issue for now...

// Loop over each bbox within current image.  Generate a tile which is
// quasi-centered around current bbox:

      int n_iters = n_tiles_per_positive_sample0_bbox;
      if(ignore_faces_flag)
      {
         n_iters = n_tiles_per_positive_sample1_bbox;
         n_bboxes = n_hand_bboxes;
      }
      else if(ignore_hands_flag)
      {
         n_bboxes = n_face_bboxes;
      }
      int max_b = n_bboxes;
      
      if(n_bboxes == 0)
      {
         max_b = n_tile_repetitions_per_negative_example * (
            1 + img_width * img_height / sqr(deeplab_tile_size));
         max_b = basic_math::min(max_b, max_tiles_per_image);
         n_iters = 1;
      }
      
      if(n_bboxes > max_tiles_per_image)
      {
         n_iters = 1;
      }
      
      int curr_image_tile_counter = 0;
      for(int iter = 0; iter < n_iters; iter++)
      {

// Quasi-randomize ordering of input bboxes:

         int prime = 997;	 // largest prime < 1000
         vector<int> permuted_b;
         for(int b = 0; b < max_b; b++)
         {
            int q = b * prime;
            permuted_b.push_back(q % max_b );
         }
         
         for(int b = 0; b < max_b; b++)
         {

// Do not generate too many tiles for any single input image:

            if(curr_image_tile_counter > max_tiles_per_image) continue;
            curr_image_tile_counter++;
            
            int px_start, py_start;
            if(n_bboxes > 0)
            {
               dlib::image_dataset_metadata::box curr_bbox = 
                  curr_object_bboxes.at(permuted_b[b]);

//               cout << "image i = " << i 
//                    << " iter = " << iter 
//                    << " b = " << b 
//                    << " permuted_b[b] = "
//                    << permuted_b[b] << endl;

// FAKE FAKE:  Hack as of Mon, Jun 6 at 7:48 am
// Eventually fix this to be more elegant !!!

               if(curr_bbox.label == "face")
               {
                  if(ignore_faces_flag) continue;
               }

               if(curr_bbox.label == "hand")
               {
                  if(ignore_hands_flag) continue;
                  if(iter >= n_tiles_per_positive_sample1_bbox) continue;
               }
               
               dlib::rectangle curr_rect = curr_bbox.rect;
               int px_min = curr_rect.left();
               int px_max = curr_rect.right();
               int py_min = curr_rect.top();
               int py_max = curr_rect.bottom();

               px_min = basic_math::max(0, px_min);
               px_max = basic_math::min(xdim - 1, px_max);
               py_min = basic_math::max(0, py_min);
               py_max = basic_math::min(ydim - 1, py_max);

               if(median_bbox_size == small)
               {
                  px_min *= 2;
                  px_max *= 2;
                  py_min *= 2;
                  py_max *= 2;
               }
               else if (median_bbox_size == large)
               {
                  px_min /= 2;
                  px_max /= 2;
                  py_min /= 2;
                  py_max /= 2;
               }

               int bbox_width = px_max - px_min;
               int bbox_height = py_max - py_min;

               double alpha = nrfunc::ran1();
               double beta = nrfunc::ran1();
               px_start = alpha * (px_min - deeplab_tile_size + bbox_width) + 
                  (1 - alpha) * px_min;
               py_start = beta * (py_min - deeplab_tile_size + bbox_height) + 
                  (1 - beta) * py_min;
            }
            else
            {
               px_start = nrfunc::ran1() * img_width;
               py_start= nrfunc::ran1() * img_height;
            }
            int px_stop = px_start + deeplab_tile_size - 1;
            int py_stop = py_start + deeplab_tile_size - 1;

            string bbox_IDstr = stringfunc::integer_to_string(b, 2);
            string iter_label = stringfunc::integer_to_string(iter, 2);
            string curr_tile_filename = 
               tiles_subdir+"tile_"+image_label_str+"_"+
               bbox_IDstr+"_"+iter_label+".jpg";

// Horizontally flip 50% of all output tile/mask pairs:

            bool horiz_flip_flag = false;
            if(nrfunc::ran1() < 0.5)
            {
               horiz_flip_flag = true;
            }

// If augment_data_flag == true, perform color modulation and noise
// addition for some sizable fraction of output tiles:
            
            if(augment_data_flag && nrfunc::ran1() > 0.25
               && n_bboxes > 0)
            {
               tr2_ptr->copy_RGB_values(curr_tr_ptr);

               if(nrfunc::ran1() > tinting_threshold)
               {
                  double delta_h = -25 + nrfunc::ran1() * 50;
                  double delta_s = -0.2 + nrfunc::ran1() * 0.4;

// If rgb2grey_flag == true, effectively reset saturation to zero for
// some relatively small percentage of output tiles:

                  if(rgb2grey_flag && nrfunc::ran1() < rgb2grey_threshold)
                  {
                     delta_s = -1.5;
                  }
                  double delta_v = -0.2 + nrfunc::ran1() * 0.4;

               
                  tr2_ptr->globally_perturb_hsv(
                     px_start, px_stop, py_start, py_stop,
                     delta_h, delta_s, delta_v);
               }

               if(nrfunc::ran1() >= noise_threshold)
               {
                  double noise_frac= 0.045 * nrfunc::ran1(); 
                  double sigma = noise_frac * 255;
                  tr2_ptr->add_gaussian_noise(
                     px_start, px_stop, py_start, py_stop, sigma);
               }

//               cout << "i = " << i 
//                    << " delta_h = " << delta_h << " noise_frac = "
//                    << noise_frac << endl;

               tr2_ptr->write_curr_subframe(
                  px_start, px_stop, 
                  img_height - py_stop, img_height - py_start,
                  curr_tile_filename, horiz_flip_flag);

/*
// Randomly select some fraction of tiles to blur by some
// random amount:

               double random_blur = nrfunc::ran1();
               double blur_sigma = 0;
               if(random_blur < 0.25)
               {
                  blur_sigma = 0;
               }
               else if (random_blur >= 0.25 && random_blur < 0.50)
               {
                  blur_sigma = 0.5 + nrfunc::ran1();  
               }
               else if (random_blur >= 0.50 && random_blur < 0.65)
               {
                  blur_sigma = 1.5 + nrfunc::ran1();        
               }
               else if (random_blur >= 0.65 && random_blur < 0.80)
               {
                  blur_sigma = 2.5 + nrfunc::ran1();        
               }
               else if (random_blur >= 0.80 && random_blur < 0.90)
               {
                  blur_sigma = 3.0 + nrfunc::ran1();        
               }
               else
               {
                  blur_sigma = 4.0;  
               }

               Magick::Image tile_image(
                  tr2_ptr->getWidth(), tr2_ptr->getHeight(), 
                  "RGB", MagickCore::CharPixel,
                  tr2_ptr->get_image_ptr()->data());
               tile_image.depth(8);

               if(horiz_flip_flag < 0.5)
               {
//                  tile_image.flip();
               }

               if(blur_sigma > 0)
               {
                  videofunc::gaussian_blur_image(tile_image,blur_sigma);
               }
               tile_image.write(curr_tile_filename);  
*/
            }
            else
            {
               curr_tr_ptr->write_curr_subframe(
                  px_start, px_stop, 
                  img_height - py_stop, img_height - py_start,
                  curr_tile_filename, horiz_flip_flag);
            }

//            cout << "total_tile_counter = " << total_tile_counter << endl;
//            cout << "horiz_flip_flag = " << horiz_flip_flag << endl;
            total_tile_counter++;

// Within this innner loop, py = 0 corresponds to the *top* row of
// the full image. 
            
            mask_value = 0;
            vector<vector<unsigned char> > byte_array;
            for(int py = py_start; py <= py_stop; py++)
            {
               vector<unsigned char> curr_byte_row;
               for(int px = px_start; px <= px_stop; px++)
               {

// Set mask values for pixels lying outside borders of current image
// equal to background value 0:

                  unsigned char curr_char = 0;
                  if(visualize_masks_flag)
                  {
                     curr_char = 255;
                  }

                  int px2 = px;
                  if(horiz_flip_flag)
                  {
                     int delta = px-px_start;
                     px2 = px_stop - delta;
                  }

                  mask_value = 0;
                  if(px2 >= 0 && py >= 0 && px2 < img_width && py < img_height)
                  {
                     mask_tr.get_pixel_RGB_values(
                        px2, py, mask_value, mask_value, mask_value);
                     if(horiz_flip_flag && quadrant_classification)
                     {
                        if(mask_value == top_left_mask_value)
                        {
                           mask_value = top_right_mask_value;
                        }
                        else if(mask_value == top_right_mask_value)
                        {
                           mask_value = top_left_mask_value;
                        }
                        else if(mask_value == bottom_left_mask_value)
                        {
                           mask_value = bottom_right_mask_value;
                        }
                        else if(mask_value == bottom_right_mask_value)
                        {
                           mask_value = bottom_left_mask_value;
                        }
                     } // horiz_flip_flag conditional
                  }
                     
// Recall get_pixel_RGB_values() returns a negative value if input pixel
// coordinates are invalid!

                  if(mask_value >= 0)
                  {
                     curr_char = mask_value;
                  }

//                  if (int(curr_char) >= 2 && !visualize_masks_flag)
//                  {
//                     cout << "px = " << px << " py = " << py 
//                          << " curr_char = " << int(curr_char) << endl;
//                  }
                  
                  curr_byte_row.push_back( curr_char );
               } // loop over index px
               
               byte_array.push_back(curr_byte_row);
            } // loop over index py

// Recall zeroth row fed into write_8bit_greyscale_pngfile() must
// correspond to TOP row of the image to be exported to output PNG
// file:
            
            string deeplab_mask_filename = 
               eightbit_masks_subdir+"mask_"+image_label_str+"_"+
               bbox_IDstr+"_"+iter_label+".png";
            videofunc::write_8bit_greyscale_pngfile(
               byte_array, deeplab_mask_filename);

// Save correspondence between image tile and image mask to STL map:

            int posn = deeplab_inputs_subdir.size() - 1;
            string reduced_tile_filename=curr_tile_filename.substr(
               posn,curr_tile_filename.size()-posn);
            string reduced_mask_filename=deeplab_mask_filename.substr(
               posn,deeplab_mask_filename.size()-posn);

            STRING_PAIR P;
            P.first = reduced_tile_filename;
            P.second = reduced_mask_filename;

            image_tiles_map_iter = image_tiles_map.find(i);
            if(image_tiles_map_iter == image_tiles_map.end()){
               vector<STRING_PAIR> V;
               V.push_back(P);
               image_tiles_map[i] = V;
            }
            else{
               vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
               V_ptr->push_back(P);
            }

            if(n_bboxes > 0)
            {
               n_positive_example_tiles++;
            }
            else
            {
               n_negative_example_tiles++;
            }

         } // loop over index b labeling bboxes for current image
      } // loop over index iter labeling number of bbox iterations per image

      delete curr_tr_ptr;
      delete tr2_ptr;
   } // loop over index i labeling training + validation images

// ----------------------------------------------------------------------
// Loop over training and validation images stops here
// ----------------------------------------------------------------------

   string images_masks_training_filename=deeplab_inputs_subdir+
      "images_masks_training.txt";
   filefunc::openfile(images_masks_training_filename, outstream);   

   int n_training_tiles = 0;
   for(int i = 0; i < n_training_images; i++)
   {
      int curr_image_ID = i;
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end()) continue;
      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
         n_training_tiles++;
      }
   }
   filefunc::closefile(images_masks_training_filename, outstream);

   string images_masks_validation_filename=deeplab_inputs_subdir+
      "images_masks_validation.txt";
   filefunc::openfile(images_masks_validation_filename, outstream);   

   int n_validation_tiles = 0;
   for(int i = n_training_images; i < n_training_images + n_validation_images;
       i++)
   {
      int curr_image_ID = i;
      image_tiles_map_iter = image_tiles_map.find(curr_image_ID);
      if(image_tiles_map_iter == image_tiles_map.end())
      {
         cout << "No image tile pair found for validation image index = " 
              << i << endl;
         continue;
      }

      vector<STRING_PAIR> *V_ptr = &image_tiles_map_iter->second;
      for(unsigned int j = 0; j < V_ptr->size(); j++)
      {
         STRING_PAIR P = V_ptr->at(j);
         outstream << P.first << " " << P.second << endl;
         n_validation_tiles++;
      }
   }
   filefunc::closefile(images_masks_validation_filename, outstream);

// Recall several authors stress that training and validation data
// sets should be randomized!  As John Wood pointed out, we can use
// the linux utility "shuf" to generate random permutations:

   string shuffled_images_masks_training_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_training.txt";

   string unix_cmd = "shuf "+images_masks_training_filename+" > "+
      shuffled_images_masks_training_filename;
   sysfunc::unix_command(unix_cmd);

   string shuffled_images_masks_validation_filename=deeplab_inputs_subdir+
      "shuffled_images_masks_validation.txt";
   unix_cmd = "shuf "+images_masks_validation_filename+" > "+
      shuffled_images_masks_validation_filename;
   sysfunc::unix_command(unix_cmd);

   string banner=
      "Exported shuffled training and validation image + masks sets to "+
      faces_subdir;
   outputfunc::write_banner(banner);

   metastream << endl;
   metastream << "Number of exported training tiles = " 
              << n_training_tiles << endl;
   metastream << "Number of exported validation tiles = " 
              << n_validation_tiles << endl;
   metastream << "n_positive_example_tiles = " << n_positive_example_tiles
              << endl;
   metastream << "n_negative_example_tiles = " << n_negative_example_tiles
              << endl;
   filefunc::closefile(metadata_filename, metastream);

// Create gzipped tarball of all deeplab inputs subdirectory files for
// transfer to GPU machine prior to deeplab processing:

   string deeplab_inputs_basedir_wo_trailing_slash = 
      deeplab_inputs_basedir.substr(0,deeplab_inputs_basedir.size()-1);
   string deeplab_inputs_tgz_filename=
      faces_subdir+deeplab_inputs_basedir_wo_trailing_slash+".tgz";
   unix_cmd="tar cvzf "+deeplab_inputs_tgz_filename+" "
      +deeplab_inputs_subdir;
   cout << "unix_cmd = " << unix_cmd << endl;
   sysfunc::unix_command(unix_cmd);
}

