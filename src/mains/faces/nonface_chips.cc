// ========================================================================
// Program NONFACE_CHIPS imports the text file containing attributed
// face bounding box information generated by program
// ATTRIBUTE_IMAGES.  Looping over each image within this file,
// NONFACE_CHIPS first fills enlarged facial bboxes with purple
// coloring. It then ignores any image whose purple content exceeds
// some threshold fraction.  NONFACE_CHIPS then randomly picks the
// numbers, sizes and locations of new bounding boxes for each image.
// Any random box which overlaps purple facial content is ignored.
// Otherwise, image chips corresponding to non-facial bounding boxes
// are exported to an output subdirectory.  Nonface chips are heavily
// biased towards those with sizable image entropies.  The exported
// image chips are decomposed into training, validation and training
// subdirectories.

//				./nonface_chips

// ========================================================================
// Last updated on 8/5/16; 8/6/16
// ========================================================================

#include <fstream>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "geometry/bounding_box.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "numrec/nrfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "time/timefuncs.h"
#include "video/videofuncs.h"

// ========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::map;
   using std::ofstream;
   using std::pair;
   using std::string;
   using std::vector;

   timefunc::initialize_timeofday_clock(); 
   std::set_new_handler(sysfunc::out_of_memory);

   int max_chip_xdim = 106;
   int max_chip_ydim = 106;
   int min_chip_xdim = 10;
   int min_chip_ydim = 10;

   string faces_rootdir = "/data/TrainingImagery/faces/";
   string labeled_faces_subdir = faces_rootdir + "images/";
//   string bbox_labels_filename = labeled_faces_subdir+"labeled_face_bboxes.txt";
   string bbox_labels_filename = labeled_faces_subdir+
      "labeled_face_bboxes_sans_corrupted_imgs.txt";
   filefunc::ReadInfile(bbox_labels_filename);

   typedef map<string, vector<bounding_box> > ANNOTATED_BBOXES_MAP;
// independent string: image_ID_str
// dependent STL vector: annotated bboxes

   ANNOTATED_BBOXES_MAP annotated_bboxes_map;
   ANNOTATED_BBOXES_MAP::iterator annotated_bboxes_iter;

   bool first_image_flag = true;
   string image_ID_str = "";
   vector<bounding_box> annotated_bboxes;
   int n_total_bboxes = 0;

   for(unsigned int i = 0; i < filefunc::text_line.size(); i++)
   {
      string curr_line=filefunc::text_line[i];

      vector<string> substrings = stringfunc::decompose_string_into_substrings(
         curr_line);
      if(substrings[0] == "Image:")
      {
         if(first_image_flag)
         {
            first_image_flag = false;
         }
         else
         {
            // Save previous image info into data structures
            annotated_bboxes_map[image_ID_str] = annotated_bboxes;
            annotated_bboxes.clear();
         }
         annotated_bboxes.clear();
         image_ID_str = substrings[6];
      }
      else
      {
         vector<string> substrings = 
            stringfunc::decompose_string_into_substrings(curr_line);
         string bbox_label = substrings[1];
         int px_min = stringfunc::string_to_number(substrings[2]);
         int px_max = stringfunc::string_to_number(substrings[3]);
         int py_min = stringfunc::string_to_number(substrings[4]);
         int py_max = stringfunc::string_to_number(substrings[5]);
         bounding_box curr_bbox(px_min, px_max, py_min, py_max);

         colorfunc::Color bbox_color = colorfunc::black;
         if(bbox_label == "face")
         {
            bbox_color = colorfunc::red;
         }
         else if(bbox_label == "hand")
         {
            bbox_color = colorfunc::cyan;
         }

         curr_bbox.set_label(bbox_label);
         curr_bbox.set_color(bbox_color);

// Search for any bbox attribute key-value pairs:

         int n_attribute_pairs = (substrings.size() - 6)/2;
         for(int ap = 0; ap < n_attribute_pairs; ap++)
         {
            string attr_key = substrings[6 + ap * 2];
            string attr_value = substrings[6 + ap * 2 + 1];
            curr_bbox.set_attribute_value(attr_key, attr_value);
         }

         curr_bbox.set_ID(annotated_bboxes.size());

         n_total_bboxes++;
         annotated_bboxes.push_back(curr_bbox);

      } // substrings[0] == "Image:" conditional
   } // loop over index i labeling lines in detections text file

   // Save final image info into data structures
   annotated_bboxes_map[image_ID_str] = annotated_bboxes;

   cout << "annotated_bboxes_map.size() = " << annotated_bboxes_map.size()
        << endl;

   string nonface_chips_subdir = "./non_face_chips/";
   string training_subdir = nonface_chips_subdir+"training/";
   string validation_subdir = nonface_chips_subdir+"validation/";
   string testing_subdir = nonface_chips_subdir+"testing/";
   filefunc::dircreate(nonface_chips_subdir);
   filefunc::dircreate(training_subdir);
   filefunc::dircreate(validation_subdir);
   filefunc::dircreate(testing_subdir);

   vector<double> widths;
   widths.push_back(8.02151); // 10
   widths.push_back(13.0974); // 20
   widths.push_back(18.715);  // 30
   widths.push_back(24.7056); // 40
   widths.push_back(30.8453); // 50
   widths.push_back(38.583);  // 60
   widths.push_back(50.1832); // 70
   widths.push_back(67.3981); // 80
   widths.push_back(99.1431);  // 90
   double RGB_threshold = 1;

   int image_counter = 0;
   int nonface_chip_counter = 0;
   int n_images = annotated_bboxes_map.size();
   for(annotated_bboxes_iter = annotated_bboxes_map.begin();
       annotated_bboxes_iter != annotated_bboxes_map.end();
       annotated_bboxes_iter++)
   {
      if(image_counter%100 == 0)
      {
         double progress_frac = double(image_counter)/double(n_images);
         outputfunc::print_elapsed_and_remaining_time(progress_frac);
         cout << " Progress face = " << progress_frac 
              << " nonface_chip_counter = " << nonface_chip_counter << endl;
      }
      image_counter++;

      string image_ID_str = annotated_bboxes_iter->first;
      vector<bounding_box> bboxes = annotated_bboxes_iter->second;
      string image_basename="image_"+image_ID_str+".jpg";
      string image_filename=labeled_faces_subdir+image_basename;

      texture_rectangle* tr_ptr = new texture_rectangle(image_filename, NULL);
      int xdim = tr_ptr->getWidth();
      int ydim = tr_ptr->getHeight();
      if(tr_ptr->getNchannels() == 3 && 
         tr_ptr->get_VideoType() != texture_rectangle::unknown)
      {
         for(unsigned int b = 0; b < bboxes.size(); b++)
         {

// Enlarge all face bboxes and fill them with purple coloring;

            bounding_box enlarged_bbox = bboxes[b];
            enlarged_bbox.inflate(2);
            tr_ptr->fill_pixel_bbox(enlarged_bbox, 255, 0, 255);
         } // loop over index b labeling bounding boxes for current image

         int n_purple_pixels = tr_ptr->count_colored_pixels(
            255, 0, 255, RGB_threshold);
         double purple_frac = double(n_purple_pixels)/(xdim * ydim);

// Ignore current image if it contains too much face content:

         if(purple_frac > 0.33) continue;

// Randomly pick bbox numbers, sizes and locations:
         
         int n_bboxes = 125 * (xdim * ydim) / (2400.0 * 2400.0);
         if(n_bboxes == 0) n_bboxes = 1;

         for(int b = 0; b < n_bboxes; b++)
         {
            int width_bin = basic_math::mytruncate(9 * nrfunc::ran1());
            double width_lo = widths[width_bin];
            double width_hi = widths[width_bin + 1];
            double bbox_width = width_lo + nrfunc::ran1() * 
               (width_hi - width_lo);
            if(bbox_width < min_chip_xdim) bbox_width = min_chip_xdim;
            if(bbox_width > max_chip_xdim) bbox_width = max_chip_xdim;
            
            double aspect_ratio = 0.75 + 2 * (nrfunc::ran1() - 0.5) * 0.10;
            double bbox_height = bbox_width / aspect_ratio;
            if(bbox_height < min_chip_ydim) bbox_height = min_chip_ydim;
            if(bbox_height > max_chip_ydim) bbox_height = max_chip_ydim;
            
            int px_center = 0.5 * bbox_width + 
               nrfunc::ran1() * (xdim - bbox_width);
            int py_center = 0.5 * bbox_height + 
               nrfunc::ran1() * (ydim - bbox_height);

            int px_min = px_center - 0.5 * bbox_width;
            int px_max = px_center + 0.5 * bbox_width;
            int py_min = py_center - 0.5 * bbox_height;
            int py_max = py_center + 0.5 * bbox_height;

// Ignore any non-face chip candidate containing any purple-colored content:

            n_purple_pixels = tr_ptr->count_colored_pixels(
               px_min, px_max, py_min, py_max, 255, 0, 255, RGB_threshold);
            if(n_purple_pixels > 0) continue;

// Ignore any non_face chip candidate whose image entropy is too
// low for a large fraction of all candidates:

            if(nrfunc::ran1() > 0.15)
            {
               const double min_entropy_threshold = 0.6;
               double entropy = tr_ptr->compute_image_entropy(
                  px_min, px_max, py_min, py_max, false, 0);
               if(entropy < min_entropy_threshold) continue;
            }
         
// Reserve 0.5% of all non-face chips for validation and 1.5% for
// testing:
   
            double tvt = nrfunc::ran1();
            string output_chips_subdir = training_subdir;
            if(tvt < 0.005)
            {
               output_chips_subdir = validation_subdir;
            }
            else if (tvt >= 0.005 && tvt < 0.015)
            {
               output_chips_subdir = testing_subdir;
            }

            string nonface_chip_filename = output_chips_subdir+
               "non_face_"+stringfunc::integer_to_string(
                  nonface_chip_counter++,6)+
//                "_"+stringfunc::number_to_string(entropy)+
               ".png";

            tr_ptr->write_curr_frame(
               px_min, px_max, ydim - py_max, ydim - py_min, 
               nonface_chip_filename);

         } // loop over index b labeling candidate non-face bbox
      } // n_channels == 3 conditional
      delete tr_ptr;
   } // loop over annotated_bboxes_iter
}

