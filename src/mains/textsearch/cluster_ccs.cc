// ========================================================================
// Program CLUSTER_CCS imports the edge list calculated by DOCRELNS
// from synthesized topic keyword text files generated by
// SYNTHESIZE_TOPIC_DOCS.  It then fills STL map cc_cluster_map with
// connected component integer IDs as a function of cluster ID.
// Connected component cluster information is exported to an output
// file along with all topic keywords corresponding to the clusters.
// The row_cc, column_cc and label columns within the
// connected_components table of the IMAGERY database are also
// updated.
// ========================================================================
// Last updated on 12/27/12; 12/29/12
// ========================================================================

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "gmm/gmm.h"
#include "gmm/gmm_matrix.h"

#include "general/filefuncs.h"
#include "math/genvector.h"
#include "graphs/graphdbfuncs.h"
#include "image/graphicsfuncs.h"
#include "math/mathfuncs.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "math/prob_distribution.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"
#include "datastructures/union_find.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::map;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

//   bool modify_IMAGERY_database_flag=true;
   bool modify_IMAGERY_database_flag=false;
   if (modify_IMAGERY_database_flag)
   {
      cout << "modify_IMAGERY_database_flag = true" << endl;
   }
   else
   {
      cout << "modify_IMAGERY_database_flag = false" << endl;
   }
   outputfunc::enter_continue_char();

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string graphs_subdir=bundler_IO_subdir+"graphs/";

   int cloudpass_ID=passes_group.get_curr_cloudpass_ID();
   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();
//   cout << "GISlayer_IDs.size() = " << GISlayer_IDs.size() << endl;

   int doc_level=1;
//   cout << "Enter document level (0 = raw docs, 1 = docs generated from topics):" << endl;
//   cin >> doc_level;

   const int ascii_A=65;
   const int ascii_Z=90;

   bool astro_flag=false;
   bool reuters_flag=true;
   string arXiv_subdir="/media/66368D22368CF3F9/visualization/arXiv/";
   string astro_subdir=arXiv_subdir+"astro/";
   string reuters_subdir=arXiv_subdir+"reuters/export/";
//   string text_subdir=astro_subdir+"txt/";
   string text_subdir=reuters_subdir+"text/";
   string ccs_subdir=text_subdir+"connected_components/";
   string topic_docs_subdir=ccs_subdir+"topic_docs/";

   if (doc_level==1)
   {
      text_subdir=topic_docs_subdir;
   }

// Instantiate postgis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_db_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(
         passes_group,GISlayer_IDs);
//   cout << "postgis_db_ptr = " << postgis_db_ptr << endl;

// Retrieve number of connected components for specified graph hierarchy:

   int hierarchy_ID=9;	// Reuters 43K
   int n_levels=graphdbfunc::retrieve_n_levels_for_particular_graph_hierarchy(
      postgis_db_ptr,hierarchy_ID);
   int n_ccs=graphdbfunc::get_n_connected_components(
      postgis_db_ptr,hierarchy_ID);
   cout << "Number connected components = " << n_ccs << endl;

// Instantiate union_find data structure:

   union_find* union_find_ptr=new union_find();
   for (int cc=0; cc<n_ccs; cc++)
   {
      union_find_ptr->MakeSet(cc);
   }
   
   double cc_link_threshold=400;
   cout << "Enter connected component edge weight threshold:" << endl;
   cin >> cc_link_threshold;
         
// Establish links within *union_find_ptr between any two connected
// components whose edge weight exceeds cc_link_threshold:

   string cc_edgelist_filename=text_subdir+"docs_edgelist.dat";
   filefunc::ReadInfile(cc_edgelist_filename);
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<double> column_values=
         stringfunc::string_to_numbers(filefunc::text_line[i]);
      int first_cc_ID=column_values[0];
      int second_cc_ID=column_values[1];
      double edge_weight=column_values[2];

      if (edge_weight > cc_link_threshold)
      {
         union_find_ptr->Link(first_cc_ID,second_cc_ID);
      }
   } // loop over index i labeling lines in docs_edgelist.dat file

// Store IDs for linked connected components within STL map:

   typedef map<int,vector<int>* > CC_CLUSTER_MAP;

// independent var = cluster ID
// dependent vars = pointer to STL vector containing connected component IDs

   CC_CLUSTER_MAP::iterator cc_cluster_iter;
   CC_CLUSTER_MAP cc_cluster_map;

   for (int cc=0; cc<n_ccs; cc++)
   {
      int root_ID=union_find_ptr->Find(cc);

      cc_cluster_iter=cc_cluster_map.find(root_ID);
      if (cc_cluster_iter==cc_cluster_map.end())
      {
         vector<int>* V_ptr=new vector<int>;
         V_ptr->push_back(cc);
         cc_cluster_map[root_ID]=V_ptr;
      }
      else
      {
         vector<int>* V_ptr=cc_cluster_iter->second;
         V_ptr->push_back(cc);
      }

//      cout << "cc_ID = " << cc
//           << " root_ID = " << root_ID
//           << endl;
   } // loop over index cc labeling connected components
   delete union_find_ptr;

   vector<int> cc_cluster_sizes;
   vector<vector<int>* > cc_cluster_IDs;
   
   for (cc_cluster_iter=cc_cluster_map.begin(); cc_cluster_iter != 
           cc_cluster_map.end(); cc_cluster_iter++)
   {
      vector<int>* V_ptr=cc_cluster_iter->second;
      cc_cluster_sizes.push_back(V_ptr->size());
      cc_cluster_IDs.push_back(V_ptr);
   }
   
   templatefunc::Quicksort_descending(cc_cluster_sizes,cc_cluster_IDs);

   string cluster_filename=topic_docs_subdir+
      "clusters_"+stringfunc::number_to_string(cc_link_threshold)+".dat";   
   ofstream cluster_stream;
   filefunc::openfile(cluster_filename,cluster_stream);

   cluster_stream << endl;

   int n_ccs_in_nontrivial_clusters=0;
   int n_clusters=cc_cluster_IDs.size();
   for (int cc_cluster=0; cc_cluster<n_clusters; cc_cluster++)
   {
      int n_ccs_in_cluster=cc_cluster_IDs[cc_cluster]->size();

      vector<string> cc_labels;
      for (int j=0; j<n_ccs_in_cluster; j++)
      {
         string curr_cc_label=stringfunc::number_to_string(cc_cluster+1);
         curr_cc_label += stringfunc::integer_to_letters(j+1);
         cc_labels.push_back(curr_cc_label);
      }

//      if (n_ccs_in_cluster <= 1) continue;
      n_ccs_in_nontrivial_clusters += n_ccs_in_cluster;

      cluster_stream << "Cluster = " << cc_cluster << endl;
      for (int j=0; j<n_ccs_in_cluster; j++)
      {
         cluster_stream << cc_cluster_IDs[cc_cluster]->at(j) << " ";
      }
      cluster_stream << endl;
      for (int j=0; j<n_ccs_in_cluster; j++)
      {
         cluster_stream << cc_labels[j] << " ";

         if (modify_IMAGERY_database_flag)
         {
            int cc_ID=cc_cluster_IDs[cc_cluster]->at(j);

            for (int graph_ID=0; graph_ID < n_levels; graph_ID++)
            {
               graphdbfunc::update_connected_component_info(
                  postgis_db_ptr,hierarchy_ID,graph_ID,cc_ID,
                  cc_cluster,j,cc_labels[j]);
//            cout << "cc_ID = " << cc_ID 
//                 << " row = " << cc_cluster
//                 << " column = " << j 
//                 << " cc_label = " << cc_labels[j]
//                 << endl;
            }
         }
      }
      cluster_stream << endl << endl;

// Write out cc keywords:

      for (int j=0; j<n_ccs_in_cluster; j++)
      {
         int cc_ID=cc_cluster_IDs[cc_cluster]->at(j);
         string topic_doc_filename=topic_docs_subdir+
            "topic_doc_"+stringfunc::integer_to_string(cc_ID,3)+".txt";
         filefunc::ReadInfile(topic_doc_filename);
         for (int l=0; l<filefunc::text_line.size(); l++)
         {
            cluster_stream << filefunc::text_line[l] << endl;
         }
      } // loop over index j labeling ccs in cluster
      cluster_stream << endl;

   } // loop over index cc_cluster labeling clusters of connected components

   cluster_stream << endl;
   cluster_stream << "cc edge weight threshold = " << cc_link_threshold 
                  << endl;
   cluster_stream << "n_clusters = " << n_clusters << endl;
   cluster_stream << "n_ccs_in_nontrivial_clusters = "
                  << n_ccs_in_nontrivial_clusters << endl;

   filefunc::closefile(cluster_filename,cluster_stream);
   string banner="Exported "+cluster_filename;
   outputfunc::write_big_banner(banner);
}

