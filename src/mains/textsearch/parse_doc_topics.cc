// ========================================================================
// Program PARSE_DOC_TOPICS parses the document-topics text file
// generated by MALLET.  It sorts coarse topics according to their
// average document purity fraction.  PARSE_DOC_TOPICS exports
// to "coarse_vs_fine_topics.dat" the sorted coarse topics and lists
// their associated fine topics sorted by fine document membership.
// The top words for each sorted coarse topic and the associated fine
// topics are also exported to this output file.

// PARSE_DOC_TOPICS generates a second output file
// ("coarse_fine_topic_docs.dat") that contains document IDs sorted by
// the coarse and fine topics to which they correspond.
// Export to 3rd output file ("components.dat") number of nodes, row,
// column and alpha-numeric label for each connected component.  Also
// export top 4 words for top 5 topics for each connected component:

// ========================================================================
// Last updated on 5/25/13; 5/27/13; 5/29/13
// ========================================================================

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "math/mathfuncs.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::map;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string image_list_filename=bundler_IO_subdir+"image_list.dat";
   
// Instantiate and populate STL map with relationships between
// text filenames and bundler image/document IDs:

   typedef map<std::string, int > FILENAME_DOCID_MAP;
// independent var = text filename prefix
// dependent var = bundler image/document ID

   FILENAME_DOCID_MAP filename_docid_map;
   FILENAME_DOCID_MAP::iterator filename_docid_iter;

   filefunc::ReadInfile(image_list_filename);
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      string curr_image_filename=filefunc::text_line[i];
      string basename=filefunc::getbasename(curr_image_filename);
      string prefix=stringfunc::prefix(basename);
      filename_docid_map[prefix]=i;
//      cout << "bundler ID = " << i << " prefix = " << prefix << endl;
   }

// Reuters 50K:

   string doc_corpus_prefix="reuters_50K_";
   int n_coarse_topics=40;
   int n_fine_topics=300;

// Reuters 43K:

//   string doc_corpus_prefix="reuters_43K_";
//   int n_coarse_topics=35;
//   int n_fine_topics=250;

// Instantiate and populate STL map with relationships between
// independent coarse and dependent fine topic IDs:

   typedef map<int,vector<int>* > TOPIC_HIERARCHY_MAP;
// independent var = coarse_topic_ID
// dependent var = fine_topic_ID STL vector

   TOPIC_HIERARCHY_MAP topic_hierarchy_map;
   TOPIC_HIERARCHY_MAP::iterator topic_hierarchy_iter;

// Import coarse_vs_fine_topic IDs:

   string coarse_vs_fine_filename=bundler_IO_subdir+
      "coarse_vs_fine_topic_hierarchies.dat";
   filefunc::ReadInfile(coarse_vs_fine_filename);
   
   for (int i=0; i<n_coarse_topics; i++)
   {
      string curr_line=filefunc::text_line[i];
//      cout << curr_line << endl;
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(curr_line);
      int coarse_topic_ID=stringfunc::string_to_number(substrings[0]);
//      cout << "coarse topic = " << coarse_topic_ID << endl;

      vector<int>* fine_topic_IDs_ptr;
      for (int j=1; j<substrings.size(); j++)
      {
         int fine_topic_ID=stringfunc::string_to_number(substrings[j]);
//         cout << fine_topic_ID << " " << flush;

         topic_hierarchy_iter=topic_hierarchy_map.find(coarse_topic_ID);
         if (topic_hierarchy_iter==topic_hierarchy_map.end())
         {
            fine_topic_IDs_ptr=new vector<int>;
            topic_hierarchy_map[coarse_topic_ID]=fine_topic_IDs_ptr;
         }
         else
         {
            fine_topic_IDs_ptr=topic_hierarchy_iter->second;
         }
         fine_topic_IDs_ptr->push_back(fine_topic_ID);
      }
//      cout << endl;
   } // loop over index i labeling coarse topics

// Store document words corresponding to coarse and fine topics within
// STL maps:

   typedef map<int,vector<string> > TOPIC_WORDS_MAP;
// independent var = topic ID
// dependent var = STL vector of top topic words   
   TOPIC_WORDS_MAP coarse_topic_words_map,fine_topic_words_map;
   TOPIC_WORDS_MAP::iterator topic_words_map_iter;

   string coarse_topic_top_words_filename=bundler_IO_subdir+
      doc_corpus_prefix+stringfunc::number_to_string(n_coarse_topics)+
      "topics_words.txt";

   filefunc::ReadInfile(coarse_topic_top_words_filename);
   for (int l=0; l<filefunc::text_line.size(); l++)
   { 
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(filefunc::text_line[l]);
      int n_coarse_topic_words=substrings.size()-2;

      int coarse_topic_ID=stringfunc::string_to_number(substrings[0]);
      vector<string> coarse_topic_words;
      for (int c=0; c<n_coarse_topic_words; c++)
      {
         coarse_topic_words.push_back(substrings[c+2]);
      }
      coarse_topic_words_map[coarse_topic_ID]=coarse_topic_words;
   }

   string fine_topic_top_words_filename=bundler_IO_subdir+
      doc_corpus_prefix+stringfunc::number_to_string(n_fine_topics)+
      "topics_words.txt";

   filefunc::ReadInfile(fine_topic_top_words_filename);
   for (int l=0; l<filefunc::text_line.size(); l++)
   { 
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(filefunc::text_line[l]);
      int n_fine_topic_words=substrings.size()-2;

      int fine_topic_ID=stringfunc::string_to_number(substrings[0]);
      vector<string> fine_topic_words;
      for (int c=0; c<n_fine_topic_words; c++)
      {
         fine_topic_words.push_back(substrings[c+2]);
      }
      fine_topic_words_map[fine_topic_ID]=fine_topic_words;
   }

   cout << "coarse_topic_words_map.size() = "
        << coarse_topic_words_map.size() << endl;
   cout << "fine_topic_words_map.size() = "
        << fine_topic_words_map.size() << endl;

// Retrieve and store coarse topic "purities" for all text documents
// within STL vector topic_id_doc_purity_frac_map:
      
   string doc_topics_filename=bundler_IO_subdir+doc_corpus_prefix+"doc_"
      +stringfunc::number_to_string(n_coarse_topics)+"topics.txt";
   filefunc::ReadInfile(doc_topics_filename);

   typedef map<int,vector<double>* > TOPIC_ID_DOC_PURITY_FRAC_MAP;
   TOPIC_ID_DOC_PURITY_FRAC_MAP topic_id_doc_purity_frac_map;
   TOPIC_ID_DOC_PURITY_FRAC_MAP::iterator iter;
// independent int = coarse topic ID
// dependent STL vector holds document dominant topic purity fractions

// Note added on 5/27/13:  Mallet doc ID != bundler doc ID  !!!

   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      string curr_line=filefunc::text_line[i];
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         curr_line);
      int mallet_doc_ID=stringfunc::string_to_number(substrings[0]);
      string doc_filename=filefunc::getbasename(substrings[1]);
      string prefix=stringfunc::prefix(doc_filename);
      
      filename_docid_iter=filename_docid_map.find(prefix);
      if (filename_docid_iter==filename_docid_map.end())
      {
         cout << "Error!  Couldn't find prefix in filename_docid_map!"
              << endl;
         outputfunc::enter_continue_char();
         continue;
      }
      int doc_ID=filename_docid_iter->second;

      int dominant_topic_ID=stringfunc::string_to_number(substrings[2]);
      double dominant_topic_purity_frac=
         stringfunc::string_to_number(substrings[3]);

      iter=topic_id_doc_purity_frac_map.find(dominant_topic_ID);
      if (iter==topic_id_doc_purity_frac_map.end())
      {
         vector<double>* doc_purity_frac_ptr=new vector<double>;
         doc_purity_frac_ptr->push_back(dominant_topic_purity_frac);
         topic_id_doc_purity_frac_map[dominant_topic_ID]=doc_purity_frac_ptr;
      }
      else
      {
         vector<double>* doc_purity_frac_ptr=iter->second;
         doc_purity_frac_ptr->push_back(dominant_topic_purity_frac);
      }
   } // loop over index labeling line in output MALLET doc-topics text file

// Compute numbers of documents and average document purity fractions
// for each coarse topic ID:

   vector<int> topic_IDs,docs_per_topic_ID;
   vector<double> avg_doc_purity_frac_per_topic_ID;
   for (int topic_ID=0; topic_ID < n_coarse_topics; topic_ID++)
   {
      topic_IDs.push_back(topic_ID);
      iter=topic_id_doc_purity_frac_map.find(topic_ID);
      vector<double>* doc_purity_frac_ptr=iter->second;
      int n_docs=doc_purity_frac_ptr->size();

      double avg_doc_purity_frac=0;
      for (int d=0; d<n_docs; d++)
      {
         avg_doc_purity_frac += doc_purity_frac_ptr->at(d);
      }
      avg_doc_purity_frac /= n_docs;

//      cout << "topic_ID = " << topic_ID << " n_docs = " << n_docs
//           << endl;
      docs_per_topic_ID.push_back(n_docs);
      avg_doc_purity_frac_per_topic_ID.push_back(avg_doc_purity_frac);
   } // loop over topic_ID

   templatefunc::Quicksort_descending(
      docs_per_topic_ID,topic_IDs,avg_doc_purity_frac_per_topic_ID);

// Export number of nodes, row, column and alpha-numeric label for
// each connected component.  Also export top 4 words for top 5
// topics for each connected component:

   string cc_filename=bundler_IO_subdir+"components.dat";
   ofstream ccstream;
   filefunc::openfile(cc_filename,ccstream);
   ccstream << "# cc_ID   n_nodes   cc_row   cc_column  label  " 
            << endl;
   ccstream << "# topic_0  topic_1  topic_2 topic_3 topic_4" << endl;
   ccstream << endl;

// Export number of documents and average documention member fractions
// for each coarse topic ID:

   string output_filename=bundler_IO_subdir+"coarse_vs_fine_topics.dat";
   ofstream outstream;
   filefunc::openfile(output_filename,outstream);
   outstream << "# Coarse topics sorted according to document membership"
             << endl << endl;

   for (int i=0; i<docs_per_topic_ID.size(); i++)
   {
      int coarse_topic_ID=topic_IDs[i];
      outstream << "coarse topic_ID = " << coarse_topic_ID
                << " n_docs = " << docs_per_topic_ID[i]
                << " avg_doc_purity_frac = " 
                << avg_doc_purity_frac_per_topic_ID[i]
                << endl;
   }
   outstream << endl << endl;

// Destroy dynamically previously generated STL vectors within
// topic_id_doc_purity_frac_map and then clear this STL map:

   for (iter=topic_id_doc_purity_frac_map.begin(); iter != 
           topic_id_doc_purity_frac_map.end(); iter++)
   {
      delete iter->second;
   }
   topic_id_doc_purity_frac_map.clear();

// Retrieve and store fine topic "purities" for all text documents
// within STL vector topic_id_doc_purity_frac_map:
      
   doc_topics_filename=bundler_IO_subdir+doc_corpus_prefix+"doc_"
      +stringfunc::number_to_string(n_fine_topics)+"topics.txt";
   filefunc::ReadInfile(doc_topics_filename);

// topic_id_doc_purity_frac_map independent int = fine topic ID

// Note: From here on, dependent STL vector holds fine document ID
// rather than dominant fine topic purity fractions !

   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      string curr_line=filefunc::text_line[i];
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         curr_line);
      int mallet_doc_ID=stringfunc::string_to_number(substrings[0]);
      string doc_filename=filefunc::getbasename(substrings[1]);
      string prefix=stringfunc::prefix(doc_filename);
      
      filename_docid_iter=filename_docid_map.find(prefix);
      if (filename_docid_iter==filename_docid_map.end())
      {
         cout << "Error!  Couldn't find prefix in filename_docid_map!"
              << endl;
         outputfunc::enter_continue_char();
         continue;
      }
      int doc_ID=filename_docid_iter->second;

      int dominant_topic_ID=stringfunc::string_to_number(substrings[2]);
      double dominant_topic_purity_frac=
         stringfunc::string_to_number(substrings[3]);

      iter=topic_id_doc_purity_frac_map.find(dominant_topic_ID);
      if (iter==topic_id_doc_purity_frac_map.end())
      {
         vector<double>* doc_ID_ptr=new vector<double>;
         doc_ID_ptr->push_back(doc_ID);
         topic_id_doc_purity_frac_map[dominant_topic_ID]=doc_ID_ptr;
//         vector<double>* doc_purity_frac_ptr=new vector<double>;
//         doc_purity_frac_ptr->push_back(dominant_topic_purity_frac);
//         topic_id_doc_purity_frac_map[dominant_topic_ID]=doc_purity_frac_ptr;
      }
      else
      {
         vector<double>* doc_ID_ptr=iter->second;
         doc_ID_ptr->push_back(doc_ID);
      }
   } // loop over index labeling line in output MALLET doc-topics text file

// Next export fine topic IDs associated with each coarse topic:

   outstream << "# Coarse topic ID            Fine topic IDs (n_fine_topic_docs)" 
             << endl << endl;
   
   int component_ID=0;
   for (int i=0; i<docs_per_topic_ID.size(); i++)
   {
      int coarse_topic_ID=topic_IDs[i];
      outstream << coarse_topic_ID << "\t\t" << flush;
      
      topic_hierarchy_iter=topic_hierarchy_map.find(coarse_topic_ID);
      vector<int>* fine_topic_IDs_ptr=topic_hierarchy_iter->second;

// Sort fine topic IDs by the number of documents corresponding to
// the fine topics:

      vector<int> fine_topic_IDs,n_fine_docs;
      for (int f=0; f<fine_topic_IDs_ptr->size(); f++)
      {
         int curr_fine_topic_ID=fine_topic_IDs_ptr->at(f);
         fine_topic_IDs.push_back(curr_fine_topic_ID);
         iter=topic_id_doc_purity_frac_map.find(curr_fine_topic_ID);
         if (iter==topic_id_doc_purity_frac_map.end())
         {
            n_fine_docs.push_back(0);
         }
         else
         {
            vector<double>* doc_purity_frac_ptr=iter->second;
            n_fine_docs.push_back(doc_purity_frac_ptr->size());
         }
      }
      templatefunc::Quicksort_descending(n_fine_docs,fine_topic_IDs);

      fine_topic_IDs_ptr->clear();
      for (int f=0; f<fine_topic_IDs.size(); f++)
      {
         fine_topic_IDs_ptr->push_back(fine_topic_IDs[f]);
         outstream << fine_topic_IDs[f] << " " 
                   << "(" << n_fine_docs[f] << ") " << flush;

// Export graph component information:

         int cc_row=i;
         int cc_column=f;
         string label=stringfunc::number_to_string(cc_row+1)+
            stringfunc::integer_to_letters(cc_column+1);

         int fine_topic_ID=fine_topic_IDs_ptr->at(f);
         topic_words_map_iter=fine_topic_words_map.find(fine_topic_ID);
         vector<string> fine_topic_words=topic_words_map_iter->second;

         int word_counter=0;
         vector<vector<string> > topic_word_rows;
         for (int t=0; t<5; t++)
         {
            vector<string> curr_topic_words;
            for (int w=0; w<4; w++)
            {
               curr_topic_words.push_back(fine_topic_words[word_counter++]);
            }
            topic_word_rows.push_back(curr_topic_words);
         } // loop over index t labeling topic word rows

         ccstream << component_ID++ << "  "
                  << n_fine_docs[f] << "  "
                  << cc_row << "  "
                  << cc_column << "  "
                  << label << "  "
                  << endl;
         for (int t=0; t<5; t++)
         {
            vector<string> curr_topic_words=topic_word_rows[t];
            for (int w=0; w<curr_topic_words.size(); w++)
            {
               ccstream << curr_topic_words[w] << " " << flush;
            }
            ccstream << endl;
         }
         ccstream << endl;
      }
      outstream << endl;

   } // loop over index i labeling coarse topic IDs
   outstream << endl;

   filefunc::closefile(cc_filename,ccstream);
   string banner="Exported "+cc_filename;
   outputfunc::write_big_banner(banner);

// Finally, export parent coarse topics as lists of document words.
// Display their corresponding children fine topics also as lists of
// document words:

   for (int c=0; c<topic_IDs.size(); c++)
   {
      int coarse_topic_ID=topic_IDs[c];
      topic_words_map_iter=coarse_topic_words_map.find(coarse_topic_ID);
      vector<string> coarse_topic_words=topic_words_map_iter->second;

      outstream << "Coarse topic " << coarse_topic_ID << endl << endl;
      for (int w=0; w<coarse_topic_words.size(); w++)
      {
         outstream << coarse_topic_words[w] << " ";
      }
      outstream << endl << endl;

      topic_hierarchy_iter=topic_hierarchy_map.find(coarse_topic_ID);
      vector<int>* fine_topic_IDs_ptr=topic_hierarchy_iter->second;
      for (int f=0; f<fine_topic_IDs_ptr->size(); f++)
      {
         int fine_topic_ID=fine_topic_IDs_ptr->at(f);
         topic_words_map_iter=fine_topic_words_map.find(fine_topic_ID);
         vector<string> fine_topic_words=topic_words_map_iter->second;

         outstream << "Fine topic " << fine_topic_ID << endl;
         for (int w=0; w<fine_topic_words.size(); w++)
         {
            outstream << fine_topic_words[w] << " ";
         }
         outstream << endl << endl;
      } // loop over index f labeling fine topics corresponding to coarse topic
      outstream << endl;
   }
   outstream << endl;

   filefunc::closefile(output_filename,outstream);
   banner="Exported "+output_filename;
   outputfunc::write_big_banner(banner);

// Generate new output file containing document_IDs listed as functions
// of the coarse and fine topics to which they correspond:

   output_filename=bundler_IO_subdir+"coarse_fine_topic_docs.dat";
   filefunc::openfile(output_filename,outstream);
   outstream << "# Coarse topic ID   Fine topic ID   Document IDs   " << endl
             << endl;

   for (int i=0; i<docs_per_topic_ID.size(); i++)
   {
      int coarse_topic_ID=topic_IDs[i];
      topic_hierarchy_iter=topic_hierarchy_map.find(coarse_topic_ID);
      vector<int>* fine_topic_IDs_ptr=topic_hierarchy_iter->second;

      vector<int> fine_topic_IDs;
      for (int f=0; f<fine_topic_IDs_ptr->size(); f++)
      {
         int curr_fine_topic_ID=fine_topic_IDs_ptr->at(f);
         fine_topic_IDs.push_back(curr_fine_topic_ID);
         outstream << coarse_topic_ID << "  "
                   << curr_fine_topic_ID << "      ";

         iter=topic_id_doc_purity_frac_map.find(curr_fine_topic_ID);
         if (iter==topic_id_doc_purity_frac_map.end()) 
         {
            outstream << endl;
            continue;
         }
         
         vector<double>* doc_ID_ptr=iter->second;
         for (int d=0; d<doc_ID_ptr->size(); d++)
         {
            int curr_doc_ID=doc_ID_ptr->at(d);
            outstream << curr_doc_ID << " ";
         }
         outstream << endl;

/*
         string doc_headline_filename=bundler_IO_subdir+"doc_headlines_"+
            stringfunc::number_to_string(coarse_topic_ID)+"_"+
            stringfunc::number_to_string(curr_fine_topic_ID)+".dat";
         ofstream docstream;
         filefunc::openfile(doc_headline_filename,docstream);
         
         for (int d=0; d<doc_ID_ptr->size(); d++)
         {
            int curr_doc_ID=doc_ID_ptr->at(d);

         } // loop over index d labeling documents within coarse/fine topic
         filefunc::closefile(doc_headline_filename,docstream);
*/

      } // loop over index f labeling fine topics

      outstream << endl;
   } // loop over index i labeling coarse topic IDs
   outstream << endl;

   filefunc::closefile(output_filename,outstream);
   banner="Exported "+output_filename;
   outputfunc::write_big_banner(banner);
}

