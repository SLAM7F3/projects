// ========================================================================
// Program TOPIC_HIERARCHY reads in a set of document words
// corresponding to "coarse" and "fine" topics generated by MALLET.
// For each fine topic, it counts the number of document words
// associated with all coarse topics.  Based upon the maxima of these
// document word counts, TOPIC_HIERARCHY associates each fine topic
// with a unique coarse topic.  It exports a text file containing fine
// topic vs coarse topic IDs and max document word overlap counts.
// ========================================================================
// Last updated on 5/27/13; 5/29/13; 5/30/13
// ========================================================================

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "general/filefuncs.h"
#include "templates/mytemplates.h"
#include "general/outputfuncs.h"
#include "passes/PassesGroup.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "time/timefuncs.h"

// ==========================================================================
int main( int argc, char** argv )
{
   using std::cin;
   using std::cout;
   using std::endl;
   using std::flush;
   using std::ifstream;
   using std::ios;
   using std::map;
   using std::ofstream;
   using std::string;
   using std::vector;
   std::set_new_handler(sysfunc::out_of_memory);

   timefunc::initialize_timeofday_clock();

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   PassesGroup passes_group(&arguments);

   string bundle_filename=passes_group.get_bundle_filename();
//   cout << " bundle_filename = " << bundle_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(bundle_filename);
//   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;

// Instantiate STL map to hold relationships between independent fine
// and dependent coarse topic IDs:

   typedef map<int,vector<int>* > TOPIC_WORDS_HIERARCHY_MAP;
// independent int = fine topic_ID 
// dependent vector<int> = 
//   # of fine topic document words matching coarse topic document words

   TOPIC_WORDS_HIERARCHY_MAP topic_words_hierarchy_map;

// Instantiate second STL map to store relationships between
// independent coarse and dependent fine topic IDs:

   typedef map<int,vector<int>* > TOPIC_HIERARCHY_MAP;
// independent var = coarse_topic_ID
// dependent var = fine_topic_ID STL vector

   TOPIC_HIERARCHY_MAP topic_hierarchy_map;
   TOPIC_HIERARCHY_MAP::iterator iter;

// Reuters 50K:

   string doc_corpus_prefix="reuters_50K_";
   int n_coarse_topics=40;
   int n_fine_topics=300;

// Reuters 43K:

//   string doc_corpus_prefix="reuters_43K_";
//   int n_coarse_topics=35;
//   int n_fine_topics=250;

   for (int f=0; f<n_fine_topics; f++)
   {
      vector<int>* coarse_topic_doc_words_ptr=new vector<int>;
      for (int c=0; c<n_coarse_topics; c++)
      {
         coarse_topic_doc_words_ptr->push_back(0);
      } // loop over index c labeling coarse topics
      topic_words_hierarchy_map[f]=coarse_topic_doc_words_ptr;
   } // loop over index f labeling fine topics

// Import assignments of "all" input document words to coase and
// fine topics:

   string coarse_topic_words_filename=bundler_IO_subdir+
      doc_corpus_prefix+stringfunc::number_to_string(n_coarse_topics)+
      "topics_state";
   string fine_topic_words_filename=bundler_IO_subdir+
      doc_corpus_prefix+stringfunc::number_to_string(n_fine_topics)+
      "topics_state";
   filefunc::gunzip_file_if_gzipped(coarse_topic_words_filename);
   filefunc::gunzip_file_if_gzipped(fine_topic_words_filename);

   ifstream coarse_stream;
   ifstream fine_stream;
   coarse_stream.open(coarse_topic_words_filename.c_str(),ios::in);
   fine_stream.open(fine_topic_words_filename.c_str(),ios::in);

// Loop over "all" document words which are assigned to both
// coarse and fine topics.  Count number of document words which match
// between fine and coarse topics.  Store such fine/coarse word count
// relationships in topic_words_hierarchy_map:

   long long n_lines=100000000;
   string coarse_line,fine_line;
   for (long long l=0; l<n_lines; l++)
   {
      long long n_reduced_lines=n_lines/100;
      double curr_frac=double(l)/double(n_lines);
      if (l%n_reduced_lines==0) cout << curr_frac << " " << flush;
//      if (l%n_reduced_lines==0) cout << l/n_reduced_lines << " " << flush;
      void* coarse_ptr=getline(coarse_stream,coarse_line,'\n');
      void* fine_ptr=getline(fine_stream,fine_line,'\n');
      if (coarse_ptr==NULL || fine_ptr==NULL) break;
      if (l < 3) continue;

//      cout << "l = " << l << endl;      
//      cout << "coarse_ptr = " << coarse_ptr << " fine_ptr = "
//           << fine_ptr << endl;
//      cout << "coarse line = " << coarse_line << endl;
//      cout << "fine_line = " << fine_line << endl;

      vector<string> coarse_substrings=
         stringfunc::decompose_string_into_substrings(coarse_line);
      vector<string> fine_substrings=
         stringfunc::decompose_string_into_substrings(fine_line);

      int coarse_topic_ID=stringfunc::string_to_number(
         coarse_substrings.back());
      int fine_topic_ID=stringfunc::string_to_number(
         fine_substrings.back());
//      cout << "coarse_topic_ID = " << coarse_topic_ID
//           << " fine_topic_ID = " << fine_topic_ID << endl;

      vector<int>* coarse_topic_words_doc_ptr=topic_words_hierarchy_map[
         fine_topic_ID];
      coarse_topic_words_doc_ptr->at(coarse_topic_ID)=
         coarse_topic_words_doc_ptr->at(coarse_topic_ID)+1;
//      cout << "coarse_topic_words_doc_ptr->at(coarse_topic_ID) = "
//           << coarse_topic_words_doc_ptr->at(coarse_topic_ID);
//      cout << endl;
   }
   cout << endl;
   coarse_stream.close();
   fine_stream.close();

   filefunc::gzip_file(coarse_topic_words_filename);
   filefunc::gzip_file(fine_topic_words_filename);

// Loop over fine topics.  For each fine topic, find coarse topic
// which has the most number of document word matches.  Export
// matching fine and coarse topic ID to output text file:
   
   string topic_hierarchy_filename=bundler_IO_subdir+
      "fine_vs_coarse_topic_hierarchies.dat";
   ofstream topic_hierarchy_outstream;
   filefunc::openfile(topic_hierarchy_filename,topic_hierarchy_outstream);
   topic_hierarchy_outstream 
      << "# Fine topic ID            Coarse topic ID        Word overlap"
      << endl << endl;

   for (int fine_topic_ID=0; fine_topic_ID<n_fine_topics; fine_topic_ID++)
   {
      cout << "---------------------------------------------------" << endl;
      cout << "fine_topic_ID = " << fine_topic_ID << endl;
      vector<int>* coarse_topic_doc_words_ptr=topic_words_hierarchy_map[
         fine_topic_ID];

      int max_n_coarse_topic_doc_words=-1;
      int max_coarse_topic_ID=-1;
      for (int coarse_topic_ID=0; coarse_topic_ID<n_coarse_topics; 
           coarse_topic_ID++)
      {
         int n_coarse_topic_doc_words=coarse_topic_doc_words_ptr->at(
            coarse_topic_ID);
         if (n_coarse_topic_doc_words==0) continue;

         if (n_coarse_topic_doc_words > max_n_coarse_topic_doc_words)
         {
            max_n_coarse_topic_doc_words=n_coarse_topic_doc_words;
            max_coarse_topic_ID=coarse_topic_ID;
         }
         
//         cout << "   coarse topic ID = " << coarse_topic_ID
//              << " n_coarse_topic_doc_words = "
//              << n_coarse_topic_doc_words << endl;
      } // loop over index coarse_topic_ID labeling coarse topics
//      cout << endl;

      cout << "  max_coarse_topic_ID = " << max_coarse_topic_ID
           << " max_n_coarse_topic_doc_words = "
           << max_n_coarse_topic_doc_words << endl;

      vector<int>* fine_topic_IDs_ptr;
      iter=topic_hierarchy_map.find(max_coarse_topic_ID);
      if (iter==topic_hierarchy_map.end())
      {
         fine_topic_IDs_ptr=new vector<int>;
         topic_hierarchy_map[max_coarse_topic_ID]=fine_topic_IDs_ptr;
      }
      else
      {
         fine_topic_IDs_ptr=iter->second;
      }
      fine_topic_IDs_ptr->push_back(fine_topic_ID);

      topic_hierarchy_outstream 
         << fine_topic_ID << "\t" << max_coarse_topic_ID 
         << " \t" << max_n_coarse_topic_doc_words << endl;

   } // loop over index fine_topic_ID labeling fine topics
   filefunc::closefile(topic_hierarchy_filename,topic_hierarchy_outstream);
   
   string banner="Exported "+topic_hierarchy_filename;
   outputfunc::write_big_banner(banner);

// Sort coarse topics according to their number of corresponding fine
// topics:

   vector<int> coarse_topic_IDs;
   vector<int> n_fine_topics_per_coarse_topic;
   for (iter=topic_hierarchy_map.begin(); iter != topic_hierarchy_map.end();
        iter++)
   {
      coarse_topic_IDs.push_back(iter->first);
      n_fine_topics_per_coarse_topic.push_back(iter->second->size());
   }
   
   templatefunc::Quicksort_descending(
      n_fine_topics_per_coarse_topic,coarse_topic_IDs);

// Export fine topic IDs as function of coarse topic ID to text output:

   topic_hierarchy_filename=bundler_IO_subdir+
      "coarse_vs_fine_topic_hierarchies.dat";
   filefunc::openfile(topic_hierarchy_filename,topic_hierarchy_outstream);
   topic_hierarchy_outstream 
      << "# Coarse topic ID            Fine topic IDs" << endl << endl;
   for (unsigned int c=0; c<coarse_topic_IDs.size(); c++)
   {
      int coarse_topic_ID=coarse_topic_IDs[c];
      topic_hierarchy_outstream << coarse_topic_ID << "\t";

      iter=topic_hierarchy_map.find(coarse_topic_ID);
      vector<int>* fine_topic_IDs_ptr=iter->second;
      for (unsigned int f=0; f<fine_topic_IDs_ptr->size(); f++)
      {
         topic_hierarchy_outstream << fine_topic_IDs_ptr->at(f) << " ";
      }
      topic_hierarchy_outstream << endl;
   }
   topic_hierarchy_outstream << endl;

// Store document words corresponding to coarse and fine topics within
// STL maps:

   typedef map<int,vector<string> > TOPIC_WORDS_MAP;
// independent var = topic ID
// dependent var = STL vector of top topic words   
   TOPIC_WORDS_MAP coarse_topic_words_map,fine_topic_words_map;
   TOPIC_WORDS_MAP::iterator topic_words_map_iter;

   string coarse_topic_top_words_filename=bundler_IO_subdir+
      doc_corpus_prefix+stringfunc::number_to_string(n_coarse_topics)+
      "topics_words.txt";

   filefunc::ReadInfile(coarse_topic_top_words_filename);
   for (unsigned int l=0; l<filefunc::text_line.size(); l++)
   { 
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(filefunc::text_line[l]);
      int n_coarse_topic_words=substrings.size()-2;

      int coarse_topic_ID=stringfunc::string_to_number(substrings[0]);
      vector<string> coarse_topic_words;
      for (int c=0; c<n_coarse_topic_words; c++)
      {
         coarse_topic_words.push_back(substrings[c+2]);
      }
      coarse_topic_words_map[coarse_topic_ID]=coarse_topic_words;
   }

   string fine_topic_top_words_filename=bundler_IO_subdir+
      doc_corpus_prefix+stringfunc::number_to_string(n_fine_topics)+
      "topics_words.txt";

   filefunc::ReadInfile(fine_topic_top_words_filename);
   for (unsigned int l=0; l<filefunc::text_line.size(); l++)
   { 
      vector<string> substrings=
         stringfunc::decompose_string_into_substrings(filefunc::text_line[l]);
      int n_fine_topic_words=substrings.size()-2;

      int fine_topic_ID=stringfunc::string_to_number(substrings[0]);
      vector<string> fine_topic_words;
      for (int c=0; c<n_fine_topic_words; c++)
      {
         fine_topic_words.push_back(substrings[c+2]);
      }
      fine_topic_words_map[fine_topic_ID]=fine_topic_words;
   }
   
// Export parent coarse topics as lists of document words.  Display
// their corresponding children fine topics also as lists of document
// words:

   for (unsigned int c=0; c<coarse_topic_IDs.size(); c++)
   {
      int coarse_topic_ID=coarse_topic_IDs[c];
      topic_words_map_iter=coarse_topic_words_map.find(coarse_topic_ID);
      vector<string> coarse_topic_words=topic_words_map_iter->second;

      topic_hierarchy_outstream << "coarse topic " << coarse_topic_ID << endl
                                << endl;
      for (unsigned int w=0; w<coarse_topic_words.size(); w++)
      {
         topic_hierarchy_outstream << coarse_topic_words[w] << " ";
      }
      topic_hierarchy_outstream << endl << endl;

      iter=topic_hierarchy_map.find(coarse_topic_ID);
      vector<int>* fine_topic_IDs_ptr=iter->second;
      for (unsigned int f=0; f<fine_topic_IDs_ptr->size(); f++)
      {
         int fine_topic_ID=fine_topic_IDs_ptr->at(f);
         topic_words_map_iter=fine_topic_words_map.find(fine_topic_ID);
         vector<string> fine_topic_words=topic_words_map_iter->second;

         topic_hierarchy_outstream << "fine topic " << fine_topic_ID << endl;
         for (unsigned int w=0; w<fine_topic_words.size(); w++)
         {
            topic_hierarchy_outstream << fine_topic_words[w] << " ";
         }
         topic_hierarchy_outstream << endl << endl;
      } // loop over index f labeling fine topics corresponding to coarse topic
      topic_hierarchy_outstream << endl;
   }
   topic_hierarchy_outstream << endl;

   filefunc::closefile(topic_hierarchy_filename,topic_hierarchy_outstream);

   banner="Exported "+topic_hierarchy_filename;
   outputfunc::write_big_banner(banner);

   outputfunc::print_elapsed_time();
}

