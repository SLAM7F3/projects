// ==========================================================================
// Program PUSHCARTREG is a specialized variant of GEOREG.  It reads
// in the bundle.out file for the MIT2317+Carleton Street "pushcart"
// photos generated by Nick Armstrong-Crews via Visual Structure for
// Motion rather than Noah Snavely's bundler program.  It also imports 
// the vsfm_vs_image_names.txt file generated by program
// MAP_VSFM_IMAGENAMES.

// For each VSfm reconstructed photo, this program queries the
// sensor_metadata table within the IMAGERY database to see if
// corresponding georegistered UTM coordinates exist for the camera's
// position.  It then performs a RANSAC loop over 200 pairs of
// reconstructed vs georegistered camera position vectors and solves
// for the global rotation, scaling and translation that maps the
// former to the latter.  The parameters which yield the minimal
// residual are returned as the best estimate for the global
// transformation.
// ==========================================================================
// Last updated on 2/19/12; 5/16/12; 8/20/12
// ==========================================================================

#include <iostream>
#include <string>
#include <vector>

#include "bundler/bundlerfuncs.h"
#include "video/camerafuncs.h"
#include "general/filefuncs.h"
#include "image/imagefuncs.h"
#include "video/imagesdatabasefuncs.h"
#include "numrec/nrfuncs.h"
#include "passes/PassesGroup.h"
#include "video/photogroup.h"
#include "osg/osgGIS/postgis_databases_group.h"
#include "general/sysfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::ofstream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);

// Use an ArgumentParser object to manage the program arguments:

   osg::ArgumentParser arguments(&argc,argv);
   const int ndims=3;
   PassesGroup passes_group(&arguments);

   int cloudpass_ID=passes_group.get_curr_cloudpass_ID();
   vector<int> GISlayer_IDs=passes_group.get_GISlayer_IDs();
//   cout << "GISlayer_IDs.size() = " << GISlayer_IDs.size() << endl;


// Instantiate postgis database objects to send data to and retrieve
// data from external Postgres database:

   postgis_databases_group* postgis_databases_group_ptr=
      new postgis_databases_group;
   postgis_database* postgis_db_ptr=postgis_databases_group_ptr->
      generate_postgis_database_from_GISlayer_IDs(
         passes_group,GISlayer_IDs);
//   cout << "postgis_db_ptr = " << postgis_db_ptr << endl;

   string image_list_filename=passes_group.get_image_list_filename();
   cout << "image_list_filename = " << image_list_filename << endl;
   string bundler_IO_subdir=filefunc::getdirname(image_list_filename);
   cout << "bundler_IO_subdir = " << bundler_IO_subdir << endl;
   string image_sizes_filename=passes_group.get_image_sizes_filename();
   cout << "image_sizes_filename = " << image_sizes_filename << endl;
   string bundle_filename=passes_group.get_bundle_filename();
   cout << "bundle_filename = " << bundle_filename << endl;

   string vsfm_vs_image_names_filename=bundler_IO_subdir+
      "vsfm_vs_image_names.txt";
   filefunc::ReadInfile(vsfm_vs_image_names_filename);
   vector<string> JPG_filenames;
   for (int i=0; i<filefunc::text_line.size(); i++)
   {
      vector<string> substrings=stringfunc::decompose_string_into_substrings(
         filefunc::text_line[i]);
      string curr_basename=filefunc::getbasename(substrings[1]);
      string prefix=stringfunc::prefix(curr_basename);
//      cout << i << "  " << prefix << endl;
      string separator_chars=".";
      vector<string> subsubstrings=
         stringfunc::decompose_string_into_substrings(prefix,separator_chars);
      string curr_JPG_filename=subsubstrings[0]+".JPG";
//      cout << i << "  " << JPG_filename << endl << endl;
      JPG_filenames.push_back(curr_JPG_filename);
   }

// Import reconstructed photographs:

   photogroup* photogroup_ptr=new photogroup;
   int n_photos_to_reconstruct=-1;
   photogroup_ptr->reconstruct_bundler_cameras(
      bundler_IO_subdir,image_list_filename,image_sizes_filename,
      bundle_filename,n_photos_to_reconstruct);

   int n_photos=photogroup_ptr->get_n_photos();
   cout << "n_photos = " << n_photos << endl;

// Record reconstructed bundler camera positions:

   vector<string> bundler_photo_filenames;
   vector<threevector> bundler_camera_posns;
   for (int n=0; n<n_photos; n++)
   {
      photograph* photo_ptr=photogroup_ptr->get_photograph_ptr(n);
      bundler_photo_filenames.push_back(
         filefunc::getbasename(photo_ptr->get_filename()));
      camera* camera_ptr=photo_ptr->get_camera_ptr();
      bundler_camera_posns.push_back(camera_ptr->get_world_posn());

/*
      string curr_filename=bundler_photo_filenames.back();
      if (curr_filename=="IMG_0911.JPG" ||
      curr_filename=="IMG_0685-1.JPG" ||
      curr_filename=="SDC12821.JPG")
      {
         cout << "n = " << n
//           << " camera = " << *camera_ptr 
              << " bundler_filename = " << bundler_photo_filenames.back()
              << " bundler_posn = " << bundler_camera_posns.back()
              << endl;
      }
*/

   }

// Import georegistered MIT2317 camera positions:

   int campaign_ID=1;
   int mission_ID=0;

// Generate image_list.dat:

//   string output_filename="image_list.dat";
//   ofstream outstream;
//   filefunc::openfile(output_filename,outstream);

   cout.precision(12);
   vector<threevector> reconstructed_XYZ,georegistered_XYZ;
   for (int i=0; i<bundler_photo_filenames.size(); i++)
   {
      if (i%100==0) cout << i << " " << flush;
//      string image_name=bundler_photo_filenames[i];
      string image_name=JPG_filenames[i];
      string image_URL="/data/ImageEngine/MIT2317/"+image_name;

      cout << "i = " << i << " image_URL = " << image_URL << endl;
      image_name="images/"+image_name;
//      outstream << image_name << endl;

      threevector curr_XYZ;
      if (!imagesdatabasefunc::retrieve_particular_sensor_posn_from_database(
         postgis_db_ptr,campaign_ID,mission_ID,image_URL,curr_XYZ))
      {
         continue;
      }

      reconstructed_XYZ.push_back(bundler_camera_posns[i]);
      georegistered_XYZ.push_back(curr_XYZ);

//      if (i%100==0)
//      {
//         cout << "i = " << i 
//              << " image = " << image_name
//              << " recon XYZ = " << reconstructed_XYZ.back()
//              << " geo XYZ = " << curr_XYZ 
//              << endl;
//         outputfunc::enter_continue_char();
//      }
      
   } // loop over index i labeling push cart image filenames
   cout << endl;

/*
// FAKE FAKE:  Sun Feb 19, 2012 at 7:07 am

vector<threevector> reconstructed_XYZ,georegistered_XYZ;

// Hardwire 3 special reconstructed photo camera posns BEFORE
// R_noah_to_peter for VSFM has been applied:

reconstructed_XYZ.push_back(threevector(0.20778,0.07205,-0.75934));
reconstructed_XYZ.push_back(threevector(12.38931,-0.29268,54.87955));
reconstructed_XYZ.push_back(threevector(-14.66417,-0.05235,63.88459));

// Hardwire 3 special reconstructed photo camera posns AFTER
// R_noah_to_peter for VSFM has been applied:

//   reconstructed_XYZ.push_back(threevector(0.20778,-0.75934,-0.07205));
//   reconstructed_XYZ.push_back(threevector(12.38931,54.87955,0.29268));
//   reconstructed_XYZ.push_back(threevector(-14.66417,63.88459,0.05235));

// Refined Jan 2012 values for MIT2317 camera positions in UTM coords:

georegistered_XYZ.push_back(
threevector(328090.87243 , 4691860.42144 , 2.91149));
georegistered_XYZ.push_back(
threevector(328255.06573 , 4691984.14420 , 3.55964));
georegistered_XYZ.push_back(
threevector(328201.01251 , 4692074.07209 , 4.08368));
*/

//   filefunc::closefile(output_filename,outstream);

   int n_matching_photos=reconstructed_XYZ.size();
   cout << "reconstructed_XYZ.size() = "
        << reconstructed_XYZ.size() << endl;
   cout << "georegistered_XYZ.size() = "
        << georegistered_XYZ.size() << endl;

// Recall that some of the georegistered MIT2317 camera positions are
// far off from truth.  It is highly likely that some of the
// MIT2317-Carleton Street VSFM reconstruction results are also wrong.  So 
// we need to apply a RANSAC procedure in order to find a reasonable
// global transformation which georegisters the MIT2317-Carleton
// Street VFSM reconstruction:

   double min_avg_residual=POSITIVEINFINITY;
   double best_az,best_el,best_roll,best_scale;
   threevector best_reconstructed_COM,best_trans_Horn,best_trans_Peter;

   int n_iters=100;
   nrfunc::init_time_based_seed();

   for (int iter=0; iter<n_iters; iter++)
   {
      string banner="iter = "+stringfunc::number_to_string(iter);
      outputfunc::write_big_banner(banner);

      const int n_cameras_to_fit=200;
      vector<threevector> georegistered_XYZ_subset,reconstructed_XYZ_subset;

      for (int i=0; i<n_cameras_to_fit; i++)
      {
         int curr_photo_index=nrfunc::ran1()*(n_matching_photos-1);
//         curr_photo_index=basic_math::max(0,curr_photo_index);
//         curr_photo_index=basic_math::min(
//            n_matching_photos-1,curr_photo_index);
//         cout << "i = " << i 
//              << " random_var = " << random_var
//              << " curr_photo_index = " << curr_photo_index
//              << endl;
         georegistered_XYZ_subset.push_back(
            georegistered_XYZ[curr_photo_index]);
         reconstructed_XYZ_subset.push_back(
            reconstructed_XYZ[curr_photo_index]);
      }

      threevector georegistered_COM=Zero_vector;
      threevector reconstructed_COM=Zero_vector;

      int n_cameras=georegistered_XYZ_subset.size();
      for (int i=0; i<n_cameras_to_fit; i++)
      {
         georegistered_COM += georegistered_XYZ_subset[i];
         reconstructed_COM += reconstructed_XYZ_subset[i];
      }

      georegistered_COM /= n_cameras_to_fit;
      reconstructed_COM /= n_cameras_to_fit;
   
//      cout << "georegistered_COM = " << georegistered_COM << endl;
//      cout << "reconstructed_COM = " << reconstructed_COM << endl;
//      cout << "|georegistered_COM-reconstructed_COM| = "
//           << (georegistered_COM-reconstructed_COM).magnitude() << endl;
   
      double az,el,roll,scale;
      threevector trans_Horn,trans_Peter;
      double max_residual_dist=50;	// meters
      double median_residual_dist,quartile_width;
      bundlerfunc::RANSAC_fit_rotation_translation_scale(
         reconstructed_XYZ_subset,georegistered_XYZ_subset,
         reconstructed_COM,georegistered_COM,
         az,el,roll,scale,trans_Horn,trans_Peter,
         median_residual_dist,quartile_width);

      rotation R;
      R=R.rotation_from_az_el_roll(az,el,roll);

      vector<threevector> transformed_left_points;
      double avg_residual=bundlerfunc::compute_avg_residual(
         reconstructed_XYZ_subset,georegistered_XYZ_subset,
         transformed_left_points,az,el,roll,scale,trans_Horn);
   
      if (avg_residual < min_avg_residual)
      {
         min_avg_residual=avg_residual;
         best_az=az;
         best_el=el;
         best_roll=roll;
         best_scale=scale;
         best_trans_Horn=trans_Horn;
         best_trans_Peter=trans_Peter;
         best_reconstructed_COM=reconstructed_COM;
      }
      cout << "Curr avg residual = " << avg_residual 
           << " Min avg residual = " << min_avg_residual << endl;

   } // loop over iter index   

   cout << "Minimum average residual = " << min_avg_residual << endl;
   cout << "Best az = " << best_az*180/PI << endl;
   cout << "Best el = " << best_el*180/PI << endl;
   cout << "Best roll = " << best_roll*180/PI << endl;
   cout << "Best scale = " << best_scale << endl;
   cout << "Best trans_Horn = " << best_trans_Horn << endl;
   cout << "Best trans_Peter = " << best_trans_Peter << endl;

   cout << "=====================================================" << endl;
   cout << endl;

   cout << "--fitted_world_to_bundler_distance_ratio " << best_scale << endl;
   cout << "--bundler_translation_X " << best_trans_Peter.get(0) << endl;
   cout << "--bundler_translation_Y " << best_trans_Peter.get(1) << endl;
   cout << "--bundler_translation_Z " << best_trans_Peter.get(2) << endl;
   cout << "--global_az " << best_az*180/PI << endl;
   cout << "--global_el " << best_el*180/PI << endl;
   cout << "--global_roll " << best_roll*180/PI << endl;
   cout << "--bundler_rotation_origin_X " << best_reconstructed_COM.get(0) 
        << endl;
   cout << "--bundler_rotation_origin_Y " << best_reconstructed_COM.get(1) 
        << endl;
   cout << "--bundler_rotation_origin_Z " << best_reconstructed_COM.get(2) 
        << endl;
   cout << endl;
   
}
