// ==========================================================================
// Program FACADE_WARP is a playground for warping an MIT2317 of the
// medical center containing no people onto a counterpart image which
// does contain people.  It reads in orthorectification metadata
// generated by PROPAGATOR for the two images.  FACADE_WARP then
// applies the homography that maps the no people to people image.  It
// exports a mask of the warped no people image corresponding to just
// background static building facades.

//	               	./facade_warp

// ==========================================================================
// Last updated on 8/15/12; 8/20/12; 8/23/12
// ==========================================================================

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include "general/filefuncs.h"
#include "geometry/homography.h"
#include "astro_geo/latlong2utmfuncs.h"
#include "general/outputfuncs.h"
#include "general/stringfuncs.h"
#include "general/sysfuncs.h"
#include "video/texture_rectangle.h"
#include "math/twovector.h"
#include "video/videofuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::ios;
using std::ofstream;
using std::ostream;
using std::string;
using std::vector;

// ==========================================================================
int main(int argc, char *argv[])
// ==========================================================================
{
   std::set_new_handler(sysfunc::out_of_memory);
   const int PRECISION=12;
   cout.precision(PRECISION);

   string no_people_subdir="./rectified_views/nick/no_people/";
   string people_subdir="./rectified_views/nick/people/";

   string no_people_metadata_filename=no_people_subdir+
//      "0_1_2_DSC_5908.rdgeom.metadata";
      "0_0_2_DSC_5908.rdgeom.metadata";
   string people_metadata_filename=people_subdir+
//       "0_1_2_DSC_5913.rdgeom.metadata";
      "0_0_2_DSC_5913.rdgeom.metadata";
   string pushcart_people_metadata_filename=people_subdir+
      "0_0_2_00002328geom.metadata";

   string no_people_photo_filename="./bundler/MIT2317/images/DSC_5908.rd.jpg";
   string people_photo_filename="./bundler/MIT2317/images/DSC_5913.rd.jpg";
   string pushcart_people_photo_filename=
      "./bundler/Pushcart/images/00002328.jpg";

// Note: As of late August 2012, Nick Armstrong-Crews requested that
// the pushcart people photo be warped so that the health center
// facade matches that in the people photo (and not the no_people
// photo).

   cout << "NO PEOPLE image:" << endl;
   filefunc::ReadInfile(no_people_metadata_filename);
   vector<twovector> no_people_facet_corners,UV,XY;
   for (int i=0; i<4; i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);
      no_people_facet_corners.push_back(
         twovector(column_values[0],column_values[1]));
      cout << "i = " << i 
           << " U = " << no_people_facet_corners.back().get(0) 
           << " V = " << no_people_facet_corners.back().get(1) 
           << endl;
   }
   cout << endl;

   cout << "PEOPLE image:" << endl;
   filefunc::ReadInfile(people_metadata_filename);
   vector<twovector> people_facet_corners;
   for (int i=0; i<4; i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);
      people_facet_corners.push_back(
         twovector(column_values[0],column_values[1]));
      cout << "i = " << i 
           << " U = " << people_facet_corners.back().get(0) 
           << " V = " << people_facet_corners.back().get(1) 
           << endl;
   }
   cout << endl;


   cout << "Pushcart PEOPLE image:" << endl;
   filefunc::ReadInfile(pushcart_people_metadata_filename);
   vector<twovector> pushcart_people_facet_corners;
   for (int i=0; i<4; i++)
   {
      vector<double> column_values=stringfunc::string_to_numbers(
         filefunc::text_line[i]);
      pushcart_people_facet_corners.push_back(
         twovector(column_values[0],column_values[1]));
      cout << "i = " << i 
           << " U = " << pushcart_people_facet_corners.back().get(0) 
           << " V = " << pushcart_people_facet_corners.back().get(1) 
           << endl;
   }
   cout << endl;


   polygon no_people_poly(no_people_facet_corners);
   cout << "no_people_poly = " << no_people_poly << endl;

   polygon people_poly(people_facet_corners);
   cout << "people_poly = " << people_poly << endl;

   polygon pushcart_people_poly(pushcart_people_facet_corners);
   cout << "pushcart_people_poly = " << pushcart_people_poly << endl;

   homography H;
//   H.parse_homography_inputs(no_people_facet_corners,people_facet_corners);
   H.parse_homography_inputs(
      pushcart_people_facet_corners,people_facet_corners);
   H.compute_homography_matrix();
   H.compute_homography_inverse();
   
   double RMS_residual=H.check_homography_matrix(
      no_people_facet_corners,people_facet_corners);
   cout << "RMS_residual = " << RMS_residual << endl;
   cout << "H = " << H << endl;

   texture_rectangle* texture_rectangle_ptr=new texture_rectangle();
//   texture_rectangle_ptr->import_photo_from_file(no_people_photo_filename);
   texture_rectangle_ptr->import_photo_from_file(
      pushcart_people_photo_filename);

   int width=texture_rectangle_ptr->getWidth();
   int height=texture_rectangle_ptr->getHeight();

   texture_rectangle* warped_texture_rectangle_ptr=new texture_rectangle(
      width,height,1,3,NULL);

   string blank_filename="blank.jpg";
   warped_texture_rectangle_ptr->generate_blank_image_file(
      width,height,blank_filename,0.5);
   warped_texture_rectangle_ptr->import_photo_from_file(blank_filename);

   int R,G,B;
   double x,y,u,v;
   for (int pu=0; pu<width; pu++)
   {
      outputfunc::update_progress_fraction(pu,100,width);
      for (int pv=0; pv<height; pv++)
      {
         warped_texture_rectangle_ptr->get_uv_coords(pu,pv,u,v);
         H.project_image_plane_to_world_plane(u,v,x,y);
         
         if (pushcart_people_poly.point_inside_polygon(twovector(x,y)))
//         if (no_people_poly.point_inside_polygon(twovector(x,y)))
         {
            texture_rectangle_ptr->get_RGB_values(x,y,R,G,B);
         }
         else
         {
            R=G=B=0;
         }
//         cout << "R = " << R << " G = " << G << " B = " << B << endl;
         warped_texture_rectangle_ptr->set_pixel_RGB_values(pu,pv,R,G,B);
      } // loop over pv index
   } // loop over pu index
   cout << endl;

   string warped_filename="warped_view.jpg";
   warped_texture_rectangle_ptr->write_curr_frame(warped_filename);

   string banner="Exported "+warped_filename;
   outputfunc::write_big_banner(banner);

// Import previously warped facet regions and generate (hopefully
// seemless) mosaic:

//   string previously_warped_filename="warped_view_a.jpg";
   string previously_warped_filename="warped_view.jpg";
   texture_rectangle_ptr->import_photo_from_file(previously_warped_filename);

   int black_threshold=5;
   for (int pu=0; pu<width; pu++)
   {
      for (int pv=0; pv<height; pv++)
      {
         texture_rectangle_ptr->get_pixel_RGB_values(pu,pv,R,G,B);
         if (R < black_threshold && G < black_threshold && B < black_threshold)
            continue;
         warped_texture_rectangle_ptr->set_pixel_RGB_values(pu,pv,R,G,B);
      } // loop over pv index
   } // loop over pu index
   
   string mosaic_filename="warped_mosaic.jpg";
   warped_texture_rectangle_ptr->write_curr_frame(mosaic_filename);

   banner="Exported "+mosaic_filename;
   outputfunc::write_big_banner(banner);

   int width_mosaic_image=warped_texture_rectangle_ptr->getWidth();
   int height_mosaic_image=warped_texture_rectangle_ptr->getHeight();

// Superpose warped "no people" mosaic onto original "people" image:

   texture_rectangle* people_texture_rectangle_ptr=new texture_rectangle();
   people_texture_rectangle_ptr->import_photo_from_file(people_photo_filename);
   int width_people_image=people_texture_rectangle_ptr->getWidth();
   int height_people_image=people_texture_rectangle_ptr->getHeight();

   string resized_people_photo_filename="resized_people_filename.jpg";
   videofunc::resize_image(
      people_photo_filename,width_people_image,height_people_image,
      width_mosaic_image,height_mosaic_image,resized_people_photo_filename);
   people_texture_rectangle_ptr->import_photo_from_file(
      resized_people_photo_filename);

   int R_nopeople,G_nopeople,B_nopeople;
   int R_people,G_people,B_people;
   for (int pu=0; pu<width; pu++)
   {
      for (int pv=0; pv<height; pv++)
      {
         warped_texture_rectangle_ptr->get_pixel_RGB_values(
            pu,pv,R_nopeople,G_nopeople,B_nopeople);
         people_texture_rectangle_ptr->get_pixel_RGB_values(
            pu,pv,R_people,G_people,B_people);

         if (R_nopeople < black_threshold && G_nopeople < black_threshold 
         && B_nopeople < black_threshold)
         {
            R=R_people;
            G=G_people;
            B=B_people;
         }
         else
         {
            R=0.5*R_people+0.5*R_nopeople;
            G=0.5*G_people+0.5*G_nopeople;
            B=0.5*B_people+0.5*B_nopeople;
         }
         
         people_texture_rectangle_ptr->set_pixel_RGB_values(pu,pv,R,G,B);
      } // loop over pv
   } // loop over pu
   
//   string comparison_filename="people_no_people_average.jpg";
   string comparison_filename="people_pushcart_people_average.jpg";
   people_texture_rectangle_ptr->write_curr_frame(comparison_filename);

   banner="Exported "+comparison_filename;
   outputfunc::write_big_banner(banner);
   
   delete texture_rectangle_ptr;
   delete warped_texture_rectangle_ptr;
   delete people_texture_rectangle_ptr;
   
   


}
