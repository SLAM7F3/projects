// ==========================================================================
// Databasefuncs namespace method definitions
// ==========================================================================
// Last modified on 10/27/11; 10/28/11; 10/31/11; 4/5/14
// ==========================================================================

#include <iostream>
#include "astro_geo/Clock.h"
#include "postgres/databasefuncs.h"
#include "postgres/gis_database.h"
#include "general/stringfuncs.h"

using std::cout;
using std::endl;
using std::ofstream;
using std::string;
using std::vector;

namespace databasefunc
{

// ==========================================================================
// Manipulation methods for world map annotations table in TOC
// database
// ==========================================================================

// Method insert_world_annotation() takes in metadata for a single
// annotation which is intended to be tied to a 3D world point.  It
// inserts this metadata into *gis_database_ptr.  

   bool insert_world_annotation(
      gis_database* gis_database_ptr,
      int fieldtest_ID,double secs_since_epoch,
      string username,string label,string description,string color,
      int importance,double longitude,double latitude,double altitude)
   {
//   cout << "inside databasefunc::insert_world_annotations()" << endl;

      string curr_insert_command=
         databasefunc::generate_insert_world_annotation_SQL_command(
            fieldtest_ID,secs_since_epoch,
            username,label,description,color,importance,
            longitude,latitude,altitude);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);
//      cout << "insert_commands.back() = " << insert_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;
      gis_database_ptr->set_SQL_commands(insert_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_insert_world_annotation_SQL_command() takes in
// metadata associated with a single world annotation.  It generates
// and returns a string containing a SQL insert command needed to
// populate a row within the world_annotations table of the
// TOC database.

   string generate_insert_world_annotation_SQL_command(
      int fieldtest_ID,double secs_since_epoch,
      string username,string label,string description,string color,
      int importance,double longitude,double latitude,double altitude)
   {
//   cout << "inside databasefunc::generate_insert_world_annotation_SQL_command()" << endl;

      Clock clock;
      clock.convert_elapsed_secs_to_date(secs_since_epoch);
      string date_str=clock.YYYY_MM_DD_H_M_S();
      
      string SQL_command="insert into world_annotations ";
      SQL_command += "(fieldtest_id,creation_time,event_time,";
      SQL_command += "username,label,description,color,";
      SQL_command += "importance,z_posn,xy_posn) ";
      SQL_command += "values( ";
      SQL_command += stringfunc::number_to_string(fieldtest_ID)+",";
      SQL_command += "'"+date_str+"',";
      SQL_command += "'"+date_str+"',";
      SQL_command += "'"+username+"',";
      SQL_command += "'"+label+"',";
      SQL_command += "'"+description+"',";
      SQL_command += "'"+color+"',";
      SQL_command += stringfunc::number_to_string(importance)+",";
      SQL_command += stringfunc::number_to_string(altitude)+",";
      SQL_command += "'SRID=4326; POINT("
         +stringfunc::number_to_string(longitude,9)
         +" "+stringfunc::number_to_string(latitude,9)+")'";
      SQL_command += ");";

//      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method get_world_annotation_ID() takes in username, label and
// description fields.  It returns the integer ID automatically
// generated by the world_annotations table within the TOC database at
// the time the world annotation was inserted.  If no world annotation
// matching the input parameters is found, this method returns -1.

   int get_world_annotation_ID(
      gis_database* gis_database_ptr,
      string username,string label,string description)
   {
//      cout << "inside databasefunc::get_world_annotation_ID()" << endl;
//      cout << "username = " << username
//           << " label = " << label
//           << " description = " << description << endl;

      string SQL_command="select id from world_annotations ";
      SQL_command += "WHERE username='"+username+"' ";
      SQL_command += "AND label='"+label+"' ";
      SQL_command += "AND description='"+description+"';";
//      cout << "SQL_command = " << SQL_command << endl;

      Genarray<string>* field_array_ptr=
         gis_database_ptr->select_data(SQL_command);
      if (field_array_ptr==NULL) return -1;

//      cout << "*field_array_ptr = " << *field_array_ptr << endl;

      int annotation_ID=stringfunc::string_to_number(
         field_array_ptr->get(0,0));
//      cout << "annotation_ID = "  << annotation_ID << endl;
      return annotation_ID;
   }

// ---------------------------------------------------------------------   
// Method get_all_world_map_annotations()

   void get_all_world_map_annotations(
      gis_database* gis_database_ptr,int fieldtest_ID,
      vector<int>& annotation_IDs,vector<string>& creation_times,
      vector<string>& event_times,vector<string>& usernames,
      vector<string>& labels,vector<string>& descriptions,
      vector<string>& colors,vector<int>& importances,
      vector<threevector>& llas)
   {
//      cout << "inside databasefunc::get_all_world_map_annotations()" << endl;
//      cout << "fieldtest_ID = " << fieldtest_ID << endl;

      string SQL_command="SELECT id,creation_time,event_time,username,";
      SQL_command += "label,description,color,importance,z_posn,";
      SQL_command += "x(xy_posn),y(xy_posn) from world_annotations ";
      SQL_command += "WHERE fieldtest_ID="+stringfunc::number_to_string(
         fieldtest_ID)+";";
//      cout << "SQL_command = " << SQL_command << endl;

      Genarray<string>* field_array_ptr=
         gis_database_ptr->select_data(SQL_command);
      if (field_array_ptr==NULL) return;

      unsigned int mdim=field_array_ptr->get_mdim();
//      unsigned int ndim=field_array_ptr->get_ndim();
//      cout << "mdim = " << mdim << " ndim = " << ndim << endl;

      for (unsigned int i=0; i<mdim; i++)
      {
         annotation_IDs.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,0)));
         creation_times.push_back(field_array_ptr->get(i,1));
         event_times.push_back(field_array_ptr->get(i,2));
         usernames.push_back(field_array_ptr->get(i,3));
         labels.push_back(field_array_ptr->get(i,4));
         descriptions.push_back(field_array_ptr->get(i,5));
         colors.push_back(field_array_ptr->get(i,6));
         importances.push_back(stringfunc::string_to_number(
            field_array_ptr->get(i,7)));
         double altitude=stringfunc::string_to_number(
            field_array_ptr->get(i,8));
         double longitude=stringfunc::string_to_number(
            field_array_ptr->get(i,9));
         double latitude=stringfunc::string_to_number(
            field_array_ptr->get(i,10));
         llas.push_back(threevector(longitude,latitude,altitude));

         cout << "annotation_ID = "  << annotation_IDs.back() << endl;
         cout << "creation_time = " << creation_times.back() << endl;
         cout << "event_time = " << event_times.back() << endl;
         cout << "username = " << usernames.back() << endl;
         cout << "label = " << labels.back() << endl;
         cout << "description = " << descriptions.back() << endl;
         cout << "color = " << colors.back() << endl;
         cout << "importance = " << importances.back() << endl;
         cout << "lon = " << longitude << " lat = " << latitude
              << " alt = " << altitude << endl;
      } // loop over index i labeling world annotations
   }

// ---------------------------------------------------------------------   
// Method update_world_annotation() takes in metadata for a single
// annotation which is intended to be tied to a 3D world point.  It
// update the appropriate entry within *gis_database_ptr.

   bool update_world_annotation(
      gis_database* gis_database_ptr,
      int annotation_ID,double secs_since_epoch,
      string username,string label,string description,string color,
      int importance,double longitude,double latitude,double altitude)
   {
//   cout << "inside databasefunc::update_world_annotations()" << endl;

      string curr_update_command=
         databasefunc::generate_update_world_annotation_SQL_command(
            annotation_ID,secs_since_epoch,
            username,label,description,color,importance,
            longitude,latitude,altitude);
      
      vector<string> update_commands;
      update_commands.push_back(curr_update_command);
//      cout << "update_commands.back() = " << update_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;
      gis_database_ptr->set_SQL_commands(update_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_update_world_annotation_SQL_command() takes in
// metadata associated with a single world annotation.  It generates
// and returns a string containing a SQL update command needed to
// alter a row within the world_annotations table of the
// TOC database.

   string generate_update_world_annotation_SQL_command(
      int annotation_ID,double secs_since_epoch,
      string username,string label,string description,string color,
      int importance,double longitude,double latitude,double altitude)
   {
//   cout << "inside databasefunc::generate_update_world_annotation_SQL_command()" << endl;

      Clock clock;
      clock.convert_elapsed_secs_to_date(secs_since_epoch);
      string date_str=clock.YYYY_MM_DD_H_M_S();
      
      string SQL_command="UPDATE world_annotations";
      SQL_command += " SET creation_time='"+date_str+"',";
      SQL_command += "event_time='"+date_str+"',";

      if (username.size() > 0)
         SQL_command += "username='"+username+"',";
      if (label.size() > 0)
         SQL_command += "label='"+label+"',";
      if (description.size() > 0)
         SQL_command += "description='"+description+"',";
      if (color.size() > 0)
         SQL_command += "color='"+color+"',";
      if (importance > 0)
         SQL_command += "importance="+stringfunc::number_to_string(
         importance)+",";
      if (altitude > 0.5*NEGATIVEINFINITY)
         SQL_command += "altitude="+stringfunc::number_to_string(
            altitude);

      if (longitude > 0.5*NEGATIVEINFINITY && latitude > 0.5*NEGATIVEINFINITY)
      {
         SQL_command += "xy_posn=PointFromText('POINT(' || ";
         SQL_command += stringfunc::number_to_string(longitude,9)+" || ' ' || ";
         SQL_command += stringfunc::number_to_string(latitude,9)+" || ')',4326) ";
      }
      
      SQL_command += " WHERE id = "+stringfunc::number_to_string(
         annotation_ID)+";";

      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------
// Method retrieve_world_annotations_from_database() takes in
// *gis_database_ptr which is assumed to contain an "expt_metadata"
// database with a "world_annotations" table.  It extracts all rows
// and columns from this database table.  After sorting the extracted
// rows according to photo_ID, this method fills output STL vectors
// with annotation metadata.

   void retrieve_world_annotations_from_database(
      gis_database* gis_database_ptr,int fieldtest_id,
      vector<int>& annotation_ID,vector<string>& time_stamp,
      vector<string>& username,vector<string>& label,
      vector<string>& description,vector<string>& color,
      vector<int>& importance,vector<double>& zposn,
      vector<double>& longitude,vector<double>& latitude)
   {
//      cout << "inside databasefunc::retrieve_world_annotations_from_database()"
//           << endl;
   
      string curr_select_command = 
         "SELECT id,time_stamp,username,label,description,color,importance,";
      curr_select_command += 
         "z_posn,x(xy_posn) as longitude,y(xy_posn) as latitude ";
      curr_select_command += "from world_annotations ";
      curr_select_command += "where fieldtest_id="+
         stringfunc::number_to_string(fieldtest_id);
//      cout << "curr_select_command = " << curr_select_command << endl;
         
      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

//   cout << "Field_array_ptr = " << field_array_ptr << endl;
//   cout << "*field_arraay_ptr = " << *field_array_ptr << endl;
//   cout << "mdim = " << field_array_ptr->get_mdim()
//        << " ndim = " << field_array_ptr->get_ndim() << endl;

      vector<int> annotation_ID_copy,annotation_ID_copy2;
      for (unsigned int i=0; i<field_array_ptr->get_mdim(); i++)
      {
         int curr_annotation_ID=stringfunc::string_to_number(
            field_array_ptr->get(i,0));
         string curr_time_stamp=field_array_ptr->get(i,1);   
         string curr_username=field_array_ptr->get(i,2);   
         string curr_label=field_array_ptr->get(i,3);   
         string curr_description=field_array_ptr->get(i,4);   
         string curr_color=field_array_ptr->get(i,5);   
         int curr_importance=stringfunc::string_to_number(
            field_array_ptr->get(i,6));   
         double curr_z=stringfunc::string_to_number(
            field_array_ptr->get(i,7));
         double curr_lon=
            stringfunc::string_to_number(field_array_ptr->get(i,8));
         double curr_lat=
            stringfunc::string_to_number(field_array_ptr->get(i,9));

         annotation_ID.push_back(curr_annotation_ID);
         annotation_ID_copy.push_back(curr_annotation_ID);
         annotation_ID_copy2.push_back(curr_annotation_ID);
         time_stamp.push_back(curr_time_stamp);
         username.push_back(curr_username);
         label.push_back(curr_label);
         description.push_back(curr_description);
         color.push_back(curr_color);
         importance.push_back(curr_importance);
         zposn.push_back(curr_z);
         longitude.push_back(curr_lon);
         latitude.push_back(curr_lat);
      } // loop over index i labeling database rows

// Recall database retrieval is NOT guaranteed to be sorted!  So in
// order to maintain consistency with Noah's original photo indexing
// conventions, we need to sort all values extracted from the database
// w.r.t photo_ID and its copies:
   
      templatefunc::Quicksort(annotation_ID,time_stamp);
      templatefunc::Quicksort(
         annotation_ID_copy,username,label,description,color,importance);
      templatefunc::Quicksort(annotation_ID_copy2,zposn,longitude,latitude);
      
   }

// ==========================================================================
// TOC database manipulation methods
// ==========================================================================

// Method insert_fieldtest() takes in metadata for a new entry within
// the fieldtests table of the TOC database.  It inserts this metadata
// into *gis_database_ptr.

   bool insert_fieldtest(
      gis_database* gis_database_ptr,
      string fieldtest_date,string brief_label,string description)
   {
//      cout << "inside databasefunc::insert_fieldtest()" << endl;

      string curr_insert_command=
         databasefunc::generate_insert_fieldtest_SQL_command(
            fieldtest_date,brief_label,description);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);
      gis_database_ptr->set_SQL_commands(insert_commands);

      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_insert_fieldtest_SQL_command() takes in
// metadata associated with a single world annotation.  It generates
// and returns a string containing a SQL insert command needed to
// populate a row within the world_annotations table of the
// expt_metadata postgis database.

   string generate_insert_fieldtest_SQL_command(
      string fieldtest_date,string brief_label,string description)
   {
//   cout << "inside databasefunc::generate_fieldtest_SQL_command()" << endl;

      string SQL_command="insert into fieldtests ";
      SQL_command += "(start_time_stamp,description,label) ";
      SQL_command += "values( ";
      SQL_command += "'"+fieldtest_date+"',";
      SQL_command += "'"+description+"',";
      SQL_command += "'"+brief_label+"'";
      SQL_command += ");";

      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method get_fieldtest_time() takes in a fieldtest ID.  It returns
// the date associated with the selected fieldtest as secs since
// midnight Jan 1, 1970.

   double get_fieldtest_time(gis_database* gis_database_ptr,int fieldtest_ID)
   {
//   cout << "inside databasefunc::get_fieldtest_time()" << endl;

      string SQL_command="select start_time_stamp from fieldtests ";
      SQL_command += "where id = "+stringfunc::number_to_string(
         fieldtest_ID)+";";
      cout << SQL_command << endl;

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(SQL_command);
      string timestamp=field_array_ptr->get(0,0);
      cout << "timestamp = " << timestamp << endl;

      bool UTC_flag=false;
      Clock clock;
      double elapsed_secs=clock.timestamp_string_to_elapsed_secs(
         timestamp,UTC_flag);
      cout << "elapsed_secs = " << elapsed_secs << endl;
            
      return elapsed_secs;
   }

// ---------------------------------------------------------------------   
// Method insert_mission() takes in metadata for a new entry within
// the missions table of the TOC database.  It inserts this metadata
// into *gis_database_ptr.  This method returns the new mission's ID.

   int insert_mission(
      gis_database* gis_database_ptr,
      string start_mission_time,string stop_mission_time,int fieldtest_ID,
      string platform_label,int platform_ID,int SDcard_ID,
      string pilot_name,string copilot_name,string courier_name)
   {
      cout << "inside databasefunc::insert_mission()" << endl;

      string curr_insert_command=
         generate_insert_mission_SQL_command(
            start_mission_time,stop_mission_time,fieldtest_ID,
	    platform_label,platform_ID,SDcard_ID,
            pilot_name,copilot_name,courier_name);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);

      gis_database_ptr->set_SQL_commands(insert_commands);
      gis_database_ptr->execute_SQL_commands();

      int new_mission_ID=-1;
      return new_mission_ID;
   }

// ---------------------------------------------------------------------   
// Method generate_insert_mission_SQL_command() takes in
// metadata associated with a single world annotation.  It generates
// and returns a string containing a SQL insert command needed to
// populate a row within the world_annotations table of the
// expt_metadata postgis database.

   string generate_insert_mission_SQL_command(
      string start_mission_time,string stop_mission_time,int fieldtest_ID,
      string platform_label,int platform_ID,int SDcard_ID,
      string pilot_name,string copilot_name,string courier_name)
   {
   cout << "inside databasefunc::generate_mission_SQL_command()" << endl;

      string SQL_command="insert into missions ";
      SQL_command += 
	"(start_time_stamp,stop_time_stamp,fieldtest_ID,platform_label,platform_ID,SDcard_ID,pilot_name,Copilot_name,courier_name) ";
      SQL_command += "values( ";
      SQL_command += "'"+start_mission_time+"',";
      SQL_command += "'"+stop_mission_time+"',";
      SQL_command += stringfunc::number_to_string(fieldtest_ID)+",";
      SQL_command += "'"+platform_label+"',";
      SQL_command += stringfunc::number_to_string(platform_ID)+",";
      SQL_command += stringfunc::number_to_string(SDcard_ID)+",";
      SQL_command += "'"+pilot_name+"', ";
      SQL_command += "'"+copilot_name+"', ";
      SQL_command += "'"+courier_name+"' ";
      SQL_command += ");";

      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method insert_platform() takes in metadata for a new entry within
// the platforms table of the TOC database.  It inserts this metadata
// into *gis_database_ptr.

   bool insert_platform(gis_database* gis_database_ptr,string description)
   {
//      cout << "inside databasefunc::insert_platform()" << endl;

      string curr_insert_command=
         databasefunc::generate_insert_platform_SQL_command(description);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);
//      cout << "insert_commands.back() = " << insert_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;

      gis_database_ptr->set_SQL_commands(insert_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_insert_platform_SQL_command() takes in
// metadata associated with a single world annotation.  It generates
// and returns a string containing a SQL insert command needed to
// populate a row within the world_annotations table of the
// expt_metadata postgis database.

   string generate_insert_platform_SQL_command(string description)
   {
//   cout << "inside databasefunc::generate_platform_SQL_command()" << endl;

      string SQL_command="insert into platforms ";
      SQL_command += "(description) ";
      SQL_command += "values( ";
      SQL_command += "'"+description+"'";
      SQL_command += ");";

      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method insert_sensor() takes in metadata for a new entry within
// the sensors table of the TOC database.  It inserts this metadata
// into *gis_database_ptr.

   bool insert_sensor(gis_database* gis_database_ptr,string description)
   {
//      cout << "inside databasefunc::insert_sensor()" << endl;

      string curr_insert_command=
         databasefunc::generate_insert_sensor_SQL_command(description);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);
//      cout << "insert_commands.back() = " << insert_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;

      gis_database_ptr->set_SQL_commands(insert_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_insert_sensor_SQL_command() takes in
// metadata associated with a single world annotation.  It generates
// and returns a string containing a SQL insert command needed to
// populate a row within the world_annotations table of the
// expt_metadata postgis database.

   string generate_insert_sensor_SQL_command(string description)
   {
//   cout << "inside databasefunc::generate_sensor_SQL_command()" << endl;

      string SQL_command="insert into sensors ";
      SQL_command += "(description) ";
      SQL_command += "values( ";
      SQL_command += "'"+description+"'";
      SQL_command += ");";

      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method delete_world_annotation() 

   bool delete_world_annotation(
      gis_database* gis_database_ptr,int annotation_ID)
   {
//   cout << "inside databasefunc::delete_world_annotation()" << endl;

      string SQL_command="delete from world_annotations where id=";
      SQL_command += stringfunc::number_to_string(annotation_ID)+";";
      
      vector<string> delete_commands;
      delete_commands.push_back(SQL_command);
//      cout << "delete_commands.back() = " << delete_commands.back() << endl;
//      cout << "gis_database_ptr = " << gis_database_ptr << endl;
      gis_database_ptr->set_SQL_commands(delete_commands);
      return gis_database_ptr->execute_SQL_commands();
   }

// ==========================================================================
// FLIR database insertion methods
// ==========================================================================

// Method insert_aircraft_metadata() takes in metadata for a new entry
// within the aircraft_metadata table of the Tstorm database.  It
// inserts this metadata into *gis_database_ptr.

   bool insert_aircraft_metadata(
      gis_database* gis_database_ptr,
      int campaign_ID,int mission_ID,int frame_ID,
      double epoch_time,string frame_prefix,
      double longitude,double latitude,double altitude,
      double yaw,double pitch,double roll)
   {
//      cout << "inside databasefunc::insert_aircraft_metadata()" << endl;

      string curr_insert_command=
         databasefunc::generate_insert_aircraft_metadata_SQL_command(
            campaign_ID,mission_ID,frame_ID,
            epoch_time,frame_prefix,longitude,latitude,altitude,
            yaw,pitch,roll);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);
      gis_database_ptr->set_SQL_commands(insert_commands);

      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_insert_aircraft_metadata_SQL_command() takes in
// metadata associated with a single aircraft spacetime point.  It
// generates and returns a string containing a SQL insert command
// needed to populate a row within the aircraft_metadata table of the
// TSTORM postgis database.

   string generate_insert_aircraft_metadata_SQL_command(
      int campaign_ID,int mission_ID,int frame_ID,
      double epoch_time,std::string frame_prefix,
      double longitude,double latitude,double altitude,
      double yaw,double pitch,double roll)
   {
//   cout << "inside databasefunc::generate_insert_aircraft_metadata_SQL_command()" << endl;

      string SQL_command="insert into aircraft_metadata ";
      SQL_command += "(campaign_ID,mission_ID,frame_ID,epoch_time,frame_prefix,longitude,latitude,altitude,yaw,pitch,roll) ";
      SQL_command += "values( ";
      SQL_command += stringfunc::number_to_string(campaign_ID)+",";
      SQL_command += stringfunc::number_to_string(mission_ID)+",";
      SQL_command += stringfunc::number_to_string(frame_ID)+",";
      SQL_command += stringfunc::number_to_string(epoch_time)+",";
      SQL_command += "'"+frame_prefix+"',";
      SQL_command += stringfunc::number_to_string(longitude)+",";
      SQL_command += stringfunc::number_to_string(latitude)+",";
      SQL_command += stringfunc::number_to_string(altitude)+",";
      SQL_command += stringfunc::number_to_string(yaw)+",";
      SQL_command += stringfunc::number_to_string(pitch)+",";
      SQL_command += stringfunc::number_to_string(roll);
      SQL_command += ");";

//      cout << SQL_command << endl;
      return SQL_command;
   }

// ---------------------------------------------------------------------   
// Method insert_camera_metadata() takes in metadata for a new entry
// within the camera_metadata table of the Tstorm database.  It
// inserts this metadata into *gis_database_ptr.

   bool insert_camera_metadata(
      gis_database* gis_database_ptr,
      int campaign_ID,int mission_ID,int frame_ID,
      double horiz_FOV,double vert_FOV,
      double camera_az,double camera_el,double camera_roll)
   {
//      cout << "inside databasefunc::insert_aircraft_metadata()" << endl;

      string curr_insert_command=
         databasefunc::generate_insert_camera_metadata_SQL_command(
            campaign_ID,mission_ID,frame_ID,
            horiz_FOV,vert_FOV,camera_az,camera_el,camera_roll);
      
      vector<string> insert_commands;
      insert_commands.push_back(curr_insert_command);
      gis_database_ptr->set_SQL_commands(insert_commands);

      return gis_database_ptr->execute_SQL_commands();
   }

// ---------------------------------------------------------------------   
// Method generate_insert_camera_metadata_SQL_command() takes in
// aerial camera metadata associated with a single aircraft spacetime
// point. It generates and returns a string containing a SQL insert
// command needed to populate a row within the aircraft_metadata table
// of the Tstorm postgis database.

   string generate_insert_camera_metadata_SQL_command(
      int campaign_ID,int mission_ID,int frame_ID,
      double horiz_FOV,double vert_FOV,
      double camera_az,double camera_el,double camera_roll)
   {
//   cout << "inside databasefunc::generate_insert_camera_metadata_SQL_command()" << endl;

      string SQL_command="insert into camera_metadata ";
      SQL_command += "(campaign_ID,mission_ID,frame_ID,horiz_fov,vert_fov,camera_azimuth,camera_elevation,camera_roll) ";
      SQL_command += "values( ";
      SQL_command += stringfunc::number_to_string(campaign_ID)+",";
      SQL_command += stringfunc::number_to_string(mission_ID)+",";
      SQL_command += stringfunc::number_to_string(frame_ID)+",";
      SQL_command += stringfunc::number_to_string(horiz_FOV)+",";
      SQL_command += stringfunc::number_to_string(vert_FOV)+",";
      SQL_command += stringfunc::number_to_string(camera_az)+",";
      SQL_command += stringfunc::number_to_string(camera_el)+",";
      SQL_command += stringfunc::number_to_string(camera_roll);
      SQL_command += ");";

//      cout << SQL_command << endl;
      return SQL_command;
   }

// ==========================================================================
// FLIR database retrieval methods
// ==========================================================================

// Method retrieve_campaign_metadata_from_database()

   void retrieve_campaign_metadata_from_database(
      gis_database* gis_database_ptr,int campaign_ID,
      string& campaign_name,int& UTM_zonenumber,bool& northern_hemisphere_flag,
      string& DTED_map_name,double& map_min_lon,double& map_max_lon,
      double& map_min_lat,double& map_max_lat)
   {
//      cout << "inside databasefunc::retrieve_campaign_metadata_from_database()"
//           << endl;
      string curr_select_command = 
         "SELECT campaign_name,utm_zonenumber,northern_hemisphere_flag,";
      curr_select_command += "DTED_map_name,map_min_lon,map_max_lon,";
      curr_select_command += "map_min_lat,map_max_lat from campaigns";
      curr_select_command += 
         " where campaign_ID = "+stringfunc::number_to_string(campaign_ID);
//      cout << "curr_select_cmd = " << curr_select_command << endl;

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      campaign_name=field_array_ptr->get(0,0);
      UTM_zonenumber=stringfunc::string_to_number(
         field_array_ptr->get(0,1));
      northern_hemisphere_flag=static_cast<bool>(
         stringfunc::string_to_number(field_array_ptr->get(0,2)));
      DTED_map_name=field_array_ptr->get(0,3);
      map_min_lon=stringfunc::string_to_number(
         field_array_ptr->get(0,4));
      map_max_lon=stringfunc::string_to_number(
         field_array_ptr->get(0,5));
      map_min_lat=stringfunc::string_to_number(
         field_array_ptr->get(0,6));
      map_max_lat=stringfunc::string_to_number(
         field_array_ptr->get(0,7));
   }

// ---------------------------------------------------------------------   
// Method retrieve_mission_metadata_from_database()

   void retrieve_mission_metadata_from_database(
      gis_database* gis_database_ptr,int campaign_ID,int mission_ID,
      int& flight_number,string& start_date)
   {
      cout << "inside databasefunc::retrieve_mission_metadata_from_database()"
           << endl;
      string curr_select_command = 
         "SELECT flight_number,start_date from missions";
      curr_select_command += " where campaign_ID="
         +stringfunc::number_to_string(campaign_ID)
         +" and mission_ID = "+stringfunc::number_to_string(mission_ID);
//      cout << "curr_select_cmd = " << curr_select_command << endl;

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      flight_number=stringfunc::string_to_number(field_array_ptr->get(0,0));
      start_date=field_array_ptr->get(0,1);

      cout << "flight_number = " << flight_number
           << " start_date = " << start_date << endl;
   }

// ---------------------------------------------------------------------   
// This overloaded version of
// retrieve_mission_metadata_from_database() takes in an epoch_time.
// It returns the campaign and mission IDs corresponding to the
// specified time.

   void retrieve_mission_metadata_from_database(
      gis_database* gis_database_ptr,double epoch_time,
      int& campaign_ID,int& mission_ID)
   {
      cout << "inside databasefunc::retrieve_mission_metadata_from_database()"
           << endl;
      string curr_select_command = 
         "SELECT campaign_id,mission_id from missions where ";
      curr_select_command += stringfunc::number_to_string(epoch_time)
         +" >= epoch_start_time and "+stringfunc::number_to_string(epoch_time)
         +" <= epoch_stop_time";
//      cout << "curr_select_cmd = " << curr_select_command << endl;

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      campaign_ID=stringfunc::string_to_number(field_array_ptr->get(0,0));
      mission_ID=stringfunc::string_to_number(field_array_ptr->get(0,1));
   }

// ---------------------------------------------------------------------   
   bool retrieve_mission_metadata_from_database(
      gis_database* gis_database_ptr,
      double epoch_start_time,double epoch_stop_time,
      int& campaign_ID,int& mission_ID)
   {
      int campaign_start_ID,campaign_stop_ID;
      int mission_start_ID,mission_stop_ID;
      retrieve_mission_metadata_from_database(
         gis_database_ptr,epoch_start_time,campaign_start_ID,mission_start_ID);
      retrieve_mission_metadata_from_database(
         gis_database_ptr,epoch_start_time,campaign_stop_ID,mission_stop_ID);

      bool valid_time_interval_flag=false;
      if ( (campaign_start_ID==campaign_stop_ID) &&
      (mission_start_ID==mission_stop_ID))
      {
         valid_time_interval_flag=true;
         campaign_ID=campaign_start_ID;
         mission_ID=mission_start_ID;
      }
      else
      {
         campaign_ID=mission_ID=-1;
      }
      return valid_time_interval_flag;
   }
   
// ---------------------------------------------------------------------   
// Method retrieve_mission_start_stop_times_from_database() retrieves
// all epoch_times from aircraft_metadata.  It returns the earliest
// and latest of these times within output start_time and stop_time.

   void retrieve_mission_start_stop_times_from_database(
      gis_database* gis_database_ptr,int campaign_ID,int mission_ID,
      double& start_time,double& stop_time)
   {
      string curr_select_command = 
         "SELECT epoch_time from aircraft_metadata ";
      curr_select_command += 
         " where campaign_ID="+stringfunc::number_to_string(campaign_ID);
      curr_select_command += 
         " and mission_ID="+stringfunc::number_to_string(mission_ID);
      curr_select_command += " order by epoch_time";

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      vector<double> epoch_time;
      for (unsigned int i=0; i<field_array_ptr->get_mdim(); i++)
      {
         double curr_epoch_time=stringfunc::string_to_number(
            field_array_ptr->get(i,0));
         epoch_time.push_back(curr_epoch_time);
      }   
      start_time=epoch_time.front();
      stop_time=epoch_time.back();
   }
   
// ---------------------------------------------------------------------   
// Method retrieve_aircraft_metadata_from_database() takes in campaign
// and mission IDs and returns corresponding aircraft metadata.

   void retrieve_aircraft_metadata_from_database(
      gis_database* gis_database_ptr,
      int campaign_ID,int mission_ID,
      vector<int>& frame_ID,vector<double>& epoch_time,
      vector<string>& frame_prefix,
      vector<double>& longitude,vector<double>& latitude,
      vector<double>& altitude,
      vector<double>& roll,vector<double>& pitch,vector<double>& yaw)
   {
      double start_time,stop_time;
      retrieve_mission_start_stop_times_from_database(
         gis_database_ptr,campaign_ID,mission_ID,start_time,stop_time);
      retrieve_aircraft_metadata_from_database(
         gis_database_ptr,campaign_ID,mission_ID,start_time,stop_time,
         frame_ID,epoch_time,frame_prefix,
         longitude,latitude,altitude,roll,pitch,yaw);
   }
   
// ---------------------------------------------------------------------   
// Method retrieve_aircraft_metadata_from_database()

   void retrieve_aircraft_metadata_from_database(
      gis_database* gis_database_ptr,
      int campaign_ID,int mission_ID,double start_time,double stop_time,
      vector<int>& frame_ID,vector<double>& epoch_time,
      vector<string>& frame_prefix,
      vector<double>& longitude,vector<double>& latitude,
      vector<double>& altitude,
      vector<double>& roll,vector<double>& pitch,vector<double>& yaw)
   {
      string curr_select_command = 
         "SELECT frame_id,epoch_time,frame_prefix,";
      curr_select_command += "longitude,latitude,altitude,";
      curr_select_command += "yaw,pitch,roll from aircraft_metadata ";
      curr_select_command += 
         "where epoch_time >= "+stringfunc::number_to_string(start_time);
      curr_select_command += 
         " and epoch_time <= "+stringfunc::number_to_string(stop_time);
      if (campaign_ID >= 0)
      {
         curr_select_command += 
            " and campaign_ID = "+stringfunc::number_to_string(campaign_ID);
      }
      if (mission_ID >= 0)
      {
         curr_select_command += 
            " and mission_ID = "+stringfunc::number_to_string(mission_ID);
      }
      curr_select_command += "order by frame_id";

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      for (unsigned int i=0; i<field_array_ptr->get_mdim(); i++)
      {
         int curr_frame_ID=stringfunc::string_to_number(
            field_array_ptr->get(i,0));
         double curr_epoch_time=stringfunc::string_to_number(
            field_array_ptr->get(i,1));
         string curr_frame_prefix=field_array_ptr->get(i,2);   
         double curr_longitude=stringfunc::string_to_number(
            field_array_ptr->get(i,3));
         double curr_latitude=stringfunc::string_to_number(
            field_array_ptr->get(i,4));
         double curr_altitude=stringfunc::string_to_number(
            field_array_ptr->get(i,5));
         double curr_yaw=stringfunc::string_to_number(
            field_array_ptr->get(i,6));
         double curr_pitch=stringfunc::string_to_number(
            field_array_ptr->get(i,7));
         double curr_roll=stringfunc::string_to_number(
            field_array_ptr->get(i,8));

         frame_ID.push_back(curr_frame_ID);
         epoch_time.push_back(curr_epoch_time);
         frame_prefix.push_back(curr_frame_prefix);
         longitude.push_back(curr_longitude);
         latitude.push_back(curr_latitude);
         altitude.push_back(curr_altitude);
         yaw.push_back(curr_yaw);
         pitch.push_back(curr_pitch);
         roll.push_back(curr_roll);
      } // loop over index i
   }

// ---------------------------------------------------------------------   
// Method retrieve_aircraft_metadata_from_database()

   void retrieve_aircraft_metadata_from_database(
      gis_database* gis_database_ptr,int campaign_ID,int mission_ID,
      double start_time,double stop_time,
      vector<double>& epoch_time,vector<string>& frame_prefix)
   {
      cout << "inside databasefunc::retrieve_aircraft_metadata_from_database()"
           << endl;
      
      string curr_select_command = 
         "SELECT frame_id,epoch_time,frame_prefix from aircraft_metadata ";
      curr_select_command += 
         "where epoch_time >= "+stringfunc::number_to_string(start_time);
      curr_select_command += 
         " and epoch_time <= "+stringfunc::number_to_string(stop_time);
      if (campaign_ID >= 0)
      {
         curr_select_command += 
            " and campaign_ID = "+stringfunc::number_to_string(campaign_ID);
      }
      if (mission_ID >= 0)
      {
         curr_select_command += 
            " and mission_ID = "+stringfunc::number_to_string(mission_ID);
      }
      curr_select_command += "order by frame_id";

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      for (unsigned int i=0; i<field_array_ptr->get_mdim(); i++)
      {
         double curr_epoch_time=stringfunc::string_to_number(
            field_array_ptr->get(i,1));
         string curr_frame_prefix=field_array_ptr->get(i,2);   

         epoch_time.push_back(curr_epoch_time);
         frame_prefix.push_back(curr_frame_prefix);

//         cout << "i = " << i
//              << " time = " << epoch_time.back()
//              << " frame = " << frame_prefix.back() << endl;
      } // loop over index i
   }

// ---------------------------------------------------------------------   
// Method retrieve_extremal_frame_IDs_from_database()

   void retrieve_extremal_frame_IDs_from_database(
      gis_database* gis_database_ptr,int campaign_ID,int mission_ID,
      double start_time,double stop_time,
      int& first_frame_ID,int& last_frame_ID)
   {
//      cout << "inside databasefunc::retrieve_extremal_frame_IDs_from_database()"
//           << endl;
      
      string curr_select_command = 
         "SELECT frame_id from aircraft_metadata ";
      curr_select_command += 
         "where epoch_time >= "+stringfunc::number_to_string(start_time);
      curr_select_command += 
         " and epoch_time <= "+stringfunc::number_to_string(stop_time);
      if (campaign_ID >= 0)
      {
         curr_select_command += 
            " and campaign_ID = "+stringfunc::number_to_string(campaign_ID);
      }
      if (mission_ID >= 0)
      {
         curr_select_command += 
            " and mission_ID = "+stringfunc::number_to_string(mission_ID);
      }
      curr_select_command += "order by frame_id";

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      vector<int> frame_ID;
      for (unsigned int i=0; i<field_array_ptr->get_mdim(); i++)
      {
         int curr_frame_ID=stringfunc::string_to_number(
            field_array_ptr->get(i,0));
         frame_ID.push_back(curr_frame_ID);
//         cout << "i = " << i
//              << " frame_ID = " << frame_ID.back() << endl;
      } // loop over index i

      first_frame_ID=frame_ID.front();
      last_frame_ID=frame_ID.back();
   }

// ---------------------------------------------------------------------   
// Method retrieve_camera_metadata_from_database()

   void retrieve_camera_metadata_from_database(
      gis_database* gis_database_ptr,int campaign_ID,int mission_ID,
      vector<double>& horiz_FOV,vector<double>& vert_FOV,
      vector<double>& camera_az,vector<double>& camera_el,
      vector<double>& camera_roll)
   {
      double start_time,stop_time;
      retrieve_mission_start_stop_times_from_database(
         gis_database_ptr,campaign_ID,mission_ID,start_time,stop_time);

      retrieve_camera_metadata_from_database(
         gis_database_ptr,campaign_ID,mission_ID,start_time,stop_time,
         horiz_FOV,vert_FOV,camera_az,camera_el,camera_roll);
   }

// ---------------------------------------------------------------------   
// Method retrieve_camera_metadata_from_database()

   void retrieve_camera_metadata_from_database(
      gis_database* gis_database_ptr,
      int campaign_ID,int mission_ID,double start_time,double stop_time,
      vector<double>& horiz_FOV,vector<double>& vert_FOV,
      vector<double>& camera_az,vector<double>& camera_el,
      vector<double>& camera_roll)
   {
      int first_frame_ID,last_frame_ID;
      retrieve_extremal_frame_IDs_from_database(
         gis_database_ptr,campaign_ID,mission_ID,
         start_time,stop_time,first_frame_ID,last_frame_ID);

      string curr_select_command = 
         "SELECT frame_ID,horiz_FOV,vert_FOV,camera_azimuth,camera_elevation,camera_roll";
      curr_select_command += " from camera_metadata ";
      curr_select_command += 
         " where frame_ID >= "+stringfunc::number_to_string(first_frame_ID);
      curr_select_command += 
         " and frame_ID <= "+stringfunc::number_to_string(last_frame_ID);
      curr_select_command += " order by frame_id";

      Genarray<string>* field_array_ptr=gis_database_ptr->
         select_data(curr_select_command);

      for (unsigned int i=0; i<field_array_ptr->get_mdim(); i++)
      {
//         int curr_frame_ID=stringfunc::string_to_number(
//            field_array_ptr->get(i,0));
         double curr_horiz_FOV=stringfunc::string_to_number(
            field_array_ptr->get(i,1));
         double curr_vert_FOV=stringfunc::string_to_number(
            field_array_ptr->get(i,2));
         double curr_camera_az=stringfunc::string_to_number(
            field_array_ptr->get(i,3));
         double curr_camera_el=stringfunc::string_to_number(
            field_array_ptr->get(i,4));
         double curr_camera_roll=stringfunc::string_to_number(
            field_array_ptr->get(i,5));

         horiz_FOV.push_back(curr_horiz_FOV);
         vert_FOV.push_back(curr_vert_FOV);
         camera_az.push_back(curr_camera_az);
         camera_el.push_back(curr_camera_el);
         camera_roll.push_back(curr_camera_roll);
      } // loop over index i
   }

   

} // databasefunc namespace

