// =========================================================================
// Vptree class member function definitions
// =========================================================================
// Last modified on 3/20/12; 4/29/13; 5/31/13; 4/5/14
// =========================================================================

#include <iostream>
#include <map>
#include <string>
#include <vector>
#include "math/binaryfuncs.h"
#include "numrec/nrfuncs.h"
#include "general/stringfuncs.h"
#include "graphs/vptree.h"

using std::cout;
using std::endl;
using std::flush;
using std::map;
using std::ostream;
using std::priority_queue;
using std::string;
using std::vector;

// ---------------------------------------------------------------------
// Initialization, constructor and destructor methods:

void vptree::allocate_member_objects()
{
   BinaryTree_ptr=new BTree();
}

void vptree::initialize_member_objects()
{
   hamming_distance_flag=KL_distance_flag=sqrd_Euclidean_distance_flag=false;
   search_queue_ptr=NULL;
   store_logarithm_values();
}		 

// --------------------------------------------------------------------------
// In order to minimize KL divergence computation time, we precompute
// and store log(x) for 0 < x <= 1.

void vptree::store_logarithm_values()
{
//    cout << "inside vptree::store_logarithm_values()" << endl;

   unsigned int istart=0;
   unsigned int istop=10000;
   double denom=istop-istart;
   double logx;
   log_values.reserve(istop);
   for (unsigned int i=istart; i<=istop; i++)
   {
      double x=double(i)/denom;
      if (nearly_equal(x,0))
      {
         logx=NEGATIVEINFINITY;
      }
      else
      {
         logx=log(x);
      }
      log_values.push_back(logx);
   } // loop over index i
   log_values.push_back(0);
//    cout << "log_values.size() = " << log_values.size() << endl;
}

// ---------------------------------------------------------------------
vptree::vptree()
{
   allocate_member_objects();
   initialize_member_objects();
}

// ---------------------------------------------------------------------
// Copy constructor:

vptree::vptree(const vptree& v)
{
   docopy(v);
}

vptree::~vptree()
{
   delete BinaryTree_ptr;
}

// ---------------------------------------------------------------------
void vptree::docopy(const vptree& v)
{
}

// Overload = operator:

vptree& vptree::operator= (const vptree& v)
{
   if (this==&v) return *this;
   docopy(v);
   return *this;
}

// ---------------------------------------------------------------------
// Overload << operator:

ostream& operator<< (ostream& outstream,const vptree& v)
{
   outstream << endl;
   return outstream;
}

// ==========================================================================
// Vantage point tree construction methods
// ==========================================================================

// Member function construct_tree() is a high-level, user-friendly
// method which generates a vantage point tree from an input set of
// metric space elements.

void vptree::construct_tree(const vector<descriptor*>& metric_space_elements)
{
   int prev_used_ID=-1;
   build_vp_tree(0,metric_space_elements,prev_used_ID);
   compute_all_extremal_subspace_distances();
   BinaryTree_ptr->compute_all_gxgy_coords();
}

// --------------------------------------------------------------------------
// This overloaded version of construct_tree() takes in an STL vector
// containing pairs of descriptor pointers.  It forms a VP tree from
// the 2nd members of the input pairs.  We wrote this specialized
// method for use with Compressed HOG feature vectors generated by
// sift_detector::extract_CHOG_features().

void vptree::construct_tree(const vector<descriptor_pair>& feature_pairs)
{
   vector<descriptor*> metric_space_elements;
   for (unsigned int f=0; f<feature_pairs.size(); f++)
   {
      metric_space_elements.push_back(feature_pairs[f].second);
   }
   construct_tree(metric_space_elements);
}

// --------------------------------------------------------------------------
vptree::BTreeNode* vptree::build_vp_tree(
   int curr_level,const vector<descriptor*>& metric_space_elements,
   int& prev_used_ID)
{
//      cout << "-------------------------------------------------" << endl;
//      cout << "inside vptree::build_vp_tree()" << endl;
//      cout << "level = " << curr_level << endl;
//      cout << "# metric elements = " << metric_space_elements.size() << endl;
//      cout << "prev_used_ID = " << prev_used_ID << endl;

   if (metric_space_elements.size()==0) return NULL;

   BTreeNode* BinaryTreeNode_ptr;
   if (BinaryTree_ptr->size()==0)
   {
      BinaryTreeNode_ptr=BinaryTree_ptr->generate_root_node();
      prev_used_ID=BinaryTreeNode_ptr->get_ID();
   }
   else
   {
      BinaryTreeNode_ptr=new BTreeNode;
      BinaryTreeNode_ptr->set_ID(prev_used_ID+1);
      BinaryTreeNode_ptr->set_level(curr_level);

      prev_used_ID++;
//         cout << "New BinaryTreeNode_ptr->get_ID() = "
//              << BinaryTreeNode_ptr->get_ID() << endl;
   }

//   descriptor* vp_ptr=select_vp(metric_space_elements);
   descriptor* vp_ptr=select_random_vp(metric_space_elements);
      
   double mu=median_separation_distance(vp_ptr,metric_space_elements);

   node_payload* node_payload_ptr=new node_payload;
   node_payload_ptr->metric_space_element_ptr=vp_ptr;
   node_payload_ptr->mu=mu;
   BinaryTreeNode_ptr->set_data(*node_payload_ptr);

   vector<descriptor*> left_metric_space_elements;
   vector<descriptor*> right_metric_space_elements;
   for (unsigned int i=0; i<metric_space_elements.size(); i++)
   {
      descriptor* curr_element_ptr=metric_space_elements[i];
      if (curr_element_ptr==vp_ptr) continue;
         
      double curr_distance=distance_between_elements(
         curr_element_ptr,vp_ptr);
      if (curr_distance < mu)
      {
         left_metric_space_elements.push_back(curr_element_ptr);
//            cout << "i = " << i << " left_element = "
//                 << *curr_element_ptr << endl;
      }
      else
      {
         right_metric_space_elements.push_back(curr_element_ptr);
//            cout << "i = " << i << " right_element = "
//                 << *curr_element_ptr << endl;
      }
   } // loop over index i labeling metric space elements
//   outputfunc::enter_continue_char();

   if (left_metric_space_elements.size() > 0)
   {
      BTreeNode* left_child_node_ptr=build_vp_tree(
         curr_level+1,left_metric_space_elements,prev_used_ID);
      if (left_child_node_ptr != NULL)
      {
//            double parent_x=BinaryTreeNode_ptr->get_data().
//               metric_space_element_ptr->get(0);
//            double parent_y=BinaryTreeNode_ptr->get_data().
//               metric_space_element_ptr->get(1);
//            cout << "Before adding left child, parent ID = "
//                 << BinaryTreeNode_ptr->get_ID() << endl;
//            cout << " parent x = " << parent_x
//                 << " parent y = " << parent_y
//                 << endl;
//            BinaryTree_ptr->addLeftChild(
//               BinaryTreeNode_ptr,left_child_node_ptr->get_ID(),
//               left_child_node_ptr->get_data());

         BinaryTreeNode_ptr->set_LeftChild_ptr(
            left_child_node_ptr);
         BinaryTree_ptr->addExistingNodeToTree(
            BinaryTreeNode_ptr,left_child_node_ptr);
      }
   }
      
   if (right_metric_space_elements.size() > 0)
   {
      BTreeNode* right_child_node_ptr=build_vp_tree(
         curr_level+1,right_metric_space_elements,prev_used_ID);
      if (right_child_node_ptr != NULL)
      {
//            double parent_x=BinaryTreeNode_ptr->get_data().
//               metric_space_element_ptr->get(0);
//            double parent_y=BinaryTreeNode_ptr->get_data().
//               metric_space_element_ptr->get(1);
//            cout << "Before adding right child, parent ID = "
//                 << BinaryTreeNode_ptr->get_ID() << endl;
//            cout << " parent x = " << parent_x
//                 << " parent y = " << parent_y
//                 << endl;

//            BinaryTree_ptr->addRightChild(
//               BinaryTreeNode_ptr,right_child_node_ptr->get_ID(),
//               right_child_node_ptr->get_data());

         BinaryTreeNode_ptr->set_RightChild_ptr(
            right_child_node_ptr);
         BinaryTree_ptr->addExistingNodeToTree(
            BinaryTreeNode_ptr,right_child_node_ptr);
      }
   }

//      cout << "At end of vptree::build_vp_tree(), BinaryTreeNode_ptr = "
//           << BinaryTreeNode_ptr << endl;
//      outputfunc::enter_continue_char();
   return BinaryTreeNode_ptr;
}
   
// --------------------------------------------------------------------------
// Method select_vp() 

descriptor* vptree::select_vp(const vector<descriptor*>& metric_space_elements)
{
//      cout << "inside vptree::select_vp()" << endl;
      
   int random_index=metric_space_elements.size()*nrfunc::ran1();
   descriptor* best_element_ptr=metric_space_elements[random_index];

   vector<descriptor*> random_element_ptrs=
      randomly_select_metric_space_elements(metric_space_elements);
//      cout << "random_element_ptrs.size() = "
//           << random_element_ptrs.size() << endl;

   double best_spread=0;
   for (unsigned int i=0; i<random_element_ptrs.size(); i++)
   {
      vector<descriptor*> more_random_element_ptrs=
         randomly_select_metric_space_elements(metric_space_elements);

      vector<double> distances;
      double mu=median_separation_distance(
         random_element_ptrs[i],more_random_element_ptrs,distances);
      if (nearly_equal(mu,0)) continue;

      for (unsigned int j=0; j<distances.size(); j++)
      {
         distances[j]=distances[j]-mu;
      }
      double spread=mathfunc::std_dev(distances);
      if (spread > best_spread)
      {
         best_spread=spread;
         best_element_ptr=random_element_ptrs[i];
      }
   } // loop over index i labeling randomly selected elements
   return best_element_ptr;
}
   
/*
// --------------------------------------------------------------------------
// Method select_random_vp() 

descriptor* vptree::select_random_vp(
   const vector<descriptor*>& metric_space_elements)
{
//      cout << "inside vptree::select_random_vp()" << endl;
      
   int random_index=metric_space_elements.size()*nrfunc::ran1();
   descriptor* best_element_ptr=metric_space_elements[random_index];
   return best_element_ptr;
}
*/
 
// --------------------------------------------------------------------------
// Method select_centroid_vp() 

descriptor* vptree::select_centroid_vp(
   const vector<descriptor*>& metric_space_elements)
{
//   cout << "inside vptree::select_centroid_vp()" << endl;
   descriptor* centroid_ptr=new descriptor(metric_space_elements[0]->get_mdim());
   centroid_ptr->clear_values();
   
   for (unsigned int i=0; i<metric_space_elements.size(); i++)
   {
//      cout << "i = " << i << " metric space element = "
//           << *(metric_space_elements[i]) << endl;
      *centroid_ptr += *(metric_space_elements[i]);
   }
   *centroid_ptr /= metric_space_elements.size();

   cout << "centroid = " << *centroid_ptr << endl;
   return centroid_ptr;
}
   
// --------------------------------------------------------------------------
// Method randomly_select_metric_space_elements()

vector<descriptor*> vptree::randomly_select_metric_space_elements(
   const vector<descriptor*>& metric_space_elements)
{
//      cout << "inside vptree::randomly_select_metric_space_elements()" 
//           << endl;
      
   int n_elements=metric_space_elements.size();
   int n_random_elements=0.1*n_elements;
   n_random_elements=basic_math::max(5,n_random_elements);
   n_random_elements=basic_math::min(n_random_elements,n_elements);

   vector<int> element_IDs=mathfunc::random_sequence(
      n_elements,n_random_elements);

   vector<descriptor*> random_element_ptrs;
   for (unsigned int i=0; i<element_IDs.size(); i++)
   {
//         cout << "i = " << i 
//              << " n_elements = " << n_elements
//              << " element_ID = " << element_IDs[i]
//              << endl;
      random_element_ptrs.push_back(
         metric_space_elements[element_IDs[i]]);
   } // loop over index i labeling randomly selected elements

   return random_element_ptrs;
}

// ==========================================================================
// Vantage point tree distance methods
// ==========================================================================

// Method distance_between_elements()

double vptree::distance_between_elements(
   descriptor* element1_ptr,descriptor* element2_ptr)
{
   if (hamming_distance_flag)
   {
      return hamming_distance_between_elements(element1_ptr,element2_ptr);
   }
   if (KL_distance_flag)
   {
      return KL_distance_between_elements(element1_ptr,element2_ptr);
   }
   else if (sqrd_Euclidean_distance_flag)
   {
      return sqrd_Euclidean_distance_between_elements(
         element1_ptr,element2_ptr);
   }
   else
   {
      return Euclidean_distance_between_elements(element1_ptr,element2_ptr);
   }
}

// --------------------------------------------------------------------------
double vptree::Euclidean_distance_between_elements(
   descriptor* element1_ptr,descriptor* element2_ptr)
{
   if (element1_ptr==NULL || element2_ptr==NULL)
   {
      cout << "inside vptree::distance_between_elements()" << endl;
      cout << "element1_ptr = " << element1_ptr << endl;
      cout << "element2_ptr = " << element2_ptr << endl;
   }

//      cout << "element1 = " << *element1_ptr << endl;
//      cout << "element2 = " << *element2_ptr << endl;

   return sqrt(element1_ptr->
   sqrd_distance_to_another_descriptor(element2_ptr));
}

// --------------------------------------------------------------------------
// Method hamming_distance_between_elements() returns the hamming distance
// between two input descriptors which are assumed to contain only 0 or
// 1 entries.

double vptree::hamming_distance_between_elements(
   descriptor* element1_ptr,descriptor* element2_ptr)
{
   return binaryfunc::hamming_distance(element1_ptr,element2_ptr);
//   double hamming_dist=binaryfunc::hamming_distance(element1_ptr,element2_ptr);
//   cout << "hamming_dist = " << hamming_dist << endl;
}

// --------------------------------------------------------------------------
// Method KL_distance_between_elements() returns the symmetrized
// Kullback-Leibler divergence between two input descriptors.  The
// descriptors' elements must be non-negative, and the sum of their
// components must equal unity.

double vptree::KL_distance_between_elements(
   descriptor* element1_ptr,descriptor* element2_ptr)
{
//      cout << "element1 = " << *element1_ptr << endl;
//      cout << "element2 = " << *element2_ptr << endl;

   double sum=0;
   unsigned int mdim=element1_ptr->get_mdim();
   for (unsigned int m=0; m<mdim; m++)
   {
      double curr_p=element1_ptr->get(m);
      double curr_q=element2_ptr->get(m);
//      cout << "curr_p = " << curr_p << " curr_q = " << curr_q << endl;
      
      int p_index=10000*curr_p;
      int q_index=10000*curr_q;
      double log_p=log_values[p_index];
      double log_q=log_values[q_index];
      sum += (curr_p-curr_q)*(log_p-log_q);
//      cout << "m = " << m << " sum = " << sum << endl;
   }

   return sum;
}

// --------------------------------------------------------------------------
// Method compute_extremal_left_subspace_distances()

void vptree::compute_extremal_left_subspace_distances(
   BTreeNode* BinaryTreeNode_ptr,double& min_dist,double& max_dist)
{
//      cout << "inside vptree::compute_extremal_left_subspace_distances()"
//           << endl;

   min_dist=max_dist=0;
   BTreeNode* LeftChild_ptr=BinaryTreeNode_ptr->get_LeftChild_ptr();
   if (LeftChild_ptr != NULL)
   {
      min_dist=POSITIVEINFINITY;
      std::vector<BTreeNode*> DescendantNode_ptrs;
      LeftChild_ptr->GetDescendantsAndSelf(DescendantNode_ptrs);

      descriptor* element_ptr=BinaryTreeNode_ptr->get_data().
         metric_space_element_ptr;
      for (unsigned int d=0; d<DescendantNode_ptrs.size(); d++)
      {
         double curr_dist=distance_between_elements(
            element_ptr,DescendantNode_ptrs[d]->get_data().
            metric_space_element_ptr);
         min_dist=basic_math::min(min_dist,curr_dist);
         max_dist=basic_math::max(max_dist,curr_dist);
      } // loop over index d labeling descendant nodes
   }
}

// --------------------------------------------------------------------------
// Method compute_extremal_right_subspace_distances()

void vptree::compute_extremal_right_subspace_distances(
   BTreeNode* BinaryTreeNode_ptr,double& min_dist,double& max_dist)
{
//      cout << "inside vptree::compute_extremal_right_subspace_distances()"
//           << endl;
      
   min_dist=max_dist=0;
   BTreeNode* RightChild_ptr=BinaryTreeNode_ptr->get_RightChild_ptr();
   if (RightChild_ptr != NULL)
   {
      min_dist=POSITIVEINFINITY;
      std::vector<BTreeNode*> DescendantNode_ptrs;
      RightChild_ptr->GetDescendantsAndSelf(DescendantNode_ptrs);

      descriptor* element_ptr=BinaryTreeNode_ptr->get_data().
         metric_space_element_ptr;
      for (unsigned int d=0; d<DescendantNode_ptrs.size(); d++)
      {
         double curr_dist=distance_between_elements(
            element_ptr,DescendantNode_ptrs[d]->get_data().
            metric_space_element_ptr);
         min_dist=basic_math::min(min_dist,curr_dist);
         max_dist=basic_math::max(max_dist,curr_dist);
      } // loop over index d labeling descendant nodes
   }
}

// --------------------------------------------------------------------------
// Method compute_all_extremal_subspace_distances()

void vptree::compute_all_extremal_subspace_distances()
{
   map<int,BTreeNode* >::iterator iter;
   for (iter=BinaryTree_ptr->get_BinaryTreeNodes_map_ptr()->begin(); 
        iter != BinaryTree_ptr->get_BinaryTreeNodes_map_ptr()->end(); 
        iter++)
   {
      BTreeNode* node_ptr=iter->second;
      double min_dist,max_dist;
      compute_extremal_left_subspace_distances(node_ptr,min_dist,max_dist);
      node_ptr->get_data().left_min_dist=min_dist;
      node_ptr->get_data().left_max_dist=max_dist;

      compute_extremal_right_subspace_distances(node_ptr,min_dist,max_dist);
      node_ptr->get_data().right_min_dist=min_dist;
      node_ptr->get_data().right_max_dist=max_dist;
   } // loop over all BTree nodes
}
   
// --------------------------------------------------------------------------
// Member function median_separation_distance() takes in descriptor
// *p_ptr along with a set of metric space elements.  It computes the
// distances between each of the latter and the former.  If *p_ptr is
// included within any of the metric space elements, its zero distance
// to itself is ignored.  This method returns the median value of the
// separation distances.

double vptree::median_separation_distance(
   descriptor* p_ptr,const vector<descriptor*>& metric_space_elements)
{
   vector<double> distances;
   return median_separation_distance(p_ptr,metric_space_elements,distances);
}

double vptree::median_separation_distance(
   descriptor* p_ptr,const vector<descriptor*>& metric_space_elements,
   vector<double>& distances)
{
   const double TINY=1E-6;
   for (unsigned int i=0; i<metric_space_elements.size(); i++)
   {
      double separation_distance=distance_between_elements(
         p_ptr,metric_space_elements[i]);
      if (separation_distance > TINY)
      {
         distances.push_back(separation_distance);
      }
//      cout << "i = " << i << " distance = " << distances.back() << endl;
   } // loop over index i labeling metric space elements
   double mu=0;
   if (distances.size() > 0) mu=mathfunc::median_value(distances);
//   cout << "mu = " << mu << endl;
   return mu;
}

// --------------------------------------------------------------------------
// Member function compute_distances_to_nodes() takes in a metric
// space query element along with a set of VPtree node IDs.  It
// computes the distances between the query element and each of the
// nodes and returns the results within output STL vector
// query_to_neighbor_distances.

void vptree::compute_distances_to_nodes(
   descriptor* query_element_ptr,
   const vector<int>& nearest_neighbor_node_IDs,
   vector<double>& query_to_neighbor_distances,
   vector<descriptor*>& metric_space_element_ptrs)
{
//   cout << "inside vptree::compute_query_distance_to_nodes()" << endl;


   for (unsigned int n=0; n<nearest_neighbor_node_IDs.size(); n++)
   {
      int node_ID=nearest_neighbor_node_IDs[n];
      BTreeNode* BTreeNode_ptr=BinaryTree_ptr->get_node_ptr(node_ID);
      descriptor* element_ptr=
         BTreeNode_ptr->get_data().metric_space_element_ptr;
      query_to_neighbor_distances.push_back(distance_between_elements(
         query_element_ptr,element_ptr));
      metric_space_element_ptrs.push_back(element_ptr);
   }
}

// ==========================================================================
// Vantage point tree display methods
// ==========================================================================

// Method print_vp_tree()

void vptree::print_vp_tree()
{
   cout << endl;
   cout << "n_nodes = " << BinaryTree_ptr->size() << endl;
   cout << "n_levels = " << BinaryTree_ptr->get_n_levels() << endl;
   cout << endl;

   vector<int> node_IDs;
   vector<BTreeNode*> node_ptrs;

   map<int,BTreeNode* >::iterator iter;
   for (iter=BinaryTree_ptr->get_BinaryTreeNodes_map_ptr()->begin(); 
        iter != BinaryTree_ptr->get_BinaryTreeNodes_map_ptr()->end(); 
        iter++)
   {
      node_IDs.push_back(iter->first);
      node_ptrs.push_back(iter->second);
   }
   templatefunc::Quicksort(node_IDs,node_ptrs);
   
   for (unsigned int i=0; i<node_IDs.size(); i++)
   {
      BTreeNode* node_ptr=node_ptrs[i];
      cout << "node: ID = " << node_ptr->get_ID()
           << " level = " << node_ptr->get_level()
           << " parentID = " << node_ptr->get_parent_ID()
//              << " n_descendants = " << node_ptr->get_n_descendants()
           << " gx = " << node_ptr->get_gx()
           << " gy = " << node_ptr->get_gy() 
           << endl;
      node_payload curr_node_data=node_ptr->get_data();
//         cout << "metric element = " 
//              << *(curr_node_data.metric_space_element_ptr) << endl;
      BTreeNode* LeftChild_ptr=node_ptr->get_LeftChild_ptr();
      BTreeNode* RightChild_ptr=node_ptr->get_RightChild_ptr();
         
      if (LeftChild_ptr != NULL)
      {
         cout << "Left Child ID = " << LeftChild_ptr->get_ID() << endl;
      }
      if (RightChild_ptr != NULL)
      {
         cout << "Right Child ID = " << RightChild_ptr->get_ID() << endl;
      }

      cout << "X= " 
           << curr_node_data.metric_space_element_ptr->get(0) 
           << " , Y = " 
           << curr_node_data.metric_space_element_ptr->get(1)
           << endl;
      cout << "mu = " << curr_node_data.mu << endl;
      cout << "left_min_dist = " << curr_node_data.left_min_dist
           << " left_max_dist = " << curr_node_data.left_max_dist
           << endl;
      cout << "right_min_dist = " << curr_node_data.right_min_dist
           << " right_max_dist = " << curr_node_data.right_max_dist
           << endl;
      cout << endl;
   } // loop over index i labeling nodes
}

// --------------------------------------------------------------------------
// Method extract_vp_node_info()

vector<string> vptree::extract_vp_node_info(BTreeNode* node_ptr)
{
   vector<string> text_lines;

   string curr_line="Node ID = "+stringfunc::number_to_string(
      node_ptr->get_ID());
   text_lines.push_back(curr_line);

   node_payload curr_node_data=node_ptr->get_data();
   BTreeNode* LeftChild_ptr=node_ptr->get_LeftChild_ptr();
   BTreeNode* RightChild_ptr=node_ptr->get_RightChild_ptr();

   if (LeftChild_ptr != NULL)
   {
      cout << "Left Child ID = " << LeftChild_ptr->get_ID() << endl;
   }
   if (RightChild_ptr != NULL)
   {
      cout << "Right Child ID = " << RightChild_ptr->get_ID() << endl;
   }

   curr_line="X= "+stringfunc::number_to_string(
      curr_node_data.metric_space_element_ptr->get(0) )+
      " , Y = "+stringfunc::number_to_string(
         curr_node_data.metric_space_element_ptr->get(1));
   text_lines.push_back(curr_line);
         
   curr_line="mu = "+stringfunc::number_to_string(curr_node_data.mu);
   text_lines.push_back(curr_line);
   return text_lines;
} 

// ==========================================================================
// Vantage point tree search methods
// ==========================================================================

// Member function find_closest_node() takes in a query descriptor.  It
// searches the Vantage Point tree for the node whose descriptor lies
// closest to the input descriptor.  The closest node's descriptor is
// returned by this method.

descriptor* vptree::find_closest_node(descriptor* query_element_ptr)
{
//   cout << "inside vptree::find_closest_node()" << endl;
   tau=POSITIVEINFINITY;
   best_node_ID=-1;
   search_vp_tree(
      BinaryTree_ptr->get_root_ptr(),query_element_ptr);
   BTreeNode* BTreeNode_ptr=BinaryTree_ptr->get_node_ptr(best_node_ID);

//   cout << "best_node_ID = " << best_node_ID << endl;
//   cout << "tau = " << tau << endl;
   
   return BTreeNode_ptr->get_data().metric_space_element_ptr;
}

// --------------------------------------------------------------------------
// Member function search_vp_tree() should initially be called with
// query descriptor *query_element_ptr and the root node of the vantage
// point tree.  Member variable tau should also be set to the desired
// search radius. Setting tau to POSITIVEINFINITY implies search
// without constraint. Upon completion, this method returns the ID of
// the nearest neighboring node within the VP tree to the query
// element within best_node_ID.  And on return, tau equals the
// distance between the query element and the best node.

void vptree::search_vp_tree( 
   BTreeNode* BinaryTreeNode_ptr,descriptor* query_element_ptr)
{
   if (BinaryTreeNode_ptr==NULL) return;

   double x=distance_between_elements(
      query_element_ptr,BinaryTreeNode_ptr->get_data().
      metric_space_element_ptr);
   if (x < tau)
   {
      tau=x;
      best_node_ID=BinaryTreeNode_ptr->get_ID();
//      cout << "best_node_ID = " << best_node_ID 
//           << " tau = " << tau << endl;
   }
   double middle=0.5*(
      BinaryTreeNode_ptr->get_data().left_max_dist+
      BinaryTreeNode_ptr->get_data().right_min_dist);
   if (x < middle)
   {
      if (x > BinaryTreeNode_ptr->get_data().left_min_dist-tau &&
      x < BinaryTreeNode_ptr->get_data().left_max_dist+tau)
      {
         search_vp_tree(
            BinaryTreeNode_ptr->get_LeftChild_ptr(),query_element_ptr);
      }
      if (x > BinaryTreeNode_ptr->get_data().right_min_dist-tau &&
      x < BinaryTreeNode_ptr->get_data().right_max_dist+tau)
      {
         search_vp_tree(
            BinaryTreeNode_ptr->get_RightChild_ptr(),query_element_ptr);
      }
   }
   else
   {
      if (x > BinaryTreeNode_ptr->get_data().right_min_dist-tau &&
      x < BinaryTreeNode_ptr->get_data().right_max_dist+tau)
      {
         search_vp_tree(
            BinaryTreeNode_ptr->get_RightChild_ptr(),query_element_ptr);
      }
      if (x > BinaryTreeNode_ptr->get_data().left_min_dist-tau &&
      x < BinaryTreeNode_ptr->get_data().left_max_dist+tau)
      {
         search_vp_tree(
            BinaryTreeNode_ptr->get_LeftChild_ptr(),query_element_ptr);
      }
         
   } // x < middle conditional
}
   
// --------------------------------------------------------------------------
// Member function incrementally_find_nearest_nodes() implements
// Hanan Samet's Incremental Nearest Neighbor algorithm for VPtrees.
// We closely follow the discussion presented in sections 4.1 and 4.5
// of "Foundations of Multidimensional and Metric Data Structures" by
// Samet (2006).  If input parameter k < 0, all nodes within the
// existing VP-tree are ranked according to their proximity to the
// input query element.  A listing of all nodes' IDs ordered by
// distance to the query element is returned within an STL vector.  If
// k > 0, only the closest k neighbor node IDs are returned.

void vptree::incrementally_find_nearest_nodes(
   int k,descriptor* query_element_ptr,
   vector<int>& nearest_neighbor_node_IDs,
   vector<double>& query_to_neighbor_distances,
   vector<descriptor*>& metric_space_element_ptrs)
{
//   cout << "inside vptree::incrementally_find_nearest_nodes()" << endl;

// First clear all output STL vectors:

   nearest_neighbor_node_IDs.clear();
   query_to_neighbor_distances.clear();
   metric_space_element_ptrs.clear();

   delete search_queue_ptr;
   search_queue_ptr=
      new priority_queue<threevector,vector<threevector>,samet_comparison>;

// Let q represent some threevector element within the priority queue.

// First coordinate of q corresponds to distance
// Second coordinate of q represents node type

// 	node type==0 --> descriptor metric space element
// 	node type==1 --> Metric subspace

// Third coordinate of q holds VP-tree node ID 

// First add entire metric space to priority queue:

   double curr_distance=0;
   int curr_node_type=1;
   int curr_node_ID=BinaryTree_ptr->get_root_ptr()->get_ID();
   threevector curr_e(curr_distance,curr_node_type,curr_node_ID);
   search_queue_ptr->push(curr_e);   

   while (search_queue_ptr->size() > 0)
   {

/*
// ---------------------------------------------------------------------
// At start of while loop, make copy of priority queue.  Then print
// out copy queue's contents for debugging purposes only...

      priority_queue<threevector,vector<threevector>,samet_comparison>* 
         copy_queue_ptr=
         new priority_queue<threevector,vector<threevector>,samet_comparison>;
      *copy_queue_ptr=*search_queue_ptr;

      int copy_queue_size=copy_queue_ptr->size();
      for (unsigned int n=0; n<copy_queue_size; n++)
      {
         threevector copy_e=copy_queue_ptr->top();

         int node_type=copy_e.get(1);
         int node_ID=copy_e.get(2);
         BTreeNode* BTreeNode_ptr=BinaryTree_ptr->get_node_ptr(node_ID);
         descriptor* element_ptr=
            BTreeNode_ptr->get_data().metric_space_element_ptr;
         double X=element_ptr->get(0);
      
         cout << "n = " << n
              << " dist = " << copy_e.get(0)
              << " node type = " << node_type
              << " node ID = " << node_ID 
              << " X = " << X 
              << endl;

         copy_queue_ptr->pop();
      }
      delete copy_queue_ptr;
      outputfunc::enter_continue_char();
// ---------------------------------------------------------------------
*/

      threevector curr_e(search_queue_ptr->top());
      search_queue_ptr->pop();

      curr_node_ID=curr_e.get(2);
      curr_node_type=basic_math::round(curr_e.get(1));
      if (curr_node_type==0)
      {
         nearest_neighbor_node_IDs.push_back(curr_node_ID);
         if (int(nearest_neighbor_node_IDs.size())==k)
         {
            compute_distances_to_nodes(
               query_element_ptr,nearest_neighbor_node_IDs,
               query_to_neighbor_distances,metric_space_element_ptrs);
            return;
         }
      }
      else
      {
         
// Retrieve metric space element contained within curr_node.  Add it
// to the priority queue:

         BTreeNode* BTreeNode_ptr=BinaryTree_ptr->get_node_ptr(curr_node_ID);
         descriptor* pivot_element_ptr=
            BTreeNode_ptr->get_data().metric_space_element_ptr;
         double mu=BTreeNode_ptr->get_data().mu;
         double query_pivot_distance=distance_between_elements(
            query_element_ptr,pivot_element_ptr);
//         curr_node_type=0;
//         curr_e=threevector(query_pivot_distance,curr_node_type,curr_node_ID);
//         search_queue_ptr->push(curr_e);   
         search_queue_ptr->push(
            threevector(query_pivot_distance,0,curr_node_ID));


// Add left metric subspace for curr_node to priority queue:

         BTreeNode* LeftNode_ptr=BTreeNode_ptr->get_LeftChild_ptr();         
         if (LeftNode_ptr != NULL)
         {
            double rlo=0;
            double rhi=mu;
//            cout << "query X = " << query_element_ptr->get(0) << endl;
//            cout << "pivot X = " << pivot_element_ptr->get(0) << endl;
//            cout << "query_pivot_distance = " << query_pivot_distance << endl;
//            cout << "left rlo = " << rlo
//                 << " left rhi = " << rhi << endl;
//            cout << "query_pivot_distance-rhi = " << query_pivot_distance-rhi 
//                 << " rlo-query_pivot_distance = " << rlo-query_pivot_distance
//                 << endl;

            curr_distance=basic_math::max( 
               query_pivot_distance-rhi , rlo-query_pivot_distance , 0.0 );
//            cout << "curr_distance = " << curr_distance << endl;
//            cout << endl;

//            curr_node_type=1;
//            curr_node_ID=LeftNode_ptr->get_ID();
//            curr_e=threevector(curr_distance,curr_node_type,curr_node_ID);
//            search_queue_ptr->push(curr_e);   
            search_queue_ptr->push(
               threevector(curr_distance,1,LeftNode_ptr->get_ID()));
         }

// Add right metric subspace for curr_node to priority queue:

         BTreeNode* RightNode_ptr=BTreeNode_ptr->get_RightChild_ptr();
         if (RightNode_ptr != NULL)
         {
            double rlo=mu;
            double rhi=POSITIVEINFINITY;
//            cout << "query X = " << query_element_ptr->get(0) << endl;
//            cout << "pivot X = " << pivot_element_ptr->get(0) << endl;
//            cout << "query_pivot_distance = " << query_pivot_distance << endl;
//            cout << "right rlo = " << rlo 
//                 << " right rhi = " << rhi << endl;
 //           cout << "query_pivot_dist-rhi = " << query_pivot_distance-rhi
//                 << " rlo-query_pivot_dist = " 
//                 << rlo-query_pivot_distance << endl;

            curr_distance=basic_math::max( 
               query_pivot_distance-rhi , rlo-query_pivot_distance , 0.0 );
//            cout << "curr_distance = " << curr_distance << endl;
//            cout << endl;

//            curr_node_type=1;
//            curr_node_ID=RightNode_ptr->get_ID();
//            curr_e=threevector(curr_distance,curr_node_type,curr_node_ID);
//            search_queue_ptr->push(curr_e);   
            search_queue_ptr->push(
               threevector(curr_distance,1,RightNode_ptr->get_ID()));
         }

      } // curr_node_type conditional
   } // while loop

   compute_distances_to_nodes(
      query_element_ptr,nearest_neighbor_node_IDs,query_to_neighbor_distances,
      metric_space_element_ptrs);
}
