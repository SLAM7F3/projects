// ==========================================================================
// Spasefuncs namespace method defintions
// ==========================================================================
// Last updated on 6/21/07; 10/29/08; 1/29/12
// ==========================================================================

#include <set>
#include <iostream>
#include "math/constants.h"
#include "geometry/contour.h"
#include "threeDgraphics/draw3Dfuncs.h"
#include "general/filefuncs.h"
#include "datastructures/Quadruple.h"
#include "geometry/regular_polygon.h"
#include "math/rotation.h"
#include "space/spasefuncs.h"
#include "general/stringfuncs.h"
#include "threeDgraphics/threeDstring.h"
#include "threeDgraphics/xyzpfuncs.h"

using std::cin;
using std::cout;
using std::endl;
using std::pair;
using std::string;
using std::vector;

namespace spasefunc
{
   const int n_solarpanels=6;
   const int n_protruding_bolts=12;

// ==========================================================================
// SPASE polygon construction & rotation methods:
// ==========================================================================

// Method generate_rotated_poly_counterparts rotates the input polygon
// about the z-axis through 60, 120, 180, 240 & 300 degrees.  It adds
// each rotated counterpart to the input STL vector *poly_ptr.

   void generate_rotated_poly_counterparts(
      polygon& poly,vector<polygon>* poly_ptr)
      {
         for (int r=1; r<6; r++)
         {
            poly.rotate(Zero_vector,0,0,PI/3);
            poly_ptr->push_back(poly);
         }
      }

// ---------------------------------------------------------------------
// Method construct_SPASE_panel_polys dynamically generates and
// returns an STL vector containing canonically oriented SPASE model
// solar panel polygons in XYZ space:

   vector<polygon>* construct_SPASE_panel_polys()
      {

// Panel #0:
   
         vector<threevector> vertex;
         vertex.push_back(threevector(-0.108,-0.187,0.394));
         vertex.push_back(threevector(-0.108,-0.187,0));
         vertex.push_back(threevector(0.108,-0.187,0));
         vertex.push_back(threevector(0.108,-0.187,0.394));
         polygon curr_panel(vertex);

         vector<polygon>* panel_ptr=new vector<polygon>;
         panel_ptr->push_back(curr_panel);
         generate_rotated_poly_counterparts(curr_panel,panel_ptr);
         return panel_ptr;
      }

// ---------------------------------------------------------------------
// Method construct_SPASE_cutout_panel_polys dynamically generates and
// returns an STL vector containing canonically oriented SPASE model
// solar panel polygons in XYZ space.  Each cutout panel is in the
// shape of a "U".  The width of the U's sides is set by input
// parameter delta_x, while the height of its top is set by delta_z.
// This specialized method was constructed for 2D ISAR image draping
// purposes.

   vector<polygon>* construct_SPASE_cutout_panel_polys(
      double delta_x,double delta_z)
      {

// Cutout panel #0:
   
         vector<threevector> vertex;
         vertex.push_back(threevector(-0.108,-0.187,0.394));
         vertex.push_back(threevector(-0.108,-0.187,0));
         vertex.push_back(threevector(0.108,-0.187,0));
         vertex.push_back(threevector(0.108,-0.187,0.394));
         vertex.push_back(threevector(0.108-delta_x,-0.187,0.394));
         vertex.push_back(threevector(0.108-delta_x,-0.187,delta_z));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,delta_z));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,0.394));
         polygon curr_panel(vertex);

         vector<polygon>* cutout_panel_ptr=new vector<polygon>;
         cutout_panel_ptr->push_back(curr_panel);
         generate_rotated_poly_counterparts(curr_panel,cutout_panel_ptr);
         return cutout_panel_ptr;
      }

// ---------------------------------------------------------------------
// Method construct_SPASE_panel_center_polys dynamically generates and
// returns an STL vector containing canonically oriented SPASE model
// solar panel polygons in XYZ space.  Each panel center represents
// the missing, middle portion of the "U" shape generated by method
// construct_SPASE_cutout_panel_polys().

   vector<polygon>* construct_SPASE_panel_center_polys(
      double delta_x,double delta_z)
      {

// Panel center #0:
   
         vector<threevector> vertex;
         vertex.push_back(threevector(0.108-delta_x,-0.187,0.394));
         vertex.push_back(threevector(0.108-delta_x,-0.187,delta_z));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,delta_z));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,0.394));
         polygon panel_center(vertex);

         vector<polygon>* panel_center_ptr=new vector<polygon>;
         panel_center_ptr->push_back(panel_center);
         generate_rotated_poly_counterparts(panel_center,panel_center_ptr);
         return panel_center_ptr;
      }

// ---------------------------------------------------------------------
   vector<polygon>* construct_SPASE_left_panel_strips(double delta_x)
      {

// Panel strip #0:
   
         vector<threevector> vertex;
         vertex.push_back(threevector(-0.108,-0.187,0.394));
         vertex.push_back(threevector(-0.108,-0.187,0));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,0));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,0.394));
         polygon curr_strip(vertex);

         vector<polygon>* panel_strip_ptr=new vector<polygon>;
         panel_strip_ptr->push_back(curr_strip);
         generate_rotated_poly_counterparts(curr_strip,panel_strip_ptr);
         return panel_strip_ptr;
      }

// ---------------------------------------------------------------------
   vector<polygon>* construct_SPASE_left_fat_strips(double delta_x)
      {

// Panel strip #0:
   
         vector<threevector> vertex;
         vertex.push_back(threevector(-0.108,-0.187,0.394));
         vertex.push_back(threevector(-0.108,-0.187,0));
         vertex.push_back(threevector(0.108-0.9*delta_x,-0.187,0));
         vertex.push_back(threevector(0.108-0.9*delta_x,-0.187,0.394));
         polygon curr_strip(vertex);

         vector<polygon>* panel_strip_ptr=new vector<polygon>;
         panel_strip_ptr->push_back(curr_strip);
         generate_rotated_poly_counterparts(curr_strip,panel_strip_ptr);
         return panel_strip_ptr;
      }

// ---------------------------------------------------------------------
   vector<polygon>* construct_SPASE_right_panel_strips(double delta_x)
      {

// Panel strip #0:
   
         vector<threevector> vertex;
         vertex.push_back(threevector(0.108,-0.187,0));
         vertex.push_back(threevector(0.108,-0.187,0.394));
         vertex.push_back(threevector(0.108-0.9*delta_x,-0.187,0.394));
         vertex.push_back(threevector(0.108-0.9*delta_x,-0.187,0));
         polygon curr_strip(vertex);

         vector<polygon>* panel_strip_ptr=new vector<polygon>;
         panel_strip_ptr->push_back(curr_strip);
         generate_rotated_poly_counterparts(curr_strip,panel_strip_ptr);
         return panel_strip_ptr;
      }

// ---------------------------------------------------------------------
   vector<polygon>* construct_SPASE_right_fat_strips(double delta_x)
      {

// Panel strip #0:
   
         vector<threevector> vertex;
         vertex.push_back(threevector(0.108,-0.187,0));
         vertex.push_back(threevector(0.108,-0.187,0.394));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,0.394));
         vertex.push_back(threevector(-0.108+delta_x,-0.187,0));
         polygon curr_strip(vertex);

         vector<polygon>* panel_strip_ptr=new vector<polygon>;
         panel_strip_ptr->push_back(curr_strip);
         generate_rotated_poly_counterparts(curr_strip,panel_strip_ptr);
         return panel_strip_ptr;
      }

// ---------------------------------------------------------------------
// Method construct_SPASE_bottom_polys dynamically generates and
// returns an STL vector containing canonically oriented SPASE model
// "golden bottom" polygonal faces in XYZ space:

   vector<polygon>* construct_SPASE_bottom_polys()
      {
         vector<polygon>* bottom_ptr=new vector<polygon>;

// Bottom polygon #0:

         vector<threevector> vertex;
         vertex.push_back(threevector(0.1626,-0.1626,0));
         vertex.push_back(threevector(-0.1626,-0.1626,0));
         vertex.push_back(threevector(-0.1626,-0.1626,-0.089));
         vertex.push_back(threevector(0.1626,-0.1626,-0.089));
         bottom_ptr->push_back(polygon(vertex));

// Bottom polygon #1:

         vertex.clear();
         vertex.push_back(threevector(0.1626,0.1626,0));
         vertex.push_back(threevector(0.1626,-0.1626,0));
         vertex.push_back(threevector(0.1626,-0.1626,-0.089));
         vertex.push_back(threevector(0.1626,0.1626,-0.089));
         bottom_ptr->push_back(polygon(vertex));

// Bottom polygon #2:

         vertex.clear();
         vertex.push_back(threevector(0.1626,0.1626,0));
         vertex.push_back(threevector(-0.1626,0.1626,0));
         vertex.push_back(threevector(-0.1626,0.1626,-0.089));
         vertex.push_back(threevector(0.1626,0.1626,-0.089));
         bottom_ptr->push_back(polygon(vertex));

// Bottom polygon #3:

         vertex.clear();
         vertex.push_back(threevector(-0.1626,0.1626,0));
         vertex.push_back(threevector(-0.1626,-0.1626,0));
         vertex.push_back(threevector(-0.1626,-0.1626,-0.089));
         vertex.push_back(threevector(-0.1626,0.1626,-0.089));
         bottom_ptr->push_back(polygon(vertex));

         return bottom_ptr;
      }


// ---------------------------------------------------------------------
// Method construct_SPASE_bottom_triangles dynamically generates and
// returns an STL vector containing canonically oriented SPASE model

   vector<polygon>* construct_SPASE_bottom_triangles()
      {
         vector<polygon>* triangle_ptr=new vector<polygon>;
         vector<threevector> vertex;         

// Triangle #0:

         vertex.push_back(threevector(0.122,0.163,0));
         vertex.push_back(threevector(0.163,0.092,0));
         vertex.push_back(threevector(0.163,0.163,0));
         triangle_ptr->push_back(polygon(vertex));
         vertex.clear();

// Triangle #1:

         vertex.push_back(threevector(-0.122,0.163,0));
         vertex.push_back(threevector(-0.163,0.163,0));
         vertex.push_back(threevector(-0.163,0.092,0));
         triangle_ptr->push_back(polygon(vertex));
         vertex.clear();

// Triangle #2:

         vertex.push_back(threevector(-0.122,-0.163,0));
         vertex.push_back(threevector(-0.163,-0.092,0));
         vertex.push_back(threevector(-0.163,-0.163,0));
         triangle_ptr->push_back(polygon(vertex));
         vertex.clear();

// Triangle #3:

         vertex.push_back(threevector(0.122,-0.163,0));
         vertex.push_back(threevector(0.163,-0.163,0));
         vertex.push_back(threevector(0.163,-0.092,0));
         triangle_ptr->push_back(polygon(vertex));

         return triangle_ptr;
      }

// ---------------------------------------------------------------------
// Method construct_SPASE_face_polys dynamically generates and returns
// an STL vector containing canonically oriented SPASE model polygonal
// top and bottom faces in XYZ space:

   vector<polygon>* construct_SPASE_face_polys()
      {
         vector<polygon>* face_ptr=new vector<polygon>;
         vector<threevector> vertex;         

// Top face:

         vertex.push_back(threevector(0.216,0,0.394));
         vertex.push_back(threevector(0.108,0.187,0.394));
         vertex.push_back(threevector(-0.108,0.187,0.394));
         vertex.push_back(threevector(-0.216,0,0.394));
         vertex.push_back(threevector(-0.108,-0.187,0.394));
         vertex.push_back(threevector(0.108,-0.187,0.394));
         face_ptr->push_back(polygon(vertex));
         vertex.clear();

// Bottom of "golden box" base:

         vertex.push_back(threevector(0.1626,0.1626,-0.089));
         vertex.push_back(threevector(-0.1626,0.1626,-0.089));
         vertex.push_back(threevector(-0.1626,-0.1626,-0.089));
         vertex.push_back(threevector(0.1626,-0.1626,-0.089));
         face_ptr->push_back(polygon(vertex));

         return face_ptr;
      }

// ==========================================================================
// SPASE polygon rotation methods:
// ==========================================================================

// Method wireframe_rotation_corresponding_to_mount_az_el computes the
// total rotation (as a function of input azimuth and elevation
// measured in degrees) which must be applied to the canonically
// oriented polygons representing SPASE's panels, "golden box" sides
// and top/bottom faces in order to align them with Weber Hoen's ISAR
// images of the half-size SPASE satellite.  Weber collected SAR data
// at the Amherst compact test range with the satellite attached to a
// mount piercing the middle of panel polygon #4.  The azimuth
// rotation about this mount ranged from 0 to 360 degrees, while the
// elevation ranged from 0 to 40 degrees.  Once the rotation matrix
// returned by this method is applied to every polygon in our
// wireframe model and once those polygons are projected down into the
// qhat-rhat image plane, one should only need to scale and translate
// the orthographic projection of the model in order to align it with
// Weber's SAR images.  On 1/28/05, Hyrum Anderson explicitly
// confirmed this using his MATLAB version of XELIAS...

// Note added on 3/21/06: The rotation matrix returned by this method
// implements an active transformation of model basis vectors into
// world space.  Model xhat (or qhat) runs along side 0 of the golden
// box.  Model yhat (or -phat) runs along side 1 of the golden box.
// Model zhat (or rhat) runs along the hexagonal cylinder symmetry
// axis.  When az=el=0, xhat_model = 1/2 xhat_world + sqrt(3)/2
// zhat_world, yhat_model = sqrt(3)/2 xhat_world - 1/2 zhat_world, and
// zhat_model = yhat_world.

   void wireframe_rotation_corresponding_to_mount_az_el(
      double azimuth,double elevation,rotation& R)
      {
         rotation R1(PI/2,0,0);
         rotation R2(0,4*PI/3,0);
         rotation R3(0,0,(azimuth-180)*PI/180);
         rotation R4(elevation*PI/180,0,0);
         R=R4*R3*R2*R1;
      }

// ---------------------------------------------------------------------
// Method translate_SPASE_polygons translates each polygon within the
// input STL vector *poly_ptr by input threevector trans:

   void translate_SPASE_polygons(
      const threevector& trans,vector<polygon>* poly_ptr)
      {
         for (unsigned int i=0; i<poly_ptr->size(); i++)
         {
            poly_ptr->at(i).translate(trans);
         }
      }

   void translate_SPASE_polygons(
      const threevector& trans,vector<polygon>* panel_ptr,
      vector<polygon>* bottom_ptr,vector<polygon>* triangle_ptr,
      vector<polygon>* face_ptr)
      {
         translate_SPASE_polygons(trans,panel_ptr);
         translate_SPASE_polygons(trans,bottom_ptr);
         translate_SPASE_polygons(trans,triangle_ptr);
         translate_SPASE_polygons(trans,face_ptr);
      }

// ---------------------------------------------------------------------
// Method scale_SPASE_polygons scales each polygon within the input
// STL vector *poly_ptr by input scalar sfactor:

   void scale_SPASE_polygons(
      double sfactor,vector<polygon>* poly_ptr)
      {
         for (unsigned int i=0; i<poly_ptr->size(); i++)
         {
            (*poly_ptr)[i].scale(Zero_vector,sfactor);
         }
      }

   void scale_SPASE_polygons(
      double sfactor,vector<polygon>* panel_ptr,
      vector<polygon>* bottom_ptr,vector<polygon>* triangle_ptr,
      vector<polygon>* face_ptr)
      {
         scale_SPASE_polygons(sfactor,panel_ptr);
         scale_SPASE_polygons(sfactor,bottom_ptr);
         scale_SPASE_polygons(sfactor,triangle_ptr);
         scale_SPASE_polygons(sfactor,face_ptr);
      }

// ---------------------------------------------------------------------
// Method rotate_SPASE_polygons rotates each polygon within input STL
// vector *poly_ptr by input matrix R.

   void rotate_SPASE_polygons(const rotation& R,vector<polygon>* poly_ptr)
      {
         for (unsigned int i=0; i<poly_ptr->size(); i++)
         {
            (*poly_ptr)[i].rotate(R);
         }
      }

   void rotate_SPASE_polygons(
      const rotation& R,vector<polygon>* panel_ptr,
      vector<polygon>* bottom_ptr,vector<polygon>* triangle_ptr,
      vector<polygon>* face_ptr)
      {
         rotate_SPASE_polygons(R,panel_ptr);
         rotate_SPASE_polygons(R,bottom_ptr);
         rotate_SPASE_polygons(R,triangle_ptr);
         rotate_SPASE_polygons(R,face_ptr);
      }

   void rotate_SPASE_polygons(
      const rotation& R,vector<polygon>* panel_ptr,
      vector<polygon>* cutout_panel_ptr,vector<polygon>* bottom_ptr,
      vector<polygon>* triangle_ptr,vector<polygon>* face_ptr)
      {
         rotate_SPASE_polygons(R,cutout_panel_ptr);
         rotate_SPASE_polygons(R,panel_ptr,bottom_ptr,triangle_ptr,face_ptr);
      }

// ==========================================================================
// SPASE model cosntruction methods:
// ==========================================================================
   
// Method bolt_location takes in the number of the vertical edge as
// well as the number of the particular bolt (ranging from 0 to
// n_protruding_bolts-1).  It returns the XYZ location of the
// particular bolt on our canonically oriented SPASE model.

/*
// FAKE FAKE: Weds, Apr 6 at 12:08 pm...

// For SCC viewgraph purposes only, we intentionally try to mess up
// bolt locations on SPASE model

   threevector bolt_location(int edge_number,int bolt_number)
      {
         const double meters_per_inch=0.0254;

         double Z[6];
         Z[0]=0.875*meters_per_inch;
         Z[1]=4.25*meters_per_inch;
         Z[2]=7.0*meters_per_inch;
         Z[3]=9.625*meters_per_inch;
         Z[4]=12.25*meters_per_inch;
         Z[5]=14.25*meters_per_inch;
         double z=0.394-Z[modulo(bolt_number,6)];

         threevector corner_vertex[n_solarpanels];
         corner_vertex.push_back(threevector(-0.108,-0.187));
         corner_vertex.push_back(threevector(0.108,-0.187));
         corner_vertex.push_back(threevector(0.216,0));
         corner_vertex.push_back(threevector(0.108,0.187));
         corner_vertex.push_back(threevector(-0.108,0.187));
         corner_vertex.push_back(threevector(-0.216,0));
         mymatrix Rplus(0,0,2*PI/3.0);
         mymatrix Rminus(0,0,-2*PI/3.0);

         threevector a_hat[n_solarpanels],b_hat[n_solarpanels];
         for (int edge=0; edge<n_solarpanels; edge++)
         {
            a_hat[edge]=Rplus*corner_vertex[edge].unitvector();
            b_hat[edge]=Rminus*corner_vertex[edge].unitvector();
         }
         
         const double delta_z=0.3126*meters_per_inch/2.0;
         threevector bolt[n_protruding_bolts];
         for (int b=0; b < n_protruding_bolts/2; b++)
         {
            bolt[b]=corner_vertex[edge_number]
//               +0.25*meters_per_inch*a_hat[edge_number]+
               +(z)*z_hat;
//            bolt[b+6]=corner_vertex[edge_number]
//               +0.25*meters_per_inch*b_hat[edge_number]+
//               (z+delta_z)*z_hat;
         }

         return bolt[bolt_number];
      }
*/

         threevector bolt_location(int edge_number,int bolt_number)
      {
         const double meters_per_inch=0.0254;

         double Z[6];
         Z[0]=0.875*meters_per_inch;
         Z[1]=4.25*meters_per_inch;
         Z[2]=7.0*meters_per_inch;
         Z[3]=9.625*meters_per_inch;
         Z[4]=12.25*meters_per_inch;
         Z[5]=14.25*meters_per_inch;
         double z=0.394-Z[modulo(bolt_number,6)];

         vector<threevector> corner_vertex;
         corner_vertex.push_back(threevector(-0.108,-0.187));
         corner_vertex.push_back(threevector(0.108,-0.187));
         corner_vertex.push_back(threevector(0.216,0));
         corner_vertex.push_back(threevector(0.108,0.187));
         corner_vertex.push_back(threevector(-0.108,0.187));
         corner_vertex.push_back(threevector(-0.216,0));
         rotation Rplus(0,0,2*PI/3.0);
         rotation Rminus(0,0,-2*PI/3.0);

         vector<threevector> a_hat,b_hat;
         for (int edge=0; edge<n_solarpanels; edge++)
         {
            a_hat.push_back(Rplus*corner_vertex[edge].unitvector());
            b_hat.push_back(Rminus*corner_vertex[edge].unitvector());
         }
         
         const double delta_z=0.3126*meters_per_inch/2.0;
         vector<threevector> bolt;
         bolt.reserve(n_protruding_bolts);
         for (int b=0; b < n_protruding_bolts; b++)
         {
            bolt.push_back(threevector(0,0,0));
         }
         
         for (int b=0; b < n_protruding_bolts/2; b++)
         {
            bolt[b]=corner_vertex[edge_number]
               +0.25*meters_per_inch*a_hat[edge_number]+
//               (z-delta_z)*z_hat;	OK
               (z+delta_z)*z_hat;	// FAKE
            bolt[b+6]=corner_vertex[edge_number]
               +0.25*meters_per_inch*b_hat[edge_number]+
//               (z+delta_z)*z_hat;	// OK
               (z-delta_z)*z_hat;	// FAKE
         }
         return bolt[bolt_number];
      }
   
// ---------------------------------------------------------------------
// Method construct_SPASE_model builds up a 3D model for the SPASE
// satellite consisting of a hexagonal cylinder, rectangular
// parallelepiped base and small, cubical bolts.  It also annotates
// the faces of the base with numerals for ID purposes.  XYZP points
// for the wireframe model are returned within a dynamically generated
// STL vector of genvector(4).

   vector<fourvector>* construct_SPASE_model(
      double model_annotation_value,double bolts_annotation_value,
      double ribs_annotation_value,double numerals_annotation_value,
      bool draw_thick_lines)
      {
         outputfunc::write_banner("Constructing SPASE model:");
         const double radius=0.216;	// meter
         const double height=0.394;	// meter
         const double r_base=0.230;	// meter
         const double h_base=0.089;	// meter

         regular_polygon* hexagon_ptr=new regular_polygon(6,radius);
         contour topface(hexagon_ptr);
         delete hexagon_ptr;

         regular_polygon* square_ptr=new regular_polygon(4,r_base);
         contour bottomface(square_ptr);

         delete square_ptr;
         bottomface.rotate(threevector(0,0),0,0,0.25*PI);
         bottomface.translate(threevector(0,0,-h_base));

//   cout << "topface = " << topface << endl;
//   cout << "bottomface = " << bottomface << endl;

         string tmp_xyzp_filename="spase_model_orig.xyzp";
         filefunc::deletefile(tmp_xyzp_filename);
   
         draw3Dfunc::draw_thick_lines=draw_thick_lines;
         draw3Dfunc::ds=0.002;	// meter

// Draw SPASE's hexagonal cylinder body:

         draw3Dfunc::draw_contour_cylinder(
            topface,height,tmp_xyzp_filename,model_annotation_value);

// Draw box for SPASE's "golden" base:

         draw3Dfunc::draw_contour_cylinder(
            bottomface,h_base,tmp_xyzp_filename,model_annotation_value);

// Draw bolts along vertical edges:

//         const double bolt_size=0.005; // meter
         const double bolt_size=0.010; // meter
//         const double bolt_size=0.015; // meter
         for (int edge_number=0; edge_number<6; edge_number++)
         {
            for (int bolt_number=0; bolt_number<n_protruding_bolts; 
                 bolt_number++)
            {

// FAKE FAKE:  Thurs Apr 7 at 2:52 pm...
// Next conditional only for viewgraph generation purposes...

//               if ((bolt_number >=1 && bolt_number <=4) ||
//                   (bolt_number >=7 && bolt_number <=10))
               {
                  draw3Dfunc::draw_tiny_cube(
                     bolt_location(edge_number,bolt_number),tmp_xyzp_filename,
                     bolts_annotation_value,bolt_size);
               }
            }
         }

// Draw ribs along panel faces:

/*
         for (int edge_number=0; edge_number<6; edge_number++)
         {
            for (int bolt_number=0; bolt_number < edge_number; bolt_number++)
            {
               draw3Dfunc::draw_line(
                  bolt_location(edge_number,bolt_number),
                  bolt_location(modulo(edge_number+1,6),bolt_number),
                  tmp_xyzp_filename,ribs_annotation_value);
            }
         }
*/

// Add 3D numerals to label base box side faces:

         const threevector origin(0,0,0);
         threeDstring cstring[4];
         for (int i=0; i<4; i++)
         {
            cstring[i].parse_string(stringfunc::number_to_string(i));
            cstring[i].scale(origin,0.01);
            cstring[i].rotate(origin,PI/2,0,0);
         }
   
         cstring[0].translate(threevector(0,-0.163,-0.08));
         cstring[1].rotate(origin,0,0,PI/2);
         cstring[1].translate(threevector(0.163,0,-0.08));
         cstring[2].rotate(origin,0,0,PI);
         cstring[2].translate(threevector(0,0.163,-0.08));
         cstring[3].rotate(origin,0,0,3*PI/2);
         cstring[3].translate(threevector(-0.163,0,-0.08));
   
         for (int i=0; i<4; i++)
         {
            draw3Dfunc::draw_threeDstring(
               cstring[i],tmp_xyzp_filename,numerals_annotation_value);
         }

// Read all XYZP points for SPASE 3D model written out to
// tmp_xyzp_filename back into a dynamically generated STL vector.
// Then delete temporary output file:

         vector<fourvector>* xyzp_pnt_ptr=
            xyzpfunc::read_xyzp_float_data(tmp_xyzp_filename);
         filefunc::deletefile(tmp_xyzp_filename);
         return xyzp_pnt_ptr;
      }

// ---------------------------------------------------------------------
// Method construct_SPASE_shadow_volumes dynamically generates an STL
// vector containing parallelepipeds corresponding to shadow volumes
// for SPASE's top face and to its 6 solar panel sides.  The common
// height for the parallelepipeds is passed as an input parameter as
// is the direction vector u_hat along which the input polygons are
// extruded.

   vector<parallelepiped>* construct_SPASE_shadow_volumes(
      vector<polygon> const *face_ptr,vector<polygon>* const panel_ptr,
      double height,const threevector& u_hat)
      {
         vector<parallelepiped>* shadow_volume_ptr=
            new vector<parallelepiped>;

         polygon top_face( face_ptr->at(0) );
//         top_face.scale(top_face.vertex_average(),0.999);
         
         vector<threevector> vertex;
         vertex.push_back(top_face.get_vertex(0));
         vertex.push_back(top_face.get_vertex(1));
         vertex.push_back(top_face.get_vertex(3));
         vertex.push_back(top_face.get_vertex(4));
         polygon top_half(vertex);
         shadow_volume_ptr->push_back(parallelepiped(top_half,u_hat,height));
         vertex.clear();

         vertex.push_back(top_face.get_vertex(1));
         vertex.push_back(top_face.get_vertex(2));
         vertex.push_back(top_face.get_vertex(4));
         vertex.push_back(top_face.get_vertex(5));
         top_half=polygon(vertex);
         shadow_volume_ptr->push_back(parallelepiped(top_half,u_hat,height));
         vertex.clear();

         vertex.push_back(top_face.get_vertex(2));
         vertex.push_back(top_face.get_vertex(3));
         vertex.push_back(top_face.get_vertex(5));
         vertex.push_back(top_face.get_vertex(0));
         top_half=polygon(vertex);
         shadow_volume_ptr->push_back(parallelepiped(top_half,u_hat,height));
         vertex.clear();
   
         for (unsigned int i=0; i<panel_ptr->size(); i++)
         {
            shadow_volume_ptr->push_back(parallelepiped(
               (*panel_ptr)[i],y_hat,height));
         }

// Set up shadow volume natural coordinate systems:
         
         for (unsigned int i=0; i<shadow_volume_ptr->size(); i++)
         {
            shadow_volume_ptr->at(i).calculate_symmetry_vectors_and_lengths();
            shadow_volume_ptr->at(i).calculate_metric_and_its_inverse();
         }

         return shadow_volume_ptr;
      }

// ==========================================================================
// SPASE polygon drawing methods:
// ==========================================================================

// Method draw_SPASE_polygons draws each polygon within input STL
// vector *poly_ptr to the output XYZP file:

   void draw_SPASE_polygons(
      vector<polygon>* poly_ptr,string xyzp_filename,
      double annotation_value)
      {
         for (unsigned int i=0; i<poly_ptr->size(); i++)
         {
            draw3Dfunc::draw_polygon(
               (*poly_ptr)[i],xyzp_filename,annotation_value);
         }
      }

   void draw_SPASE_polygons(
      vector<polygon>* panel_ptr,
      vector<polygon>* bottom_ptr,vector<polygon>* triangle_ptr,
      vector<polygon>* face_ptr,string xyzp_filename,double annotation_value)
      {
         draw_SPASE_polygons(panel_ptr,xyzp_filename,annotation_value);
         draw_SPASE_polygons(bottom_ptr,xyzp_filename,annotation_value);
         draw_SPASE_polygons(triangle_ptr,xyzp_filename,annotation_value);
         draw_SPASE_polygons(face_ptr,xyzp_filename,annotation_value);
      }

// ---------------------------------------------------------------------
// Method draw_model_3D_axes adds a set of intersecting vectors to the
// output xyzp_filename which is assumed to already containg SPASE
// model xyzp points.

//   const double max_axes_extent=0.5;	// meter
   const double max_axes_extent=0.75;	// meter
//   const double max_axes_extent=1.0;	// meter

   void draw_model_3D_axes(
      string xyzp_filename,string xaxis_label,string yaxis_label,
      string zaxis_label,double annotation_value)
      {
         const double axes_label_size=0.02;
//         const double annotation_value=0.5;
         draw3Dfunc::draw_3D_axes(
            Zero_vector,max_axes_extent,axes_label_size,xyzp_filename,
            annotation_value,xaxis_label,yaxis_label,zaxis_label);
      }

// ---------------------------------------------------------------------
// Method draw_axes_endpoints draws small cubes at the tip points of
// the model axes.  We concocted this little method primarily for
// image-wireframe matching debugging purposes.

   void draw_axes_endpoints(string xyzp_filename)
      {
         double cube_size=0.0035;	 // meter
         double annotation_value=0.1;
         draw3Dfunc::draw_tiny_cube(
            max_axes_extent*x_hat,xyzp_filename,annotation_value,cube_size);
         draw3Dfunc::draw_tiny_cube(
            max_axes_extent*y_hat,xyzp_filename,annotation_value,cube_size);
         draw3Dfunc::draw_tiny_cube(
            max_axes_extent*z_hat,xyzp_filename,annotation_value,cube_size);
      }

// On 6/21/07, we commented out the next method in order to remove
// dependence upon our old, deprecated pngfunc methods to help with
// porting our codes from linux to Mac OS X.  If we ever need to fuse
// photos and SAR imagery in the future, we should rewrite the method
// below using newer, better OSG techniques...

/*
// ---------------------------------------------------------------------
// Method fuse_photo_and_SAR_images

   void fuse_photo_and_SAR_images(
      string input_subdir,string xyzp_filename,
      string photo_PNGfilename,string photo_xyzuv_filename,
      string SAR_PNGfilename,string SAR_xyzuv_filename,const mymatrix& R,
      const vector<polygon>& polygon_face,double delta_s)
      {
         vector<Quadruple<threevector,bool,double,double> >* interior_points_ptr=
            draw3Dfunc::generate_3D_polygon_interior_points(
               polygon_face,delta_s);
         draw3Dfunc::drape_PNG_image_onto_multiple_polygons(
            input_subdir,photo_PNGfilename,photo_xyzuv_filename,
            interior_points_ptr,false);

// After draping photo, rotate interior points to SAR frame:

         draw3Dfunc::rotate_3D_polygon_interior_points(R,interior_points_ptr);

         draw3Dfunc::check_for_shadows=false;
//   draw3Dfunc::check_for_shadows=true;
         bool orthographic_projection=true;

         draw3Dfunc::drape_PNG_image_onto_multiple_polygons(
            input_subdir,SAR_PNGfilename,SAR_xyzuv_filename,
            interior_points_ptr,orthographic_projection);

// Rotate from SAR back to photo frame:

         draw3Dfunc::rotate_3D_polygon_interior_points(
            R.transpose(),interior_points_ptr);

         draw3Dfunc::write_out_fused_poly_info(
            interior_points_ptr,xyzp_filename);
         draw3Dfunc::check_for_shadows=false;
         delete interior_points_ptr;
      }
*/
 
// ==========================================================================
// Miscellaneous SPASE model methods:
// ==========================================================================

// Method locate_closest_SPASE_polygon

   Triple<bool,double,threevector> locate_closest_SPASE_polygon(
      const threevector& curr_point,vector<polygon>* poly_ptr)
      {
         bool proj_pnt_inside_poly=true;
         double min_distance=POSITIVEINFINITY;
         threevector closest_poly_point;
         for (unsigned int i=0; i<poly_ptr->size(); i++)
         {
            Triple<bool,double,threevector> T(
               poly_ptr->at(i).closest_polygon_point(curr_point));
            if (T.second < min_distance)
            {
               proj_pnt_inside_poly=T.first;
               min_distance=T.second;
               closest_poly_point=T.third;
            }
         }
         return Triple<bool,double,threevector>(
            proj_pnt_inside_poly,min_distance,closest_poly_point);
      }

   Triple<bool,double,threevector> locate_closest_SPASE_polygon(
      const threevector& curr_point,
      vector<polygon>* panel_ptr,vector<polygon>* bottom_ptr,
      vector<polygon>* triangle_ptr,vector<polygon>* face_ptr)
      {
         vector<polygon> all_poly;
         for (unsigned int i=0; i<panel_ptr->size(); i++)
         {
            all_poly.push_back((*panel_ptr)[i]);
         }
         for (unsigned int i=0; i<bottom_ptr->size(); i++)
         {
            all_poly.push_back((*bottom_ptr)[i]);
         }
         for (unsigned int i=0; i<triangle_ptr->size(); i++)
         {
            all_poly.push_back((*triangle_ptr)[i]);
         }
         for (unsigned int i=0; i<face_ptr->size(); i++)
         {
            all_poly.push_back((*face_ptr)[i]);
         }
         return locate_closest_SPASE_polygon(curr_point,&all_poly);
         
      }

// ==========================================================================
// Imagecdf parsing methods:
// ==========================================================================

// Method parse_imagecdf_textdump is a specialized utility for parsing
// imagecdf header information dumped to a text file by Hyrum
// Anderson's CDFDUMP utility on FIASCO.  We use this pair of software
// tools to circumvent XELIAS.

   void parse_imagecdf_textdump(
      string imagecdf_text_filename,vector<pair<int,int> >& image_size,
      vector<twovector>& meters_per_pixel,vector<twovector>& center_shift,
      vector<twovector>& translation,vector<rotation*>& R_ptr)
      {
         filefunc::ReadInfile(imagecdf_text_filename);
         const int nlines_per_image=9;
         int n_images=filefunc::text_line.size()/nlines_per_image;

         for (int i=0; i<n_images; i++)
         {
            int init_linenumber=i*nlines_per_image;

            string dims_in_pixels_line=filefunc::text_line[init_linenumber+1];
            vector<string> substring=
               stringfunc::decompose_string_into_substrings(
                  dims_in_pixels_line);
            int curr_width=stringfunc::string_to_integer(substring[1]);
            int curr_height=stringfunc::string_to_integer(substring[3]);
            pair<int,int> p(curr_width,curr_height);
            image_size.push_back(p);

            string meters_per_pixel_line=filefunc::text_line[
               init_linenumber+2];
            substring=stringfunc::decompose_string_into_substrings(
               meters_per_pixel_line);
            twovector curr_mpp(stringfunc::string_to_number(substring[1]),
                               stringfunc::string_to_number(substring[3]));
            meters_per_pixel.push_back(curr_mpp);

            string center_shift_line=filefunc::text_line[init_linenumber+3];
            substring=stringfunc::decompose_string_into_substrings(
               center_shift_line);
            twovector curr_shift(stringfunc::string_to_number(substring[1]),
                                 stringfunc::string_to_number(substring[3]));
            center_shift.push_back(curr_shift);

            string trans_line=filefunc::text_line[init_linenumber+4];
            substring.clear();
            substring=stringfunc::decompose_string_into_substrings(
               trans_line);
            string xtrans_str=substring[1];
            double xtrans=stringfunc::string_to_number(
               xtrans_str.substr(1,xtrans_str.size()-2));
            string ytrans_str=substring[2];
            double ytrans=stringfunc::string_to_number(
               ytrans_str.substr(0,ytrans_str.size()-1));
            twovector curr_trans(xtrans,ytrans);
            translation.push_back(curr_trans);

            rotation* curr_Rptr=new rotation;
            for (int l=0; l<3; l++)
            {
               string rot_line=filefunc::text_line[init_linenumber+6+l];
               substring.clear();
               substring=stringfunc::decompose_string_into_substrings(
                  rot_line);
               string r0_str=substring[1];
               string r1_str=substring[2];
               string r2_str=substring[3];
               double r0=stringfunc::string_to_number(
                  r0_str.substr(0,r0_str.size()-1));
               double r1=stringfunc::string_to_number(
                  r1_str.substr(0,r1_str.size()-1));
               double r2=stringfunc::string_to_number(
                  r2_str.substr(0,r2_str.size()));
               curr_Rptr->put(l,0,r0);
               curr_Rptr->put(l,1,r1);
               curr_Rptr->put(l,2,r2);
            } // loop over l index labeling 3 rotation matrix lines
            R_ptr.push_back(curr_Rptr);
         } // loop over index i labeling images
      }

} // spasefunc namespace
