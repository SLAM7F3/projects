// ==========================================================================
// Affine_Transform class member functions
// ==========================================================================
// Last modified on 7/26/13; 7/27/13
// ==========================================================================

#include "geometry/affine_transform.h"
#include "math/genmatrix.h"
#include "math/genvector.h"
#include "general/stringfuncs.h"

using std::cout;
using std::cin;
using std::endl;
using std::ostream;
using std::string;
using std::vector;

// ---------------------------------------------------------------------
// Initialization, constructor and destructor functions:
// ---------------------------------------------------------------------

void affine_transform::allocate_member_objects()
{
   A_ptr=new genmatrix(2,2);
   Ainv_ptr=new genmatrix(2,2);
   best_A_ptr=new genmatrix(2,2);
}

void affine_transform::initialize_member_objects()
{
   max_n_inliers=-1;
   M_ptr=NULL;
   B_ptr=NULL;
}		       

affine_transform::affine_transform()
{
   allocate_member_objects();
   initialize_member_objects();
}

affine_transform::~affine_transform()
{
   delete A_ptr;
   delete Ainv_ptr;
   delete best_A_ptr;
   delete M_ptr;
   delete B_ptr;
}

// ---------------------------------------------------------------------
// Overload << operator:

ostream& operator<< (ostream& outstream,const affine_transform& AT)
{
   outstream << endl;
   outstream << "A = " << *(AT.A_ptr) << endl;
   outstream << "trans = " << AT.trans << endl;
   return outstream;
}

// ==========================================================================
// 3x3 affine_transform matrix determination:
// ==========================================================================
   
bool affine_transform::parse_affine_transform_inputs(
   const vector<twovector>& XY,const vector<twovector>& UV)
{
   return parse_affine_transform_inputs(XY,UV,XY.size());
}

// ---------------------------------------------------------------------
// This overloaded version of boolean member function
// parse_affine_transform_inputs returns false if there are insufficient
// tiepoint pair inputs to actually compute a affine_transform.

bool affine_transform::parse_affine_transform_inputs(
   const vector<twovector>& XY,const vector<twovector>& UV,
   unsigned int n_inputs)
{
//   cout << "inside affine_transform::parse_affine_transform_inputs()" << endl;
//   cout << "n_inputs = " << n_inputs << endl;
   
   if (XY.size() != UV.size())
   {
      cout << "Error in affine_transform::parse_affine_transform_inputs()"
           << endl;
      cout << "XY.size() = " << XY.size() 
           << " UV.size() = " << UV.size() << endl;
      exit(-1);
   }

// Recall that at least 3 sets of tiepoints are needed in order to
// compute a affine_transform:

   if (n_inputs < 3) return false;

   int nrows=2*n_inputs;
   int ncolumns=6;
   delete M_ptr;
   M_ptr=new genmatrix(nrows,ncolumns);
   M_ptr->clear_values();
   
   delete B_ptr;
   B_ptr=new genvector(nrows);

   for (unsigned int i=0; i<n_inputs; i++)
   {
      double x=XY[i].get(0);
      double y=XY[i].get(1);
      double u=UV[i].get(0);
      double v=UV[i].get(1);

//      cout << "i = " << i
//           << " X = " << x << " Y = " << y 
//           << " U = " << u << " V = " << v << endl;

      int row=i*2+0;
      M_ptr->put(row,0,x);
      M_ptr->put(row,1,y);
      M_ptr->put(row,4,1);
      B_ptr->put(row,u);

      row++;

      M_ptr->put(row,2,x);
      M_ptr->put(row,3,y);
      M_ptr->put(row,5,1);
      B_ptr->put(row,v);

   } // loop over index i
   
//   cout << "M = " << *M_ptr << endl;
//   cout << "M.mdim = " << M_ptr->get_mdim() << " M.ndim = " 
//        << M_ptr->get_ndim() << endl;
//   cout << "M.det = " << M_ptr->determinant() << endl;
//   cout << "B = " << *B_ptr << endl;

   return true;
}

// ---------------------------------------------------------------------
// Method fit_affine_transformation() works with the 2r x 6 genmatrix
// *M_ptr generated by method parse_affine_transform_inputs.  It first
// performs a singular value decomposition of *A_ptr = U diag(w) V^T.
// It then identifies the smallest singular value (which should be
// close to zero) as well as the corresponding column eigenvector v
// within matrix V.  This column vector should approximately satisfy
// the homogenous system of equantions *A_ptr v = 0.  Finally, this
// method rearranges the 9 entries within v into the 3x3 projection
// genmatrix *H_ptr which maps homogeneous (x,y,1) coordinates from a
// world plane onto their corresponding homogenous (u,v,1) coordinates
// within image space.  
   
void affine_transform::fit_affine_transformation()
{
//   cout << "inside affine_transform::fit_affine_transformation()" << endl;

   genvector X(6);
   X=M_ptr->pseudo_inverse() * *B_ptr;

   A_ptr->put(0,0,X.get(0));
   A_ptr->put(0,1,X.get(1));
   A_ptr->put(1,0,X.get(2));
   A_ptr->put(1,1,X.get(3));
   
   trans.put(0,X.get(4));
   trans.put(1,X.get(5));

   A_ptr->inverse(*Ainv_ptr);

//   cout << "A = " << *A_ptr << endl;
//   cout << "trans = " << trans << endl;
}

// ---------------------------------------------------------------------
// Method project_world_plane_to_image_plane takes in the world
// coordinates for some planar point within twovector r.  It projects
// this world point down onto the image plane via 3x3 affine_transform
// matrix *H_ptr.  This method returns the (u,v) image plane
// coordinates of the projected point.

void affine_transform::project_world_plane_to_image_plane(
   double x,double y,double& u,double& v)
{
//   cout << "inside affine_transform::project_world_plane_to_image_plane()" << endl;

   u=A_ptr->get(0,0)*x + A_ptr->get(0,1)*y + trans.get(0);
   v=A_ptr->get(1,0)*x + A_ptr->get(1,1)*y + trans.get(1);
}

twovector affine_transform::project_world_plane_to_image_plane(
   const twovector& r)
{
   double u=A_ptr->get(0,0)*r.get(0) + A_ptr->get(0,1)*r.get(1) + trans.get(0);
   double v=A_ptr->get(1,0)*r.get(0) + A_ptr->get(1,1)*r.get(1) + trans.get(1);
   return twovector(u,v);
}

// ---------------------------------------------------------------------
// Method check_affine_transformation() reads in the original XY-UV
// information.  It projects the XY points down into the UV image
// plane using the 3x3 matrix *H_ptr.  This method's direct comparison
// of the projected UV values with the measured ones provides some
// indication of the projection fit's quality.

double affine_transform::check_affine_transformation(
   vector<twovector>& XY,vector<twovector>& UV)
{
   unsigned int n_inputs=XY.size();
   double chisq=0;
   vector<double> d_chisq;

   XY_sorted.clear();
   UV_sorted.clear();

   vector<int> index;
   for (unsigned int i=0; i<n_inputs; i++)
   {
      index.push_back(i);
      XY_sorted.push_back(XY[i]);
      UV_sorted.push_back(UV[i]);
      twovector q=project_world_plane_to_image_plane(XY[i]);

      d_chisq.push_back(sqr(UV[i].get(0)-q.get(0))+
                        sqr(UV[i].get(1)-q.get(1)));
      chisq += d_chisq.back();
   }
   
   templatefunc::Quicksort(d_chisq,index,XY_sorted,UV_sorted);


   for (unsigned int i=0; i<n_inputs; i++)
   {
      twovector q=project_world_plane_to_image_plane(XY_sorted[i]);
/*
      cout << "i = " << i << " index = " << index[i] 
           << " X = " << XY_sorted[i].get(0) 
           << " Y = " << XY_sorted[i].get(1) << endl;
      cout << "Input U = " << UV_sorted[i].get(0) 
           << " projected U = " << q.get(0)
           << " input V = " << UV_sorted[i].get(1) 
           << " projected V = " << q.get(1) 
           << " sqrt(d_chisq) = " << sqrt(d_chisq[i]) 
           << endl << endl;
*/
    
   } // loop over index i 
   double RMS_residual=sqrt(chisq/n_inputs);

/*
   cout << endl;
   cout << "===============================================" << endl;
   cout << "RMS residual between measured and calculated UV points = " 
        << RMS_residual << endl;
   cout << "===============================================" << endl;
   cout << endl;
*/

   return RMS_residual;
}



// ---------------------------------------------------------------------
// Method count_affine_inliers()

int affine_transform::count_affine_inliers(
   vector<twovector>& XY,vector<twovector>& UV,double max_delta_UV)
{
   int n_inliers=0;
   for (unsigned int t=0; t<XY.size(); t++)
   {
      twovector UV_comp(*A_ptr * XY[t]+trans);
      double delta_UV=(UV_comp-UV[t]).magnitude();
      if (delta_UV < max_delta_UV) n_inliers++;
   } // loop over index t labeling all tiepoint pairs

   if (n_inliers > max_n_inliers)
   {
      max_n_inliers=n_inliers;
      *best_A_ptr=*A_ptr;
      best_trans=trans;
//      cout << "maximum n_affine_inliers = " << max_n_inliers << endl;
   }

   return n_inliers;
} 

// ---------------------------------------------------------------------
// Method export_affine_inliers()

void affine_transform::export_affine_inliers(
   vector<twovector>& XY,vector<twovector>& UV,double max_delta_UV)
{

   vector<twovector> affine_inlier_XY,affine_inlier_UV;
   for (unsigned int t=0; t<XY.size(); t++)
   {
      twovector UV_comp=*best_A_ptr * XY[t]+best_trans;
      double delta_UV=(UV_comp-UV[t]).magnitude();
      if (delta_UV < max_delta_UV) 
      {
         affine_inlier_XY.push_back(XY[t]);
         affine_inlier_UV.push_back(UV[t]);
      }
   } // loop over index t labeling all tiepoint pairs

   XY.clear();
   UV.clear();
   
   for (unsigned int i=0; i<affine_inlier_XY.size(); i++)
   {
      XY.push_back(affine_inlier_XY[i]);
      UV.push_back(affine_inlier_UV[i]);
   }
} 

// ---------------------------------------------------------------------
// Method export_affine_inlier_indices()

std::vector<int> affine_transform::export_affine_inlier_indices(
   const vector<twovector>& XY,const vector<twovector>& UV,double max_delta_UV)
{
   vector<int> inlier_indices;
   for (unsigned int t=0; t<XY.size(); t++)
   {
      twovector UV_comp=*best_A_ptr * XY[t]+best_trans;
      double delta_UV=(UV_comp-UV[t]).magnitude();
      if (delta_UV < max_delta_UV) 
      {
         inlier_indices.push_back(t);
      }
   } // loop over index t labeling all tiepoint pairs
   return inlier_indices;
} 
