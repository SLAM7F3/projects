/* soapC.cpp
   Generated by gSOAP 2.7.9a from ./src/SKSClient.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.9a 2006-11-21 17:39:08 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ns2__Order:
		return soap_in_ns2__Order(soap, NULL, NULL, "ns2:Order");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns2__Order_:
		return soap_in_ns2__Order_(soap, NULL, NULL, "ns2:Order");
	case SOAP_TYPE_ns5__SKSWSException:
		return soap_in_ns5__SKSWSException(soap, NULL, NULL, "ns5:SKSWSException");
	case SOAP_TYPE_ns4__ArrayOfCommentVO:
		return soap_in_ns4__ArrayOfCommentVO(soap, NULL, NULL, "ns4:ArrayOfCommentVO");
	case SOAP_TYPE_ns4__ArrayOfImageVO:
		return soap_in_ns4__ArrayOfImageVO(soap, NULL, NULL, "ns4:ArrayOfImageVO");
	case SOAP_TYPE_ns4__ArrayOfUserVO:
		return soap_in_ns4__ArrayOfUserVO(soap, NULL, NULL, "ns4:ArrayOfUserVO");
	case SOAP_TYPE_ns4__ArrayOfEntityVO:
		return soap_in_ns4__ArrayOfEntityVO(soap, NULL, NULL, "ns4:ArrayOfEntityVO");
	case SOAP_TYPE_ns4__CommentVO:
		return soap_in_ns4__CommentVO(soap, NULL, NULL, "ns4:CommentVO");
	case SOAP_TYPE_ns4__ArrayOfDictionaryVO:
		return soap_in_ns4__ArrayOfDictionaryVO(soap, NULL, NULL, "ns4:ArrayOfDictionaryVO");
	case SOAP_TYPE_ns4__ArrayOfERelationVO:
		return soap_in_ns4__ArrayOfERelationVO(soap, NULL, NULL, "ns4:ArrayOfERelationVO");
	case SOAP_TYPE_ns4__DictionaryVO:
		return soap_in_ns4__DictionaryVO(soap, NULL, NULL, "ns4:DictionaryVO");
	case SOAP_TYPE_ns4__PPTVO:
		return soap_in_ns4__PPTVO(soap, NULL, NULL, "ns4:PPTVO");
	case SOAP_TYPE_ns4__ArrayOfPPTVO:
		return soap_in_ns4__ArrayOfPPTVO(soap, NULL, NULL, "ns4:ArrayOfPPTVO");
	case SOAP_TYPE_ns4__ContainerVO:
		return soap_in_ns4__ContainerVO(soap, NULL, NULL, "ns4:ContainerVO");
	case SOAP_TYPE_ns4__ArrayOfContainerVO:
		return soap_in_ns4__ArrayOfContainerVO(soap, NULL, NULL, "ns4:ArrayOfContainerVO");
	case SOAP_TYPE_ns4__ArrayOfPPTSlideVO:
		return soap_in_ns4__ArrayOfPPTSlideVO(soap, NULL, NULL, "ns4:ArrayOfPPTSlideVO");
	case SOAP_TYPE_ns4__ERelationVO:
		return soap_in_ns4__ERelationVO(soap, NULL, NULL, "ns4:ERelationVO");
	case SOAP_TYPE_ns4__ImageVO:
		return soap_in_ns4__ImageVO(soap, NULL, NULL, "ns4:ImageVO");
	case SOAP_TYPE_ns4__ArrayOfEActivityVO:
		return soap_in_ns4__ArrayOfEActivityVO(soap, NULL, NULL, "ns4:ArrayOfEActivityVO");
	case SOAP_TYPE_ns4__PPTSlideVO:
		return soap_in_ns4__PPTSlideVO(soap, NULL, NULL, "ns4:PPTSlideVO");
	case SOAP_TYPE_ns4__EActivityVO:
		return soap_in_ns4__EActivityVO(soap, NULL, NULL, "ns4:EActivityVO");
	case SOAP_TYPE_ns4__UserVO:
		return soap_in_ns4__UserVO(soap, NULL, NULL, "ns4:UserVO");
	case SOAP_TYPE_ns4__FeedbackVO:
		return soap_in_ns4__FeedbackVO(soap, NULL, NULL, "ns4:FeedbackVO");
	case SOAP_TYPE_ns4__ArrayOfFeedbackVO:
		return soap_in_ns4__ArrayOfFeedbackVO(soap, NULL, NULL, "ns4:ArrayOfFeedbackVO");
	case SOAP_TYPE_ns4__EntityVO:
		return soap_in_ns4__EntityVO(soap, NULL, NULL, "ns4:EntityVO");
	case SOAP_TYPE_ns4__ESignatureVO:
		return soap_in_ns4__ESignatureVO(soap, NULL, NULL, "ns4:ESignatureVO");
	case SOAP_TYPE_ns4__ArrayOfESignatureVO:
		return soap_in_ns4__ArrayOfESignatureVO(soap, NULL, NULL, "ns4:ArrayOfESignatureVO");
	case SOAP_TYPE_ns1__ArrayOfLong:
		return soap_in_ns1__ArrayOfLong(soap, NULL, NULL, "ns1:ArrayOfLong");
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		return soap_in_ns1__ArrayOfDateTime(soap, NULL, NULL, "ns1:ArrayOfDateTime");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__anyType2anyTypeMap:
		return soap_in_ns1__anyType2anyTypeMap(soap, NULL, NULL, "ns1:anyType2anyTypeMap");
	case SOAP_TYPE_ns3__OperatorIntf:
		return soap_in_ns3__OperatorIntf(soap, NULL, NULL, "ns3:OperatorIntf");
	case SOAP_TYPE_ns3__ArrayOfDBColumn:
		return soap_in_ns3__ArrayOfDBColumn(soap, NULL, NULL, "ns3:ArrayOfDBColumn");
	case SOAP_TYPE_ns3__SKSObject:
		return soap_in_ns3__SKSObject(soap, NULL, NULL, "ns3:SKSObject");
	case SOAP_TYPE_ns3__ArrayOfSKSObject:
		return soap_in_ns3__ArrayOfSKSObject(soap, NULL, NULL, "ns3:ArrayOfSKSObject");
	case SOAP_TYPE_ns3__ColumnOperatorIntf:
		return soap_in_ns3__ColumnOperatorIntf(soap, NULL, NULL, "ns3:ColumnOperatorIntf");
	case SOAP_TYPE_ns3__ScalarIntf:
		return soap_in_ns3__ScalarIntf(soap, NULL, NULL, "ns3:ScalarIntf");
	case SOAP_TYPE_ns3__DBColumn:
		return soap_in_ns3__DBColumn(soap, NULL, NULL, "ns3:DBColumn");
	case SOAP_TYPE_ns2__QueryColumn:
		return soap_in_ns2__QueryColumn(soap, NULL, NULL, "ns2:QueryColumn");
	case SOAP_TYPE_ns2__ArrayOfQueryColumn:
		return soap_in_ns2__ArrayOfQueryColumn(soap, NULL, NULL, "ns2:ArrayOfQueryColumn");
	case SOAP_TYPE_ns2__ReturnColumn:
		return soap_in_ns2__ReturnColumn(soap, NULL, NULL, "ns2:ReturnColumn");
	case SOAP_TYPE_ns2__ArrayOfReturnColumn:
		return soap_in_ns2__ArrayOfReturnColumn(soap, NULL, NULL, "ns2:ArrayOfReturnColumn");
	case SOAP_TYPE_ns2__LimitOffset:
		return soap_in_ns2__LimitOffset(soap, NULL, NULL, "ns2:LimitOffset");
	case SOAP_TYPE_ns2__OrderColumn:
		return soap_in_ns2__OrderColumn(soap, NULL, NULL, "ns2:OrderColumn");
	case SOAP_TYPE_ns2__ArrayOfOrderColumn:
		return soap_in_ns2__ArrayOfOrderColumn(soap, NULL, NULL, "ns2:ArrayOfOrderColumn");
	case SOAP_TYPE_ns2__SKSQuery:
		return soap_in_ns2__SKSQuery(soap, NULL, NULL, "ns2:SKSQuery");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return soap_in_xsd__decimal_(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return soap_in_xsd__base64Binary_(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns1__create4Response:
		return soap_in_PointerTo_ns1__create4Response(soap, NULL, NULL, "ns1:create4Response");
	case SOAP_TYPE_PointerTo_ns1__create4:
		return soap_in_PointerTo_ns1__create4(soap, NULL, NULL, "ns1:create4");
	case SOAP_TYPE_PointerTo_ns1__create9Response:
		return soap_in_PointerTo_ns1__create9Response(soap, NULL, NULL, "ns1:create9Response");
	case SOAP_TYPE_PointerTo_ns1__create9:
		return soap_in_PointerTo_ns1__create9(soap, NULL, NULL, "ns1:create9");
	case SOAP_TYPE_PointerTo_ns1__findByPK11Response:
		return soap_in_PointerTo_ns1__findByPK11Response(soap, NULL, NULL, "ns1:findByPK11Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK11:
		return soap_in_PointerTo_ns1__findByPK11(soap, NULL, NULL, "ns1:findByPK11");
	case SOAP_TYPE_PointerTo_ns1__update1Response:
		return soap_in_PointerTo_ns1__update1Response(soap, NULL, NULL, "ns1:update1Response");
	case SOAP_TYPE_PointerTo_ns1__update1:
		return soap_in_PointerTo_ns1__update1(soap, NULL, NULL, "ns1:update1");
	case SOAP_TYPE_PointerTo_ns1__create10Response:
		return soap_in_PointerTo_ns1__create10Response(soap, NULL, NULL, "ns1:create10Response");
	case SOAP_TYPE_PointerTo_ns1__create10:
		return soap_in_PointerTo_ns1__create10(soap, NULL, NULL, "ns1:create10");
	case SOAP_TYPE_PointerTo_ns1__findByPK1Response:
		return soap_in_PointerTo_ns1__findByPK1Response(soap, NULL, NULL, "ns1:findByPK1Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK1:
		return soap_in_PointerTo_ns1__findByPK1(soap, NULL, NULL, "ns1:findByPK1");
	case SOAP_TYPE_PointerTo_ns1__removeResponse:
		return soap_in_PointerTo_ns1__removeResponse(soap, NULL, NULL, "ns1:removeResponse");
	case SOAP_TYPE_PointerTo_ns1__remove:
		return soap_in_PointerTo_ns1__remove(soap, NULL, NULL, "ns1:remove");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnCommentVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnCommentVO");
	case SOAP_TYPE_PointerTo_ns1__findByPK10Response:
		return soap_in_PointerTo_ns1__findByPK10Response(soap, NULL, NULL, "ns1:findByPK10Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK10:
		return soap_in_PointerTo_ns1__findByPK10(soap, NULL, NULL, "ns1:findByPK10");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnImageVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnImageVO");
	case SOAP_TYPE_PointerTo_ns1__update2Response:
		return soap_in_PointerTo_ns1__update2Response(soap, NULL, NULL, "ns1:update2Response");
	case SOAP_TYPE_PointerTo_ns1__update2:
		return soap_in_PointerTo_ns1__update2(soap, NULL, NULL, "ns1:update2");
	case SOAP_TYPE_PointerTo_ns1__findByPK3Response:
		return soap_in_PointerTo_ns1__findByPK3Response(soap, NULL, NULL, "ns1:findByPK3Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK3:
		return soap_in_PointerTo_ns1__findByPK3(soap, NULL, NULL, "ns1:findByPK3");
	case SOAP_TYPE_PointerTo_ns1__update5Response:
		return soap_in_PointerTo_ns1__update5Response(soap, NULL, NULL, "ns1:update5Response");
	case SOAP_TYPE_PointerTo_ns1__update5:
		return soap_in_PointerTo_ns1__update5(soap, NULL, NULL, "ns1:update5");
	case SOAP_TYPE_PointerTo_ns1__remove2Response:
		return soap_in_PointerTo_ns1__remove2Response(soap, NULL, NULL, "ns1:remove2Response");
	case SOAP_TYPE_PointerTo_ns1__remove2:
		return soap_in_PointerTo_ns1__remove2(soap, NULL, NULL, "ns1:remove2");
	case SOAP_TYPE_PointerTo_ns1__create5Response:
		return soap_in_PointerTo_ns1__create5Response(soap, NULL, NULL, "ns1:create5Response");
	case SOAP_TYPE_PointerTo_ns1__create5:
		return soap_in_PointerTo_ns1__create5(soap, NULL, NULL, "ns1:create5");
	case SOAP_TYPE_PointerTo_ns1__remove11Response:
		return soap_in_PointerTo_ns1__remove11Response(soap, NULL, NULL, "ns1:remove11Response");
	case SOAP_TYPE_PointerTo_ns1__remove11:
		return soap_in_PointerTo_ns1__remove11(soap, NULL, NULL, "ns1:remove11");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnUserVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnUserVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnEntityVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnEntityVO");
	case SOAP_TYPE_PointerTo_ns1__createResponse:
		return soap_in_PointerTo_ns1__createResponse(soap, NULL, NULL, "ns1:createResponse");
	case SOAP_TYPE_PointerTo_ns1__create:
		return soap_in_PointerTo_ns1__create(soap, NULL, NULL, "ns1:create");
	case SOAP_TYPE_PointerTo_ns1__remove1Response:
		return soap_in_PointerTo_ns1__remove1Response(soap, NULL, NULL, "ns1:remove1Response");
	case SOAP_TYPE_PointerTo_ns1__remove1:
		return soap_in_PointerTo_ns1__remove1(soap, NULL, NULL, "ns1:remove1");
	case SOAP_TYPE_PointerTo_ns1__findByPK7Response:
		return soap_in_PointerTo_ns1__findByPK7Response(soap, NULL, NULL, "ns1:findByPK7Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK7:
		return soap_in_PointerTo_ns1__findByPK7(soap, NULL, NULL, "ns1:findByPK7");
	case SOAP_TYPE_PointerTo_ns1__echoStringResponse:
		return soap_in_PointerTo_ns1__echoStringResponse(soap, NULL, NULL, "ns1:echoStringResponse");
	case SOAP_TYPE_PointerTo_ns1__echoString:
		return soap_in_PointerTo_ns1__echoString(soap, NULL, NULL, "ns1:echoString");
	case SOAP_TYPE_PointerTo_ns1__create2Response:
		return soap_in_PointerTo_ns1__create2Response(soap, NULL, NULL, "ns1:create2Response");
	case SOAP_TYPE_PointerTo_ns1__create2:
		return soap_in_PointerTo_ns1__create2(soap, NULL, NULL, "ns1:create2");
	case SOAP_TYPE_PointerTo_ns1__findByPK6Response:
		return soap_in_PointerTo_ns1__findByPK6Response(soap, NULL, NULL, "ns1:findByPK6Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK6:
		return soap_in_PointerTo_ns1__findByPK6(soap, NULL, NULL, "ns1:findByPK6");
	case SOAP_TYPE_PointerTo_ns1__updateResponse:
		return soap_in_PointerTo_ns1__updateResponse(soap, NULL, NULL, "ns1:updateResponse");
	case SOAP_TYPE_PointerTo_ns1__update:
		return soap_in_PointerTo_ns1__update(soap, NULL, NULL, "ns1:update");
	case SOAP_TYPE_PointerTo_ns1__remove10Response:
		return soap_in_PointerTo_ns1__remove10Response(soap, NULL, NULL, "ns1:remove10Response");
	case SOAP_TYPE_PointerTo_ns1__remove10:
		return soap_in_PointerTo_ns1__remove10(soap, NULL, NULL, "ns1:remove10");
	case SOAP_TYPE_PointerTo_ns1__create3Response:
		return soap_in_PointerTo_ns1__create3Response(soap, NULL, NULL, "ns1:create3Response");
	case SOAP_TYPE_PointerTo_ns1__create3:
		return soap_in_PointerTo_ns1__create3(soap, NULL, NULL, "ns1:create3");
	case SOAP_TYPE_PointerTo_ns1__findByPKResponse:
		return soap_in_PointerTo_ns1__findByPKResponse(soap, NULL, NULL, "ns1:findByPKResponse");
	case SOAP_TYPE_PointerTo_ns1__findByPK:
		return soap_in_PointerTo_ns1__findByPK(soap, NULL, NULL, "ns1:findByPK");
	case SOAP_TYPE_PointerTo_ns1__update6Response:
		return soap_in_PointerTo_ns1__update6Response(soap, NULL, NULL, "ns1:update6Response");
	case SOAP_TYPE_PointerTo_ns1__update6:
		return soap_in_PointerTo_ns1__update6(soap, NULL, NULL, "ns1:update6");
	case SOAP_TYPE_PointerTo_ns1__update9Response:
		return soap_in_PointerTo_ns1__update9Response(soap, NULL, NULL, "ns1:update9Response");
	case SOAP_TYPE_PointerTo_ns1__update9:
		return soap_in_PointerTo_ns1__update9(soap, NULL, NULL, "ns1:update9");
	case SOAP_TYPE_PointerTo_ns1__update11Response:
		return soap_in_PointerTo_ns1__update11Response(soap, NULL, NULL, "ns1:update11Response");
	case SOAP_TYPE_PointerTo_ns1__update11:
		return soap_in_PointerTo_ns1__update11(soap, NULL, NULL, "ns1:update11");
	case SOAP_TYPE_PointerTo_ns1__remove7Response:
		return soap_in_PointerTo_ns1__remove7Response(soap, NULL, NULL, "ns1:remove7Response");
	case SOAP_TYPE_PointerTo_ns1__remove7:
		return soap_in_PointerTo_ns1__remove7(soap, NULL, NULL, "ns1:remove7");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnDictionaryVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnDictionaryVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnERelationVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnERelationVO");
	case SOAP_TYPE_PointerTo_ns1__findByPK4Response:
		return soap_in_PointerTo_ns1__findByPK4Response(soap, NULL, NULL, "ns1:findByPK4Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK4:
		return soap_in_PointerTo_ns1__findByPK4(soap, NULL, NULL, "ns1:findByPK4");
	case SOAP_TYPE_PointerTo_ns1__findByPK9Response:
		return soap_in_PointerTo_ns1__findByPK9Response(soap, NULL, NULL, "ns1:findByPK9Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK9:
		return soap_in_PointerTo_ns1__findByPK9(soap, NULL, NULL, "ns1:findByPK9");
	case SOAP_TYPE_PointerTo_ns1__update10Response:
		return soap_in_PointerTo_ns1__update10Response(soap, NULL, NULL, "ns1:update10Response");
	case SOAP_TYPE_PointerTo_ns1__update10:
		return soap_in_PointerTo_ns1__update10(soap, NULL, NULL, "ns1:update10");
	case SOAP_TYPE_PointerTo_ns1__update8Response:
		return soap_in_PointerTo_ns1__update8Response(soap, NULL, NULL, "ns1:update8Response");
	case SOAP_TYPE_PointerTo_ns1__update8:
		return soap_in_PointerTo_ns1__update8(soap, NULL, NULL, "ns1:update8");
	case SOAP_TYPE_PointerTo_ns1__create1Response:
		return soap_in_PointerTo_ns1__create1Response(soap, NULL, NULL, "ns1:create1Response");
	case SOAP_TYPE_PointerTo_ns1__create1:
		return soap_in_PointerTo_ns1__create1(soap, NULL, NULL, "ns1:create1");
	case SOAP_TYPE_PointerTo_ns1__remove8Response:
		return soap_in_PointerTo_ns1__remove8Response(soap, NULL, NULL, "ns1:remove8Response");
	case SOAP_TYPE_PointerTo_ns1__remove8:
		return soap_in_PointerTo_ns1__remove8(soap, NULL, NULL, "ns1:remove8");
	case SOAP_TYPE_PointerTo_ns1__update7Response:
		return soap_in_PointerTo_ns1__update7Response(soap, NULL, NULL, "ns1:update7Response");
	case SOAP_TYPE_PointerTo_ns1__update7:
		return soap_in_PointerTo_ns1__update7(soap, NULL, NULL, "ns1:update7");
	case SOAP_TYPE_PointerTo_ns1__remove5Response:
		return soap_in_PointerTo_ns1__remove5Response(soap, NULL, NULL, "ns1:remove5Response");
	case SOAP_TYPE_PointerTo_ns1__remove5:
		return soap_in_PointerTo_ns1__remove5(soap, NULL, NULL, "ns1:remove5");
	case SOAP_TYPE_PointerTo_ns1__remove4Response:
		return soap_in_PointerTo_ns1__remove4Response(soap, NULL, NULL, "ns1:remove4Response");
	case SOAP_TYPE_PointerTo_ns1__remove4:
		return soap_in_PointerTo_ns1__remove4(soap, NULL, NULL, "ns1:remove4");
	case SOAP_TYPE_PointerTo_ns1__create7Response:
		return soap_in_PointerTo_ns1__create7Response(soap, NULL, NULL, "ns1:create7Response");
	case SOAP_TYPE_PointerTo_ns1__create7:
		return soap_in_PointerTo_ns1__create7(soap, NULL, NULL, "ns1:create7");
	case SOAP_TYPE_PointerTo_ns1__findByPK2Response:
		return soap_in_PointerTo_ns1__findByPK2Response(soap, NULL, NULL, "ns1:findByPK2Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK2:
		return soap_in_PointerTo_ns1__findByPK2(soap, NULL, NULL, "ns1:findByPK2");
	case SOAP_TYPE_PointerTo_ns1__generateSQLQueryResponse:
		return soap_in_PointerTo_ns1__generateSQLQueryResponse(soap, NULL, NULL, "ns1:generateSQLQueryResponse");
	case SOAP_TYPE_PointerTo_ns1__generateSQLQuery:
		return soap_in_PointerTo_ns1__generateSQLQuery(soap, NULL, NULL, "ns1:generateSQLQuery");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnPPTVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnPPTVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnContainerVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnContainerVO");
	case SOAP_TYPE_PointerTo_ns1__create6Response:
		return soap_in_PointerTo_ns1__create6Response(soap, NULL, NULL, "ns1:create6Response");
	case SOAP_TYPE_PointerTo_ns1__create6:
		return soap_in_PointerTo_ns1__create6(soap, NULL, NULL, "ns1:create6");
	case SOAP_TYPE_PointerTo_ns1__findByPK5Response:
		return soap_in_PointerTo_ns1__findByPK5Response(soap, NULL, NULL, "ns1:findByPK5Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK5:
		return soap_in_PointerTo_ns1__findByPK5(soap, NULL, NULL, "ns1:findByPK5");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnPPTSlideVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnPPTSlideVO");
	case SOAP_TYPE_PointerTo_ns1__update4Response:
		return soap_in_PointerTo_ns1__update4Response(soap, NULL, NULL, "ns1:update4Response");
	case SOAP_TYPE_PointerTo_ns1__update4:
		return soap_in_PointerTo_ns1__update4(soap, NULL, NULL, "ns1:update4");
	case SOAP_TYPE_PointerTo_ns1__create8Response:
		return soap_in_PointerTo_ns1__create8Response(soap, NULL, NULL, "ns1:create8Response");
	case SOAP_TYPE_PointerTo_ns1__create8:
		return soap_in_PointerTo_ns1__create8(soap, NULL, NULL, "ns1:create8");
	case SOAP_TYPE_PointerTo_ns1__findByPK8Response:
		return soap_in_PointerTo_ns1__findByPK8Response(soap, NULL, NULL, "ns1:findByPK8Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK8:
		return soap_in_PointerTo_ns1__findByPK8(soap, NULL, NULL, "ns1:findByPK8");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnEActivityVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnEActivityVO");
	case SOAP_TYPE_PointerTo_ns1__remove9Response:
		return soap_in_PointerTo_ns1__remove9Response(soap, NULL, NULL, "ns1:remove9Response");
	case SOAP_TYPE_PointerTo_ns1__remove9:
		return soap_in_PointerTo_ns1__remove9(soap, NULL, NULL, "ns1:remove9");
	case SOAP_TYPE_PointerTo_ns1__create11Response:
		return soap_in_PointerTo_ns1__create11Response(soap, NULL, NULL, "ns1:create11Response");
	case SOAP_TYPE_PointerTo_ns1__create11:
		return soap_in_PointerTo_ns1__create11(soap, NULL, NULL, "ns1:create11");
	case SOAP_TYPE_PointerTo_ns1__update3Response:
		return soap_in_PointerTo_ns1__update3Response(soap, NULL, NULL, "ns1:update3Response");
	case SOAP_TYPE_PointerTo_ns1__update3:
		return soap_in_PointerTo_ns1__update3(soap, NULL, NULL, "ns1:update3");
	case SOAP_TYPE_PointerTo_ns1__remove6Response:
		return soap_in_PointerTo_ns1__remove6Response(soap, NULL, NULL, "ns1:remove6Response");
	case SOAP_TYPE_PointerTo_ns1__remove6:
		return soap_in_PointerTo_ns1__remove6(soap, NULL, NULL, "ns1:remove6");
	case SOAP_TYPE_PointerTo_ns1__remove3Response:
		return soap_in_PointerTo_ns1__remove3Response(soap, NULL, NULL, "ns1:remove3Response");
	case SOAP_TYPE_PointerTo_ns1__remove3:
		return soap_in_PointerTo_ns1__remove3(soap, NULL, NULL, "ns1:remove3");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnFeedbackVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnFeedbackVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(soap, NULL, NULL, "ns1:findBySQLQueryReturnESignatureVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVO:
		return soap_in_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, NULL, NULL, "ns1:findBySQLQueryReturnESignatureVO");
	case SOAP_TYPE_PointerTons5__SKSWSException:
		return soap_in_PointerTons5__SKSWSException(soap, NULL, NULL, "ns5:SKSWSException");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTons4__ArrayOfCommentVO:
		return soap_in_PointerTons4__ArrayOfCommentVO(soap, NULL, NULL, "ns4:ArrayOfCommentVO");
	case SOAP_TYPE_PointerTons4__ArrayOfImageVO:
		return soap_in_PointerTons4__ArrayOfImageVO(soap, NULL, NULL, "ns4:ArrayOfImageVO");
	case SOAP_TYPE_PointerTons4__ArrayOfUserVO:
		return soap_in_PointerTons4__ArrayOfUserVO(soap, NULL, NULL, "ns4:ArrayOfUserVO");
	case SOAP_TYPE_PointerTons4__ArrayOfEntityVO:
		return soap_in_PointerTons4__ArrayOfEntityVO(soap, NULL, NULL, "ns4:ArrayOfEntityVO");
	case SOAP_TYPE_PointerTons4__CommentVO:
		return soap_in_PointerTons4__CommentVO(soap, NULL, NULL, "ns4:CommentVO");
	case SOAP_TYPE_PointerTons4__ArrayOfDictionaryVO:
		return soap_in_PointerTons4__ArrayOfDictionaryVO(soap, NULL, NULL, "ns4:ArrayOfDictionaryVO");
	case SOAP_TYPE_PointerTons4__ArrayOfERelationVO:
		return soap_in_PointerTons4__ArrayOfERelationVO(soap, NULL, NULL, "ns4:ArrayOfERelationVO");
	case SOAP_TYPE_PointerTons4__PPTVO:
		return soap_in_PointerTons4__PPTVO(soap, NULL, NULL, "ns4:PPTVO");
	case SOAP_TYPE_PointerTons4__ContainerVO:
		return soap_in_PointerTons4__ContainerVO(soap, NULL, NULL, "ns4:ContainerVO");
	case SOAP_TYPE_PointerTons4__FeedbackVO:
		return soap_in_PointerTons4__FeedbackVO(soap, NULL, NULL, "ns4:FeedbackVO");
	case SOAP_TYPE_PointerTons4__DictionaryVO:
		return soap_in_PointerTons4__DictionaryVO(soap, NULL, NULL, "ns4:DictionaryVO");
	case SOAP_TYPE_PointerTons4__ArrayOfPPTVO:
		return soap_in_PointerTons4__ArrayOfPPTVO(soap, NULL, NULL, "ns4:ArrayOfPPTVO");
	case SOAP_TYPE_PointerTons4__ArrayOfContainerVO:
		return soap_in_PointerTons4__ArrayOfContainerVO(soap, NULL, NULL, "ns4:ArrayOfContainerVO");
	case SOAP_TYPE_PointerTons4__ESignatureVO:
		return soap_in_PointerTons4__ESignatureVO(soap, NULL, NULL, "ns4:ESignatureVO");
	case SOAP_TYPE_PointerTons4__ArrayOfPPTSlideVO:
		return soap_in_PointerTons4__ArrayOfPPTSlideVO(soap, NULL, NULL, "ns4:ArrayOfPPTSlideVO");
	case SOAP_TYPE_PointerTons4__ERelationVO:
		return soap_in_PointerTons4__ERelationVO(soap, NULL, NULL, "ns4:ERelationVO");
	case SOAP_TYPE_PointerTons4__ImageVO:
		return soap_in_PointerTons4__ImageVO(soap, NULL, NULL, "ns4:ImageVO");
	case SOAP_TYPE_PointerTons4__ArrayOfEActivityVO:
		return soap_in_PointerTons4__ArrayOfEActivityVO(soap, NULL, NULL, "ns4:ArrayOfEActivityVO");
	case SOAP_TYPE_PointerTons4__PPTSlideVO:
		return soap_in_PointerTons4__PPTSlideVO(soap, NULL, NULL, "ns4:PPTSlideVO");
	case SOAP_TYPE_PointerTons4__UserVO:
		return soap_in_PointerTons4__UserVO(soap, NULL, NULL, "ns4:UserVO");
	case SOAP_TYPE_PointerTons4__EntityVO:
		return soap_in_PointerTons4__EntityVO(soap, NULL, NULL, "ns4:EntityVO");
	case SOAP_TYPE_PointerTons4__EActivityVO:
		return soap_in_PointerTons4__EActivityVO(soap, NULL, NULL, "ns4:EActivityVO");
	case SOAP_TYPE_PointerTons4__ArrayOfFeedbackVO:
		return soap_in_PointerTons4__ArrayOfFeedbackVO(soap, NULL, NULL, "ns4:ArrayOfFeedbackVO");
	case SOAP_TYPE_PointerTons4__ArrayOfESignatureVO:
		return soap_in_PointerTons4__ArrayOfESignatureVO(soap, NULL, NULL, "ns4:ArrayOfESignatureVO");
	case SOAP_TYPE_PointerTons2__SKSQuery:
		return soap_in_PointerTons2__SKSQuery(soap, NULL, NULL, "ns2:SKSQuery");
	case SOAP_TYPE_PointerTo_ns1__anyType2anyTypeMap_entry:
		return soap_in_PointerTo_ns1__anyType2anyTypeMap_entry(soap, NULL, NULL, "ns1:anyType2anyTypeMap-entry");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__anyType2anyTypeMap:
		return soap_in_PointerTons1__anyType2anyTypeMap(soap, NULL, NULL, "ns1:anyType2anyTypeMap");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__ArrayOfDateTime:
		return soap_in_PointerTons1__ArrayOfDateTime(soap, NULL, NULL, "ns1:ArrayOfDateTime");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons3__OperatorIntf:
		return soap_in_PointerTons3__OperatorIntf(soap, NULL, NULL, "ns3:OperatorIntf");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons1__ArrayOfLong:
		return soap_in_PointerTons1__ArrayOfLong(soap, NULL, NULL, "ns1:ArrayOfLong");
	case SOAP_TYPE_PointerTons2__QueryColumn:
		return soap_in_PointerTons2__QueryColumn(soap, NULL, NULL, "ns2:QueryColumn");
	case SOAP_TYPE_PointerTons3__ColumnOperatorIntf:
		return soap_in_PointerTons3__ColumnOperatorIntf(soap, NULL, NULL, "ns3:ColumnOperatorIntf");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons3__ScalarIntf:
		return soap_in_PointerTons3__ScalarIntf(soap, NULL, NULL, "ns3:ScalarIntf");
	case SOAP_TYPE_PointerTons2__ReturnColumn:
		return soap_in_PointerTons2__ReturnColumn(soap, NULL, NULL, "ns2:ReturnColumn");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons2__Order:
		return soap_in_PointerTons2__Order(soap, NULL, NULL, "ns2:Order");
	case SOAP_TYPE_PointerTons3__DBColumn:
		return soap_in_PointerTons3__DBColumn(soap, NULL, NULL, "ns3:DBColumn");
	case SOAP_TYPE_PointerTons2__OrderColumn:
		return soap_in_PointerTons2__OrderColumn(soap, NULL, NULL, "ns2:OrderColumn");
	case SOAP_TYPE_PointerTons2__ArrayOfReturnColumn:
		return soap_in_PointerTons2__ArrayOfReturnColumn(soap, NULL, NULL, "ns2:ArrayOfReturnColumn");
	case SOAP_TYPE_PointerTons3__SKSObject:
		return soap_in_PointerTons3__SKSObject(soap, NULL, NULL, "ns3:SKSObject");
	case SOAP_TYPE_PointerTons2__ArrayOfQueryColumn:
		return soap_in_PointerTons2__ArrayOfQueryColumn(soap, NULL, NULL, "ns2:ArrayOfQueryColumn");
	case SOAP_TYPE_PointerTons2__ArrayOfOrderColumn:
		return soap_in_PointerTons2__ArrayOfOrderColumn(soap, NULL, NULL, "ns2:ArrayOfOrderColumn");
	case SOAP_TYPE_PointerTons2__LimitOffset:
		return soap_in_PointerTons2__LimitOffset(soap, NULL, NULL, "ns2:LimitOffset");
	case SOAP_TYPE_PointerTons3__ArrayOfDBColumn:
		return soap_in_PointerTons3__ArrayOfDBColumn(soap, NULL, NULL, "ns3:ArrayOfDBColumn");
	case SOAP_TYPE_PointerTons3__ArrayOfSKSObject:
		return soap_in_PointerTons3__ArrayOfSKSObject(soap, NULL, NULL, "ns3:ArrayOfSKSObject");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Order"))
		{	*type = SOAP_TYPE_ns2__Order;
			return soap_in_ns2__Order(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Order"))
		{	*type = SOAP_TYPE_ns2__Order_;
			return soap_in_ns2__Order_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SKSWSException"))
		{	*type = SOAP_TYPE_ns5__SKSWSException;
			return soap_in_ns5__SKSWSException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfCommentVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfCommentVO;
			return soap_in_ns4__ArrayOfCommentVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfImageVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfImageVO;
			return soap_in_ns4__ArrayOfImageVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfUserVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfUserVO;
			return soap_in_ns4__ArrayOfUserVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfEntityVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfEntityVO;
			return soap_in_ns4__ArrayOfEntityVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CommentVO"))
		{	*type = SOAP_TYPE_ns4__CommentVO;
			return soap_in_ns4__CommentVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfDictionaryVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfDictionaryVO;
			return soap_in_ns4__ArrayOfDictionaryVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfERelationVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfERelationVO;
			return soap_in_ns4__ArrayOfERelationVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DictionaryVO"))
		{	*type = SOAP_TYPE_ns4__DictionaryVO;
			return soap_in_ns4__DictionaryVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PPTVO"))
		{	*type = SOAP_TYPE_ns4__PPTVO;
			return soap_in_ns4__PPTVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfPPTVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfPPTVO;
			return soap_in_ns4__ArrayOfPPTVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ContainerVO"))
		{	*type = SOAP_TYPE_ns4__ContainerVO;
			return soap_in_ns4__ContainerVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfContainerVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfContainerVO;
			return soap_in_ns4__ArrayOfContainerVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfPPTSlideVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfPPTSlideVO;
			return soap_in_ns4__ArrayOfPPTSlideVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ERelationVO"))
		{	*type = SOAP_TYPE_ns4__ERelationVO;
			return soap_in_ns4__ERelationVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ImageVO"))
		{	*type = SOAP_TYPE_ns4__ImageVO;
			return soap_in_ns4__ImageVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfEActivityVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfEActivityVO;
			return soap_in_ns4__ArrayOfEActivityVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PPTSlideVO"))
		{	*type = SOAP_TYPE_ns4__PPTSlideVO;
			return soap_in_ns4__PPTSlideVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:EActivityVO"))
		{	*type = SOAP_TYPE_ns4__EActivityVO;
			return soap_in_ns4__EActivityVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UserVO"))
		{	*type = SOAP_TYPE_ns4__UserVO;
			return soap_in_ns4__UserVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FeedbackVO"))
		{	*type = SOAP_TYPE_ns4__FeedbackVO;
			return soap_in_ns4__FeedbackVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfFeedbackVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfFeedbackVO;
			return soap_in_ns4__ArrayOfFeedbackVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:EntityVO"))
		{	*type = SOAP_TYPE_ns4__EntityVO;
			return soap_in_ns4__EntityVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ESignatureVO"))
		{	*type = SOAP_TYPE_ns4__ESignatureVO;
			return soap_in_ns4__ESignatureVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfESignatureVO"))
		{	*type = SOAP_TYPE_ns4__ArrayOfESignatureVO;
			return soap_in_ns4__ArrayOfESignatureVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfLong"))
		{	*type = SOAP_TYPE_ns1__ArrayOfLong;
			return soap_in_ns1__ArrayOfLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDateTime"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDateTime;
			return soap_in_ns1__ArrayOfDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:anyType2anyTypeMap"))
		{	*type = SOAP_TYPE_ns1__anyType2anyTypeMap;
			return soap_in_ns1__anyType2anyTypeMap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:OperatorIntf"))
		{	*type = SOAP_TYPE_ns3__OperatorIntf;
			return soap_in_ns3__OperatorIntf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfDBColumn"))
		{	*type = SOAP_TYPE_ns3__ArrayOfDBColumn;
			return soap_in_ns3__ArrayOfDBColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SKSObject"))
		{	*type = SOAP_TYPE_ns3__SKSObject;
			return soap_in_ns3__SKSObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfSKSObject"))
		{	*type = SOAP_TYPE_ns3__ArrayOfSKSObject;
			return soap_in_ns3__ArrayOfSKSObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ColumnOperatorIntf"))
		{	*type = SOAP_TYPE_ns3__ColumnOperatorIntf;
			return soap_in_ns3__ColumnOperatorIntf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ScalarIntf"))
		{	*type = SOAP_TYPE_ns3__ScalarIntf;
			return soap_in_ns3__ScalarIntf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DBColumn"))
		{	*type = SOAP_TYPE_ns3__DBColumn;
			return soap_in_ns3__DBColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:QueryColumn"))
		{	*type = SOAP_TYPE_ns2__QueryColumn;
			return soap_in_ns2__QueryColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArrayOfQueryColumn"))
		{	*type = SOAP_TYPE_ns2__ArrayOfQueryColumn;
			return soap_in_ns2__ArrayOfQueryColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReturnColumn"))
		{	*type = SOAP_TYPE_ns2__ReturnColumn;
			return soap_in_ns2__ReturnColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArrayOfReturnColumn"))
		{	*type = SOAP_TYPE_ns2__ArrayOfReturnColumn;
			return soap_in_ns2__ArrayOfReturnColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LimitOffset"))
		{	*type = SOAP_TYPE_ns2__LimitOffset;
			return soap_in_ns2__LimitOffset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OrderColumn"))
		{	*type = SOAP_TYPE_ns2__OrderColumn;
			return soap_in_ns2__OrderColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArrayOfOrderColumn"))
		{	*type = SOAP_TYPE_ns2__ArrayOfOrderColumn;
			return soap_in_ns2__ArrayOfOrderColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SKSQuery"))
		{	*type = SOAP_TYPE_ns2__SKSQuery;
			return soap_in_ns2__SKSQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal_;
			return soap_in_xsd__decimal_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary_;
			return soap_in_xsd__base64Binary_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:create4Response"))
		{	*type = SOAP_TYPE__ns1__create4Response;
			return soap_in__ns1__create4Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create4"))
		{	*type = SOAP_TYPE__ns1__create4;
			return soap_in__ns1__create4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create9Response"))
		{	*type = SOAP_TYPE__ns1__create9Response;
			return soap_in__ns1__create9Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create9"))
		{	*type = SOAP_TYPE__ns1__create9;
			return soap_in__ns1__create9(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK11Response"))
		{	*type = SOAP_TYPE__ns1__findByPK11Response;
			return soap_in__ns1__findByPK11Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK11"))
		{	*type = SOAP_TYPE__ns1__findByPK11;
			return soap_in__ns1__findByPK11(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update1Response"))
		{	*type = SOAP_TYPE__ns1__update1Response;
			return soap_in__ns1__update1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update1"))
		{	*type = SOAP_TYPE__ns1__update1;
			return soap_in__ns1__update1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create10Response"))
		{	*type = SOAP_TYPE__ns1__create10Response;
			return soap_in__ns1__create10Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create10"))
		{	*type = SOAP_TYPE__ns1__create10;
			return soap_in__ns1__create10(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK1Response"))
		{	*type = SOAP_TYPE__ns1__findByPK1Response;
			return soap_in__ns1__findByPK1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK1"))
		{	*type = SOAP_TYPE__ns1__findByPK1;
			return soap_in__ns1__findByPK1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeResponse"))
		{	*type = SOAP_TYPE__ns1__removeResponse;
			return soap_in__ns1__removeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove"))
		{	*type = SOAP_TYPE__ns1__remove;
			return soap_in__ns1__remove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnCommentVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse;
			return soap_in__ns1__findBySQLQueryReturnCommentVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnCommentVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO;
			return soap_in__ns1__findBySQLQueryReturnCommentVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK10Response"))
		{	*type = SOAP_TYPE__ns1__findByPK10Response;
			return soap_in__ns1__findByPK10Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK10"))
		{	*type = SOAP_TYPE__ns1__findByPK10;
			return soap_in__ns1__findByPK10(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnImageVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse;
			return soap_in__ns1__findBySQLQueryReturnImageVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnImageVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnImageVO;
			return soap_in__ns1__findBySQLQueryReturnImageVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update2Response"))
		{	*type = SOAP_TYPE__ns1__update2Response;
			return soap_in__ns1__update2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update2"))
		{	*type = SOAP_TYPE__ns1__update2;
			return soap_in__ns1__update2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK3Response"))
		{	*type = SOAP_TYPE__ns1__findByPK3Response;
			return soap_in__ns1__findByPK3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK3"))
		{	*type = SOAP_TYPE__ns1__findByPK3;
			return soap_in__ns1__findByPK3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update5Response"))
		{	*type = SOAP_TYPE__ns1__update5Response;
			return soap_in__ns1__update5Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update5"))
		{	*type = SOAP_TYPE__ns1__update5;
			return soap_in__ns1__update5(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove2Response"))
		{	*type = SOAP_TYPE__ns1__remove2Response;
			return soap_in__ns1__remove2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove2"))
		{	*type = SOAP_TYPE__ns1__remove2;
			return soap_in__ns1__remove2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create5Response"))
		{	*type = SOAP_TYPE__ns1__create5Response;
			return soap_in__ns1__create5Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create5"))
		{	*type = SOAP_TYPE__ns1__create5;
			return soap_in__ns1__create5(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove11Response"))
		{	*type = SOAP_TYPE__ns1__remove11Response;
			return soap_in__ns1__remove11Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove11"))
		{	*type = SOAP_TYPE__ns1__remove11;
			return soap_in__ns1__remove11(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnUserVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse;
			return soap_in__ns1__findBySQLQueryReturnUserVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnUserVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnUserVO;
			return soap_in__ns1__findBySQLQueryReturnUserVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnEntityVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse;
			return soap_in__ns1__findBySQLQueryReturnEntityVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnEntityVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO;
			return soap_in__ns1__findBySQLQueryReturnEntityVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createResponse"))
		{	*type = SOAP_TYPE__ns1__createResponse;
			return soap_in__ns1__createResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create"))
		{	*type = SOAP_TYPE__ns1__create;
			return soap_in__ns1__create(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove1Response"))
		{	*type = SOAP_TYPE__ns1__remove1Response;
			return soap_in__ns1__remove1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove1"))
		{	*type = SOAP_TYPE__ns1__remove1;
			return soap_in__ns1__remove1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK7Response"))
		{	*type = SOAP_TYPE__ns1__findByPK7Response;
			return soap_in__ns1__findByPK7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK7"))
		{	*type = SOAP_TYPE__ns1__findByPK7;
			return soap_in__ns1__findByPK7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:echoStringResponse"))
		{	*type = SOAP_TYPE__ns1__echoStringResponse;
			return soap_in__ns1__echoStringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:echoString"))
		{	*type = SOAP_TYPE__ns1__echoString;
			return soap_in__ns1__echoString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create2Response"))
		{	*type = SOAP_TYPE__ns1__create2Response;
			return soap_in__ns1__create2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create2"))
		{	*type = SOAP_TYPE__ns1__create2;
			return soap_in__ns1__create2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK6Response"))
		{	*type = SOAP_TYPE__ns1__findByPK6Response;
			return soap_in__ns1__findByPK6Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK6"))
		{	*type = SOAP_TYPE__ns1__findByPK6;
			return soap_in__ns1__findByPK6(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateResponse"))
		{	*type = SOAP_TYPE__ns1__updateResponse;
			return soap_in__ns1__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update"))
		{	*type = SOAP_TYPE__ns1__update;
			return soap_in__ns1__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove10Response"))
		{	*type = SOAP_TYPE__ns1__remove10Response;
			return soap_in__ns1__remove10Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove10"))
		{	*type = SOAP_TYPE__ns1__remove10;
			return soap_in__ns1__remove10(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create3Response"))
		{	*type = SOAP_TYPE__ns1__create3Response;
			return soap_in__ns1__create3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create3"))
		{	*type = SOAP_TYPE__ns1__create3;
			return soap_in__ns1__create3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPKResponse"))
		{	*type = SOAP_TYPE__ns1__findByPKResponse;
			return soap_in__ns1__findByPKResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK"))
		{	*type = SOAP_TYPE__ns1__findByPK;
			return soap_in__ns1__findByPK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update6Response"))
		{	*type = SOAP_TYPE__ns1__update6Response;
			return soap_in__ns1__update6Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update6"))
		{	*type = SOAP_TYPE__ns1__update6;
			return soap_in__ns1__update6(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update9Response"))
		{	*type = SOAP_TYPE__ns1__update9Response;
			return soap_in__ns1__update9Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update9"))
		{	*type = SOAP_TYPE__ns1__update9;
			return soap_in__ns1__update9(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update11Response"))
		{	*type = SOAP_TYPE__ns1__update11Response;
			return soap_in__ns1__update11Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update11"))
		{	*type = SOAP_TYPE__ns1__update11;
			return soap_in__ns1__update11(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove7Response"))
		{	*type = SOAP_TYPE__ns1__remove7Response;
			return soap_in__ns1__remove7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove7"))
		{	*type = SOAP_TYPE__ns1__remove7;
			return soap_in__ns1__remove7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnDictionaryVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse;
			return soap_in__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnDictionaryVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO;
			return soap_in__ns1__findBySQLQueryReturnDictionaryVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnERelationVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse;
			return soap_in__ns1__findBySQLQueryReturnERelationVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnERelationVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO;
			return soap_in__ns1__findBySQLQueryReturnERelationVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK4Response"))
		{	*type = SOAP_TYPE__ns1__findByPK4Response;
			return soap_in__ns1__findByPK4Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK4"))
		{	*type = SOAP_TYPE__ns1__findByPK4;
			return soap_in__ns1__findByPK4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK9Response"))
		{	*type = SOAP_TYPE__ns1__findByPK9Response;
			return soap_in__ns1__findByPK9Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK9"))
		{	*type = SOAP_TYPE__ns1__findByPK9;
			return soap_in__ns1__findByPK9(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update10Response"))
		{	*type = SOAP_TYPE__ns1__update10Response;
			return soap_in__ns1__update10Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update10"))
		{	*type = SOAP_TYPE__ns1__update10;
			return soap_in__ns1__update10(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update8Response"))
		{	*type = SOAP_TYPE__ns1__update8Response;
			return soap_in__ns1__update8Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update8"))
		{	*type = SOAP_TYPE__ns1__update8;
			return soap_in__ns1__update8(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create1Response"))
		{	*type = SOAP_TYPE__ns1__create1Response;
			return soap_in__ns1__create1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create1"))
		{	*type = SOAP_TYPE__ns1__create1;
			return soap_in__ns1__create1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove8Response"))
		{	*type = SOAP_TYPE__ns1__remove8Response;
			return soap_in__ns1__remove8Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove8"))
		{	*type = SOAP_TYPE__ns1__remove8;
			return soap_in__ns1__remove8(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update7Response"))
		{	*type = SOAP_TYPE__ns1__update7Response;
			return soap_in__ns1__update7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update7"))
		{	*type = SOAP_TYPE__ns1__update7;
			return soap_in__ns1__update7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove5Response"))
		{	*type = SOAP_TYPE__ns1__remove5Response;
			return soap_in__ns1__remove5Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove5"))
		{	*type = SOAP_TYPE__ns1__remove5;
			return soap_in__ns1__remove5(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove4Response"))
		{	*type = SOAP_TYPE__ns1__remove4Response;
			return soap_in__ns1__remove4Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove4"))
		{	*type = SOAP_TYPE__ns1__remove4;
			return soap_in__ns1__remove4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create7Response"))
		{	*type = SOAP_TYPE__ns1__create7Response;
			return soap_in__ns1__create7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create7"))
		{	*type = SOAP_TYPE__ns1__create7;
			return soap_in__ns1__create7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK2Response"))
		{	*type = SOAP_TYPE__ns1__findByPK2Response;
			return soap_in__ns1__findByPK2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK2"))
		{	*type = SOAP_TYPE__ns1__findByPK2;
			return soap_in__ns1__findByPK2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:generateSQLQueryResponse"))
		{	*type = SOAP_TYPE__ns1__generateSQLQueryResponse;
			return soap_in__ns1__generateSQLQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:generateSQLQuery"))
		{	*type = SOAP_TYPE__ns1__generateSQLQuery;
			return soap_in__ns1__generateSQLQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnPPTVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse;
			return soap_in__ns1__findBySQLQueryReturnPPTVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnPPTVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO;
			return soap_in__ns1__findBySQLQueryReturnPPTVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnContainerVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse;
			return soap_in__ns1__findBySQLQueryReturnContainerVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnContainerVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO;
			return soap_in__ns1__findBySQLQueryReturnContainerVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create6Response"))
		{	*type = SOAP_TYPE__ns1__create6Response;
			return soap_in__ns1__create6Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create6"))
		{	*type = SOAP_TYPE__ns1__create6;
			return soap_in__ns1__create6(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK5Response"))
		{	*type = SOAP_TYPE__ns1__findByPK5Response;
			return soap_in__ns1__findByPK5Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK5"))
		{	*type = SOAP_TYPE__ns1__findByPK5;
			return soap_in__ns1__findByPK5(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnPPTSlideVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse;
			return soap_in__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnPPTSlideVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO;
			return soap_in__ns1__findBySQLQueryReturnPPTSlideVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update4Response"))
		{	*type = SOAP_TYPE__ns1__update4Response;
			return soap_in__ns1__update4Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update4"))
		{	*type = SOAP_TYPE__ns1__update4;
			return soap_in__ns1__update4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create8Response"))
		{	*type = SOAP_TYPE__ns1__create8Response;
			return soap_in__ns1__create8Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create8"))
		{	*type = SOAP_TYPE__ns1__create8;
			return soap_in__ns1__create8(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK8Response"))
		{	*type = SOAP_TYPE__ns1__findByPK8Response;
			return soap_in__ns1__findByPK8Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findByPK8"))
		{	*type = SOAP_TYPE__ns1__findByPK8;
			return soap_in__ns1__findByPK8(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnEActivityVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse;
			return soap_in__ns1__findBySQLQueryReturnEActivityVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnEActivityVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO;
			return soap_in__ns1__findBySQLQueryReturnEActivityVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove9Response"))
		{	*type = SOAP_TYPE__ns1__remove9Response;
			return soap_in__ns1__remove9Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove9"))
		{	*type = SOAP_TYPE__ns1__remove9;
			return soap_in__ns1__remove9(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create11Response"))
		{	*type = SOAP_TYPE__ns1__create11Response;
			return soap_in__ns1__create11Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create11"))
		{	*type = SOAP_TYPE__ns1__create11;
			return soap_in__ns1__create11(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update3Response"))
		{	*type = SOAP_TYPE__ns1__update3Response;
			return soap_in__ns1__update3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update3"))
		{	*type = SOAP_TYPE__ns1__update3;
			return soap_in__ns1__update3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove6Response"))
		{	*type = SOAP_TYPE__ns1__remove6Response;
			return soap_in__ns1__remove6Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove6"))
		{	*type = SOAP_TYPE__ns1__remove6;
			return soap_in__ns1__remove6(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove3Response"))
		{	*type = SOAP_TYPE__ns1__remove3Response;
			return soap_in__ns1__remove3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:remove3"))
		{	*type = SOAP_TYPE__ns1__remove3;
			return soap_in__ns1__remove3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnFeedbackVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse;
			return soap_in__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnFeedbackVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO;
			return soap_in__ns1__findBySQLQueryReturnFeedbackVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnESignatureVOResponse"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse;
			return soap_in__ns1__findBySQLQueryReturnESignatureVOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findBySQLQueryReturnESignatureVO"))
		{	*type = SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO;
			return soap_in__ns1__findBySQLQueryReturnESignatureVO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:anyType2anyTypeMap-entry"))
		{	*type = SOAP_TYPE__ns1__anyType2anyTypeMap_entry;
			return soap_in__ns1__anyType2anyTypeMap_entry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_ns2__Order:
		return soap_out_ns2__Order(soap, tag, id, (const enum ns2__Order *)ptr, "ns2:Order");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns2__Order_:
		return ((ns2__Order_ *)ptr)->soap_out(soap, tag, id, "ns2:Order");
	case SOAP_TYPE_ns5__SKSWSException:
		return ((ns5__SKSWSException *)ptr)->soap_out(soap, tag, id, "ns5:SKSWSException");
	case SOAP_TYPE_ns4__ArrayOfCommentVO:
		return ((ns4__ArrayOfCommentVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfCommentVO");
	case SOAP_TYPE_ns4__ArrayOfImageVO:
		return ((ns4__ArrayOfImageVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfImageVO");
	case SOAP_TYPE_ns4__ArrayOfUserVO:
		return ((ns4__ArrayOfUserVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfUserVO");
	case SOAP_TYPE_ns4__ArrayOfEntityVO:
		return ((ns4__ArrayOfEntityVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfEntityVO");
	case SOAP_TYPE_ns4__CommentVO:
		return ((ns4__CommentVO *)ptr)->soap_out(soap, tag, id, "ns4:CommentVO");
	case SOAP_TYPE_ns4__ArrayOfDictionaryVO:
		return ((ns4__ArrayOfDictionaryVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfDictionaryVO");
	case SOAP_TYPE_ns4__ArrayOfERelationVO:
		return ((ns4__ArrayOfERelationVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfERelationVO");
	case SOAP_TYPE_ns4__DictionaryVO:
		return ((ns4__DictionaryVO *)ptr)->soap_out(soap, tag, id, "ns4:DictionaryVO");
	case SOAP_TYPE_ns4__PPTVO:
		return ((ns4__PPTVO *)ptr)->soap_out(soap, tag, id, "ns4:PPTVO");
	case SOAP_TYPE_ns4__ArrayOfPPTVO:
		return ((ns4__ArrayOfPPTVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfPPTVO");
	case SOAP_TYPE_ns4__ContainerVO:
		return ((ns4__ContainerVO *)ptr)->soap_out(soap, tag, id, "ns4:ContainerVO");
	case SOAP_TYPE_ns4__ArrayOfContainerVO:
		return ((ns4__ArrayOfContainerVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfContainerVO");
	case SOAP_TYPE_ns4__ArrayOfPPTSlideVO:
		return ((ns4__ArrayOfPPTSlideVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfPPTSlideVO");
	case SOAP_TYPE_ns4__ERelationVO:
		return ((ns4__ERelationVO *)ptr)->soap_out(soap, tag, id, "ns4:ERelationVO");
	case SOAP_TYPE_ns4__ImageVO:
		return ((ns4__ImageVO *)ptr)->soap_out(soap, tag, id, "ns4:ImageVO");
	case SOAP_TYPE_ns4__ArrayOfEActivityVO:
		return ((ns4__ArrayOfEActivityVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfEActivityVO");
	case SOAP_TYPE_ns4__PPTSlideVO:
		return ((ns4__PPTSlideVO *)ptr)->soap_out(soap, tag, id, "ns4:PPTSlideVO");
	case SOAP_TYPE_ns4__EActivityVO:
		return ((ns4__EActivityVO *)ptr)->soap_out(soap, tag, id, "ns4:EActivityVO");
	case SOAP_TYPE_ns4__UserVO:
		return ((ns4__UserVO *)ptr)->soap_out(soap, tag, id, "ns4:UserVO");
	case SOAP_TYPE_ns4__FeedbackVO:
		return ((ns4__FeedbackVO *)ptr)->soap_out(soap, tag, id, "ns4:FeedbackVO");
	case SOAP_TYPE_ns4__ArrayOfFeedbackVO:
		return ((ns4__ArrayOfFeedbackVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfFeedbackVO");
	case SOAP_TYPE_ns4__EntityVO:
		return ((ns4__EntityVO *)ptr)->soap_out(soap, tag, id, "ns4:EntityVO");
	case SOAP_TYPE_ns4__ESignatureVO:
		return ((ns4__ESignatureVO *)ptr)->soap_out(soap, tag, id, "ns4:ESignatureVO");
	case SOAP_TYPE_ns4__ArrayOfESignatureVO:
		return ((ns4__ArrayOfESignatureVO *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfESignatureVO");
	case SOAP_TYPE__ns1__create4Response:
		return ((_ns1__create4Response *)ptr)->soap_out(soap, "ns1:create4Response", id, NULL);
	case SOAP_TYPE__ns1__create4:
		return ((_ns1__create4 *)ptr)->soap_out(soap, "ns1:create4", id, NULL);
	case SOAP_TYPE__ns1__create9Response:
		return ((_ns1__create9Response *)ptr)->soap_out(soap, "ns1:create9Response", id, NULL);
	case SOAP_TYPE__ns1__create9:
		return ((_ns1__create9 *)ptr)->soap_out(soap, "ns1:create9", id, NULL);
	case SOAP_TYPE__ns1__findByPK11Response:
		return ((_ns1__findByPK11Response *)ptr)->soap_out(soap, "ns1:findByPK11Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK11:
		return ((_ns1__findByPK11 *)ptr)->soap_out(soap, "ns1:findByPK11", id, NULL);
	case SOAP_TYPE__ns1__update1Response:
		return ((_ns1__update1Response *)ptr)->soap_out(soap, "ns1:update1Response", id, NULL);
	case SOAP_TYPE__ns1__update1:
		return ((_ns1__update1 *)ptr)->soap_out(soap, "ns1:update1", id, NULL);
	case SOAP_TYPE__ns1__create10Response:
		return ((_ns1__create10Response *)ptr)->soap_out(soap, "ns1:create10Response", id, NULL);
	case SOAP_TYPE__ns1__create10:
		return ((_ns1__create10 *)ptr)->soap_out(soap, "ns1:create10", id, NULL);
	case SOAP_TYPE__ns1__findByPK1Response:
		return ((_ns1__findByPK1Response *)ptr)->soap_out(soap, "ns1:findByPK1Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK1:
		return ((_ns1__findByPK1 *)ptr)->soap_out(soap, "ns1:findByPK1", id, NULL);
	case SOAP_TYPE__ns1__removeResponse:
		return ((_ns1__removeResponse *)ptr)->soap_out(soap, "ns1:removeResponse", id, NULL);
	case SOAP_TYPE__ns1__remove:
		return ((_ns1__remove *)ptr)->soap_out(soap, "ns1:remove", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse:
		return ((_ns1__findBySQLQueryReturnCommentVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnCommentVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO:
		return ((_ns1__findBySQLQueryReturnCommentVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnCommentVO", id, NULL);
	case SOAP_TYPE__ns1__findByPK10Response:
		return ((_ns1__findByPK10Response *)ptr)->soap_out(soap, "ns1:findByPK10Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK10:
		return ((_ns1__findByPK10 *)ptr)->soap_out(soap, "ns1:findByPK10", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse:
		return ((_ns1__findBySQLQueryReturnImageVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnImageVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVO:
		return ((_ns1__findBySQLQueryReturnImageVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnImageVO", id, NULL);
	case SOAP_TYPE__ns1__update2Response:
		return ((_ns1__update2Response *)ptr)->soap_out(soap, "ns1:update2Response", id, NULL);
	case SOAP_TYPE__ns1__update2:
		return ((_ns1__update2 *)ptr)->soap_out(soap, "ns1:update2", id, NULL);
	case SOAP_TYPE__ns1__findByPK3Response:
		return ((_ns1__findByPK3Response *)ptr)->soap_out(soap, "ns1:findByPK3Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK3:
		return ((_ns1__findByPK3 *)ptr)->soap_out(soap, "ns1:findByPK3", id, NULL);
	case SOAP_TYPE__ns1__update5Response:
		return ((_ns1__update5Response *)ptr)->soap_out(soap, "ns1:update5Response", id, NULL);
	case SOAP_TYPE__ns1__update5:
		return ((_ns1__update5 *)ptr)->soap_out(soap, "ns1:update5", id, NULL);
	case SOAP_TYPE__ns1__remove2Response:
		return ((_ns1__remove2Response *)ptr)->soap_out(soap, "ns1:remove2Response", id, NULL);
	case SOAP_TYPE__ns1__remove2:
		return ((_ns1__remove2 *)ptr)->soap_out(soap, "ns1:remove2", id, NULL);
	case SOAP_TYPE__ns1__create5Response:
		return ((_ns1__create5Response *)ptr)->soap_out(soap, "ns1:create5Response", id, NULL);
	case SOAP_TYPE__ns1__create5:
		return ((_ns1__create5 *)ptr)->soap_out(soap, "ns1:create5", id, NULL);
	case SOAP_TYPE__ns1__remove11Response:
		return ((_ns1__remove11Response *)ptr)->soap_out(soap, "ns1:remove11Response", id, NULL);
	case SOAP_TYPE__ns1__remove11:
		return ((_ns1__remove11 *)ptr)->soap_out(soap, "ns1:remove11", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse:
		return ((_ns1__findBySQLQueryReturnUserVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnUserVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVO:
		return ((_ns1__findBySQLQueryReturnUserVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnUserVO", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse:
		return ((_ns1__findBySQLQueryReturnEntityVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnEntityVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO:
		return ((_ns1__findBySQLQueryReturnEntityVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnEntityVO", id, NULL);
	case SOAP_TYPE__ns1__createResponse:
		return ((_ns1__createResponse *)ptr)->soap_out(soap, "ns1:createResponse", id, NULL);
	case SOAP_TYPE__ns1__create:
		return ((_ns1__create *)ptr)->soap_out(soap, "ns1:create", id, NULL);
	case SOAP_TYPE__ns1__remove1Response:
		return ((_ns1__remove1Response *)ptr)->soap_out(soap, "ns1:remove1Response", id, NULL);
	case SOAP_TYPE__ns1__remove1:
		return ((_ns1__remove1 *)ptr)->soap_out(soap, "ns1:remove1", id, NULL);
	case SOAP_TYPE__ns1__findByPK7Response:
		return ((_ns1__findByPK7Response *)ptr)->soap_out(soap, "ns1:findByPK7Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK7:
		return ((_ns1__findByPK7 *)ptr)->soap_out(soap, "ns1:findByPK7", id, NULL);
	case SOAP_TYPE__ns1__echoStringResponse:
		return ((_ns1__echoStringResponse *)ptr)->soap_out(soap, "ns1:echoStringResponse", id, NULL);
	case SOAP_TYPE__ns1__echoString:
		return ((_ns1__echoString *)ptr)->soap_out(soap, "ns1:echoString", id, NULL);
	case SOAP_TYPE__ns1__create2Response:
		return ((_ns1__create2Response *)ptr)->soap_out(soap, "ns1:create2Response", id, NULL);
	case SOAP_TYPE__ns1__create2:
		return ((_ns1__create2 *)ptr)->soap_out(soap, "ns1:create2", id, NULL);
	case SOAP_TYPE__ns1__findByPK6Response:
		return ((_ns1__findByPK6Response *)ptr)->soap_out(soap, "ns1:findByPK6Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK6:
		return ((_ns1__findByPK6 *)ptr)->soap_out(soap, "ns1:findByPK6", id, NULL);
	case SOAP_TYPE__ns1__updateResponse:
		return ((_ns1__updateResponse *)ptr)->soap_out(soap, "ns1:updateResponse", id, NULL);
	case SOAP_TYPE__ns1__update:
		return ((_ns1__update *)ptr)->soap_out(soap, "ns1:update", id, NULL);
	case SOAP_TYPE__ns1__remove10Response:
		return ((_ns1__remove10Response *)ptr)->soap_out(soap, "ns1:remove10Response", id, NULL);
	case SOAP_TYPE__ns1__remove10:
		return ((_ns1__remove10 *)ptr)->soap_out(soap, "ns1:remove10", id, NULL);
	case SOAP_TYPE__ns1__create3Response:
		return ((_ns1__create3Response *)ptr)->soap_out(soap, "ns1:create3Response", id, NULL);
	case SOAP_TYPE__ns1__create3:
		return ((_ns1__create3 *)ptr)->soap_out(soap, "ns1:create3", id, NULL);
	case SOAP_TYPE__ns1__findByPKResponse:
		return ((_ns1__findByPKResponse *)ptr)->soap_out(soap, "ns1:findByPKResponse", id, NULL);
	case SOAP_TYPE__ns1__findByPK:
		return ((_ns1__findByPK *)ptr)->soap_out(soap, "ns1:findByPK", id, NULL);
	case SOAP_TYPE__ns1__update6Response:
		return ((_ns1__update6Response *)ptr)->soap_out(soap, "ns1:update6Response", id, NULL);
	case SOAP_TYPE__ns1__update6:
		return ((_ns1__update6 *)ptr)->soap_out(soap, "ns1:update6", id, NULL);
	case SOAP_TYPE__ns1__update9Response:
		return ((_ns1__update9Response *)ptr)->soap_out(soap, "ns1:update9Response", id, NULL);
	case SOAP_TYPE__ns1__update9:
		return ((_ns1__update9 *)ptr)->soap_out(soap, "ns1:update9", id, NULL);
	case SOAP_TYPE__ns1__update11Response:
		return ((_ns1__update11Response *)ptr)->soap_out(soap, "ns1:update11Response", id, NULL);
	case SOAP_TYPE__ns1__update11:
		return ((_ns1__update11 *)ptr)->soap_out(soap, "ns1:update11", id, NULL);
	case SOAP_TYPE__ns1__remove7Response:
		return ((_ns1__remove7Response *)ptr)->soap_out(soap, "ns1:remove7Response", id, NULL);
	case SOAP_TYPE__ns1__remove7:
		return ((_ns1__remove7 *)ptr)->soap_out(soap, "ns1:remove7", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse:
		return ((_ns1__findBySQLQueryReturnDictionaryVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnDictionaryVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO:
		return ((_ns1__findBySQLQueryReturnDictionaryVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnDictionaryVO", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse:
		return ((_ns1__findBySQLQueryReturnERelationVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnERelationVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO:
		return ((_ns1__findBySQLQueryReturnERelationVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnERelationVO", id, NULL);
	case SOAP_TYPE__ns1__findByPK4Response:
		return ((_ns1__findByPK4Response *)ptr)->soap_out(soap, "ns1:findByPK4Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK4:
		return ((_ns1__findByPK4 *)ptr)->soap_out(soap, "ns1:findByPK4", id, NULL);
	case SOAP_TYPE__ns1__findByPK9Response:
		return ((_ns1__findByPK9Response *)ptr)->soap_out(soap, "ns1:findByPK9Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK9:
		return ((_ns1__findByPK9 *)ptr)->soap_out(soap, "ns1:findByPK9", id, NULL);
	case SOAP_TYPE__ns1__update10Response:
		return ((_ns1__update10Response *)ptr)->soap_out(soap, "ns1:update10Response", id, NULL);
	case SOAP_TYPE__ns1__update10:
		return ((_ns1__update10 *)ptr)->soap_out(soap, "ns1:update10", id, NULL);
	case SOAP_TYPE__ns1__update8Response:
		return ((_ns1__update8Response *)ptr)->soap_out(soap, "ns1:update8Response", id, NULL);
	case SOAP_TYPE__ns1__update8:
		return ((_ns1__update8 *)ptr)->soap_out(soap, "ns1:update8", id, NULL);
	case SOAP_TYPE__ns1__create1Response:
		return ((_ns1__create1Response *)ptr)->soap_out(soap, "ns1:create1Response", id, NULL);
	case SOAP_TYPE__ns1__create1:
		return ((_ns1__create1 *)ptr)->soap_out(soap, "ns1:create1", id, NULL);
	case SOAP_TYPE__ns1__remove8Response:
		return ((_ns1__remove8Response *)ptr)->soap_out(soap, "ns1:remove8Response", id, NULL);
	case SOAP_TYPE__ns1__remove8:
		return ((_ns1__remove8 *)ptr)->soap_out(soap, "ns1:remove8", id, NULL);
	case SOAP_TYPE__ns1__update7Response:
		return ((_ns1__update7Response *)ptr)->soap_out(soap, "ns1:update7Response", id, NULL);
	case SOAP_TYPE__ns1__update7:
		return ((_ns1__update7 *)ptr)->soap_out(soap, "ns1:update7", id, NULL);
	case SOAP_TYPE__ns1__remove5Response:
		return ((_ns1__remove5Response *)ptr)->soap_out(soap, "ns1:remove5Response", id, NULL);
	case SOAP_TYPE__ns1__remove5:
		return ((_ns1__remove5 *)ptr)->soap_out(soap, "ns1:remove5", id, NULL);
	case SOAP_TYPE__ns1__remove4Response:
		return ((_ns1__remove4Response *)ptr)->soap_out(soap, "ns1:remove4Response", id, NULL);
	case SOAP_TYPE__ns1__remove4:
		return ((_ns1__remove4 *)ptr)->soap_out(soap, "ns1:remove4", id, NULL);
	case SOAP_TYPE__ns1__create7Response:
		return ((_ns1__create7Response *)ptr)->soap_out(soap, "ns1:create7Response", id, NULL);
	case SOAP_TYPE__ns1__create7:
		return ((_ns1__create7 *)ptr)->soap_out(soap, "ns1:create7", id, NULL);
	case SOAP_TYPE__ns1__findByPK2Response:
		return ((_ns1__findByPK2Response *)ptr)->soap_out(soap, "ns1:findByPK2Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK2:
		return ((_ns1__findByPK2 *)ptr)->soap_out(soap, "ns1:findByPK2", id, NULL);
	case SOAP_TYPE__ns1__generateSQLQueryResponse:
		return ((_ns1__generateSQLQueryResponse *)ptr)->soap_out(soap, "ns1:generateSQLQueryResponse", id, NULL);
	case SOAP_TYPE__ns1__generateSQLQuery:
		return ((_ns1__generateSQLQuery *)ptr)->soap_out(soap, "ns1:generateSQLQuery", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse:
		return ((_ns1__findBySQLQueryReturnPPTVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnPPTVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO:
		return ((_ns1__findBySQLQueryReturnPPTVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnPPTVO", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse:
		return ((_ns1__findBySQLQueryReturnContainerVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnContainerVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO:
		return ((_ns1__findBySQLQueryReturnContainerVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnContainerVO", id, NULL);
	case SOAP_TYPE__ns1__create6Response:
		return ((_ns1__create6Response *)ptr)->soap_out(soap, "ns1:create6Response", id, NULL);
	case SOAP_TYPE__ns1__create6:
		return ((_ns1__create6 *)ptr)->soap_out(soap, "ns1:create6", id, NULL);
	case SOAP_TYPE__ns1__findByPK5Response:
		return ((_ns1__findByPK5Response *)ptr)->soap_out(soap, "ns1:findByPK5Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK5:
		return ((_ns1__findByPK5 *)ptr)->soap_out(soap, "ns1:findByPK5", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse:
		return ((_ns1__findBySQLQueryReturnPPTSlideVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnPPTSlideVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO:
		return ((_ns1__findBySQLQueryReturnPPTSlideVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnPPTSlideVO", id, NULL);
	case SOAP_TYPE__ns1__update4Response:
		return ((_ns1__update4Response *)ptr)->soap_out(soap, "ns1:update4Response", id, NULL);
	case SOAP_TYPE__ns1__update4:
		return ((_ns1__update4 *)ptr)->soap_out(soap, "ns1:update4", id, NULL);
	case SOAP_TYPE__ns1__create8Response:
		return ((_ns1__create8Response *)ptr)->soap_out(soap, "ns1:create8Response", id, NULL);
	case SOAP_TYPE__ns1__create8:
		return ((_ns1__create8 *)ptr)->soap_out(soap, "ns1:create8", id, NULL);
	case SOAP_TYPE__ns1__findByPK8Response:
		return ((_ns1__findByPK8Response *)ptr)->soap_out(soap, "ns1:findByPK8Response", id, NULL);
	case SOAP_TYPE__ns1__findByPK8:
		return ((_ns1__findByPK8 *)ptr)->soap_out(soap, "ns1:findByPK8", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse:
		return ((_ns1__findBySQLQueryReturnEActivityVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnEActivityVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO:
		return ((_ns1__findBySQLQueryReturnEActivityVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnEActivityVO", id, NULL);
	case SOAP_TYPE__ns1__remove9Response:
		return ((_ns1__remove9Response *)ptr)->soap_out(soap, "ns1:remove9Response", id, NULL);
	case SOAP_TYPE__ns1__remove9:
		return ((_ns1__remove9 *)ptr)->soap_out(soap, "ns1:remove9", id, NULL);
	case SOAP_TYPE__ns1__create11Response:
		return ((_ns1__create11Response *)ptr)->soap_out(soap, "ns1:create11Response", id, NULL);
	case SOAP_TYPE__ns1__create11:
		return ((_ns1__create11 *)ptr)->soap_out(soap, "ns1:create11", id, NULL);
	case SOAP_TYPE__ns1__update3Response:
		return ((_ns1__update3Response *)ptr)->soap_out(soap, "ns1:update3Response", id, NULL);
	case SOAP_TYPE__ns1__update3:
		return ((_ns1__update3 *)ptr)->soap_out(soap, "ns1:update3", id, NULL);
	case SOAP_TYPE__ns1__remove6Response:
		return ((_ns1__remove6Response *)ptr)->soap_out(soap, "ns1:remove6Response", id, NULL);
	case SOAP_TYPE__ns1__remove6:
		return ((_ns1__remove6 *)ptr)->soap_out(soap, "ns1:remove6", id, NULL);
	case SOAP_TYPE__ns1__remove3Response:
		return ((_ns1__remove3Response *)ptr)->soap_out(soap, "ns1:remove3Response", id, NULL);
	case SOAP_TYPE__ns1__remove3:
		return ((_ns1__remove3 *)ptr)->soap_out(soap, "ns1:remove3", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse:
		return ((_ns1__findBySQLQueryReturnFeedbackVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnFeedbackVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO:
		return ((_ns1__findBySQLQueryReturnFeedbackVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnFeedbackVO", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse:
		return ((_ns1__findBySQLQueryReturnESignatureVOResponse *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnESignatureVOResponse", id, NULL);
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO:
		return ((_ns1__findBySQLQueryReturnESignatureVO *)ptr)->soap_out(soap, "ns1:findBySQLQueryReturnESignatureVO", id, NULL);
	case SOAP_TYPE_ns1__ArrayOfLong:
		return ((ns1__ArrayOfLong *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfLong");
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		return ((ns1__ArrayOfDateTime *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDateTime");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__anyType2anyTypeMap:
		return ((ns1__anyType2anyTypeMap *)ptr)->soap_out(soap, tag, id, "ns1:anyType2anyTypeMap");
	case SOAP_TYPE_ns3__OperatorIntf:
		return ((ns3__OperatorIntf *)ptr)->soap_out(soap, tag, id, "ns3:OperatorIntf");
	case SOAP_TYPE_ns3__ArrayOfDBColumn:
		return ((ns3__ArrayOfDBColumn *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfDBColumn");
	case SOAP_TYPE_ns3__SKSObject:
		return ((ns3__SKSObject *)ptr)->soap_out(soap, tag, id, "ns3:SKSObject");
	case SOAP_TYPE_ns3__ArrayOfSKSObject:
		return ((ns3__ArrayOfSKSObject *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfSKSObject");
	case SOAP_TYPE_ns3__ColumnOperatorIntf:
		return ((ns3__ColumnOperatorIntf *)ptr)->soap_out(soap, tag, id, "ns3:ColumnOperatorIntf");
	case SOAP_TYPE_ns3__ScalarIntf:
		return ((ns3__ScalarIntf *)ptr)->soap_out(soap, tag, id, "ns3:ScalarIntf");
	case SOAP_TYPE_ns3__DBColumn:
		return ((ns3__DBColumn *)ptr)->soap_out(soap, tag, id, "ns3:DBColumn");
	case SOAP_TYPE_ns2__QueryColumn:
		return ((ns2__QueryColumn *)ptr)->soap_out(soap, tag, id, "ns2:QueryColumn");
	case SOAP_TYPE_ns2__ArrayOfQueryColumn:
		return ((ns2__ArrayOfQueryColumn *)ptr)->soap_out(soap, tag, id, "ns2:ArrayOfQueryColumn");
	case SOAP_TYPE_ns2__ReturnColumn:
		return ((ns2__ReturnColumn *)ptr)->soap_out(soap, tag, id, "ns2:ReturnColumn");
	case SOAP_TYPE_ns2__ArrayOfReturnColumn:
		return ((ns2__ArrayOfReturnColumn *)ptr)->soap_out(soap, tag, id, "ns2:ArrayOfReturnColumn");
	case SOAP_TYPE_ns2__LimitOffset:
		return ((ns2__LimitOffset *)ptr)->soap_out(soap, tag, id, "ns2:LimitOffset");
	case SOAP_TYPE_ns2__OrderColumn:
		return ((ns2__OrderColumn *)ptr)->soap_out(soap, tag, id, "ns2:OrderColumn");
	case SOAP_TYPE_ns2__ArrayOfOrderColumn:
		return ((ns2__ArrayOfOrderColumn *)ptr)->soap_out(soap, tag, id, "ns2:ArrayOfOrderColumn");
	case SOAP_TYPE_ns2__SKSQuery:
		return ((ns2__SKSQuery *)ptr)->soap_out(soap, tag, id, "ns2:SKSQuery");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return ((xsd__decimal_ *)ptr)->soap_out(soap, tag, id, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return ((xsd__base64Binary_ *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE__ns1__anyType2anyTypeMap_entry:
		return soap_out__ns1__anyType2anyTypeMap_entry(soap, "ns1:anyType2anyTypeMap-entry", id, (const struct _ns1__anyType2anyTypeMap_entry *)ptr, NULL);
	case SOAP_TYPE_PointerTo_ns1__create4Response:
		return soap_out_PointerTo_ns1__create4Response(soap, tag, id, (_ns1__create4Response *const*)ptr, "ns1:create4Response");
	case SOAP_TYPE_PointerTo_ns1__create4:
		return soap_out_PointerTo_ns1__create4(soap, tag, id, (_ns1__create4 *const*)ptr, "ns1:create4");
	case SOAP_TYPE_PointerTo_ns1__create9Response:
		return soap_out_PointerTo_ns1__create9Response(soap, tag, id, (_ns1__create9Response *const*)ptr, "ns1:create9Response");
	case SOAP_TYPE_PointerTo_ns1__create9:
		return soap_out_PointerTo_ns1__create9(soap, tag, id, (_ns1__create9 *const*)ptr, "ns1:create9");
	case SOAP_TYPE_PointerTo_ns1__findByPK11Response:
		return soap_out_PointerTo_ns1__findByPK11Response(soap, tag, id, (_ns1__findByPK11Response *const*)ptr, "ns1:findByPK11Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK11:
		return soap_out_PointerTo_ns1__findByPK11(soap, tag, id, (_ns1__findByPK11 *const*)ptr, "ns1:findByPK11");
	case SOAP_TYPE_PointerTo_ns1__update1Response:
		return soap_out_PointerTo_ns1__update1Response(soap, tag, id, (_ns1__update1Response *const*)ptr, "ns1:update1Response");
	case SOAP_TYPE_PointerTo_ns1__update1:
		return soap_out_PointerTo_ns1__update1(soap, tag, id, (_ns1__update1 *const*)ptr, "ns1:update1");
	case SOAP_TYPE_PointerTo_ns1__create10Response:
		return soap_out_PointerTo_ns1__create10Response(soap, tag, id, (_ns1__create10Response *const*)ptr, "ns1:create10Response");
	case SOAP_TYPE_PointerTo_ns1__create10:
		return soap_out_PointerTo_ns1__create10(soap, tag, id, (_ns1__create10 *const*)ptr, "ns1:create10");
	case SOAP_TYPE_PointerTo_ns1__findByPK1Response:
		return soap_out_PointerTo_ns1__findByPK1Response(soap, tag, id, (_ns1__findByPK1Response *const*)ptr, "ns1:findByPK1Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK1:
		return soap_out_PointerTo_ns1__findByPK1(soap, tag, id, (_ns1__findByPK1 *const*)ptr, "ns1:findByPK1");
	case SOAP_TYPE_PointerTo_ns1__removeResponse:
		return soap_out_PointerTo_ns1__removeResponse(soap, tag, id, (_ns1__removeResponse *const*)ptr, "ns1:removeResponse");
	case SOAP_TYPE_PointerTo_ns1__remove:
		return soap_out_PointerTo_ns1__remove(soap, tag, id, (_ns1__remove *const*)ptr, "ns1:remove");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnCommentVOResponse *const*)ptr, "ns1:findBySQLQueryReturnCommentVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, tag, id, (_ns1__findBySQLQueryReturnCommentVO *const*)ptr, "ns1:findBySQLQueryReturnCommentVO");
	case SOAP_TYPE_PointerTo_ns1__findByPK10Response:
		return soap_out_PointerTo_ns1__findByPK10Response(soap, tag, id, (_ns1__findByPK10Response *const*)ptr, "ns1:findByPK10Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK10:
		return soap_out_PointerTo_ns1__findByPK10(soap, tag, id, (_ns1__findByPK10 *const*)ptr, "ns1:findByPK10");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnImageVOResponse *const*)ptr, "ns1:findBySQLQueryReturnImageVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, tag, id, (_ns1__findBySQLQueryReturnImageVO *const*)ptr, "ns1:findBySQLQueryReturnImageVO");
	case SOAP_TYPE_PointerTo_ns1__update2Response:
		return soap_out_PointerTo_ns1__update2Response(soap, tag, id, (_ns1__update2Response *const*)ptr, "ns1:update2Response");
	case SOAP_TYPE_PointerTo_ns1__update2:
		return soap_out_PointerTo_ns1__update2(soap, tag, id, (_ns1__update2 *const*)ptr, "ns1:update2");
	case SOAP_TYPE_PointerTo_ns1__findByPK3Response:
		return soap_out_PointerTo_ns1__findByPK3Response(soap, tag, id, (_ns1__findByPK3Response *const*)ptr, "ns1:findByPK3Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK3:
		return soap_out_PointerTo_ns1__findByPK3(soap, tag, id, (_ns1__findByPK3 *const*)ptr, "ns1:findByPK3");
	case SOAP_TYPE_PointerTo_ns1__update5Response:
		return soap_out_PointerTo_ns1__update5Response(soap, tag, id, (_ns1__update5Response *const*)ptr, "ns1:update5Response");
	case SOAP_TYPE_PointerTo_ns1__update5:
		return soap_out_PointerTo_ns1__update5(soap, tag, id, (_ns1__update5 *const*)ptr, "ns1:update5");
	case SOAP_TYPE_PointerTo_ns1__remove2Response:
		return soap_out_PointerTo_ns1__remove2Response(soap, tag, id, (_ns1__remove2Response *const*)ptr, "ns1:remove2Response");
	case SOAP_TYPE_PointerTo_ns1__remove2:
		return soap_out_PointerTo_ns1__remove2(soap, tag, id, (_ns1__remove2 *const*)ptr, "ns1:remove2");
	case SOAP_TYPE_PointerTo_ns1__create5Response:
		return soap_out_PointerTo_ns1__create5Response(soap, tag, id, (_ns1__create5Response *const*)ptr, "ns1:create5Response");
	case SOAP_TYPE_PointerTo_ns1__create5:
		return soap_out_PointerTo_ns1__create5(soap, tag, id, (_ns1__create5 *const*)ptr, "ns1:create5");
	case SOAP_TYPE_PointerTo_ns1__remove11Response:
		return soap_out_PointerTo_ns1__remove11Response(soap, tag, id, (_ns1__remove11Response *const*)ptr, "ns1:remove11Response");
	case SOAP_TYPE_PointerTo_ns1__remove11:
		return soap_out_PointerTo_ns1__remove11(soap, tag, id, (_ns1__remove11 *const*)ptr, "ns1:remove11");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnUserVOResponse *const*)ptr, "ns1:findBySQLQueryReturnUserVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, tag, id, (_ns1__findBySQLQueryReturnUserVO *const*)ptr, "ns1:findBySQLQueryReturnUserVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnEntityVOResponse *const*)ptr, "ns1:findBySQLQueryReturnEntityVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, tag, id, (_ns1__findBySQLQueryReturnEntityVO *const*)ptr, "ns1:findBySQLQueryReturnEntityVO");
	case SOAP_TYPE_PointerTo_ns1__createResponse:
		return soap_out_PointerTo_ns1__createResponse(soap, tag, id, (_ns1__createResponse *const*)ptr, "ns1:createResponse");
	case SOAP_TYPE_PointerTo_ns1__create:
		return soap_out_PointerTo_ns1__create(soap, tag, id, (_ns1__create *const*)ptr, "ns1:create");
	case SOAP_TYPE_PointerTo_ns1__remove1Response:
		return soap_out_PointerTo_ns1__remove1Response(soap, tag, id, (_ns1__remove1Response *const*)ptr, "ns1:remove1Response");
	case SOAP_TYPE_PointerTo_ns1__remove1:
		return soap_out_PointerTo_ns1__remove1(soap, tag, id, (_ns1__remove1 *const*)ptr, "ns1:remove1");
	case SOAP_TYPE_PointerTo_ns1__findByPK7Response:
		return soap_out_PointerTo_ns1__findByPK7Response(soap, tag, id, (_ns1__findByPK7Response *const*)ptr, "ns1:findByPK7Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK7:
		return soap_out_PointerTo_ns1__findByPK7(soap, tag, id, (_ns1__findByPK7 *const*)ptr, "ns1:findByPK7");
	case SOAP_TYPE_PointerTo_ns1__echoStringResponse:
		return soap_out_PointerTo_ns1__echoStringResponse(soap, tag, id, (_ns1__echoStringResponse *const*)ptr, "ns1:echoStringResponse");
	case SOAP_TYPE_PointerTo_ns1__echoString:
		return soap_out_PointerTo_ns1__echoString(soap, tag, id, (_ns1__echoString *const*)ptr, "ns1:echoString");
	case SOAP_TYPE_PointerTo_ns1__create2Response:
		return soap_out_PointerTo_ns1__create2Response(soap, tag, id, (_ns1__create2Response *const*)ptr, "ns1:create2Response");
	case SOAP_TYPE_PointerTo_ns1__create2:
		return soap_out_PointerTo_ns1__create2(soap, tag, id, (_ns1__create2 *const*)ptr, "ns1:create2");
	case SOAP_TYPE_PointerTo_ns1__findByPK6Response:
		return soap_out_PointerTo_ns1__findByPK6Response(soap, tag, id, (_ns1__findByPK6Response *const*)ptr, "ns1:findByPK6Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK6:
		return soap_out_PointerTo_ns1__findByPK6(soap, tag, id, (_ns1__findByPK6 *const*)ptr, "ns1:findByPK6");
	case SOAP_TYPE_PointerTo_ns1__updateResponse:
		return soap_out_PointerTo_ns1__updateResponse(soap, tag, id, (_ns1__updateResponse *const*)ptr, "ns1:updateResponse");
	case SOAP_TYPE_PointerTo_ns1__update:
		return soap_out_PointerTo_ns1__update(soap, tag, id, (_ns1__update *const*)ptr, "ns1:update");
	case SOAP_TYPE_PointerTo_ns1__remove10Response:
		return soap_out_PointerTo_ns1__remove10Response(soap, tag, id, (_ns1__remove10Response *const*)ptr, "ns1:remove10Response");
	case SOAP_TYPE_PointerTo_ns1__remove10:
		return soap_out_PointerTo_ns1__remove10(soap, tag, id, (_ns1__remove10 *const*)ptr, "ns1:remove10");
	case SOAP_TYPE_PointerTo_ns1__create3Response:
		return soap_out_PointerTo_ns1__create3Response(soap, tag, id, (_ns1__create3Response *const*)ptr, "ns1:create3Response");
	case SOAP_TYPE_PointerTo_ns1__create3:
		return soap_out_PointerTo_ns1__create3(soap, tag, id, (_ns1__create3 *const*)ptr, "ns1:create3");
	case SOAP_TYPE_PointerTo_ns1__findByPKResponse:
		return soap_out_PointerTo_ns1__findByPKResponse(soap, tag, id, (_ns1__findByPKResponse *const*)ptr, "ns1:findByPKResponse");
	case SOAP_TYPE_PointerTo_ns1__findByPK:
		return soap_out_PointerTo_ns1__findByPK(soap, tag, id, (_ns1__findByPK *const*)ptr, "ns1:findByPK");
	case SOAP_TYPE_PointerTo_ns1__update6Response:
		return soap_out_PointerTo_ns1__update6Response(soap, tag, id, (_ns1__update6Response *const*)ptr, "ns1:update6Response");
	case SOAP_TYPE_PointerTo_ns1__update6:
		return soap_out_PointerTo_ns1__update6(soap, tag, id, (_ns1__update6 *const*)ptr, "ns1:update6");
	case SOAP_TYPE_PointerTo_ns1__update9Response:
		return soap_out_PointerTo_ns1__update9Response(soap, tag, id, (_ns1__update9Response *const*)ptr, "ns1:update9Response");
	case SOAP_TYPE_PointerTo_ns1__update9:
		return soap_out_PointerTo_ns1__update9(soap, tag, id, (_ns1__update9 *const*)ptr, "ns1:update9");
	case SOAP_TYPE_PointerTo_ns1__update11Response:
		return soap_out_PointerTo_ns1__update11Response(soap, tag, id, (_ns1__update11Response *const*)ptr, "ns1:update11Response");
	case SOAP_TYPE_PointerTo_ns1__update11:
		return soap_out_PointerTo_ns1__update11(soap, tag, id, (_ns1__update11 *const*)ptr, "ns1:update11");
	case SOAP_TYPE_PointerTo_ns1__remove7Response:
		return soap_out_PointerTo_ns1__remove7Response(soap, tag, id, (_ns1__remove7Response *const*)ptr, "ns1:remove7Response");
	case SOAP_TYPE_PointerTo_ns1__remove7:
		return soap_out_PointerTo_ns1__remove7(soap, tag, id, (_ns1__remove7 *const*)ptr, "ns1:remove7");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnDictionaryVOResponse *const*)ptr, "ns1:findBySQLQueryReturnDictionaryVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, tag, id, (_ns1__findBySQLQueryReturnDictionaryVO *const*)ptr, "ns1:findBySQLQueryReturnDictionaryVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnERelationVOResponse *const*)ptr, "ns1:findBySQLQueryReturnERelationVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, tag, id, (_ns1__findBySQLQueryReturnERelationVO *const*)ptr, "ns1:findBySQLQueryReturnERelationVO");
	case SOAP_TYPE_PointerTo_ns1__findByPK4Response:
		return soap_out_PointerTo_ns1__findByPK4Response(soap, tag, id, (_ns1__findByPK4Response *const*)ptr, "ns1:findByPK4Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK4:
		return soap_out_PointerTo_ns1__findByPK4(soap, tag, id, (_ns1__findByPK4 *const*)ptr, "ns1:findByPK4");
	case SOAP_TYPE_PointerTo_ns1__findByPK9Response:
		return soap_out_PointerTo_ns1__findByPK9Response(soap, tag, id, (_ns1__findByPK9Response *const*)ptr, "ns1:findByPK9Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK9:
		return soap_out_PointerTo_ns1__findByPK9(soap, tag, id, (_ns1__findByPK9 *const*)ptr, "ns1:findByPK9");
	case SOAP_TYPE_PointerTo_ns1__update10Response:
		return soap_out_PointerTo_ns1__update10Response(soap, tag, id, (_ns1__update10Response *const*)ptr, "ns1:update10Response");
	case SOAP_TYPE_PointerTo_ns1__update10:
		return soap_out_PointerTo_ns1__update10(soap, tag, id, (_ns1__update10 *const*)ptr, "ns1:update10");
	case SOAP_TYPE_PointerTo_ns1__update8Response:
		return soap_out_PointerTo_ns1__update8Response(soap, tag, id, (_ns1__update8Response *const*)ptr, "ns1:update8Response");
	case SOAP_TYPE_PointerTo_ns1__update8:
		return soap_out_PointerTo_ns1__update8(soap, tag, id, (_ns1__update8 *const*)ptr, "ns1:update8");
	case SOAP_TYPE_PointerTo_ns1__create1Response:
		return soap_out_PointerTo_ns1__create1Response(soap, tag, id, (_ns1__create1Response *const*)ptr, "ns1:create1Response");
	case SOAP_TYPE_PointerTo_ns1__create1:
		return soap_out_PointerTo_ns1__create1(soap, tag, id, (_ns1__create1 *const*)ptr, "ns1:create1");
	case SOAP_TYPE_PointerTo_ns1__remove8Response:
		return soap_out_PointerTo_ns1__remove8Response(soap, tag, id, (_ns1__remove8Response *const*)ptr, "ns1:remove8Response");
	case SOAP_TYPE_PointerTo_ns1__remove8:
		return soap_out_PointerTo_ns1__remove8(soap, tag, id, (_ns1__remove8 *const*)ptr, "ns1:remove8");
	case SOAP_TYPE_PointerTo_ns1__update7Response:
		return soap_out_PointerTo_ns1__update7Response(soap, tag, id, (_ns1__update7Response *const*)ptr, "ns1:update7Response");
	case SOAP_TYPE_PointerTo_ns1__update7:
		return soap_out_PointerTo_ns1__update7(soap, tag, id, (_ns1__update7 *const*)ptr, "ns1:update7");
	case SOAP_TYPE_PointerTo_ns1__remove5Response:
		return soap_out_PointerTo_ns1__remove5Response(soap, tag, id, (_ns1__remove5Response *const*)ptr, "ns1:remove5Response");
	case SOAP_TYPE_PointerTo_ns1__remove5:
		return soap_out_PointerTo_ns1__remove5(soap, tag, id, (_ns1__remove5 *const*)ptr, "ns1:remove5");
	case SOAP_TYPE_PointerTo_ns1__remove4Response:
		return soap_out_PointerTo_ns1__remove4Response(soap, tag, id, (_ns1__remove4Response *const*)ptr, "ns1:remove4Response");
	case SOAP_TYPE_PointerTo_ns1__remove4:
		return soap_out_PointerTo_ns1__remove4(soap, tag, id, (_ns1__remove4 *const*)ptr, "ns1:remove4");
	case SOAP_TYPE_PointerTo_ns1__create7Response:
		return soap_out_PointerTo_ns1__create7Response(soap, tag, id, (_ns1__create7Response *const*)ptr, "ns1:create7Response");
	case SOAP_TYPE_PointerTo_ns1__create7:
		return soap_out_PointerTo_ns1__create7(soap, tag, id, (_ns1__create7 *const*)ptr, "ns1:create7");
	case SOAP_TYPE_PointerTo_ns1__findByPK2Response:
		return soap_out_PointerTo_ns1__findByPK2Response(soap, tag, id, (_ns1__findByPK2Response *const*)ptr, "ns1:findByPK2Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK2:
		return soap_out_PointerTo_ns1__findByPK2(soap, tag, id, (_ns1__findByPK2 *const*)ptr, "ns1:findByPK2");
	case SOAP_TYPE_PointerTo_ns1__generateSQLQueryResponse:
		return soap_out_PointerTo_ns1__generateSQLQueryResponse(soap, tag, id, (_ns1__generateSQLQueryResponse *const*)ptr, "ns1:generateSQLQueryResponse");
	case SOAP_TYPE_PointerTo_ns1__generateSQLQuery:
		return soap_out_PointerTo_ns1__generateSQLQuery(soap, tag, id, (_ns1__generateSQLQuery *const*)ptr, "ns1:generateSQLQuery");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnPPTVOResponse *const*)ptr, "ns1:findBySQLQueryReturnPPTVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, tag, id, (_ns1__findBySQLQueryReturnPPTVO *const*)ptr, "ns1:findBySQLQueryReturnPPTVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnContainerVOResponse *const*)ptr, "ns1:findBySQLQueryReturnContainerVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, tag, id, (_ns1__findBySQLQueryReturnContainerVO *const*)ptr, "ns1:findBySQLQueryReturnContainerVO");
	case SOAP_TYPE_PointerTo_ns1__create6Response:
		return soap_out_PointerTo_ns1__create6Response(soap, tag, id, (_ns1__create6Response *const*)ptr, "ns1:create6Response");
	case SOAP_TYPE_PointerTo_ns1__create6:
		return soap_out_PointerTo_ns1__create6(soap, tag, id, (_ns1__create6 *const*)ptr, "ns1:create6");
	case SOAP_TYPE_PointerTo_ns1__findByPK5Response:
		return soap_out_PointerTo_ns1__findByPK5Response(soap, tag, id, (_ns1__findByPK5Response *const*)ptr, "ns1:findByPK5Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK5:
		return soap_out_PointerTo_ns1__findByPK5(soap, tag, id, (_ns1__findByPK5 *const*)ptr, "ns1:findByPK5");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnPPTSlideVOResponse *const*)ptr, "ns1:findBySQLQueryReturnPPTSlideVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, id, (_ns1__findBySQLQueryReturnPPTSlideVO *const*)ptr, "ns1:findBySQLQueryReturnPPTSlideVO");
	case SOAP_TYPE_PointerTo_ns1__update4Response:
		return soap_out_PointerTo_ns1__update4Response(soap, tag, id, (_ns1__update4Response *const*)ptr, "ns1:update4Response");
	case SOAP_TYPE_PointerTo_ns1__update4:
		return soap_out_PointerTo_ns1__update4(soap, tag, id, (_ns1__update4 *const*)ptr, "ns1:update4");
	case SOAP_TYPE_PointerTo_ns1__create8Response:
		return soap_out_PointerTo_ns1__create8Response(soap, tag, id, (_ns1__create8Response *const*)ptr, "ns1:create8Response");
	case SOAP_TYPE_PointerTo_ns1__create8:
		return soap_out_PointerTo_ns1__create8(soap, tag, id, (_ns1__create8 *const*)ptr, "ns1:create8");
	case SOAP_TYPE_PointerTo_ns1__findByPK8Response:
		return soap_out_PointerTo_ns1__findByPK8Response(soap, tag, id, (_ns1__findByPK8Response *const*)ptr, "ns1:findByPK8Response");
	case SOAP_TYPE_PointerTo_ns1__findByPK8:
		return soap_out_PointerTo_ns1__findByPK8(soap, tag, id, (_ns1__findByPK8 *const*)ptr, "ns1:findByPK8");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnEActivityVOResponse *const*)ptr, "ns1:findBySQLQueryReturnEActivityVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, tag, id, (_ns1__findBySQLQueryReturnEActivityVO *const*)ptr, "ns1:findBySQLQueryReturnEActivityVO");
	case SOAP_TYPE_PointerTo_ns1__remove9Response:
		return soap_out_PointerTo_ns1__remove9Response(soap, tag, id, (_ns1__remove9Response *const*)ptr, "ns1:remove9Response");
	case SOAP_TYPE_PointerTo_ns1__remove9:
		return soap_out_PointerTo_ns1__remove9(soap, tag, id, (_ns1__remove9 *const*)ptr, "ns1:remove9");
	case SOAP_TYPE_PointerTo_ns1__create11Response:
		return soap_out_PointerTo_ns1__create11Response(soap, tag, id, (_ns1__create11Response *const*)ptr, "ns1:create11Response");
	case SOAP_TYPE_PointerTo_ns1__create11:
		return soap_out_PointerTo_ns1__create11(soap, tag, id, (_ns1__create11 *const*)ptr, "ns1:create11");
	case SOAP_TYPE_PointerTo_ns1__update3Response:
		return soap_out_PointerTo_ns1__update3Response(soap, tag, id, (_ns1__update3Response *const*)ptr, "ns1:update3Response");
	case SOAP_TYPE_PointerTo_ns1__update3:
		return soap_out_PointerTo_ns1__update3(soap, tag, id, (_ns1__update3 *const*)ptr, "ns1:update3");
	case SOAP_TYPE_PointerTo_ns1__remove6Response:
		return soap_out_PointerTo_ns1__remove6Response(soap, tag, id, (_ns1__remove6Response *const*)ptr, "ns1:remove6Response");
	case SOAP_TYPE_PointerTo_ns1__remove6:
		return soap_out_PointerTo_ns1__remove6(soap, tag, id, (_ns1__remove6 *const*)ptr, "ns1:remove6");
	case SOAP_TYPE_PointerTo_ns1__remove3Response:
		return soap_out_PointerTo_ns1__remove3Response(soap, tag, id, (_ns1__remove3Response *const*)ptr, "ns1:remove3Response");
	case SOAP_TYPE_PointerTo_ns1__remove3:
		return soap_out_PointerTo_ns1__remove3(soap, tag, id, (_ns1__remove3 *const*)ptr, "ns1:remove3");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnFeedbackVOResponse *const*)ptr, "ns1:findBySQLQueryReturnFeedbackVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, tag, id, (_ns1__findBySQLQueryReturnFeedbackVO *const*)ptr, "ns1:findBySQLQueryReturnFeedbackVO");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(soap, tag, id, (_ns1__findBySQLQueryReturnESignatureVOResponse *const*)ptr, "ns1:findBySQLQueryReturnESignatureVOResponse");
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVO:
		return soap_out_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, tag, id, (_ns1__findBySQLQueryReturnESignatureVO *const*)ptr, "ns1:findBySQLQueryReturnESignatureVO");
	case SOAP_TYPE_PointerTons5__SKSWSException:
		return soap_out_PointerTons5__SKSWSException(soap, tag, id, (ns5__SKSWSException *const*)ptr, "ns5:SKSWSException");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTons4__ArrayOfCommentVO:
		return soap_out_PointerTons4__ArrayOfCommentVO(soap, tag, id, (ns4__ArrayOfCommentVO *const*)ptr, "ns4:ArrayOfCommentVO");
	case SOAP_TYPE_PointerTons4__ArrayOfImageVO:
		return soap_out_PointerTons4__ArrayOfImageVO(soap, tag, id, (ns4__ArrayOfImageVO *const*)ptr, "ns4:ArrayOfImageVO");
	case SOAP_TYPE_PointerTons4__ArrayOfUserVO:
		return soap_out_PointerTons4__ArrayOfUserVO(soap, tag, id, (ns4__ArrayOfUserVO *const*)ptr, "ns4:ArrayOfUserVO");
	case SOAP_TYPE_PointerTons4__ArrayOfEntityVO:
		return soap_out_PointerTons4__ArrayOfEntityVO(soap, tag, id, (ns4__ArrayOfEntityVO *const*)ptr, "ns4:ArrayOfEntityVO");
	case SOAP_TYPE_PointerTons4__CommentVO:
		return soap_out_PointerTons4__CommentVO(soap, tag, id, (ns4__CommentVO *const*)ptr, "ns4:CommentVO");
	case SOAP_TYPE_PointerTons4__ArrayOfDictionaryVO:
		return soap_out_PointerTons4__ArrayOfDictionaryVO(soap, tag, id, (ns4__ArrayOfDictionaryVO *const*)ptr, "ns4:ArrayOfDictionaryVO");
	case SOAP_TYPE_PointerTons4__ArrayOfERelationVO:
		return soap_out_PointerTons4__ArrayOfERelationVO(soap, tag, id, (ns4__ArrayOfERelationVO *const*)ptr, "ns4:ArrayOfERelationVO");
	case SOAP_TYPE_PointerTons4__PPTVO:
		return soap_out_PointerTons4__PPTVO(soap, tag, id, (ns4__PPTVO *const*)ptr, "ns4:PPTVO");
	case SOAP_TYPE_PointerTons4__ContainerVO:
		return soap_out_PointerTons4__ContainerVO(soap, tag, id, (ns4__ContainerVO *const*)ptr, "ns4:ContainerVO");
	case SOAP_TYPE_PointerTons4__FeedbackVO:
		return soap_out_PointerTons4__FeedbackVO(soap, tag, id, (ns4__FeedbackVO *const*)ptr, "ns4:FeedbackVO");
	case SOAP_TYPE_PointerTons4__DictionaryVO:
		return soap_out_PointerTons4__DictionaryVO(soap, tag, id, (ns4__DictionaryVO *const*)ptr, "ns4:DictionaryVO");
	case SOAP_TYPE_PointerTons4__ArrayOfPPTVO:
		return soap_out_PointerTons4__ArrayOfPPTVO(soap, tag, id, (ns4__ArrayOfPPTVO *const*)ptr, "ns4:ArrayOfPPTVO");
	case SOAP_TYPE_PointerTons4__ArrayOfContainerVO:
		return soap_out_PointerTons4__ArrayOfContainerVO(soap, tag, id, (ns4__ArrayOfContainerVO *const*)ptr, "ns4:ArrayOfContainerVO");
	case SOAP_TYPE_PointerTons4__ESignatureVO:
		return soap_out_PointerTons4__ESignatureVO(soap, tag, id, (ns4__ESignatureVO *const*)ptr, "ns4:ESignatureVO");
	case SOAP_TYPE_PointerTons4__ArrayOfPPTSlideVO:
		return soap_out_PointerTons4__ArrayOfPPTSlideVO(soap, tag, id, (ns4__ArrayOfPPTSlideVO *const*)ptr, "ns4:ArrayOfPPTSlideVO");
	case SOAP_TYPE_PointerTons4__ERelationVO:
		return soap_out_PointerTons4__ERelationVO(soap, tag, id, (ns4__ERelationVO *const*)ptr, "ns4:ERelationVO");
	case SOAP_TYPE_PointerTons4__ImageVO:
		return soap_out_PointerTons4__ImageVO(soap, tag, id, (ns4__ImageVO *const*)ptr, "ns4:ImageVO");
	case SOAP_TYPE_PointerTons4__ArrayOfEActivityVO:
		return soap_out_PointerTons4__ArrayOfEActivityVO(soap, tag, id, (ns4__ArrayOfEActivityVO *const*)ptr, "ns4:ArrayOfEActivityVO");
	case SOAP_TYPE_PointerTons4__PPTSlideVO:
		return soap_out_PointerTons4__PPTSlideVO(soap, tag, id, (ns4__PPTSlideVO *const*)ptr, "ns4:PPTSlideVO");
	case SOAP_TYPE_PointerTons4__UserVO:
		return soap_out_PointerTons4__UserVO(soap, tag, id, (ns4__UserVO *const*)ptr, "ns4:UserVO");
	case SOAP_TYPE_PointerTons4__EntityVO:
		return soap_out_PointerTons4__EntityVO(soap, tag, id, (ns4__EntityVO *const*)ptr, "ns4:EntityVO");
	case SOAP_TYPE_PointerTons4__EActivityVO:
		return soap_out_PointerTons4__EActivityVO(soap, tag, id, (ns4__EActivityVO *const*)ptr, "ns4:EActivityVO");
	case SOAP_TYPE_PointerTons4__ArrayOfFeedbackVO:
		return soap_out_PointerTons4__ArrayOfFeedbackVO(soap, tag, id, (ns4__ArrayOfFeedbackVO *const*)ptr, "ns4:ArrayOfFeedbackVO");
	case SOAP_TYPE_PointerTons4__ArrayOfESignatureVO:
		return soap_out_PointerTons4__ArrayOfESignatureVO(soap, tag, id, (ns4__ArrayOfESignatureVO *const*)ptr, "ns4:ArrayOfESignatureVO");
	case SOAP_TYPE_PointerTons2__SKSQuery:
		return soap_out_PointerTons2__SKSQuery(soap, tag, id, (ns2__SKSQuery *const*)ptr, "ns2:SKSQuery");
	case SOAP_TYPE_PointerTo_ns1__anyType2anyTypeMap_entry:
		return soap_out_PointerTo_ns1__anyType2anyTypeMap_entry(soap, tag, id, (struct _ns1__anyType2anyTypeMap_entry *const*)ptr, "ns1:anyType2anyTypeMap-entry");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__anyType2anyTypeMap:
		return soap_out_PointerTons1__anyType2anyTypeMap(soap, tag, id, (ns1__anyType2anyTypeMap *const*)ptr, "ns1:anyType2anyTypeMap");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__ArrayOfDateTime:
		return soap_out_PointerTons1__ArrayOfDateTime(soap, tag, id, (ns1__ArrayOfDateTime *const*)ptr, "ns1:ArrayOfDateTime");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons3__OperatorIntf:
		return soap_out_PointerTons3__OperatorIntf(soap, tag, id, (ns3__OperatorIntf *const*)ptr, "ns3:OperatorIntf");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons1__ArrayOfLong:
		return soap_out_PointerTons1__ArrayOfLong(soap, tag, id, (ns1__ArrayOfLong *const*)ptr, "ns1:ArrayOfLong");
	case SOAP_TYPE_PointerTons2__QueryColumn:
		return soap_out_PointerTons2__QueryColumn(soap, tag, id, (ns2__QueryColumn *const*)ptr, "ns2:QueryColumn");
	case SOAP_TYPE_PointerTons3__ColumnOperatorIntf:
		return soap_out_PointerTons3__ColumnOperatorIntf(soap, tag, id, (ns3__ColumnOperatorIntf *const*)ptr, "ns3:ColumnOperatorIntf");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons3__ScalarIntf:
		return soap_out_PointerTons3__ScalarIntf(soap, tag, id, (ns3__ScalarIntf *const*)ptr, "ns3:ScalarIntf");
	case SOAP_TYPE_PointerTons2__ReturnColumn:
		return soap_out_PointerTons2__ReturnColumn(soap, tag, id, (ns2__ReturnColumn *const*)ptr, "ns2:ReturnColumn");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons2__Order:
		return soap_out_PointerTons2__Order(soap, tag, id, (enum ns2__Order *const*)ptr, "ns2:Order");
	case SOAP_TYPE_PointerTons3__DBColumn:
		return soap_out_PointerTons3__DBColumn(soap, tag, id, (ns3__DBColumn *const*)ptr, "ns3:DBColumn");
	case SOAP_TYPE_PointerTons2__OrderColumn:
		return soap_out_PointerTons2__OrderColumn(soap, tag, id, (ns2__OrderColumn *const*)ptr, "ns2:OrderColumn");
	case SOAP_TYPE_PointerTons2__ArrayOfReturnColumn:
		return soap_out_PointerTons2__ArrayOfReturnColumn(soap, tag, id, (ns2__ArrayOfReturnColumn *const*)ptr, "ns2:ArrayOfReturnColumn");
	case SOAP_TYPE_PointerTons3__SKSObject:
		return soap_out_PointerTons3__SKSObject(soap, tag, id, (ns3__SKSObject *const*)ptr, "ns3:SKSObject");
	case SOAP_TYPE_PointerTons2__ArrayOfQueryColumn:
		return soap_out_PointerTons2__ArrayOfQueryColumn(soap, tag, id, (ns2__ArrayOfQueryColumn *const*)ptr, "ns2:ArrayOfQueryColumn");
	case SOAP_TYPE_PointerTons2__ArrayOfOrderColumn:
		return soap_out_PointerTons2__ArrayOfOrderColumn(soap, tag, id, (ns2__ArrayOfOrderColumn *const*)ptr, "ns2:ArrayOfOrderColumn");
	case SOAP_TYPE_PointerTons2__LimitOffset:
		return soap_out_PointerTons2__LimitOffset(soap, tag, id, (ns2__LimitOffset *const*)ptr, "ns2:LimitOffset");
	case SOAP_TYPE_PointerTons3__ArrayOfDBColumn:
		return soap_out_PointerTons3__ArrayOfDBColumn(soap, tag, id, (ns3__ArrayOfDBColumn *const*)ptr, "ns3:ArrayOfDBColumn");
	case SOAP_TYPE_PointerTons3__ArrayOfSKSObject:
		return soap_out_PointerTons3__ArrayOfSKSObject(soap, tag, id, (ns3__ArrayOfSKSObject *const*)ptr, "ns3:ArrayOfSKSObject");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns2__Order_:
		((ns2__Order_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SKSWSException:
		((ns5__SKSWSException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfCommentVO:
		((ns4__ArrayOfCommentVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfImageVO:
		((ns4__ArrayOfImageVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfUserVO:
		((ns4__ArrayOfUserVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfEntityVO:
		((ns4__ArrayOfEntityVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__CommentVO:
		((ns4__CommentVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfDictionaryVO:
		((ns4__ArrayOfDictionaryVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfERelationVO:
		((ns4__ArrayOfERelationVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__DictionaryVO:
		((ns4__DictionaryVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__PPTVO:
		((ns4__PPTVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfPPTVO:
		((ns4__ArrayOfPPTVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ContainerVO:
		((ns4__ContainerVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfContainerVO:
		((ns4__ArrayOfContainerVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfPPTSlideVO:
		((ns4__ArrayOfPPTSlideVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ERelationVO:
		((ns4__ERelationVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ImageVO:
		((ns4__ImageVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfEActivityVO:
		((ns4__ArrayOfEActivityVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__PPTSlideVO:
		((ns4__PPTSlideVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__EActivityVO:
		((ns4__EActivityVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__UserVO:
		((ns4__UserVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__FeedbackVO:
		((ns4__FeedbackVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfFeedbackVO:
		((ns4__ArrayOfFeedbackVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__EntityVO:
		((ns4__EntityVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ESignatureVO:
		((ns4__ESignatureVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfESignatureVO:
		((ns4__ArrayOfESignatureVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create4Response:
		((_ns1__create4Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create4:
		((_ns1__create4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create9Response:
		((_ns1__create9Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create9:
		((_ns1__create9 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK11Response:
		((_ns1__findByPK11Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK11:
		((_ns1__findByPK11 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update1Response:
		((_ns1__update1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update1:
		((_ns1__update1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create10Response:
		((_ns1__create10Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create10:
		((_ns1__create10 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK1Response:
		((_ns1__findByPK1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK1:
		((_ns1__findByPK1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeResponse:
		((_ns1__removeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove:
		((_ns1__remove *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse:
		((_ns1__findBySQLQueryReturnCommentVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO:
		((_ns1__findBySQLQueryReturnCommentVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK10Response:
		((_ns1__findByPK10Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK10:
		((_ns1__findByPK10 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse:
		((_ns1__findBySQLQueryReturnImageVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVO:
		((_ns1__findBySQLQueryReturnImageVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update2Response:
		((_ns1__update2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update2:
		((_ns1__update2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK3Response:
		((_ns1__findByPK3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK3:
		((_ns1__findByPK3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update5Response:
		((_ns1__update5Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update5:
		((_ns1__update5 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove2Response:
		((_ns1__remove2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove2:
		((_ns1__remove2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create5Response:
		((_ns1__create5Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create5:
		((_ns1__create5 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove11Response:
		((_ns1__remove11Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove11:
		((_ns1__remove11 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse:
		((_ns1__findBySQLQueryReturnUserVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVO:
		((_ns1__findBySQLQueryReturnUserVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse:
		((_ns1__findBySQLQueryReturnEntityVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO:
		((_ns1__findBySQLQueryReturnEntityVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__createResponse:
		((_ns1__createResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create:
		((_ns1__create *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove1Response:
		((_ns1__remove1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove1:
		((_ns1__remove1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK7Response:
		((_ns1__findByPK7Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK7:
		((_ns1__findByPK7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__echoStringResponse:
		((_ns1__echoStringResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__echoString:
		((_ns1__echoString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create2Response:
		((_ns1__create2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create2:
		((_ns1__create2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK6Response:
		((_ns1__findByPK6Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK6:
		((_ns1__findByPK6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__updateResponse:
		((_ns1__updateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update:
		((_ns1__update *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove10Response:
		((_ns1__remove10Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove10:
		((_ns1__remove10 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create3Response:
		((_ns1__create3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create3:
		((_ns1__create3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPKResponse:
		((_ns1__findByPKResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK:
		((_ns1__findByPK *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update6Response:
		((_ns1__update6Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update6:
		((_ns1__update6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update9Response:
		((_ns1__update9Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update9:
		((_ns1__update9 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update11Response:
		((_ns1__update11Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update11:
		((_ns1__update11 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove7Response:
		((_ns1__remove7Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove7:
		((_ns1__remove7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse:
		((_ns1__findBySQLQueryReturnDictionaryVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO:
		((_ns1__findBySQLQueryReturnDictionaryVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse:
		((_ns1__findBySQLQueryReturnERelationVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO:
		((_ns1__findBySQLQueryReturnERelationVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK4Response:
		((_ns1__findByPK4Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK4:
		((_ns1__findByPK4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK9Response:
		((_ns1__findByPK9Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK9:
		((_ns1__findByPK9 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update10Response:
		((_ns1__update10Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update10:
		((_ns1__update10 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update8Response:
		((_ns1__update8Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update8:
		((_ns1__update8 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create1Response:
		((_ns1__create1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create1:
		((_ns1__create1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove8Response:
		((_ns1__remove8Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove8:
		((_ns1__remove8 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update7Response:
		((_ns1__update7Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update7:
		((_ns1__update7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove5Response:
		((_ns1__remove5Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove5:
		((_ns1__remove5 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove4Response:
		((_ns1__remove4Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove4:
		((_ns1__remove4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create7Response:
		((_ns1__create7Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create7:
		((_ns1__create7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK2Response:
		((_ns1__findByPK2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK2:
		((_ns1__findByPK2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__generateSQLQueryResponse:
		((_ns1__generateSQLQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__generateSQLQuery:
		((_ns1__generateSQLQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse:
		((_ns1__findBySQLQueryReturnPPTVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO:
		((_ns1__findBySQLQueryReturnPPTVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse:
		((_ns1__findBySQLQueryReturnContainerVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO:
		((_ns1__findBySQLQueryReturnContainerVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create6Response:
		((_ns1__create6Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create6:
		((_ns1__create6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK5Response:
		((_ns1__findByPK5Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK5:
		((_ns1__findByPK5 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse:
		((_ns1__findBySQLQueryReturnPPTSlideVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO:
		((_ns1__findBySQLQueryReturnPPTSlideVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update4Response:
		((_ns1__update4Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update4:
		((_ns1__update4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create8Response:
		((_ns1__create8Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create8:
		((_ns1__create8 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK8Response:
		((_ns1__findByPK8Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findByPK8:
		((_ns1__findByPK8 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse:
		((_ns1__findBySQLQueryReturnEActivityVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO:
		((_ns1__findBySQLQueryReturnEActivityVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove9Response:
		((_ns1__remove9Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove9:
		((_ns1__remove9 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create11Response:
		((_ns1__create11Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__create11:
		((_ns1__create11 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update3Response:
		((_ns1__update3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__update3:
		((_ns1__update3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove6Response:
		((_ns1__remove6Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove6:
		((_ns1__remove6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove3Response:
		((_ns1__remove3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__remove3:
		((_ns1__remove3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse:
		((_ns1__findBySQLQueryReturnFeedbackVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO:
		((_ns1__findBySQLQueryReturnFeedbackVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse:
		((_ns1__findBySQLQueryReturnESignatureVOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO:
		((_ns1__findBySQLQueryReturnESignatureVO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfLong:
		((ns1__ArrayOfLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		((ns1__ArrayOfDateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__anyType2anyTypeMap:
		((ns1__anyType2anyTypeMap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__OperatorIntf:
		((ns3__OperatorIntf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfDBColumn:
		((ns3__ArrayOfDBColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__SKSObject:
		((ns3__SKSObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfSKSObject:
		((ns3__ArrayOfSKSObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ColumnOperatorIntf:
		((ns3__ColumnOperatorIntf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ScalarIntf:
		((ns3__ScalarIntf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__DBColumn:
		((ns3__DBColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__QueryColumn:
		((ns2__QueryColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ArrayOfQueryColumn:
		((ns2__ArrayOfQueryColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReturnColumn:
		((ns2__ReturnColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ArrayOfReturnColumn:
		((ns2__ArrayOfReturnColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LimitOffset:
		((ns2__LimitOffset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OrderColumn:
		((ns2__OrderColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ArrayOfOrderColumn:
		((ns2__ArrayOfOrderColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SKSQuery:
		((ns2__SKSQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal_:
		((xsd__decimal_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		((xsd__base64Binary_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__create4:
		soap_serialize___ns1__create4(soap, (const struct __ns1__create4 *)ptr);
		break;
	case SOAP_TYPE___ns1__create9:
		soap_serialize___ns1__create9(soap, (const struct __ns1__create9 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK11:
		soap_serialize___ns1__findByPK11(soap, (const struct __ns1__findByPK11 *)ptr);
		break;
	case SOAP_TYPE___ns1__update1:
		soap_serialize___ns1__update1(soap, (const struct __ns1__update1 *)ptr);
		break;
	case SOAP_TYPE___ns1__create10:
		soap_serialize___ns1__create10(soap, (const struct __ns1__create10 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK1:
		soap_serialize___ns1__findByPK1(soap, (const struct __ns1__findByPK1 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove:
		soap_serialize___ns1__remove(soap, (const struct __ns1__remove *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnCommentVO:
		soap_serialize___ns1__findBySQLQueryReturnCommentVO(soap, (const struct __ns1__findBySQLQueryReturnCommentVO *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK10:
		soap_serialize___ns1__findByPK10(soap, (const struct __ns1__findByPK10 *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnImageVO:
		soap_serialize___ns1__findBySQLQueryReturnImageVO(soap, (const struct __ns1__findBySQLQueryReturnImageVO *)ptr);
		break;
	case SOAP_TYPE___ns1__update2:
		soap_serialize___ns1__update2(soap, (const struct __ns1__update2 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK3:
		soap_serialize___ns1__findByPK3(soap, (const struct __ns1__findByPK3 *)ptr);
		break;
	case SOAP_TYPE___ns1__update5:
		soap_serialize___ns1__update5(soap, (const struct __ns1__update5 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove2:
		soap_serialize___ns1__remove2(soap, (const struct __ns1__remove2 *)ptr);
		break;
	case SOAP_TYPE___ns1__create5:
		soap_serialize___ns1__create5(soap, (const struct __ns1__create5 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove11:
		soap_serialize___ns1__remove11(soap, (const struct __ns1__remove11 *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnUserVO:
		soap_serialize___ns1__findBySQLQueryReturnUserVO(soap, (const struct __ns1__findBySQLQueryReturnUserVO *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnEntityVO:
		soap_serialize___ns1__findBySQLQueryReturnEntityVO(soap, (const struct __ns1__findBySQLQueryReturnEntityVO *)ptr);
		break;
	case SOAP_TYPE___ns1__create:
		soap_serialize___ns1__create(soap, (const struct __ns1__create *)ptr);
		break;
	case SOAP_TYPE___ns1__remove1:
		soap_serialize___ns1__remove1(soap, (const struct __ns1__remove1 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK7:
		soap_serialize___ns1__findByPK7(soap, (const struct __ns1__findByPK7 *)ptr);
		break;
	case SOAP_TYPE___ns1__echoString:
		soap_serialize___ns1__echoString(soap, (const struct __ns1__echoString *)ptr);
		break;
	case SOAP_TYPE___ns1__create2:
		soap_serialize___ns1__create2(soap, (const struct __ns1__create2 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK6:
		soap_serialize___ns1__findByPK6(soap, (const struct __ns1__findByPK6 *)ptr);
		break;
	case SOAP_TYPE___ns1__update:
		soap_serialize___ns1__update(soap, (const struct __ns1__update *)ptr);
		break;
	case SOAP_TYPE___ns1__remove10:
		soap_serialize___ns1__remove10(soap, (const struct __ns1__remove10 *)ptr);
		break;
	case SOAP_TYPE___ns1__create3:
		soap_serialize___ns1__create3(soap, (const struct __ns1__create3 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK:
		soap_serialize___ns1__findByPK(soap, (const struct __ns1__findByPK *)ptr);
		break;
	case SOAP_TYPE___ns1__update6:
		soap_serialize___ns1__update6(soap, (const struct __ns1__update6 *)ptr);
		break;
	case SOAP_TYPE___ns1__update9:
		soap_serialize___ns1__update9(soap, (const struct __ns1__update9 *)ptr);
		break;
	case SOAP_TYPE___ns1__update11:
		soap_serialize___ns1__update11(soap, (const struct __ns1__update11 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove7:
		soap_serialize___ns1__remove7(soap, (const struct __ns1__remove7 *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnDictionaryVO:
		soap_serialize___ns1__findBySQLQueryReturnDictionaryVO(soap, (const struct __ns1__findBySQLQueryReturnDictionaryVO *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnERelationVO:
		soap_serialize___ns1__findBySQLQueryReturnERelationVO(soap, (const struct __ns1__findBySQLQueryReturnERelationVO *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK4:
		soap_serialize___ns1__findByPK4(soap, (const struct __ns1__findByPK4 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK9:
		soap_serialize___ns1__findByPK9(soap, (const struct __ns1__findByPK9 *)ptr);
		break;
	case SOAP_TYPE___ns1__update10:
		soap_serialize___ns1__update10(soap, (const struct __ns1__update10 *)ptr);
		break;
	case SOAP_TYPE___ns1__update8:
		soap_serialize___ns1__update8(soap, (const struct __ns1__update8 *)ptr);
		break;
	case SOAP_TYPE___ns1__create1:
		soap_serialize___ns1__create1(soap, (const struct __ns1__create1 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove8:
		soap_serialize___ns1__remove8(soap, (const struct __ns1__remove8 *)ptr);
		break;
	case SOAP_TYPE___ns1__update7:
		soap_serialize___ns1__update7(soap, (const struct __ns1__update7 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove5:
		soap_serialize___ns1__remove5(soap, (const struct __ns1__remove5 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove4:
		soap_serialize___ns1__remove4(soap, (const struct __ns1__remove4 *)ptr);
		break;
	case SOAP_TYPE___ns1__create7:
		soap_serialize___ns1__create7(soap, (const struct __ns1__create7 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK2:
		soap_serialize___ns1__findByPK2(soap, (const struct __ns1__findByPK2 *)ptr);
		break;
	case SOAP_TYPE___ns1__generateSQLQuery:
		soap_serialize___ns1__generateSQLQuery(soap, (const struct __ns1__generateSQLQuery *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnPPTVO:
		soap_serialize___ns1__findBySQLQueryReturnPPTVO(soap, (const struct __ns1__findBySQLQueryReturnPPTVO *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnContainerVO:
		soap_serialize___ns1__findBySQLQueryReturnContainerVO(soap, (const struct __ns1__findBySQLQueryReturnContainerVO *)ptr);
		break;
	case SOAP_TYPE___ns1__create6:
		soap_serialize___ns1__create6(soap, (const struct __ns1__create6 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK5:
		soap_serialize___ns1__findByPK5(soap, (const struct __ns1__findByPK5 *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnPPTSlideVO:
		soap_serialize___ns1__findBySQLQueryReturnPPTSlideVO(soap, (const struct __ns1__findBySQLQueryReturnPPTSlideVO *)ptr);
		break;
	case SOAP_TYPE___ns1__update4:
		soap_serialize___ns1__update4(soap, (const struct __ns1__update4 *)ptr);
		break;
	case SOAP_TYPE___ns1__create8:
		soap_serialize___ns1__create8(soap, (const struct __ns1__create8 *)ptr);
		break;
	case SOAP_TYPE___ns1__findByPK8:
		soap_serialize___ns1__findByPK8(soap, (const struct __ns1__findByPK8 *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnEActivityVO:
		soap_serialize___ns1__findBySQLQueryReturnEActivityVO(soap, (const struct __ns1__findBySQLQueryReturnEActivityVO *)ptr);
		break;
	case SOAP_TYPE___ns1__remove9:
		soap_serialize___ns1__remove9(soap, (const struct __ns1__remove9 *)ptr);
		break;
	case SOAP_TYPE___ns1__create11:
		soap_serialize___ns1__create11(soap, (const struct __ns1__create11 *)ptr);
		break;
	case SOAP_TYPE___ns1__update3:
		soap_serialize___ns1__update3(soap, (const struct __ns1__update3 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove6:
		soap_serialize___ns1__remove6(soap, (const struct __ns1__remove6 *)ptr);
		break;
	case SOAP_TYPE___ns1__remove3:
		soap_serialize___ns1__remove3(soap, (const struct __ns1__remove3 *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnFeedbackVO:
		soap_serialize___ns1__findBySQLQueryReturnFeedbackVO(soap, (const struct __ns1__findBySQLQueryReturnFeedbackVO *)ptr);
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnESignatureVO:
		soap_serialize___ns1__findBySQLQueryReturnESignatureVO(soap, (const struct __ns1__findBySQLQueryReturnESignatureVO *)ptr);
		break;
	case SOAP_TYPE__ns1__anyType2anyTypeMap_entry:
		soap_serialize__ns1__anyType2anyTypeMap_entry(soap, (const struct _ns1__anyType2anyTypeMap_entry *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create4Response:
		soap_serialize_PointerTo_ns1__create4Response(soap, (_ns1__create4Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create4:
		soap_serialize_PointerTo_ns1__create4(soap, (_ns1__create4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create9Response:
		soap_serialize_PointerTo_ns1__create9Response(soap, (_ns1__create9Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create9:
		soap_serialize_PointerTo_ns1__create9(soap, (_ns1__create9 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK11Response:
		soap_serialize_PointerTo_ns1__findByPK11Response(soap, (_ns1__findByPK11Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK11:
		soap_serialize_PointerTo_ns1__findByPK11(soap, (_ns1__findByPK11 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update1Response:
		soap_serialize_PointerTo_ns1__update1Response(soap, (_ns1__update1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update1:
		soap_serialize_PointerTo_ns1__update1(soap, (_ns1__update1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create10Response:
		soap_serialize_PointerTo_ns1__create10Response(soap, (_ns1__create10Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create10:
		soap_serialize_PointerTo_ns1__create10(soap, (_ns1__create10 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK1Response:
		soap_serialize_PointerTo_ns1__findByPK1Response(soap, (_ns1__findByPK1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK1:
		soap_serialize_PointerTo_ns1__findByPK1(soap, (_ns1__findByPK1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeResponse:
		soap_serialize_PointerTo_ns1__removeResponse(soap, (_ns1__removeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove:
		soap_serialize_PointerTo_ns1__remove(soap, (_ns1__remove *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(soap, (_ns1__findBySQLQueryReturnCommentVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, (_ns1__findBySQLQueryReturnCommentVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK10Response:
		soap_serialize_PointerTo_ns1__findByPK10Response(soap, (_ns1__findByPK10Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK10:
		soap_serialize_PointerTo_ns1__findByPK10(soap, (_ns1__findByPK10 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(soap, (_ns1__findBySQLQueryReturnImageVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, (_ns1__findBySQLQueryReturnImageVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update2Response:
		soap_serialize_PointerTo_ns1__update2Response(soap, (_ns1__update2Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update2:
		soap_serialize_PointerTo_ns1__update2(soap, (_ns1__update2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK3Response:
		soap_serialize_PointerTo_ns1__findByPK3Response(soap, (_ns1__findByPK3Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK3:
		soap_serialize_PointerTo_ns1__findByPK3(soap, (_ns1__findByPK3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update5Response:
		soap_serialize_PointerTo_ns1__update5Response(soap, (_ns1__update5Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update5:
		soap_serialize_PointerTo_ns1__update5(soap, (_ns1__update5 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove2Response:
		soap_serialize_PointerTo_ns1__remove2Response(soap, (_ns1__remove2Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove2:
		soap_serialize_PointerTo_ns1__remove2(soap, (_ns1__remove2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create5Response:
		soap_serialize_PointerTo_ns1__create5Response(soap, (_ns1__create5Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create5:
		soap_serialize_PointerTo_ns1__create5(soap, (_ns1__create5 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove11Response:
		soap_serialize_PointerTo_ns1__remove11Response(soap, (_ns1__remove11Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove11:
		soap_serialize_PointerTo_ns1__remove11(soap, (_ns1__remove11 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(soap, (_ns1__findBySQLQueryReturnUserVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, (_ns1__findBySQLQueryReturnUserVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(soap, (_ns1__findBySQLQueryReturnEntityVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, (_ns1__findBySQLQueryReturnEntityVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createResponse:
		soap_serialize_PointerTo_ns1__createResponse(soap, (_ns1__createResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create:
		soap_serialize_PointerTo_ns1__create(soap, (_ns1__create *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove1Response:
		soap_serialize_PointerTo_ns1__remove1Response(soap, (_ns1__remove1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove1:
		soap_serialize_PointerTo_ns1__remove1(soap, (_ns1__remove1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK7Response:
		soap_serialize_PointerTo_ns1__findByPK7Response(soap, (_ns1__findByPK7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK7:
		soap_serialize_PointerTo_ns1__findByPK7(soap, (_ns1__findByPK7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__echoStringResponse:
		soap_serialize_PointerTo_ns1__echoStringResponse(soap, (_ns1__echoStringResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__echoString:
		soap_serialize_PointerTo_ns1__echoString(soap, (_ns1__echoString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create2Response:
		soap_serialize_PointerTo_ns1__create2Response(soap, (_ns1__create2Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create2:
		soap_serialize_PointerTo_ns1__create2(soap, (_ns1__create2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK6Response:
		soap_serialize_PointerTo_ns1__findByPK6Response(soap, (_ns1__findByPK6Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK6:
		soap_serialize_PointerTo_ns1__findByPK6(soap, (_ns1__findByPK6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateResponse:
		soap_serialize_PointerTo_ns1__updateResponse(soap, (_ns1__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update:
		soap_serialize_PointerTo_ns1__update(soap, (_ns1__update *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove10Response:
		soap_serialize_PointerTo_ns1__remove10Response(soap, (_ns1__remove10Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove10:
		soap_serialize_PointerTo_ns1__remove10(soap, (_ns1__remove10 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create3Response:
		soap_serialize_PointerTo_ns1__create3Response(soap, (_ns1__create3Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create3:
		soap_serialize_PointerTo_ns1__create3(soap, (_ns1__create3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPKResponse:
		soap_serialize_PointerTo_ns1__findByPKResponse(soap, (_ns1__findByPKResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK:
		soap_serialize_PointerTo_ns1__findByPK(soap, (_ns1__findByPK *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update6Response:
		soap_serialize_PointerTo_ns1__update6Response(soap, (_ns1__update6Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update6:
		soap_serialize_PointerTo_ns1__update6(soap, (_ns1__update6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update9Response:
		soap_serialize_PointerTo_ns1__update9Response(soap, (_ns1__update9Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update9:
		soap_serialize_PointerTo_ns1__update9(soap, (_ns1__update9 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update11Response:
		soap_serialize_PointerTo_ns1__update11Response(soap, (_ns1__update11Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update11:
		soap_serialize_PointerTo_ns1__update11(soap, (_ns1__update11 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove7Response:
		soap_serialize_PointerTo_ns1__remove7Response(soap, (_ns1__remove7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove7:
		soap_serialize_PointerTo_ns1__remove7(soap, (_ns1__remove7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(soap, (_ns1__findBySQLQueryReturnDictionaryVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, (_ns1__findBySQLQueryReturnDictionaryVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(soap, (_ns1__findBySQLQueryReturnERelationVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, (_ns1__findBySQLQueryReturnERelationVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK4Response:
		soap_serialize_PointerTo_ns1__findByPK4Response(soap, (_ns1__findByPK4Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK4:
		soap_serialize_PointerTo_ns1__findByPK4(soap, (_ns1__findByPK4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK9Response:
		soap_serialize_PointerTo_ns1__findByPK9Response(soap, (_ns1__findByPK9Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK9:
		soap_serialize_PointerTo_ns1__findByPK9(soap, (_ns1__findByPK9 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update10Response:
		soap_serialize_PointerTo_ns1__update10Response(soap, (_ns1__update10Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update10:
		soap_serialize_PointerTo_ns1__update10(soap, (_ns1__update10 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update8Response:
		soap_serialize_PointerTo_ns1__update8Response(soap, (_ns1__update8Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update8:
		soap_serialize_PointerTo_ns1__update8(soap, (_ns1__update8 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create1Response:
		soap_serialize_PointerTo_ns1__create1Response(soap, (_ns1__create1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create1:
		soap_serialize_PointerTo_ns1__create1(soap, (_ns1__create1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove8Response:
		soap_serialize_PointerTo_ns1__remove8Response(soap, (_ns1__remove8Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove8:
		soap_serialize_PointerTo_ns1__remove8(soap, (_ns1__remove8 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update7Response:
		soap_serialize_PointerTo_ns1__update7Response(soap, (_ns1__update7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update7:
		soap_serialize_PointerTo_ns1__update7(soap, (_ns1__update7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove5Response:
		soap_serialize_PointerTo_ns1__remove5Response(soap, (_ns1__remove5Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove5:
		soap_serialize_PointerTo_ns1__remove5(soap, (_ns1__remove5 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove4Response:
		soap_serialize_PointerTo_ns1__remove4Response(soap, (_ns1__remove4Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove4:
		soap_serialize_PointerTo_ns1__remove4(soap, (_ns1__remove4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create7Response:
		soap_serialize_PointerTo_ns1__create7Response(soap, (_ns1__create7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create7:
		soap_serialize_PointerTo_ns1__create7(soap, (_ns1__create7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK2Response:
		soap_serialize_PointerTo_ns1__findByPK2Response(soap, (_ns1__findByPK2Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK2:
		soap_serialize_PointerTo_ns1__findByPK2(soap, (_ns1__findByPK2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__generateSQLQueryResponse:
		soap_serialize_PointerTo_ns1__generateSQLQueryResponse(soap, (_ns1__generateSQLQueryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__generateSQLQuery:
		soap_serialize_PointerTo_ns1__generateSQLQuery(soap, (_ns1__generateSQLQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(soap, (_ns1__findBySQLQueryReturnPPTVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, (_ns1__findBySQLQueryReturnPPTVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(soap, (_ns1__findBySQLQueryReturnContainerVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, (_ns1__findBySQLQueryReturnContainerVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create6Response:
		soap_serialize_PointerTo_ns1__create6Response(soap, (_ns1__create6Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create6:
		soap_serialize_PointerTo_ns1__create6(soap, (_ns1__create6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK5Response:
		soap_serialize_PointerTo_ns1__findByPK5Response(soap, (_ns1__findByPK5Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK5:
		soap_serialize_PointerTo_ns1__findByPK5(soap, (_ns1__findByPK5 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, (_ns1__findBySQLQueryReturnPPTSlideVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, (_ns1__findBySQLQueryReturnPPTSlideVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update4Response:
		soap_serialize_PointerTo_ns1__update4Response(soap, (_ns1__update4Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update4:
		soap_serialize_PointerTo_ns1__update4(soap, (_ns1__update4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create8Response:
		soap_serialize_PointerTo_ns1__create8Response(soap, (_ns1__create8Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create8:
		soap_serialize_PointerTo_ns1__create8(soap, (_ns1__create8 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK8Response:
		soap_serialize_PointerTo_ns1__findByPK8Response(soap, (_ns1__findByPK8Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findByPK8:
		soap_serialize_PointerTo_ns1__findByPK8(soap, (_ns1__findByPK8 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(soap, (_ns1__findBySQLQueryReturnEActivityVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, (_ns1__findBySQLQueryReturnEActivityVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove9Response:
		soap_serialize_PointerTo_ns1__remove9Response(soap, (_ns1__remove9Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove9:
		soap_serialize_PointerTo_ns1__remove9(soap, (_ns1__remove9 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create11Response:
		soap_serialize_PointerTo_ns1__create11Response(soap, (_ns1__create11Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__create11:
		soap_serialize_PointerTo_ns1__create11(soap, (_ns1__create11 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update3Response:
		soap_serialize_PointerTo_ns1__update3Response(soap, (_ns1__update3Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__update3:
		soap_serialize_PointerTo_ns1__update3(soap, (_ns1__update3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove6Response:
		soap_serialize_PointerTo_ns1__remove6Response(soap, (_ns1__remove6Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove6:
		soap_serialize_PointerTo_ns1__remove6(soap, (_ns1__remove6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove3Response:
		soap_serialize_PointerTo_ns1__remove3Response(soap, (_ns1__remove3Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__remove3:
		soap_serialize_PointerTo_ns1__remove3(soap, (_ns1__remove3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(soap, (_ns1__findBySQLQueryReturnFeedbackVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, (_ns1__findBySQLQueryReturnFeedbackVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(soap, (_ns1__findBySQLQueryReturnESignatureVOResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVO:
		soap_serialize_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, (_ns1__findBySQLQueryReturnESignatureVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SKSWSException:
		soap_serialize_PointerTons5__SKSWSException(soap, (ns5__SKSWSException *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfCommentVO:
		soap_serialize_PointerTons4__ArrayOfCommentVO(soap, (ns4__ArrayOfCommentVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfImageVO:
		soap_serialize_PointerTons4__ArrayOfImageVO(soap, (ns4__ArrayOfImageVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfUserVO:
		soap_serialize_PointerTons4__ArrayOfUserVO(soap, (ns4__ArrayOfUserVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfEntityVO:
		soap_serialize_PointerTons4__ArrayOfEntityVO(soap, (ns4__ArrayOfEntityVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CommentVO:
		soap_serialize_PointerTons4__CommentVO(soap, (ns4__CommentVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfDictionaryVO:
		soap_serialize_PointerTons4__ArrayOfDictionaryVO(soap, (ns4__ArrayOfDictionaryVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfERelationVO:
		soap_serialize_PointerTons4__ArrayOfERelationVO(soap, (ns4__ArrayOfERelationVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__PPTVO:
		soap_serialize_PointerTons4__PPTVO(soap, (ns4__PPTVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ContainerVO:
		soap_serialize_PointerTons4__ContainerVO(soap, (ns4__ContainerVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__FeedbackVO:
		soap_serialize_PointerTons4__FeedbackVO(soap, (ns4__FeedbackVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__DictionaryVO:
		soap_serialize_PointerTons4__DictionaryVO(soap, (ns4__DictionaryVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfPPTVO:
		soap_serialize_PointerTons4__ArrayOfPPTVO(soap, (ns4__ArrayOfPPTVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfContainerVO:
		soap_serialize_PointerTons4__ArrayOfContainerVO(soap, (ns4__ArrayOfContainerVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ESignatureVO:
		soap_serialize_PointerTons4__ESignatureVO(soap, (ns4__ESignatureVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfPPTSlideVO:
		soap_serialize_PointerTons4__ArrayOfPPTSlideVO(soap, (ns4__ArrayOfPPTSlideVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ERelationVO:
		soap_serialize_PointerTons4__ERelationVO(soap, (ns4__ERelationVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ImageVO:
		soap_serialize_PointerTons4__ImageVO(soap, (ns4__ImageVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfEActivityVO:
		soap_serialize_PointerTons4__ArrayOfEActivityVO(soap, (ns4__ArrayOfEActivityVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__PPTSlideVO:
		soap_serialize_PointerTons4__PPTSlideVO(soap, (ns4__PPTSlideVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UserVO:
		soap_serialize_PointerTons4__UserVO(soap, (ns4__UserVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__EntityVO:
		soap_serialize_PointerTons4__EntityVO(soap, (ns4__EntityVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__EActivityVO:
		soap_serialize_PointerTons4__EActivityVO(soap, (ns4__EActivityVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfFeedbackVO:
		soap_serialize_PointerTons4__ArrayOfFeedbackVO(soap, (ns4__ArrayOfFeedbackVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfESignatureVO:
		soap_serialize_PointerTons4__ArrayOfESignatureVO(soap, (ns4__ArrayOfESignatureVO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SKSQuery:
		soap_serialize_PointerTons2__SKSQuery(soap, (ns2__SKSQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__anyType2anyTypeMap_entry:
		soap_serialize_PointerTo_ns1__anyType2anyTypeMap_entry(soap, (struct _ns1__anyType2anyTypeMap_entry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__anyType2anyTypeMap:
		soap_serialize_PointerTons1__anyType2anyTypeMap(soap, (ns1__anyType2anyTypeMap *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDateTime:
		soap_serialize_PointerTons1__ArrayOfDateTime(soap, (ns1__ArrayOfDateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__OperatorIntf:
		soap_serialize_PointerTons3__OperatorIntf(soap, (ns3__OperatorIntf *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfLong:
		soap_serialize_PointerTons1__ArrayOfLong(soap, (ns1__ArrayOfLong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__QueryColumn:
		soap_serialize_PointerTons2__QueryColumn(soap, (ns2__QueryColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ColumnOperatorIntf:
		soap_serialize_PointerTons3__ColumnOperatorIntf(soap, (ns3__ColumnOperatorIntf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ScalarIntf:
		soap_serialize_PointerTons3__ScalarIntf(soap, (ns3__ScalarIntf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReturnColumn:
		soap_serialize_PointerTons2__ReturnColumn(soap, (ns2__ReturnColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Order:
		soap_serialize_PointerTons2__Order(soap, (enum ns2__Order *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__DBColumn:
		soap_serialize_PointerTons3__DBColumn(soap, (ns3__DBColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OrderColumn:
		soap_serialize_PointerTons2__OrderColumn(soap, (ns2__OrderColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ArrayOfReturnColumn:
		soap_serialize_PointerTons2__ArrayOfReturnColumn(soap, (ns2__ArrayOfReturnColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__SKSObject:
		soap_serialize_PointerTons3__SKSObject(soap, (ns3__SKSObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ArrayOfQueryColumn:
		soap_serialize_PointerTons2__ArrayOfQueryColumn(soap, (ns2__ArrayOfQueryColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ArrayOfOrderColumn:
		soap_serialize_PointerTons2__ArrayOfOrderColumn(soap, (ns2__ArrayOfOrderColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LimitOffset:
		soap_serialize_PointerTons2__LimitOffset(soap, (ns2__LimitOffset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfDBColumn:
		soap_serialize_PointerTons3__ArrayOfDBColumn(soap, (ns3__ArrayOfDBColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfSKSObject:
		soap_serialize_PointerTons3__ArrayOfSKSObject(soap, (ns3__ArrayOfSKSObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary_:
		return (void*)soap_instantiate_xsd__base64Binary_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal_:
		return (void*)soap_instantiate_xsd__decimal_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Order_:
		return (void*)soap_instantiate_ns2__Order_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SKSQuery:
		return (void*)soap_instantiate_ns2__SKSQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ArrayOfOrderColumn:
		return (void*)soap_instantiate_ns2__ArrayOfOrderColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OrderColumn:
		return (void*)soap_instantiate_ns2__OrderColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LimitOffset:
		return (void*)soap_instantiate_ns2__LimitOffset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ArrayOfReturnColumn:
		return (void*)soap_instantiate_ns2__ArrayOfReturnColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReturnColumn:
		return (void*)soap_instantiate_ns2__ReturnColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ArrayOfQueryColumn:
		return (void*)soap_instantiate_ns2__ArrayOfQueryColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__QueryColumn:
		return (void*)soap_instantiate_ns2__QueryColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__DBColumn:
		return (void*)soap_instantiate_ns3__DBColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ScalarIntf:
		return (void*)soap_instantiate_ns3__ScalarIntf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ColumnOperatorIntf:
		return (void*)soap_instantiate_ns3__ColumnOperatorIntf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfSKSObject:
		return (void*)soap_instantiate_ns3__ArrayOfSKSObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__SKSObject:
		return (void*)soap_instantiate_ns3__SKSObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfDBColumn:
		return (void*)soap_instantiate_ns3__ArrayOfDBColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__OperatorIntf:
		return (void*)soap_instantiate_ns3__OperatorIntf(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__anyType2anyTypeMap_entry:
		return (void*)soap_instantiate__ns1__anyType2anyTypeMap_entry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__anyType2anyTypeMap:
		return (void*)soap_instantiate_ns1__anyType2anyTypeMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		return (void*)soap_instantiate_ns1__ArrayOfDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfLong:
		return (void*)soap_instantiate_ns1__ArrayOfLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnESignatureVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnESignatureVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnFeedbackVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove3:
		return (void*)soap_instantiate__ns1__remove3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove3Response:
		return (void*)soap_instantiate__ns1__remove3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove6:
		return (void*)soap_instantiate__ns1__remove6(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove6Response:
		return (void*)soap_instantiate__ns1__remove6Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update3:
		return (void*)soap_instantiate__ns1__update3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update3Response:
		return (void*)soap_instantiate__ns1__update3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create11:
		return (void*)soap_instantiate__ns1__create11(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create11Response:
		return (void*)soap_instantiate__ns1__create11Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove9:
		return (void*)soap_instantiate__ns1__remove9(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove9Response:
		return (void*)soap_instantiate__ns1__remove9Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnEActivityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnEActivityVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK8:
		return (void*)soap_instantiate__ns1__findByPK8(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK8Response:
		return (void*)soap_instantiate__ns1__findByPK8Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create8:
		return (void*)soap_instantiate__ns1__create8(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create8Response:
		return (void*)soap_instantiate__ns1__create8Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update4:
		return (void*)soap_instantiate__ns1__update4(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update4Response:
		return (void*)soap_instantiate__ns1__update4Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK5:
		return (void*)soap_instantiate__ns1__findByPK5(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK5Response:
		return (void*)soap_instantiate__ns1__findByPK5Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create6:
		return (void*)soap_instantiate__ns1__create6(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create6Response:
		return (void*)soap_instantiate__ns1__create6Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnContainerVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnContainerVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnPPTVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnPPTVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__generateSQLQuery:
		return (void*)soap_instantiate__ns1__generateSQLQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__generateSQLQueryResponse:
		return (void*)soap_instantiate__ns1__generateSQLQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK2:
		return (void*)soap_instantiate__ns1__findByPK2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK2Response:
		return (void*)soap_instantiate__ns1__findByPK2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create7:
		return (void*)soap_instantiate__ns1__create7(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create7Response:
		return (void*)soap_instantiate__ns1__create7Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove4:
		return (void*)soap_instantiate__ns1__remove4(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove4Response:
		return (void*)soap_instantiate__ns1__remove4Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove5:
		return (void*)soap_instantiate__ns1__remove5(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove5Response:
		return (void*)soap_instantiate__ns1__remove5Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update7:
		return (void*)soap_instantiate__ns1__update7(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update7Response:
		return (void*)soap_instantiate__ns1__update7Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove8:
		return (void*)soap_instantiate__ns1__remove8(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove8Response:
		return (void*)soap_instantiate__ns1__remove8Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create1:
		return (void*)soap_instantiate__ns1__create1(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create1Response:
		return (void*)soap_instantiate__ns1__create1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update8:
		return (void*)soap_instantiate__ns1__update8(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update8Response:
		return (void*)soap_instantiate__ns1__update8Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update10:
		return (void*)soap_instantiate__ns1__update10(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update10Response:
		return (void*)soap_instantiate__ns1__update10Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK9:
		return (void*)soap_instantiate__ns1__findByPK9(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK9Response:
		return (void*)soap_instantiate__ns1__findByPK9Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK4:
		return (void*)soap_instantiate__ns1__findByPK4(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK4Response:
		return (void*)soap_instantiate__ns1__findByPK4Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnERelationVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnERelationVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnDictionaryVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove7:
		return (void*)soap_instantiate__ns1__remove7(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove7Response:
		return (void*)soap_instantiate__ns1__remove7Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update11:
		return (void*)soap_instantiate__ns1__update11(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update11Response:
		return (void*)soap_instantiate__ns1__update11Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update9:
		return (void*)soap_instantiate__ns1__update9(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update9Response:
		return (void*)soap_instantiate__ns1__update9Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update6:
		return (void*)soap_instantiate__ns1__update6(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update6Response:
		return (void*)soap_instantiate__ns1__update6Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK:
		return (void*)soap_instantiate__ns1__findByPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPKResponse:
		return (void*)soap_instantiate__ns1__findByPKResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create3:
		return (void*)soap_instantiate__ns1__create3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create3Response:
		return (void*)soap_instantiate__ns1__create3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove10:
		return (void*)soap_instantiate__ns1__remove10(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove10Response:
		return (void*)soap_instantiate__ns1__remove10Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update:
		return (void*)soap_instantiate__ns1__update(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__updateResponse:
		return (void*)soap_instantiate__ns1__updateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK6:
		return (void*)soap_instantiate__ns1__findByPK6(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK6Response:
		return (void*)soap_instantiate__ns1__findByPK6Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create2:
		return (void*)soap_instantiate__ns1__create2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create2Response:
		return (void*)soap_instantiate__ns1__create2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__echoString:
		return (void*)soap_instantiate__ns1__echoString(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__echoStringResponse:
		return (void*)soap_instantiate__ns1__echoStringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK7:
		return (void*)soap_instantiate__ns1__findByPK7(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK7Response:
		return (void*)soap_instantiate__ns1__findByPK7Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove1:
		return (void*)soap_instantiate__ns1__remove1(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove1Response:
		return (void*)soap_instantiate__ns1__remove1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create:
		return (void*)soap_instantiate__ns1__create(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createResponse:
		return (void*)soap_instantiate__ns1__createResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnEntityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnEntityVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnUserVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnUserVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove11:
		return (void*)soap_instantiate__ns1__remove11(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove11Response:
		return (void*)soap_instantiate__ns1__remove11Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create5:
		return (void*)soap_instantiate__ns1__create5(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create5Response:
		return (void*)soap_instantiate__ns1__create5Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove2:
		return (void*)soap_instantiate__ns1__remove2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove2Response:
		return (void*)soap_instantiate__ns1__remove2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update5:
		return (void*)soap_instantiate__ns1__update5(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update5Response:
		return (void*)soap_instantiate__ns1__update5Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK3:
		return (void*)soap_instantiate__ns1__findByPK3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK3Response:
		return (void*)soap_instantiate__ns1__findByPK3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update2:
		return (void*)soap_instantiate__ns1__update2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update2Response:
		return (void*)soap_instantiate__ns1__update2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnImageVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnImageVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK10:
		return (void*)soap_instantiate__ns1__findByPK10(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK10Response:
		return (void*)soap_instantiate__ns1__findByPK10Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnCommentVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse:
		return (void*)soap_instantiate__ns1__findBySQLQueryReturnCommentVOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__remove:
		return (void*)soap_instantiate__ns1__remove(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeResponse:
		return (void*)soap_instantiate__ns1__removeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK1:
		return (void*)soap_instantiate__ns1__findByPK1(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK1Response:
		return (void*)soap_instantiate__ns1__findByPK1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create10:
		return (void*)soap_instantiate__ns1__create10(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create10Response:
		return (void*)soap_instantiate__ns1__create10Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update1:
		return (void*)soap_instantiate__ns1__update1(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__update1Response:
		return (void*)soap_instantiate__ns1__update1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK11:
		return (void*)soap_instantiate__ns1__findByPK11(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findByPK11Response:
		return (void*)soap_instantiate__ns1__findByPK11Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create9:
		return (void*)soap_instantiate__ns1__create9(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create9Response:
		return (void*)soap_instantiate__ns1__create9Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create4:
		return (void*)soap_instantiate__ns1__create4(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__create4Response:
		return (void*)soap_instantiate__ns1__create4Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfESignatureVO:
		return (void*)soap_instantiate_ns4__ArrayOfESignatureVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ESignatureVO:
		return (void*)soap_instantiate_ns4__ESignatureVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__EntityVO:
		return (void*)soap_instantiate_ns4__EntityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfFeedbackVO:
		return (void*)soap_instantiate_ns4__ArrayOfFeedbackVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__FeedbackVO:
		return (void*)soap_instantiate_ns4__FeedbackVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__UserVO:
		return (void*)soap_instantiate_ns4__UserVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__EActivityVO:
		return (void*)soap_instantiate_ns4__EActivityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__PPTSlideVO:
		return (void*)soap_instantiate_ns4__PPTSlideVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfEActivityVO:
		return (void*)soap_instantiate_ns4__ArrayOfEActivityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ImageVO:
		return (void*)soap_instantiate_ns4__ImageVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ERelationVO:
		return (void*)soap_instantiate_ns4__ERelationVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfPPTSlideVO:
		return (void*)soap_instantiate_ns4__ArrayOfPPTSlideVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfContainerVO:
		return (void*)soap_instantiate_ns4__ArrayOfContainerVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ContainerVO:
		return (void*)soap_instantiate_ns4__ContainerVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfPPTVO:
		return (void*)soap_instantiate_ns4__ArrayOfPPTVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__PPTVO:
		return (void*)soap_instantiate_ns4__PPTVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__DictionaryVO:
		return (void*)soap_instantiate_ns4__DictionaryVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfERelationVO:
		return (void*)soap_instantiate_ns4__ArrayOfERelationVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfDictionaryVO:
		return (void*)soap_instantiate_ns4__ArrayOfDictionaryVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__CommentVO:
		return (void*)soap_instantiate_ns4__CommentVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfEntityVO:
		return (void*)soap_instantiate_ns4__ArrayOfEntityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfUserVO:
		return (void*)soap_instantiate_ns4__ArrayOfUserVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfImageVO:
		return (void*)soap_instantiate_ns4__ArrayOfImageVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfCommentVO:
		return (void*)soap_instantiate_ns4__ArrayOfCommentVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SKSWSException:
		return (void*)soap_instantiate_ns5__SKSWSException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnESignatureVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnESignatureVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnFeedbackVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnFeedbackVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove3:
		return (void*)soap_instantiate___ns1__remove3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove6:
		return (void*)soap_instantiate___ns1__remove6(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update3:
		return (void*)soap_instantiate___ns1__update3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create11:
		return (void*)soap_instantiate___ns1__create11(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove9:
		return (void*)soap_instantiate___ns1__remove9(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnEActivityVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnEActivityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK8:
		return (void*)soap_instantiate___ns1__findByPK8(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create8:
		return (void*)soap_instantiate___ns1__create8(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update4:
		return (void*)soap_instantiate___ns1__update4(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnPPTSlideVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnPPTSlideVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK5:
		return (void*)soap_instantiate___ns1__findByPK5(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create6:
		return (void*)soap_instantiate___ns1__create6(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnContainerVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnContainerVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnPPTVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnPPTVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__generateSQLQuery:
		return (void*)soap_instantiate___ns1__generateSQLQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK2:
		return (void*)soap_instantiate___ns1__findByPK2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create7:
		return (void*)soap_instantiate___ns1__create7(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove4:
		return (void*)soap_instantiate___ns1__remove4(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove5:
		return (void*)soap_instantiate___ns1__remove5(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update7:
		return (void*)soap_instantiate___ns1__update7(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove8:
		return (void*)soap_instantiate___ns1__remove8(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create1:
		return (void*)soap_instantiate___ns1__create1(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update8:
		return (void*)soap_instantiate___ns1__update8(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update10:
		return (void*)soap_instantiate___ns1__update10(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK9:
		return (void*)soap_instantiate___ns1__findByPK9(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK4:
		return (void*)soap_instantiate___ns1__findByPK4(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnERelationVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnERelationVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnDictionaryVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnDictionaryVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove7:
		return (void*)soap_instantiate___ns1__remove7(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update11:
		return (void*)soap_instantiate___ns1__update11(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update9:
		return (void*)soap_instantiate___ns1__update9(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update6:
		return (void*)soap_instantiate___ns1__update6(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK:
		return (void*)soap_instantiate___ns1__findByPK(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create3:
		return (void*)soap_instantiate___ns1__create3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove10:
		return (void*)soap_instantiate___ns1__remove10(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update:
		return (void*)soap_instantiate___ns1__update(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK6:
		return (void*)soap_instantiate___ns1__findByPK6(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create2:
		return (void*)soap_instantiate___ns1__create2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__echoString:
		return (void*)soap_instantiate___ns1__echoString(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK7:
		return (void*)soap_instantiate___ns1__findByPK7(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove1:
		return (void*)soap_instantiate___ns1__remove1(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create:
		return (void*)soap_instantiate___ns1__create(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnEntityVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnEntityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnUserVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnUserVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove11:
		return (void*)soap_instantiate___ns1__remove11(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create5:
		return (void*)soap_instantiate___ns1__create5(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove2:
		return (void*)soap_instantiate___ns1__remove2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update5:
		return (void*)soap_instantiate___ns1__update5(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK3:
		return (void*)soap_instantiate___ns1__findByPK3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update2:
		return (void*)soap_instantiate___ns1__update2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnImageVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnImageVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK10:
		return (void*)soap_instantiate___ns1__findByPK10(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findBySQLQueryReturnCommentVO:
		return (void*)soap_instantiate___ns1__findBySQLQueryReturnCommentVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__remove:
		return (void*)soap_instantiate___ns1__remove(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK1:
		return (void*)soap_instantiate___ns1__findByPK1(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create10:
		return (void*)soap_instantiate___ns1__create10(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__update1:
		return (void*)soap_instantiate___ns1__update1(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findByPK11:
		return (void*)soap_instantiate___ns1__findByPK11(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create9:
		return (void*)soap_instantiate___ns1__create9(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create4:
		return (void*)soap_instantiate___ns1__create4(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__CommentVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__CommentVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ImageVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__ImageVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__UserVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__UserVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__EntityVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__EntityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__DictionaryVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__DictionaryVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ERelationVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__ERelationVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__PPTVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ContainerVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__ContainerVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTSlideVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__PPTSlideVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__EActivityVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__EActivityVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__FeedbackVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__FeedbackVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ESignatureVO:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__ESignatureVO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		return (void*)soap_instantiate_std__vectorTemplateOfLONG64(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftime:
		return (void*)soap_instantiate_std__vectorTemplateOftime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DBColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__DBColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__SKSObject:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__SKSObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__QueryColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__QueryColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ReturnColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ReturnColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OrderColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__OrderColumn(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		if (p->size < 0)
			delete (xsd__base64Binary_*)p->ptr;
		else
			delete[] (xsd__base64Binary_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			delete (xsd__boolean*)p->ptr;
		else
			delete[] (xsd__boolean*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			delete (xsd__dateTime*)p->ptr;
		else
			delete[] (xsd__dateTime*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal_:
		if (p->size < 0)
			delete (xsd__decimal_*)p->ptr;
		else
			delete[] (xsd__decimal_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__double:
		if (p->size < 0)
			delete (xsd__double*)p->ptr;
		else
			delete[] (xsd__double*)p->ptr;
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			delete (xsd__int*)p->ptr;
		else
			delete[] (xsd__int*)p->ptr;
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			delete (xsd__long*)p->ptr;
		else
			delete[] (xsd__long*)p->ptr;
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			delete (xsd__string*)p->ptr;
		else
			delete[] (xsd__string*)p->ptr;
		break;
	case SOAP_TYPE_ns2__Order_:
		if (p->size < 0)
			delete (ns2__Order_*)p->ptr;
		else
			delete[] (ns2__Order_*)p->ptr;
		break;
	case SOAP_TYPE_ns2__SKSQuery:
		if (p->size < 0)
			delete (ns2__SKSQuery*)p->ptr;
		else
			delete[] (ns2__SKSQuery*)p->ptr;
		break;
	case SOAP_TYPE_ns2__ArrayOfOrderColumn:
		if (p->size < 0)
			delete (ns2__ArrayOfOrderColumn*)p->ptr;
		else
			delete[] (ns2__ArrayOfOrderColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns2__OrderColumn:
		if (p->size < 0)
			delete (ns2__OrderColumn*)p->ptr;
		else
			delete[] (ns2__OrderColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns2__LimitOffset:
		if (p->size < 0)
			delete (ns2__LimitOffset*)p->ptr;
		else
			delete[] (ns2__LimitOffset*)p->ptr;
		break;
	case SOAP_TYPE_ns2__ArrayOfReturnColumn:
		if (p->size < 0)
			delete (ns2__ArrayOfReturnColumn*)p->ptr;
		else
			delete[] (ns2__ArrayOfReturnColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns2__ReturnColumn:
		if (p->size < 0)
			delete (ns2__ReturnColumn*)p->ptr;
		else
			delete[] (ns2__ReturnColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns2__ArrayOfQueryColumn:
		if (p->size < 0)
			delete (ns2__ArrayOfQueryColumn*)p->ptr;
		else
			delete[] (ns2__ArrayOfQueryColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns2__QueryColumn:
		if (p->size < 0)
			delete (ns2__QueryColumn*)p->ptr;
		else
			delete[] (ns2__QueryColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns3__DBColumn:
		if (p->size < 0)
			delete (ns3__DBColumn*)p->ptr;
		else
			delete[] (ns3__DBColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ScalarIntf:
		if (p->size < 0)
			delete (ns3__ScalarIntf*)p->ptr;
		else
			delete[] (ns3__ScalarIntf*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ColumnOperatorIntf:
		if (p->size < 0)
			delete (ns3__ColumnOperatorIntf*)p->ptr;
		else
			delete[] (ns3__ColumnOperatorIntf*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfSKSObject:
		if (p->size < 0)
			delete (ns3__ArrayOfSKSObject*)p->ptr;
		else
			delete[] (ns3__ArrayOfSKSObject*)p->ptr;
		break;
	case SOAP_TYPE_ns3__SKSObject:
		if (p->size < 0)
			delete (ns3__SKSObject*)p->ptr;
		else
			delete[] (ns3__SKSObject*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfDBColumn:
		if (p->size < 0)
			delete (ns3__ArrayOfDBColumn*)p->ptr;
		else
			delete[] (ns3__ArrayOfDBColumn*)p->ptr;
		break;
	case SOAP_TYPE_ns3__OperatorIntf:
		if (p->size < 0)
			delete (ns3__OperatorIntf*)p->ptr;
		else
			delete[] (ns3__OperatorIntf*)p->ptr;
		break;
	case SOAP_TYPE__ns1__anyType2anyTypeMap_entry:
		if (p->size < 0)
			delete (struct _ns1__anyType2anyTypeMap_entry*)p->ptr;
		else
			delete[] (struct _ns1__anyType2anyTypeMap_entry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__anyType2anyTypeMap:
		if (p->size < 0)
			delete (ns1__anyType2anyTypeMap*)p->ptr;
		else
			delete[] (ns1__anyType2anyTypeMap*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			delete (ns1__ArrayOfString*)p->ptr;
		else
			delete[] (ns1__ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		if (p->size < 0)
			delete (ns1__ArrayOfDateTime*)p->ptr;
		else
			delete[] (ns1__ArrayOfDateTime*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfLong:
		if (p->size < 0)
			delete (ns1__ArrayOfLong*)p->ptr;
		else
			delete[] (ns1__ArrayOfLong*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnESignatureVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnESignatureVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnESignatureVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnESignatureVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnFeedbackVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnFeedbackVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnFeedbackVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnFeedbackVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove3:
		if (p->size < 0)
			delete (_ns1__remove3*)p->ptr;
		else
			delete[] (_ns1__remove3*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove3Response:
		if (p->size < 0)
			delete (_ns1__remove3Response*)p->ptr;
		else
			delete[] (_ns1__remove3Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove6:
		if (p->size < 0)
			delete (_ns1__remove6*)p->ptr;
		else
			delete[] (_ns1__remove6*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove6Response:
		if (p->size < 0)
			delete (_ns1__remove6Response*)p->ptr;
		else
			delete[] (_ns1__remove6Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update3:
		if (p->size < 0)
			delete (_ns1__update3*)p->ptr;
		else
			delete[] (_ns1__update3*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update3Response:
		if (p->size < 0)
			delete (_ns1__update3Response*)p->ptr;
		else
			delete[] (_ns1__update3Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create11:
		if (p->size < 0)
			delete (_ns1__create11*)p->ptr;
		else
			delete[] (_ns1__create11*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create11Response:
		if (p->size < 0)
			delete (_ns1__create11Response*)p->ptr;
		else
			delete[] (_ns1__create11Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove9:
		if (p->size < 0)
			delete (_ns1__remove9*)p->ptr;
		else
			delete[] (_ns1__remove9*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove9Response:
		if (p->size < 0)
			delete (_ns1__remove9Response*)p->ptr;
		else
			delete[] (_ns1__remove9Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnEActivityVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnEActivityVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnEActivityVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnEActivityVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK8:
		if (p->size < 0)
			delete (_ns1__findByPK8*)p->ptr;
		else
			delete[] (_ns1__findByPK8*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK8Response:
		if (p->size < 0)
			delete (_ns1__findByPK8Response*)p->ptr;
		else
			delete[] (_ns1__findByPK8Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create8:
		if (p->size < 0)
			delete (_ns1__create8*)p->ptr;
		else
			delete[] (_ns1__create8*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create8Response:
		if (p->size < 0)
			delete (_ns1__create8Response*)p->ptr;
		else
			delete[] (_ns1__create8Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update4:
		if (p->size < 0)
			delete (_ns1__update4*)p->ptr;
		else
			delete[] (_ns1__update4*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update4Response:
		if (p->size < 0)
			delete (_ns1__update4Response*)p->ptr;
		else
			delete[] (_ns1__update4Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnPPTSlideVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnPPTSlideVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnPPTSlideVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnPPTSlideVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK5:
		if (p->size < 0)
			delete (_ns1__findByPK5*)p->ptr;
		else
			delete[] (_ns1__findByPK5*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK5Response:
		if (p->size < 0)
			delete (_ns1__findByPK5Response*)p->ptr;
		else
			delete[] (_ns1__findByPK5Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create6:
		if (p->size < 0)
			delete (_ns1__create6*)p->ptr;
		else
			delete[] (_ns1__create6*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create6Response:
		if (p->size < 0)
			delete (_ns1__create6Response*)p->ptr;
		else
			delete[] (_ns1__create6Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnContainerVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnContainerVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnContainerVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnContainerVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnPPTVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnPPTVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnPPTVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnPPTVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__generateSQLQuery:
		if (p->size < 0)
			delete (_ns1__generateSQLQuery*)p->ptr;
		else
			delete[] (_ns1__generateSQLQuery*)p->ptr;
		break;
	case SOAP_TYPE__ns1__generateSQLQueryResponse:
		if (p->size < 0)
			delete (_ns1__generateSQLQueryResponse*)p->ptr;
		else
			delete[] (_ns1__generateSQLQueryResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK2:
		if (p->size < 0)
			delete (_ns1__findByPK2*)p->ptr;
		else
			delete[] (_ns1__findByPK2*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK2Response:
		if (p->size < 0)
			delete (_ns1__findByPK2Response*)p->ptr;
		else
			delete[] (_ns1__findByPK2Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create7:
		if (p->size < 0)
			delete (_ns1__create7*)p->ptr;
		else
			delete[] (_ns1__create7*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create7Response:
		if (p->size < 0)
			delete (_ns1__create7Response*)p->ptr;
		else
			delete[] (_ns1__create7Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove4:
		if (p->size < 0)
			delete (_ns1__remove4*)p->ptr;
		else
			delete[] (_ns1__remove4*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove4Response:
		if (p->size < 0)
			delete (_ns1__remove4Response*)p->ptr;
		else
			delete[] (_ns1__remove4Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove5:
		if (p->size < 0)
			delete (_ns1__remove5*)p->ptr;
		else
			delete[] (_ns1__remove5*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove5Response:
		if (p->size < 0)
			delete (_ns1__remove5Response*)p->ptr;
		else
			delete[] (_ns1__remove5Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update7:
		if (p->size < 0)
			delete (_ns1__update7*)p->ptr;
		else
			delete[] (_ns1__update7*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update7Response:
		if (p->size < 0)
			delete (_ns1__update7Response*)p->ptr;
		else
			delete[] (_ns1__update7Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove8:
		if (p->size < 0)
			delete (_ns1__remove8*)p->ptr;
		else
			delete[] (_ns1__remove8*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove8Response:
		if (p->size < 0)
			delete (_ns1__remove8Response*)p->ptr;
		else
			delete[] (_ns1__remove8Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create1:
		if (p->size < 0)
			delete (_ns1__create1*)p->ptr;
		else
			delete[] (_ns1__create1*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create1Response:
		if (p->size < 0)
			delete (_ns1__create1Response*)p->ptr;
		else
			delete[] (_ns1__create1Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update8:
		if (p->size < 0)
			delete (_ns1__update8*)p->ptr;
		else
			delete[] (_ns1__update8*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update8Response:
		if (p->size < 0)
			delete (_ns1__update8Response*)p->ptr;
		else
			delete[] (_ns1__update8Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update10:
		if (p->size < 0)
			delete (_ns1__update10*)p->ptr;
		else
			delete[] (_ns1__update10*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update10Response:
		if (p->size < 0)
			delete (_ns1__update10Response*)p->ptr;
		else
			delete[] (_ns1__update10Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK9:
		if (p->size < 0)
			delete (_ns1__findByPK9*)p->ptr;
		else
			delete[] (_ns1__findByPK9*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK9Response:
		if (p->size < 0)
			delete (_ns1__findByPK9Response*)p->ptr;
		else
			delete[] (_ns1__findByPK9Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK4:
		if (p->size < 0)
			delete (_ns1__findByPK4*)p->ptr;
		else
			delete[] (_ns1__findByPK4*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK4Response:
		if (p->size < 0)
			delete (_ns1__findByPK4Response*)p->ptr;
		else
			delete[] (_ns1__findByPK4Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnERelationVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnERelationVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnERelationVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnERelationVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnDictionaryVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnDictionaryVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnDictionaryVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnDictionaryVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove7:
		if (p->size < 0)
			delete (_ns1__remove7*)p->ptr;
		else
			delete[] (_ns1__remove7*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove7Response:
		if (p->size < 0)
			delete (_ns1__remove7Response*)p->ptr;
		else
			delete[] (_ns1__remove7Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update11:
		if (p->size < 0)
			delete (_ns1__update11*)p->ptr;
		else
			delete[] (_ns1__update11*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update11Response:
		if (p->size < 0)
			delete (_ns1__update11Response*)p->ptr;
		else
			delete[] (_ns1__update11Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update9:
		if (p->size < 0)
			delete (_ns1__update9*)p->ptr;
		else
			delete[] (_ns1__update9*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update9Response:
		if (p->size < 0)
			delete (_ns1__update9Response*)p->ptr;
		else
			delete[] (_ns1__update9Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update6:
		if (p->size < 0)
			delete (_ns1__update6*)p->ptr;
		else
			delete[] (_ns1__update6*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update6Response:
		if (p->size < 0)
			delete (_ns1__update6Response*)p->ptr;
		else
			delete[] (_ns1__update6Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK:
		if (p->size < 0)
			delete (_ns1__findByPK*)p->ptr;
		else
			delete[] (_ns1__findByPK*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPKResponse:
		if (p->size < 0)
			delete (_ns1__findByPKResponse*)p->ptr;
		else
			delete[] (_ns1__findByPKResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create3:
		if (p->size < 0)
			delete (_ns1__create3*)p->ptr;
		else
			delete[] (_ns1__create3*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create3Response:
		if (p->size < 0)
			delete (_ns1__create3Response*)p->ptr;
		else
			delete[] (_ns1__create3Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove10:
		if (p->size < 0)
			delete (_ns1__remove10*)p->ptr;
		else
			delete[] (_ns1__remove10*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove10Response:
		if (p->size < 0)
			delete (_ns1__remove10Response*)p->ptr;
		else
			delete[] (_ns1__remove10Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update:
		if (p->size < 0)
			delete (_ns1__update*)p->ptr;
		else
			delete[] (_ns1__update*)p->ptr;
		break;
	case SOAP_TYPE__ns1__updateResponse:
		if (p->size < 0)
			delete (_ns1__updateResponse*)p->ptr;
		else
			delete[] (_ns1__updateResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK6:
		if (p->size < 0)
			delete (_ns1__findByPK6*)p->ptr;
		else
			delete[] (_ns1__findByPK6*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK6Response:
		if (p->size < 0)
			delete (_ns1__findByPK6Response*)p->ptr;
		else
			delete[] (_ns1__findByPK6Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create2:
		if (p->size < 0)
			delete (_ns1__create2*)p->ptr;
		else
			delete[] (_ns1__create2*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create2Response:
		if (p->size < 0)
			delete (_ns1__create2Response*)p->ptr;
		else
			delete[] (_ns1__create2Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__echoString:
		if (p->size < 0)
			delete (_ns1__echoString*)p->ptr;
		else
			delete[] (_ns1__echoString*)p->ptr;
		break;
	case SOAP_TYPE__ns1__echoStringResponse:
		if (p->size < 0)
			delete (_ns1__echoStringResponse*)p->ptr;
		else
			delete[] (_ns1__echoStringResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK7:
		if (p->size < 0)
			delete (_ns1__findByPK7*)p->ptr;
		else
			delete[] (_ns1__findByPK7*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK7Response:
		if (p->size < 0)
			delete (_ns1__findByPK7Response*)p->ptr;
		else
			delete[] (_ns1__findByPK7Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove1:
		if (p->size < 0)
			delete (_ns1__remove1*)p->ptr;
		else
			delete[] (_ns1__remove1*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove1Response:
		if (p->size < 0)
			delete (_ns1__remove1Response*)p->ptr;
		else
			delete[] (_ns1__remove1Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create:
		if (p->size < 0)
			delete (_ns1__create*)p->ptr;
		else
			delete[] (_ns1__create*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createResponse:
		if (p->size < 0)
			delete (_ns1__createResponse*)p->ptr;
		else
			delete[] (_ns1__createResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnEntityVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnEntityVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnEntityVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnEntityVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnUserVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnUserVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnUserVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnUserVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove11:
		if (p->size < 0)
			delete (_ns1__remove11*)p->ptr;
		else
			delete[] (_ns1__remove11*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove11Response:
		if (p->size < 0)
			delete (_ns1__remove11Response*)p->ptr;
		else
			delete[] (_ns1__remove11Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create5:
		if (p->size < 0)
			delete (_ns1__create5*)p->ptr;
		else
			delete[] (_ns1__create5*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create5Response:
		if (p->size < 0)
			delete (_ns1__create5Response*)p->ptr;
		else
			delete[] (_ns1__create5Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove2:
		if (p->size < 0)
			delete (_ns1__remove2*)p->ptr;
		else
			delete[] (_ns1__remove2*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove2Response:
		if (p->size < 0)
			delete (_ns1__remove2Response*)p->ptr;
		else
			delete[] (_ns1__remove2Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update5:
		if (p->size < 0)
			delete (_ns1__update5*)p->ptr;
		else
			delete[] (_ns1__update5*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update5Response:
		if (p->size < 0)
			delete (_ns1__update5Response*)p->ptr;
		else
			delete[] (_ns1__update5Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK3:
		if (p->size < 0)
			delete (_ns1__findByPK3*)p->ptr;
		else
			delete[] (_ns1__findByPK3*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK3Response:
		if (p->size < 0)
			delete (_ns1__findByPK3Response*)p->ptr;
		else
			delete[] (_ns1__findByPK3Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update2:
		if (p->size < 0)
			delete (_ns1__update2*)p->ptr;
		else
			delete[] (_ns1__update2*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update2Response:
		if (p->size < 0)
			delete (_ns1__update2Response*)p->ptr;
		else
			delete[] (_ns1__update2Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnImageVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnImageVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnImageVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnImageVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK10:
		if (p->size < 0)
			delete (_ns1__findByPK10*)p->ptr;
		else
			delete[] (_ns1__findByPK10*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK10Response:
		if (p->size < 0)
			delete (_ns1__findByPK10Response*)p->ptr;
		else
			delete[] (_ns1__findByPK10Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnCommentVO*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnCommentVO*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse:
		if (p->size < 0)
			delete (_ns1__findBySQLQueryReturnCommentVOResponse*)p->ptr;
		else
			delete[] (_ns1__findBySQLQueryReturnCommentVOResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__remove:
		if (p->size < 0)
			delete (_ns1__remove*)p->ptr;
		else
			delete[] (_ns1__remove*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeResponse:
		if (p->size < 0)
			delete (_ns1__removeResponse*)p->ptr;
		else
			delete[] (_ns1__removeResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK1:
		if (p->size < 0)
			delete (_ns1__findByPK1*)p->ptr;
		else
			delete[] (_ns1__findByPK1*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK1Response:
		if (p->size < 0)
			delete (_ns1__findByPK1Response*)p->ptr;
		else
			delete[] (_ns1__findByPK1Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create10:
		if (p->size < 0)
			delete (_ns1__create10*)p->ptr;
		else
			delete[] (_ns1__create10*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create10Response:
		if (p->size < 0)
			delete (_ns1__create10Response*)p->ptr;
		else
			delete[] (_ns1__create10Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update1:
		if (p->size < 0)
			delete (_ns1__update1*)p->ptr;
		else
			delete[] (_ns1__update1*)p->ptr;
		break;
	case SOAP_TYPE__ns1__update1Response:
		if (p->size < 0)
			delete (_ns1__update1Response*)p->ptr;
		else
			delete[] (_ns1__update1Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK11:
		if (p->size < 0)
			delete (_ns1__findByPK11*)p->ptr;
		else
			delete[] (_ns1__findByPK11*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findByPK11Response:
		if (p->size < 0)
			delete (_ns1__findByPK11Response*)p->ptr;
		else
			delete[] (_ns1__findByPK11Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create9:
		if (p->size < 0)
			delete (_ns1__create9*)p->ptr;
		else
			delete[] (_ns1__create9*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create9Response:
		if (p->size < 0)
			delete (_ns1__create9Response*)p->ptr;
		else
			delete[] (_ns1__create9Response*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create4:
		if (p->size < 0)
			delete (_ns1__create4*)p->ptr;
		else
			delete[] (_ns1__create4*)p->ptr;
		break;
	case SOAP_TYPE__ns1__create4Response:
		if (p->size < 0)
			delete (_ns1__create4Response*)p->ptr;
		else
			delete[] (_ns1__create4Response*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfESignatureVO:
		if (p->size < 0)
			delete (ns4__ArrayOfESignatureVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfESignatureVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ESignatureVO:
		if (p->size < 0)
			delete (ns4__ESignatureVO*)p->ptr;
		else
			delete[] (ns4__ESignatureVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__EntityVO:
		if (p->size < 0)
			delete (ns4__EntityVO*)p->ptr;
		else
			delete[] (ns4__EntityVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfFeedbackVO:
		if (p->size < 0)
			delete (ns4__ArrayOfFeedbackVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfFeedbackVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__FeedbackVO:
		if (p->size < 0)
			delete (ns4__FeedbackVO*)p->ptr;
		else
			delete[] (ns4__FeedbackVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__UserVO:
		if (p->size < 0)
			delete (ns4__UserVO*)p->ptr;
		else
			delete[] (ns4__UserVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__EActivityVO:
		if (p->size < 0)
			delete (ns4__EActivityVO*)p->ptr;
		else
			delete[] (ns4__EActivityVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__PPTSlideVO:
		if (p->size < 0)
			delete (ns4__PPTSlideVO*)p->ptr;
		else
			delete[] (ns4__PPTSlideVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfEActivityVO:
		if (p->size < 0)
			delete (ns4__ArrayOfEActivityVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfEActivityVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ImageVO:
		if (p->size < 0)
			delete (ns4__ImageVO*)p->ptr;
		else
			delete[] (ns4__ImageVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ERelationVO:
		if (p->size < 0)
			delete (ns4__ERelationVO*)p->ptr;
		else
			delete[] (ns4__ERelationVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfPPTSlideVO:
		if (p->size < 0)
			delete (ns4__ArrayOfPPTSlideVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfPPTSlideVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfContainerVO:
		if (p->size < 0)
			delete (ns4__ArrayOfContainerVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfContainerVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ContainerVO:
		if (p->size < 0)
			delete (ns4__ContainerVO*)p->ptr;
		else
			delete[] (ns4__ContainerVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfPPTVO:
		if (p->size < 0)
			delete (ns4__ArrayOfPPTVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfPPTVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__PPTVO:
		if (p->size < 0)
			delete (ns4__PPTVO*)p->ptr;
		else
			delete[] (ns4__PPTVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__DictionaryVO:
		if (p->size < 0)
			delete (ns4__DictionaryVO*)p->ptr;
		else
			delete[] (ns4__DictionaryVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfERelationVO:
		if (p->size < 0)
			delete (ns4__ArrayOfERelationVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfERelationVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfDictionaryVO:
		if (p->size < 0)
			delete (ns4__ArrayOfDictionaryVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfDictionaryVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__CommentVO:
		if (p->size < 0)
			delete (ns4__CommentVO*)p->ptr;
		else
			delete[] (ns4__CommentVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfEntityVO:
		if (p->size < 0)
			delete (ns4__ArrayOfEntityVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfEntityVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfUserVO:
		if (p->size < 0)
			delete (ns4__ArrayOfUserVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfUserVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfImageVO:
		if (p->size < 0)
			delete (ns4__ArrayOfImageVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfImageVO*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfCommentVO:
		if (p->size < 0)
			delete (ns4__ArrayOfCommentVO*)p->ptr;
		else
			delete[] (ns4__ArrayOfCommentVO*)p->ptr;
		break;
	case SOAP_TYPE_ns5__SKSWSException:
		if (p->size < 0)
			delete (ns5__SKSWSException*)p->ptr;
		else
			delete[] (ns5__SKSWSException*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnESignatureVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnESignatureVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnESignatureVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnFeedbackVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnFeedbackVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnFeedbackVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove3:
		if (p->size < 0)
			delete (struct __ns1__remove3*)p->ptr;
		else
			delete[] (struct __ns1__remove3*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove6:
		if (p->size < 0)
			delete (struct __ns1__remove6*)p->ptr;
		else
			delete[] (struct __ns1__remove6*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update3:
		if (p->size < 0)
			delete (struct __ns1__update3*)p->ptr;
		else
			delete[] (struct __ns1__update3*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create11:
		if (p->size < 0)
			delete (struct __ns1__create11*)p->ptr;
		else
			delete[] (struct __ns1__create11*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove9:
		if (p->size < 0)
			delete (struct __ns1__remove9*)p->ptr;
		else
			delete[] (struct __ns1__remove9*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnEActivityVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnEActivityVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnEActivityVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK8:
		if (p->size < 0)
			delete (struct __ns1__findByPK8*)p->ptr;
		else
			delete[] (struct __ns1__findByPK8*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create8:
		if (p->size < 0)
			delete (struct __ns1__create8*)p->ptr;
		else
			delete[] (struct __ns1__create8*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update4:
		if (p->size < 0)
			delete (struct __ns1__update4*)p->ptr;
		else
			delete[] (struct __ns1__update4*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnPPTSlideVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnPPTSlideVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnPPTSlideVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK5:
		if (p->size < 0)
			delete (struct __ns1__findByPK5*)p->ptr;
		else
			delete[] (struct __ns1__findByPK5*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create6:
		if (p->size < 0)
			delete (struct __ns1__create6*)p->ptr;
		else
			delete[] (struct __ns1__create6*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnContainerVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnContainerVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnContainerVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnPPTVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnPPTVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnPPTVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__generateSQLQuery:
		if (p->size < 0)
			delete (struct __ns1__generateSQLQuery*)p->ptr;
		else
			delete[] (struct __ns1__generateSQLQuery*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK2:
		if (p->size < 0)
			delete (struct __ns1__findByPK2*)p->ptr;
		else
			delete[] (struct __ns1__findByPK2*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create7:
		if (p->size < 0)
			delete (struct __ns1__create7*)p->ptr;
		else
			delete[] (struct __ns1__create7*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove4:
		if (p->size < 0)
			delete (struct __ns1__remove4*)p->ptr;
		else
			delete[] (struct __ns1__remove4*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove5:
		if (p->size < 0)
			delete (struct __ns1__remove5*)p->ptr;
		else
			delete[] (struct __ns1__remove5*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update7:
		if (p->size < 0)
			delete (struct __ns1__update7*)p->ptr;
		else
			delete[] (struct __ns1__update7*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove8:
		if (p->size < 0)
			delete (struct __ns1__remove8*)p->ptr;
		else
			delete[] (struct __ns1__remove8*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create1:
		if (p->size < 0)
			delete (struct __ns1__create1*)p->ptr;
		else
			delete[] (struct __ns1__create1*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update8:
		if (p->size < 0)
			delete (struct __ns1__update8*)p->ptr;
		else
			delete[] (struct __ns1__update8*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update10:
		if (p->size < 0)
			delete (struct __ns1__update10*)p->ptr;
		else
			delete[] (struct __ns1__update10*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK9:
		if (p->size < 0)
			delete (struct __ns1__findByPK9*)p->ptr;
		else
			delete[] (struct __ns1__findByPK9*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK4:
		if (p->size < 0)
			delete (struct __ns1__findByPK4*)p->ptr;
		else
			delete[] (struct __ns1__findByPK4*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnERelationVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnERelationVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnERelationVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnDictionaryVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnDictionaryVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnDictionaryVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove7:
		if (p->size < 0)
			delete (struct __ns1__remove7*)p->ptr;
		else
			delete[] (struct __ns1__remove7*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update11:
		if (p->size < 0)
			delete (struct __ns1__update11*)p->ptr;
		else
			delete[] (struct __ns1__update11*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update9:
		if (p->size < 0)
			delete (struct __ns1__update9*)p->ptr;
		else
			delete[] (struct __ns1__update9*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update6:
		if (p->size < 0)
			delete (struct __ns1__update6*)p->ptr;
		else
			delete[] (struct __ns1__update6*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK:
		if (p->size < 0)
			delete (struct __ns1__findByPK*)p->ptr;
		else
			delete[] (struct __ns1__findByPK*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create3:
		if (p->size < 0)
			delete (struct __ns1__create3*)p->ptr;
		else
			delete[] (struct __ns1__create3*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove10:
		if (p->size < 0)
			delete (struct __ns1__remove10*)p->ptr;
		else
			delete[] (struct __ns1__remove10*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update:
		if (p->size < 0)
			delete (struct __ns1__update*)p->ptr;
		else
			delete[] (struct __ns1__update*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK6:
		if (p->size < 0)
			delete (struct __ns1__findByPK6*)p->ptr;
		else
			delete[] (struct __ns1__findByPK6*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create2:
		if (p->size < 0)
			delete (struct __ns1__create2*)p->ptr;
		else
			delete[] (struct __ns1__create2*)p->ptr;
		break;
	case SOAP_TYPE___ns1__echoString:
		if (p->size < 0)
			delete (struct __ns1__echoString*)p->ptr;
		else
			delete[] (struct __ns1__echoString*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK7:
		if (p->size < 0)
			delete (struct __ns1__findByPK7*)p->ptr;
		else
			delete[] (struct __ns1__findByPK7*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove1:
		if (p->size < 0)
			delete (struct __ns1__remove1*)p->ptr;
		else
			delete[] (struct __ns1__remove1*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create:
		if (p->size < 0)
			delete (struct __ns1__create*)p->ptr;
		else
			delete[] (struct __ns1__create*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnEntityVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnEntityVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnEntityVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnUserVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnUserVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnUserVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove11:
		if (p->size < 0)
			delete (struct __ns1__remove11*)p->ptr;
		else
			delete[] (struct __ns1__remove11*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create5:
		if (p->size < 0)
			delete (struct __ns1__create5*)p->ptr;
		else
			delete[] (struct __ns1__create5*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove2:
		if (p->size < 0)
			delete (struct __ns1__remove2*)p->ptr;
		else
			delete[] (struct __ns1__remove2*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update5:
		if (p->size < 0)
			delete (struct __ns1__update5*)p->ptr;
		else
			delete[] (struct __ns1__update5*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK3:
		if (p->size < 0)
			delete (struct __ns1__findByPK3*)p->ptr;
		else
			delete[] (struct __ns1__findByPK3*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update2:
		if (p->size < 0)
			delete (struct __ns1__update2*)p->ptr;
		else
			delete[] (struct __ns1__update2*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnImageVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnImageVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnImageVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK10:
		if (p->size < 0)
			delete (struct __ns1__findByPK10*)p->ptr;
		else
			delete[] (struct __ns1__findByPK10*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findBySQLQueryReturnCommentVO:
		if (p->size < 0)
			delete (struct __ns1__findBySQLQueryReturnCommentVO*)p->ptr;
		else
			delete[] (struct __ns1__findBySQLQueryReturnCommentVO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__remove:
		if (p->size < 0)
			delete (struct __ns1__remove*)p->ptr;
		else
			delete[] (struct __ns1__remove*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK1:
		if (p->size < 0)
			delete (struct __ns1__findByPK1*)p->ptr;
		else
			delete[] (struct __ns1__findByPK1*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create10:
		if (p->size < 0)
			delete (struct __ns1__create10*)p->ptr;
		else
			delete[] (struct __ns1__create10*)p->ptr;
		break;
	case SOAP_TYPE___ns1__update1:
		if (p->size < 0)
			delete (struct __ns1__update1*)p->ptr;
		else
			delete[] (struct __ns1__update1*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findByPK11:
		if (p->size < 0)
			delete (struct __ns1__findByPK11*)p->ptr;
		else
			delete[] (struct __ns1__findByPK11*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create9:
		if (p->size < 0)
			delete (struct __ns1__create9*)p->ptr;
		else
			delete[] (struct __ns1__create9*)p->ptr;
		break;
	case SOAP_TYPE___ns1__create4:
		if (p->size < 0)
			delete (struct __ns1__create4*)p->ptr;
		else
			delete[] (struct __ns1__create4*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__CommentVO:
		if (p->size < 0)
			delete (std::vector<ns4__CommentVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__CommentVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ImageVO:
		if (p->size < 0)
			delete (std::vector<ns4__ImageVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__ImageVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__UserVO:
		if (p->size < 0)
			delete (std::vector<ns4__UserVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__UserVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__EntityVO:
		if (p->size < 0)
			delete (std::vector<ns4__EntityVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__EntityVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__DictionaryVO:
		if (p->size < 0)
			delete (std::vector<ns4__DictionaryVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__DictionaryVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ERelationVO:
		if (p->size < 0)
			delete (std::vector<ns4__ERelationVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__ERelationVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTVO:
		if (p->size < 0)
			delete (std::vector<ns4__PPTVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__PPTVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ContainerVO:
		if (p->size < 0)
			delete (std::vector<ns4__ContainerVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__ContainerVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTSlideVO:
		if (p->size < 0)
			delete (std::vector<ns4__PPTSlideVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__PPTSlideVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__EActivityVO:
		if (p->size < 0)
			delete (std::vector<ns4__EActivityVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__EActivityVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__FeedbackVO:
		if (p->size < 0)
			delete (std::vector<ns4__FeedbackVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__FeedbackVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ESignatureVO:
		if (p->size < 0)
			delete (std::vector<ns4__ESignatureVO * >*)p->ptr;
		else
			delete[] (std::vector<ns4__ESignatureVO * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		if (p->size < 0)
			delete (std::vector<LONG64 >*)p->ptr;
		else
			delete[] (std::vector<LONG64 >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOftime:
		if (p->size < 0)
			delete (std::vector<time_t >*)p->ptr;
		else
			delete[] (std::vector<time_t >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DBColumn:
		if (p->size < 0)
			delete (std::vector<ns3__DBColumn * >*)p->ptr;
		else
			delete[] (std::vector<ns3__DBColumn * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__SKSObject:
		if (p->size < 0)
			delete (std::vector<ns3__SKSObject * >*)p->ptr;
		else
			delete[] (std::vector<ns3__SKSObject * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__QueryColumn:
		if (p->size < 0)
			delete (std::vector<ns2__QueryColumn * >*)p->ptr;
		else
			delete[] (std::vector<ns2__QueryColumn * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ReturnColumn:
		if (p->size < 0)
			delete (std::vector<ns2__ReturnColumn * >*)p->ptr;
		else
			delete[] (std::vector<ns2__ReturnColumn * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OrderColumn:
		if (p->size < 0)
			delete (std::vector<ns2__OrderColumn * >*)p->ptr;
		else
			delete[] (std::vector<ns2__OrderColumn * >*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__CommentVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__CommentVO * >*)p)[len] = *(ns4__CommentVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ImageVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__ImageVO * >*)p)[len] = *(ns4__ImageVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__UserVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__UserVO * >*)p)[len] = *(ns4__UserVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__EntityVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__EntityVO * >*)p)[len] = *(ns4__EntityVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__DictionaryVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__DictionaryVO * >*)p)[len] = *(ns4__DictionaryVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ERelationVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__ERelationVO * >*)p)[len] = *(ns4__ERelationVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__PPTVO * >*)p)[len] = *(ns4__PPTVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ContainerVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__ContainerVO * >*)p)[len] = *(ns4__ContainerVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTSlideVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__PPTSlideVO * >*)p)[len] = *(ns4__PPTSlideVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__EActivityVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__EActivityVO * >*)p)[len] = *(ns4__EActivityVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__FeedbackVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__FeedbackVO * >*)p)[len] = *(ns4__FeedbackVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__ESignatureVO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__ESignatureVO * >*)p)[len] = *(ns4__ESignatureVO **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<LONG64 >*)p)[len] = *(LONG64 *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<time_t >*)p)[len] = *(time_t *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DBColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__DBColumn * >*)p)[len] = *(ns3__DBColumn **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__SKSObject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__SKSObject * >*)p)[len] = *(ns3__SKSObject **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__QueryColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__QueryColumn * >*)p)[len] = *(ns2__QueryColumn **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ReturnColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ReturnColumn * >*)p)[len] = *(ns2__ReturnColumn **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OrderColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__OrderColumn * >*)p)[len] = *(ns2__OrderColumn **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Order(struct soap *soap, enum ns2__Order *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Order
	*a = SOAP_DEFAULT_ns2__Order;
#else
	*a = (enum ns2__Order)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Order(struct soap *soap, const enum ns2__Order *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Order);
	if (soap_out_ns2__Order(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns2__Order[] =
{	{ (long)ns2__Order__ASC, "ASC" },
	{ (long)ns2__Order__DESC, "DESC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__Order2s(struct soap *soap, enum ns2__Order n)
{	const char *s = soap_code_str(soap_codes_ns2__Order, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Order(struct soap *soap, const char *tag, int id, const enum ns2__Order *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Order), type);
	soap_send(soap, soap_ns2__Order2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns2__Order * SOAP_FMAC4 soap_get_ns2__Order(struct soap *soap, enum ns2__Order *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Order(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__Order(struct soap *soap, const char *s, enum ns2__Order *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns2__Order, s);
	if (map)
		*a = (enum ns2__Order)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__Order)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__Order * SOAP_FMAC4 soap_in_ns2__Order(struct soap *soap, const char *tag, enum ns2__Order *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__Order *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Order, sizeof(enum ns2__Order), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__Order(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__Order *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Order, 0, sizeof(enum ns2__Order), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

void ns2__Order_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns2__Order_*)this)->__item, SOAP_TYPE_ns2__Order);
	/* transient soap skipped */
}

void ns2__Order_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__Order(soap, &((ns2__Order_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__Order_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Order_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__Order_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Order_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Order_(struct soap *soap, const char *tag, int id, const ns2__Order_ *a, const char *type)
{
	return soap_out_ns2__Order(soap, tag, id, &(((ns2__Order_*)a)->__item), "ns2:Order");
}

void *ns2__Order_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Order_(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Order_ * SOAP_FMAC4 soap_get_ns2__Order_(struct soap *soap, ns2__Order_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Order_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__Order_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Order_(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Order_ * SOAP_FMAC4 soap_in_ns2__Order_(struct soap *soap, const char *tag, ns2__Order_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__Order_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Order_, sizeof(ns2__Order_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Order_)
			return (ns2__Order_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns2__Order(soap, tag, &(((ns2__Order_*)a)->__item), "ns2:Order"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns2__Order_ * SOAP_FMAC6 soap_new_ns2__Order_(struct soap *soap, int n)
{	return soap_instantiate_ns2__Order_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__Order_(struct soap *soap, ns2__Order_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__Order_ * SOAP_FMAC4 soap_instantiate_ns2__Order_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Order_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Order_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__Order_;
		if (size)
			*size = sizeof(ns2__Order_);
		((ns2__Order_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__Order_[n];
		if (size)
			*size = n * sizeof(ns2__Order_);
		for (int i = 0; i < n; i++)
			((ns2__Order_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__Order_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Order_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Order_ %p -> %p\n", q, p));
	*(ns2__Order_*)p = *(ns2__Order_*)q;
}

void ns5__SKSWSException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void ns5__SKSWSException::soap_default(struct soap *soap)
{
	this->soap = soap;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns5__SKSWSException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__SKSWSException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__SKSWSException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SKSWSException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SKSWSException(struct soap *soap, const char *tag, int id, const ns5__SKSWSException *a, const char *type)
{
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), "ns5:SKSWSException");
}

void *ns5__SKSWSException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SKSWSException(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SKSWSException * SOAP_FMAC4 soap_get_ns5__SKSWSException(struct soap *soap, ns5__SKSWSException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SKSWSException(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__SKSWSException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SKSWSException(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SKSWSException * SOAP_FMAC4 soap_in_ns5__SKSWSException(struct soap *soap, const char *tag, ns5__SKSWSException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__SKSWSException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SKSWSException, sizeof(ns5__SKSWSException), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__SKSWSException)
			return (ns5__SKSWSException *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 ns5__SKSWSException * SOAP_FMAC6 soap_new_ns5__SKSWSException(struct soap *soap, int n)
{	return soap_instantiate_ns5__SKSWSException(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__SKSWSException(struct soap *soap, ns5__SKSWSException *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__SKSWSException * SOAP_FMAC4 soap_instantiate_ns5__SKSWSException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SKSWSException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__SKSWSException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__SKSWSException;
		if (size)
			*size = sizeof(ns5__SKSWSException);
		((ns5__SKSWSException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__SKSWSException[n];
		if (size)
			*size = n * sizeof(ns5__SKSWSException);
		for (int i = 0; i < n; i++)
			((ns5__SKSWSException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__SKSWSException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__SKSWSException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__SKSWSException %p -> %p\n", q, p));
	*(ns5__SKSWSException*)p = *(ns5__SKSWSException*)q;
}

void ns4__ArrayOfCommentVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__CommentVO(soap, &((ns4__ArrayOfCommentVO*)this)->CommentVO);
	/* transient soap skipped */
}

void ns4__ArrayOfCommentVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__CommentVO(soap, &((ns4__ArrayOfCommentVO*)this)->CommentVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfCommentVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfCommentVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfCommentVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfCommentVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfCommentVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfCommentVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfCommentVO), "ns4:ArrayOfCommentVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__CommentVO(soap, "ns4:CommentVO", -1, &(((ns4__ArrayOfCommentVO*)a)->CommentVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfCommentVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfCommentVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfCommentVO * SOAP_FMAC4 soap_get_ns4__ArrayOfCommentVO(struct soap *soap, ns4__ArrayOfCommentVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfCommentVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfCommentVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfCommentVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfCommentVO * SOAP_FMAC4 soap_in_ns4__ArrayOfCommentVO(struct soap *soap, const char *tag, ns4__ArrayOfCommentVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfCommentVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfCommentVO, sizeof(ns4__ArrayOfCommentVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfCommentVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfCommentVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__CommentVO(soap, "ns4:CommentVO", &(((ns4__ArrayOfCommentVO*)a)->CommentVO), "ns4:CommentVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfCommentVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfCommentVO, 0, sizeof(ns4__ArrayOfCommentVO), 0, soap_copy_ns4__ArrayOfCommentVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfCommentVO * SOAP_FMAC6 soap_new_ns4__ArrayOfCommentVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfCommentVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfCommentVO(struct soap *soap, ns4__ArrayOfCommentVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfCommentVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfCommentVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfCommentVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfCommentVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfCommentVO;
		if (size)
			*size = sizeof(ns4__ArrayOfCommentVO);
		((ns4__ArrayOfCommentVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfCommentVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfCommentVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfCommentVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfCommentVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfCommentVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfCommentVO %p -> %p\n", q, p));
	*(ns4__ArrayOfCommentVO*)p = *(ns4__ArrayOfCommentVO*)q;
}

void ns4__ArrayOfImageVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__ImageVO(soap, &((ns4__ArrayOfImageVO*)this)->ImageVO);
	/* transient soap skipped */
}

void ns4__ArrayOfImageVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__ImageVO(soap, &((ns4__ArrayOfImageVO*)this)->ImageVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfImageVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfImageVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfImageVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfImageVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfImageVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfImageVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfImageVO), "ns4:ArrayOfImageVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__ImageVO(soap, "ns4:ImageVO", -1, &(((ns4__ArrayOfImageVO*)a)->ImageVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfImageVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfImageVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfImageVO * SOAP_FMAC4 soap_get_ns4__ArrayOfImageVO(struct soap *soap, ns4__ArrayOfImageVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfImageVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfImageVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfImageVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfImageVO * SOAP_FMAC4 soap_in_ns4__ArrayOfImageVO(struct soap *soap, const char *tag, ns4__ArrayOfImageVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfImageVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfImageVO, sizeof(ns4__ArrayOfImageVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfImageVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfImageVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__ImageVO(soap, "ns4:ImageVO", &(((ns4__ArrayOfImageVO*)a)->ImageVO), "ns4:ImageVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfImageVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfImageVO, 0, sizeof(ns4__ArrayOfImageVO), 0, soap_copy_ns4__ArrayOfImageVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfImageVO * SOAP_FMAC6 soap_new_ns4__ArrayOfImageVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfImageVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfImageVO(struct soap *soap, ns4__ArrayOfImageVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfImageVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfImageVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfImageVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfImageVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfImageVO;
		if (size)
			*size = sizeof(ns4__ArrayOfImageVO);
		((ns4__ArrayOfImageVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfImageVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfImageVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfImageVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfImageVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfImageVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfImageVO %p -> %p\n", q, p));
	*(ns4__ArrayOfImageVO*)p = *(ns4__ArrayOfImageVO*)q;
}

void ns4__ArrayOfUserVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__UserVO(soap, &((ns4__ArrayOfUserVO*)this)->UserVO);
	/* transient soap skipped */
}

void ns4__ArrayOfUserVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__UserVO(soap, &((ns4__ArrayOfUserVO*)this)->UserVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfUserVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfUserVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfUserVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfUserVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfUserVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfUserVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfUserVO), "ns4:ArrayOfUserVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__UserVO(soap, "ns4:UserVO", -1, &(((ns4__ArrayOfUserVO*)a)->UserVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfUserVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfUserVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfUserVO * SOAP_FMAC4 soap_get_ns4__ArrayOfUserVO(struct soap *soap, ns4__ArrayOfUserVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfUserVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfUserVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfUserVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfUserVO * SOAP_FMAC4 soap_in_ns4__ArrayOfUserVO(struct soap *soap, const char *tag, ns4__ArrayOfUserVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfUserVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfUserVO, sizeof(ns4__ArrayOfUserVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfUserVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfUserVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__UserVO(soap, "ns4:UserVO", &(((ns4__ArrayOfUserVO*)a)->UserVO), "ns4:UserVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfUserVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfUserVO, 0, sizeof(ns4__ArrayOfUserVO), 0, soap_copy_ns4__ArrayOfUserVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfUserVO * SOAP_FMAC6 soap_new_ns4__ArrayOfUserVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfUserVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfUserVO(struct soap *soap, ns4__ArrayOfUserVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfUserVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfUserVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfUserVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfUserVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfUserVO;
		if (size)
			*size = sizeof(ns4__ArrayOfUserVO);
		((ns4__ArrayOfUserVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfUserVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfUserVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfUserVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfUserVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfUserVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfUserVO %p -> %p\n", q, p));
	*(ns4__ArrayOfUserVO*)p = *(ns4__ArrayOfUserVO*)q;
}

void ns4__ArrayOfEntityVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__EntityVO(soap, &((ns4__ArrayOfEntityVO*)this)->EntityVO);
	/* transient soap skipped */
}

void ns4__ArrayOfEntityVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__EntityVO(soap, &((ns4__ArrayOfEntityVO*)this)->EntityVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfEntityVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfEntityVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfEntityVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfEntityVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfEntityVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfEntityVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfEntityVO), "ns4:ArrayOfEntityVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__EntityVO(soap, "ns4:EntityVO", -1, &(((ns4__ArrayOfEntityVO*)a)->EntityVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfEntityVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfEntityVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfEntityVO * SOAP_FMAC4 soap_get_ns4__ArrayOfEntityVO(struct soap *soap, ns4__ArrayOfEntityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfEntityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfEntityVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfEntityVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfEntityVO * SOAP_FMAC4 soap_in_ns4__ArrayOfEntityVO(struct soap *soap, const char *tag, ns4__ArrayOfEntityVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfEntityVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfEntityVO, sizeof(ns4__ArrayOfEntityVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfEntityVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfEntityVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__EntityVO(soap, "ns4:EntityVO", &(((ns4__ArrayOfEntityVO*)a)->EntityVO), "ns4:EntityVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfEntityVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfEntityVO, 0, sizeof(ns4__ArrayOfEntityVO), 0, soap_copy_ns4__ArrayOfEntityVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfEntityVO * SOAP_FMAC6 soap_new_ns4__ArrayOfEntityVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfEntityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfEntityVO(struct soap *soap, ns4__ArrayOfEntityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfEntityVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfEntityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfEntityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfEntityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfEntityVO;
		if (size)
			*size = sizeof(ns4__ArrayOfEntityVO);
		((ns4__ArrayOfEntityVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfEntityVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfEntityVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfEntityVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfEntityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfEntityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfEntityVO %p -> %p\n", q, p));
	*(ns4__ArrayOfEntityVO*)p = *(ns4__ArrayOfEntityVO*)q;
}

void ns4__CommentVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__CommentVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__CommentVO*)this)->allScalars);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->commentId);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->commentType);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__CommentVO*)this)->entityVO);
	soap_serialize_PointerToLONG64(soap, &((ns4__CommentVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->labelTextX);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->labelTextY);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->labelType);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->lineColor);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->movieclip);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->name);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->poiId);
	soap_serialize_PointerToLONG64(soap, &((ns4__CommentVO*)this)->securityLabel);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->text);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->textBackgroundColor);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->textColor);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->url);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->username);
	soap_serialize_PointerToxsd__decimal(soap, &((ns4__CommentVO*)this)->x);
	soap_serialize_PointerToxsd__decimal(soap, &((ns4__CommentVO*)this)->xscale);
	soap_serialize_PointerToxsd__decimal(soap, &((ns4__CommentVO*)this)->y);
	soap_serialize_PointerToxsd__decimal(soap, &((ns4__CommentVO*)this)->yscale);
	soap_serialize_PointerTostd__string(soap, &((ns4__CommentVO*)this)->zoom);
	/* transient soap skipped */
}

void ns4__CommentVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__CommentVO*)this)->DBTableName = NULL;
	((ns4__CommentVO*)this)->VOName = NULL;
	((ns4__CommentVO*)this)->allDBColumns = NULL;
	((ns4__CommentVO*)this)->allScalars = NULL;
	((ns4__CommentVO*)this)->commentId = NULL;
	((ns4__CommentVO*)this)->commentType = NULL;
	((ns4__CommentVO*)this)->entityVO = NULL;
	((ns4__CommentVO*)this)->id = NULL;
	((ns4__CommentVO*)this)->identifier = NULL;
	((ns4__CommentVO*)this)->labelTextX = NULL;
	((ns4__CommentVO*)this)->labelTextY = NULL;
	((ns4__CommentVO*)this)->labelType = NULL;
	((ns4__CommentVO*)this)->lineColor = NULL;
	((ns4__CommentVO*)this)->movieclip = NULL;
	((ns4__CommentVO*)this)->name = NULL;
	((ns4__CommentVO*)this)->poiId = NULL;
	((ns4__CommentVO*)this)->securityLabel = NULL;
	((ns4__CommentVO*)this)->text = NULL;
	((ns4__CommentVO*)this)->textBackgroundColor = NULL;
	((ns4__CommentVO*)this)->textColor = NULL;
	((ns4__CommentVO*)this)->url = NULL;
	((ns4__CommentVO*)this)->username = NULL;
	((ns4__CommentVO*)this)->x = NULL;
	((ns4__CommentVO*)this)->xscale = NULL;
	((ns4__CommentVO*)this)->y = NULL;
	((ns4__CommentVO*)this)->yscale = NULL;
	((ns4__CommentVO*)this)->zoom = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__CommentVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__CommentVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__CommentVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__CommentVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CommentVO(struct soap *soap, const char *tag, int id, const ns4__CommentVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CommentVO), "ns4:CommentVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__CommentVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__CommentVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__CommentVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__CommentVO*)a)->allScalars), "");
	soap_out_PointerTostd__string(soap, "ns4:commentId", -1, &(((ns4__CommentVO*)a)->commentId), "");
	soap_out_PointerTostd__string(soap, "ns4:commentType", -1, &(((ns4__CommentVO*)a)->commentType), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__CommentVO*)a)->entityVO), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__CommentVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__CommentVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:labelTextX", -1, &(((ns4__CommentVO*)a)->labelTextX), "");
	soap_out_PointerTostd__string(soap, "ns4:labelTextY", -1, &(((ns4__CommentVO*)a)->labelTextY), "");
	soap_out_PointerTostd__string(soap, "ns4:labelType", -1, &(((ns4__CommentVO*)a)->labelType), "");
	soap_out_PointerTostd__string(soap, "ns4:lineColor", -1, &(((ns4__CommentVO*)a)->lineColor), "");
	soap_out_PointerTostd__string(soap, "ns4:movieclip", -1, &(((ns4__CommentVO*)a)->movieclip), "");
	soap_out_PointerTostd__string(soap, "ns4:name", -1, &(((ns4__CommentVO*)a)->name), "");
	soap_out_PointerTostd__string(soap, "ns4:poiId", -1, &(((ns4__CommentVO*)a)->poiId), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__CommentVO*)a)->securityLabel), "");
	soap_out_PointerTostd__string(soap, "ns4:text", -1, &(((ns4__CommentVO*)a)->text), "");
	soap_out_PointerTostd__string(soap, "ns4:textBackgroundColor", -1, &(((ns4__CommentVO*)a)->textBackgroundColor), "");
	soap_out_PointerTostd__string(soap, "ns4:textColor", -1, &(((ns4__CommentVO*)a)->textColor), "");
	soap_out_PointerTostd__string(soap, "ns4:url", -1, &(((ns4__CommentVO*)a)->url), "");
	soap_out_PointerTostd__string(soap, "ns4:username", -1, &(((ns4__CommentVO*)a)->username), "");
	soap_out_PointerToxsd__decimal(soap, "ns4:x", -1, &(((ns4__CommentVO*)a)->x), "");
	soap_out_PointerToxsd__decimal(soap, "ns4:xscale", -1, &(((ns4__CommentVO*)a)->xscale), "");
	soap_out_PointerToxsd__decimal(soap, "ns4:y", -1, &(((ns4__CommentVO*)a)->y), "");
	soap_out_PointerToxsd__decimal(soap, "ns4:yscale", -1, &(((ns4__CommentVO*)a)->yscale), "");
	soap_out_PointerTostd__string(soap, "ns4:zoom", -1, &(((ns4__CommentVO*)a)->zoom), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__CommentVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__CommentVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__CommentVO * SOAP_FMAC4 soap_get_ns4__CommentVO(struct soap *soap, ns4__CommentVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CommentVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__CommentVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__CommentVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__CommentVO * SOAP_FMAC4 soap_in_ns4__CommentVO(struct soap *soap, const char *tag, ns4__CommentVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__CommentVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CommentVO, sizeof(ns4__CommentVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__CommentVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__CommentVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_commentId1 = 1, soap_flag_commentType1 = 1, soap_flag_entityVO1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_labelTextX1 = 1, soap_flag_labelTextY1 = 1, soap_flag_labelType1 = 1, soap_flag_lineColor1 = 1, soap_flag_movieclip1 = 1, soap_flag_name1 = 1, soap_flag_poiId1 = 1, soap_flag_securityLabel1 = 1, soap_flag_text1 = 1, soap_flag_textBackgroundColor1 = 1, soap_flag_textColor1 = 1, soap_flag_url1 = 1, soap_flag_username1 = 1, soap_flag_x1 = 1, soap_flag_xscale1 = 1, soap_flag_y1 = 1, soap_flag_yscale1 = 1, soap_flag_zoom1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__CommentVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__CommentVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__CommentVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__CommentVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_commentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:commentId", &(((ns4__CommentVO*)a)->commentId), "xsd:string"))
				{	soap_flag_commentId1--;
					continue;
				}
			if (soap_flag_commentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:commentType", &(((ns4__CommentVO*)a)->commentType), "xsd:string"))
				{	soap_flag_commentType1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__CommentVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__CommentVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__CommentVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_labelTextX1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:labelTextX", &(((ns4__CommentVO*)a)->labelTextX), "xsd:string"))
				{	soap_flag_labelTextX1--;
					continue;
				}
			if (soap_flag_labelTextY1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:labelTextY", &(((ns4__CommentVO*)a)->labelTextY), "xsd:string"))
				{	soap_flag_labelTextY1--;
					continue;
				}
			if (soap_flag_labelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:labelType", &(((ns4__CommentVO*)a)->labelType), "xsd:string"))
				{	soap_flag_labelType1--;
					continue;
				}
			if (soap_flag_lineColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:lineColor", &(((ns4__CommentVO*)a)->lineColor), "xsd:string"))
				{	soap_flag_lineColor1--;
					continue;
				}
			if (soap_flag_movieclip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:movieclip", &(((ns4__CommentVO*)a)->movieclip), "xsd:string"))
				{	soap_flag_movieclip1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:name", &(((ns4__CommentVO*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_poiId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:poiId", &(((ns4__CommentVO*)a)->poiId), "xsd:string"))
				{	soap_flag_poiId1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__CommentVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:text", &(((ns4__CommentVO*)a)->text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_textBackgroundColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:textBackgroundColor", &(((ns4__CommentVO*)a)->textBackgroundColor), "xsd:string"))
				{	soap_flag_textBackgroundColor1--;
					continue;
				}
			if (soap_flag_textColor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:textColor", &(((ns4__CommentVO*)a)->textColor), "xsd:string"))
				{	soap_flag_textColor1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:url", &(((ns4__CommentVO*)a)->url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:username", &(((ns4__CommentVO*)a)->username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_x1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "ns4:x", &(((ns4__CommentVO*)a)->x), "xsd:decimal"))
				{	soap_flag_x1--;
					continue;
				}
			if (soap_flag_xscale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "ns4:xscale", &(((ns4__CommentVO*)a)->xscale), "xsd:decimal"))
				{	soap_flag_xscale1--;
					continue;
				}
			if (soap_flag_y1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "ns4:y", &(((ns4__CommentVO*)a)->y), "xsd:decimal"))
				{	soap_flag_y1--;
					continue;
				}
			if (soap_flag_yscale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "ns4:yscale", &(((ns4__CommentVO*)a)->yscale), "xsd:decimal"))
				{	soap_flag_yscale1--;
					continue;
				}
			if (soap_flag_zoom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:zoom", &(((ns4__CommentVO*)a)->zoom), "xsd:string"))
				{	soap_flag_zoom1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__CommentVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CommentVO, 0, sizeof(ns4__CommentVO), 0, soap_copy_ns4__CommentVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__CommentVO * SOAP_FMAC6 soap_new_ns4__CommentVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__CommentVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__CommentVO(struct soap *soap, ns4__CommentVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__CommentVO * SOAP_FMAC4 soap_instantiate_ns4__CommentVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__CommentVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__CommentVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__CommentVO;
		if (size)
			*size = sizeof(ns4__CommentVO);
		((ns4__CommentVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__CommentVO[n];
		if (size)
			*size = n * sizeof(ns4__CommentVO);
		for (int i = 0; i < n; i++)
			((ns4__CommentVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__CommentVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__CommentVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__CommentVO %p -> %p\n", q, p));
	*(ns4__CommentVO*)p = *(ns4__CommentVO*)q;
}

void ns4__ArrayOfDictionaryVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__DictionaryVO(soap, &((ns4__ArrayOfDictionaryVO*)this)->DictionaryVO);
	/* transient soap skipped */
}

void ns4__ArrayOfDictionaryVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__DictionaryVO(soap, &((ns4__ArrayOfDictionaryVO*)this)->DictionaryVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfDictionaryVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfDictionaryVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfDictionaryVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfDictionaryVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfDictionaryVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfDictionaryVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfDictionaryVO), "ns4:ArrayOfDictionaryVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__DictionaryVO(soap, "ns4:DictionaryVO", -1, &(((ns4__ArrayOfDictionaryVO*)a)->DictionaryVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfDictionaryVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfDictionaryVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfDictionaryVO * SOAP_FMAC4 soap_get_ns4__ArrayOfDictionaryVO(struct soap *soap, ns4__ArrayOfDictionaryVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfDictionaryVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfDictionaryVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfDictionaryVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfDictionaryVO * SOAP_FMAC4 soap_in_ns4__ArrayOfDictionaryVO(struct soap *soap, const char *tag, ns4__ArrayOfDictionaryVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfDictionaryVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfDictionaryVO, sizeof(ns4__ArrayOfDictionaryVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfDictionaryVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfDictionaryVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__DictionaryVO(soap, "ns4:DictionaryVO", &(((ns4__ArrayOfDictionaryVO*)a)->DictionaryVO), "ns4:DictionaryVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfDictionaryVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfDictionaryVO, 0, sizeof(ns4__ArrayOfDictionaryVO), 0, soap_copy_ns4__ArrayOfDictionaryVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfDictionaryVO * SOAP_FMAC6 soap_new_ns4__ArrayOfDictionaryVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfDictionaryVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfDictionaryVO(struct soap *soap, ns4__ArrayOfDictionaryVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfDictionaryVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfDictionaryVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfDictionaryVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfDictionaryVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfDictionaryVO;
		if (size)
			*size = sizeof(ns4__ArrayOfDictionaryVO);
		((ns4__ArrayOfDictionaryVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfDictionaryVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfDictionaryVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfDictionaryVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfDictionaryVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfDictionaryVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfDictionaryVO %p -> %p\n", q, p));
	*(ns4__ArrayOfDictionaryVO*)p = *(ns4__ArrayOfDictionaryVO*)q;
}

void ns4__ArrayOfERelationVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__ERelationVO(soap, &((ns4__ArrayOfERelationVO*)this)->ERelationVO);
	/* transient soap skipped */
}

void ns4__ArrayOfERelationVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__ERelationVO(soap, &((ns4__ArrayOfERelationVO*)this)->ERelationVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfERelationVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfERelationVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfERelationVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfERelationVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfERelationVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfERelationVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfERelationVO), "ns4:ArrayOfERelationVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__ERelationVO(soap, "ns4:ERelationVO", -1, &(((ns4__ArrayOfERelationVO*)a)->ERelationVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfERelationVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfERelationVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfERelationVO * SOAP_FMAC4 soap_get_ns4__ArrayOfERelationVO(struct soap *soap, ns4__ArrayOfERelationVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfERelationVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfERelationVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfERelationVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfERelationVO * SOAP_FMAC4 soap_in_ns4__ArrayOfERelationVO(struct soap *soap, const char *tag, ns4__ArrayOfERelationVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfERelationVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfERelationVO, sizeof(ns4__ArrayOfERelationVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfERelationVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfERelationVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__ERelationVO(soap, "ns4:ERelationVO", &(((ns4__ArrayOfERelationVO*)a)->ERelationVO), "ns4:ERelationVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfERelationVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfERelationVO, 0, sizeof(ns4__ArrayOfERelationVO), 0, soap_copy_ns4__ArrayOfERelationVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfERelationVO * SOAP_FMAC6 soap_new_ns4__ArrayOfERelationVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfERelationVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfERelationVO(struct soap *soap, ns4__ArrayOfERelationVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfERelationVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfERelationVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfERelationVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfERelationVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfERelationVO;
		if (size)
			*size = sizeof(ns4__ArrayOfERelationVO);
		((ns4__ArrayOfERelationVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfERelationVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfERelationVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfERelationVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfERelationVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfERelationVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfERelationVO %p -> %p\n", q, p));
	*(ns4__ArrayOfERelationVO*)p = *(ns4__ArrayOfERelationVO*)q;
}

void ns4__DictionaryVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__DictionaryVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__DictionaryVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__DictionaryVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__DictionaryVO*)this)->allScalars);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__DictionaryVO*)this)->entityVO);
	soap_serialize_PointerToLONG64(soap, &((ns4__DictionaryVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__DictionaryVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__DictionaryVO*)this)->name);
	soap_serialize_PointerToLONG64(soap, &((ns4__DictionaryVO*)this)->securityLabel);
	soap_serialize_PointerTotime(soap, &((ns4__DictionaryVO*)this)->timeEnd);
	soap_serialize_PointerTotime(soap, &((ns4__DictionaryVO*)this)->timeStart);
	/* transient soap skipped */
}

void ns4__DictionaryVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__DictionaryVO*)this)->DBTableName = NULL;
	((ns4__DictionaryVO*)this)->VOName = NULL;
	((ns4__DictionaryVO*)this)->allDBColumns = NULL;
	((ns4__DictionaryVO*)this)->allScalars = NULL;
	((ns4__DictionaryVO*)this)->entityVO = NULL;
	((ns4__DictionaryVO*)this)->id = NULL;
	((ns4__DictionaryVO*)this)->identifier = NULL;
	((ns4__DictionaryVO*)this)->name = NULL;
	((ns4__DictionaryVO*)this)->securityLabel = NULL;
	((ns4__DictionaryVO*)this)->timeEnd = NULL;
	((ns4__DictionaryVO*)this)->timeStart = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__DictionaryVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__DictionaryVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__DictionaryVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__DictionaryVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DictionaryVO(struct soap *soap, const char *tag, int id, const ns4__DictionaryVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__DictionaryVO), "ns4:DictionaryVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__DictionaryVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__DictionaryVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__DictionaryVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__DictionaryVO*)a)->allScalars), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__DictionaryVO*)a)->entityVO), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__DictionaryVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__DictionaryVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:name", -1, &(((ns4__DictionaryVO*)a)->name), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__DictionaryVO*)a)->securityLabel), "");
	soap_out_PointerTotime(soap, "ns4:timeEnd", -1, &(((ns4__DictionaryVO*)a)->timeEnd), "");
	soap_out_PointerTotime(soap, "ns4:timeStart", -1, &(((ns4__DictionaryVO*)a)->timeStart), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__DictionaryVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__DictionaryVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__DictionaryVO * SOAP_FMAC4 soap_get_ns4__DictionaryVO(struct soap *soap, ns4__DictionaryVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DictionaryVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__DictionaryVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__DictionaryVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__DictionaryVO * SOAP_FMAC4 soap_in_ns4__DictionaryVO(struct soap *soap, const char *tag, ns4__DictionaryVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__DictionaryVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DictionaryVO, sizeof(ns4__DictionaryVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__DictionaryVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__DictionaryVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_entityVO1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_name1 = 1, soap_flag_securityLabel1 = 1, soap_flag_timeEnd1 = 1, soap_flag_timeStart1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__DictionaryVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__DictionaryVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__DictionaryVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__DictionaryVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__DictionaryVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__DictionaryVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__DictionaryVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:name", &(((ns4__DictionaryVO*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__DictionaryVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_timeEnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:timeEnd", &(((ns4__DictionaryVO*)a)->timeEnd), "xsd:dateTime"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			if (soap_flag_timeStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:timeStart", &(((ns4__DictionaryVO*)a)->timeStart), "xsd:dateTime"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__DictionaryVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DictionaryVO, 0, sizeof(ns4__DictionaryVO), 0, soap_copy_ns4__DictionaryVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__DictionaryVO * SOAP_FMAC6 soap_new_ns4__DictionaryVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__DictionaryVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__DictionaryVO(struct soap *soap, ns4__DictionaryVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__DictionaryVO * SOAP_FMAC4 soap_instantiate_ns4__DictionaryVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__DictionaryVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__DictionaryVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__DictionaryVO;
		if (size)
			*size = sizeof(ns4__DictionaryVO);
		((ns4__DictionaryVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__DictionaryVO[n];
		if (size)
			*size = n * sizeof(ns4__DictionaryVO);
		for (int i = 0; i < n; i++)
			((ns4__DictionaryVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__DictionaryVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__DictionaryVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__DictionaryVO %p -> %p\n", q, p));
	*(ns4__DictionaryVO*)p = *(ns4__DictionaryVO*)q;
}

void ns4__PPTVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__PPTVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__PPTVO*)this)->allScalars);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->author);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->category);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->comments);
	soap_serialize_PointerToLONG64(soap, &((ns4__PPTVO*)this)->entityID);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__PPTVO*)this)->entityVO);
	soap_serialize_PointerToint(soap, &((ns4__PPTVO*)this)->height);
	soap_serialize_PointerToLONG64(soap, &((ns4__PPTVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->imageMimetype);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->imageType);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->imageUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->keywords);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->revision);
	soap_serialize_PointerToLONG64(soap, &((ns4__PPTVO*)this)->securityLabel);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->sourceDir);
	soap_serialize_PointerToxsd__base64Binary(soap, &((ns4__PPTVO*)this)->thumbS);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->thumbSMimetype);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->thumbUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->tileUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTVO*)this)->title);
	soap_serialize_PointerToint(soap, &((ns4__PPTVO*)this)->width);
	/* transient soap skipped */
}

void ns4__PPTVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__PPTVO*)this)->DBTableName = NULL;
	((ns4__PPTVO*)this)->VOName = NULL;
	((ns4__PPTVO*)this)->allDBColumns = NULL;
	((ns4__PPTVO*)this)->allScalars = NULL;
	((ns4__PPTVO*)this)->author = NULL;
	((ns4__PPTVO*)this)->category = NULL;
	((ns4__PPTVO*)this)->comments = NULL;
	((ns4__PPTVO*)this)->entityID = NULL;
	((ns4__PPTVO*)this)->entityVO = NULL;
	((ns4__PPTVO*)this)->height = NULL;
	((ns4__PPTVO*)this)->id = NULL;
	((ns4__PPTVO*)this)->identifier = NULL;
	((ns4__PPTVO*)this)->imageMimetype = NULL;
	((ns4__PPTVO*)this)->imageType = NULL;
	((ns4__PPTVO*)this)->imageUrl = NULL;
	((ns4__PPTVO*)this)->keywords = NULL;
	((ns4__PPTVO*)this)->revision = NULL;
	((ns4__PPTVO*)this)->securityLabel = NULL;
	((ns4__PPTVO*)this)->sourceDir = NULL;
	((ns4__PPTVO*)this)->thumbS = NULL;
	((ns4__PPTVO*)this)->thumbSMimetype = NULL;
	((ns4__PPTVO*)this)->thumbUrl = NULL;
	((ns4__PPTVO*)this)->tileUrl = NULL;
	((ns4__PPTVO*)this)->title = NULL;
	((ns4__PPTVO*)this)->width = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__PPTVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__PPTVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__PPTVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__PPTVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PPTVO(struct soap *soap, const char *tag, int id, const ns4__PPTVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__PPTVO), "ns4:PPTVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__PPTVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__PPTVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__PPTVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__PPTVO*)a)->allScalars), "");
	soap_out_PointerTostd__string(soap, "ns4:author", -1, &(((ns4__PPTVO*)a)->author), "");
	soap_out_PointerTostd__string(soap, "ns4:category", -1, &(((ns4__PPTVO*)a)->category), "");
	soap_out_PointerTostd__string(soap, "ns4:comments", -1, &(((ns4__PPTVO*)a)->comments), "");
	soap_out_PointerToLONG64(soap, "ns4:entityID", -1, &(((ns4__PPTVO*)a)->entityID), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__PPTVO*)a)->entityVO), "");
	soap_out_PointerToint(soap, "ns4:height", -1, &(((ns4__PPTVO*)a)->height), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__PPTVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__PPTVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:imageMimetype", -1, &(((ns4__PPTVO*)a)->imageMimetype), "");
	soap_out_PointerTostd__string(soap, "ns4:imageType", -1, &(((ns4__PPTVO*)a)->imageType), "");
	soap_out_PointerTostd__string(soap, "ns4:imageUrl", -1, &(((ns4__PPTVO*)a)->imageUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:keywords", -1, &(((ns4__PPTVO*)a)->keywords), "");
	soap_out_PointerTostd__string(soap, "ns4:revision", -1, &(((ns4__PPTVO*)a)->revision), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__PPTVO*)a)->securityLabel), "");
	soap_out_PointerTostd__string(soap, "ns4:sourceDir", -1, &(((ns4__PPTVO*)a)->sourceDir), "");
	soap_out_PointerToxsd__base64Binary(soap, "ns4:thumbS", -1, &(((ns4__PPTVO*)a)->thumbS), "");
	soap_out_PointerTostd__string(soap, "ns4:thumbSMimetype", -1, &(((ns4__PPTVO*)a)->thumbSMimetype), "");
	soap_out_PointerTostd__string(soap, "ns4:thumbUrl", -1, &(((ns4__PPTVO*)a)->thumbUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:tileUrl", -1, &(((ns4__PPTVO*)a)->tileUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:title", -1, &(((ns4__PPTVO*)a)->title), "");
	soap_out_PointerToint(soap, "ns4:width", -1, &(((ns4__PPTVO*)a)->width), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__PPTVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__PPTVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__PPTVO * SOAP_FMAC4 soap_get_ns4__PPTVO(struct soap *soap, ns4__PPTVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PPTVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__PPTVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__PPTVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__PPTVO * SOAP_FMAC4 soap_in_ns4__PPTVO(struct soap *soap, const char *tag, ns4__PPTVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__PPTVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__PPTVO, sizeof(ns4__PPTVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__PPTVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__PPTVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_author1 = 1, soap_flag_category1 = 1, soap_flag_comments1 = 1, soap_flag_entityID1 = 1, soap_flag_entityVO1 = 1, soap_flag_height1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_imageMimetype1 = 1, soap_flag_imageType1 = 1, soap_flag_imageUrl1 = 1, soap_flag_keywords1 = 1, soap_flag_revision1 = 1, soap_flag_securityLabel1 = 1, soap_flag_sourceDir1 = 1, soap_flag_thumbS1 = 1, soap_flag_thumbSMimetype1 = 1, soap_flag_thumbUrl1 = 1, soap_flag_tileUrl1 = 1, soap_flag_title1 = 1, soap_flag_width1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__PPTVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__PPTVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__PPTVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__PPTVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:author", &(((ns4__PPTVO*)a)->author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:category", &(((ns4__PPTVO*)a)->category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:comments", &(((ns4__PPTVO*)a)->comments), "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			if (soap_flag_entityID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:entityID", &(((ns4__PPTVO*)a)->entityID), "xsd:long"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__PPTVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_height1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:height", &(((ns4__PPTVO*)a)->height), "xsd:int"))
				{	soap_flag_height1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__PPTVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__PPTVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_imageMimetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:imageMimetype", &(((ns4__PPTVO*)a)->imageMimetype), "xsd:string"))
				{	soap_flag_imageMimetype1--;
					continue;
				}
			if (soap_flag_imageType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:imageType", &(((ns4__PPTVO*)a)->imageType), "xsd:string"))
				{	soap_flag_imageType1--;
					continue;
				}
			if (soap_flag_imageUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:imageUrl", &(((ns4__PPTVO*)a)->imageUrl), "xsd:string"))
				{	soap_flag_imageUrl1--;
					continue;
				}
			if (soap_flag_keywords1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:keywords", &(((ns4__PPTVO*)a)->keywords), "xsd:string"))
				{	soap_flag_keywords1--;
					continue;
				}
			if (soap_flag_revision1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:revision", &(((ns4__PPTVO*)a)->revision), "xsd:string"))
				{	soap_flag_revision1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__PPTVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_sourceDir1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:sourceDir", &(((ns4__PPTVO*)a)->sourceDir), "xsd:string"))
				{	soap_flag_sourceDir1--;
					continue;
				}
			if (soap_flag_thumbS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns4:thumbS", &(((ns4__PPTVO*)a)->thumbS), "xsd:base64Binary"))
				{	soap_flag_thumbS1--;
					continue;
				}
			if (soap_flag_thumbSMimetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:thumbSMimetype", &(((ns4__PPTVO*)a)->thumbSMimetype), "xsd:string"))
				{	soap_flag_thumbSMimetype1--;
					continue;
				}
			if (soap_flag_thumbUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:thumbUrl", &(((ns4__PPTVO*)a)->thumbUrl), "xsd:string"))
				{	soap_flag_thumbUrl1--;
					continue;
				}
			if (soap_flag_tileUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:tileUrl", &(((ns4__PPTVO*)a)->tileUrl), "xsd:string"))
				{	soap_flag_tileUrl1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:title", &(((ns4__PPTVO*)a)->title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_width1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:width", &(((ns4__PPTVO*)a)->width), "xsd:int"))
				{	soap_flag_width1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__PPTVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__PPTVO, 0, sizeof(ns4__PPTVO), 0, soap_copy_ns4__PPTVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__PPTVO * SOAP_FMAC6 soap_new_ns4__PPTVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__PPTVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__PPTVO(struct soap *soap, ns4__PPTVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__PPTVO * SOAP_FMAC4 soap_instantiate_ns4__PPTVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__PPTVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__PPTVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__PPTVO;
		if (size)
			*size = sizeof(ns4__PPTVO);
		((ns4__PPTVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__PPTVO[n];
		if (size)
			*size = n * sizeof(ns4__PPTVO);
		for (int i = 0; i < n; i++)
			((ns4__PPTVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__PPTVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__PPTVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__PPTVO %p -> %p\n", q, p));
	*(ns4__PPTVO*)p = *(ns4__PPTVO*)q;
}

void ns4__ArrayOfPPTVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__PPTVO(soap, &((ns4__ArrayOfPPTVO*)this)->PPTVO);
	/* transient soap skipped */
}

void ns4__ArrayOfPPTVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__PPTVO(soap, &((ns4__ArrayOfPPTVO*)this)->PPTVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfPPTVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfPPTVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfPPTVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfPPTVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfPPTVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfPPTVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfPPTVO), "ns4:ArrayOfPPTVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__PPTVO(soap, "ns4:PPTVO", -1, &(((ns4__ArrayOfPPTVO*)a)->PPTVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfPPTVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfPPTVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfPPTVO * SOAP_FMAC4 soap_get_ns4__ArrayOfPPTVO(struct soap *soap, ns4__ArrayOfPPTVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfPPTVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfPPTVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfPPTVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfPPTVO * SOAP_FMAC4 soap_in_ns4__ArrayOfPPTVO(struct soap *soap, const char *tag, ns4__ArrayOfPPTVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfPPTVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfPPTVO, sizeof(ns4__ArrayOfPPTVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfPPTVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfPPTVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__PPTVO(soap, "ns4:PPTVO", &(((ns4__ArrayOfPPTVO*)a)->PPTVO), "ns4:PPTVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfPPTVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfPPTVO, 0, sizeof(ns4__ArrayOfPPTVO), 0, soap_copy_ns4__ArrayOfPPTVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfPPTVO * SOAP_FMAC6 soap_new_ns4__ArrayOfPPTVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfPPTVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfPPTVO(struct soap *soap, ns4__ArrayOfPPTVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfPPTVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfPPTVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfPPTVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfPPTVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfPPTVO;
		if (size)
			*size = sizeof(ns4__ArrayOfPPTVO);
		((ns4__ArrayOfPPTVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfPPTVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfPPTVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfPPTVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfPPTVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfPPTVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfPPTVO %p -> %p\n", q, p));
	*(ns4__ArrayOfPPTVO*)p = *(ns4__ArrayOfPPTVO*)q;
}

void ns4__ContainerVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__ContainerVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__ContainerVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__ContainerVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__ContainerVO*)this)->allScalars);
	soap_serialize_PointerToLONG64(soap, &((ns4__ContainerVO*)this)->entityID);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__ContainerVO*)this)->entityVO);
	soap_serialize_PointerToLONG64(soap, &((ns4__ContainerVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__ContainerVO*)this)->identifier);
	soap_serialize_PointerToLONG64(soap, &((ns4__ContainerVO*)this)->securityLabel);
	soap_serialize_PointerTostd__string(soap, &((ns4__ContainerVO*)this)->sourceDir);
	/* transient soap skipped */
}

void ns4__ContainerVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__ContainerVO*)this)->DBTableName = NULL;
	((ns4__ContainerVO*)this)->VOName = NULL;
	((ns4__ContainerVO*)this)->allDBColumns = NULL;
	((ns4__ContainerVO*)this)->allScalars = NULL;
	((ns4__ContainerVO*)this)->entityID = NULL;
	((ns4__ContainerVO*)this)->entityVO = NULL;
	((ns4__ContainerVO*)this)->id = NULL;
	((ns4__ContainerVO*)this)->identifier = NULL;
	((ns4__ContainerVO*)this)->securityLabel = NULL;
	((ns4__ContainerVO*)this)->sourceDir = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ContainerVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ContainerVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ContainerVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ContainerVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ContainerVO(struct soap *soap, const char *tag, int id, const ns4__ContainerVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ContainerVO), "ns4:ContainerVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__ContainerVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__ContainerVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__ContainerVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__ContainerVO*)a)->allScalars), "");
	soap_out_PointerToLONG64(soap, "ns4:entityID", -1, &(((ns4__ContainerVO*)a)->entityID), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__ContainerVO*)a)->entityVO), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__ContainerVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__ContainerVO*)a)->identifier), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__ContainerVO*)a)->securityLabel), "");
	soap_out_PointerTostd__string(soap, "ns4:sourceDir", -1, &(((ns4__ContainerVO*)a)->sourceDir), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ContainerVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ContainerVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ContainerVO * SOAP_FMAC4 soap_get_ns4__ContainerVO(struct soap *soap, ns4__ContainerVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ContainerVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ContainerVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ContainerVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ContainerVO * SOAP_FMAC4 soap_in_ns4__ContainerVO(struct soap *soap, const char *tag, ns4__ContainerVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ContainerVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ContainerVO, sizeof(ns4__ContainerVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ContainerVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ContainerVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_entityID1 = 1, soap_flag_entityVO1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_securityLabel1 = 1, soap_flag_sourceDir1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__ContainerVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__ContainerVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__ContainerVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__ContainerVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_entityID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:entityID", &(((ns4__ContainerVO*)a)->entityID), "xsd:long"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__ContainerVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__ContainerVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__ContainerVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__ContainerVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_sourceDir1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:sourceDir", &(((ns4__ContainerVO*)a)->sourceDir), "xsd:string"))
				{	soap_flag_sourceDir1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ContainerVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ContainerVO, 0, sizeof(ns4__ContainerVO), 0, soap_copy_ns4__ContainerVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ContainerVO * SOAP_FMAC6 soap_new_ns4__ContainerVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ContainerVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ContainerVO(struct soap *soap, ns4__ContainerVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ContainerVO * SOAP_FMAC4 soap_instantiate_ns4__ContainerVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ContainerVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ContainerVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ContainerVO;
		if (size)
			*size = sizeof(ns4__ContainerVO);
		((ns4__ContainerVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ContainerVO[n];
		if (size)
			*size = n * sizeof(ns4__ContainerVO);
		for (int i = 0; i < n; i++)
			((ns4__ContainerVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ContainerVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ContainerVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ContainerVO %p -> %p\n", q, p));
	*(ns4__ContainerVO*)p = *(ns4__ContainerVO*)q;
}

void ns4__ArrayOfContainerVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__ContainerVO(soap, &((ns4__ArrayOfContainerVO*)this)->ContainerVO);
	/* transient soap skipped */
}

void ns4__ArrayOfContainerVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__ContainerVO(soap, &((ns4__ArrayOfContainerVO*)this)->ContainerVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfContainerVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfContainerVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfContainerVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfContainerVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfContainerVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfContainerVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfContainerVO), "ns4:ArrayOfContainerVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__ContainerVO(soap, "ns4:ContainerVO", -1, &(((ns4__ArrayOfContainerVO*)a)->ContainerVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfContainerVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfContainerVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfContainerVO * SOAP_FMAC4 soap_get_ns4__ArrayOfContainerVO(struct soap *soap, ns4__ArrayOfContainerVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfContainerVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfContainerVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfContainerVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfContainerVO * SOAP_FMAC4 soap_in_ns4__ArrayOfContainerVO(struct soap *soap, const char *tag, ns4__ArrayOfContainerVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfContainerVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfContainerVO, sizeof(ns4__ArrayOfContainerVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfContainerVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfContainerVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__ContainerVO(soap, "ns4:ContainerVO", &(((ns4__ArrayOfContainerVO*)a)->ContainerVO), "ns4:ContainerVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfContainerVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfContainerVO, 0, sizeof(ns4__ArrayOfContainerVO), 0, soap_copy_ns4__ArrayOfContainerVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfContainerVO * SOAP_FMAC6 soap_new_ns4__ArrayOfContainerVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfContainerVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfContainerVO(struct soap *soap, ns4__ArrayOfContainerVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfContainerVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfContainerVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfContainerVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfContainerVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfContainerVO;
		if (size)
			*size = sizeof(ns4__ArrayOfContainerVO);
		((ns4__ArrayOfContainerVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfContainerVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfContainerVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfContainerVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfContainerVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfContainerVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfContainerVO %p -> %p\n", q, p));
	*(ns4__ArrayOfContainerVO*)p = *(ns4__ArrayOfContainerVO*)q;
}

void ns4__ArrayOfPPTSlideVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__PPTSlideVO(soap, &((ns4__ArrayOfPPTSlideVO*)this)->PPTSlideVO);
	/* transient soap skipped */
}

void ns4__ArrayOfPPTSlideVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__PPTSlideVO(soap, &((ns4__ArrayOfPPTSlideVO*)this)->PPTSlideVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfPPTSlideVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfPPTSlideVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfPPTSlideVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfPPTSlideVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfPPTSlideVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfPPTSlideVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfPPTSlideVO), "ns4:ArrayOfPPTSlideVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__PPTSlideVO(soap, "ns4:PPTSlideVO", -1, &(((ns4__ArrayOfPPTSlideVO*)a)->PPTSlideVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfPPTSlideVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfPPTSlideVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfPPTSlideVO * SOAP_FMAC4 soap_get_ns4__ArrayOfPPTSlideVO(struct soap *soap, ns4__ArrayOfPPTSlideVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfPPTSlideVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfPPTSlideVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfPPTSlideVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfPPTSlideVO * SOAP_FMAC4 soap_in_ns4__ArrayOfPPTSlideVO(struct soap *soap, const char *tag, ns4__ArrayOfPPTSlideVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfPPTSlideVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfPPTSlideVO, sizeof(ns4__ArrayOfPPTSlideVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfPPTSlideVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfPPTSlideVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__PPTSlideVO(soap, "ns4:PPTSlideVO", &(((ns4__ArrayOfPPTSlideVO*)a)->PPTSlideVO), "ns4:PPTSlideVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfPPTSlideVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfPPTSlideVO, 0, sizeof(ns4__ArrayOfPPTSlideVO), 0, soap_copy_ns4__ArrayOfPPTSlideVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfPPTSlideVO * SOAP_FMAC6 soap_new_ns4__ArrayOfPPTSlideVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfPPTSlideVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfPPTSlideVO(struct soap *soap, ns4__ArrayOfPPTSlideVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfPPTSlideVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfPPTSlideVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfPPTSlideVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfPPTSlideVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfPPTSlideVO;
		if (size)
			*size = sizeof(ns4__ArrayOfPPTSlideVO);
		((ns4__ArrayOfPPTSlideVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfPPTSlideVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfPPTSlideVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfPPTSlideVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfPPTSlideVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfPPTSlideVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfPPTSlideVO %p -> %p\n", q, p));
	*(ns4__ArrayOfPPTSlideVO*)p = *(ns4__ArrayOfPPTSlideVO*)q;
}

void ns4__ERelationVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__ERelationVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__ERelationVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__ERelationVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__ERelationVO*)this)->allScalars);
	soap_serialize_PointerToxsd__decimal(soap, &((ns4__ERelationVO*)this)->conf);
	soap_serialize_PointerToLONG64(soap, &((ns4__ERelationVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__ERelationVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__ERelationVO*)this)->relationType);
	soap_serialize_PointerToLONG64(soap, &((ns4__ERelationVO*)this)->securityLabel);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__ERelationVO*)this)->srcEntityVO);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__ERelationVO*)this)->tgtEntityVO);
	/* transient soap skipped */
}

void ns4__ERelationVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__ERelationVO*)this)->DBTableName = NULL;
	((ns4__ERelationVO*)this)->VOName = NULL;
	((ns4__ERelationVO*)this)->allDBColumns = NULL;
	((ns4__ERelationVO*)this)->allScalars = NULL;
	((ns4__ERelationVO*)this)->conf = NULL;
	((ns4__ERelationVO*)this)->id = NULL;
	((ns4__ERelationVO*)this)->identifier = NULL;
	((ns4__ERelationVO*)this)->relationType = NULL;
	((ns4__ERelationVO*)this)->securityLabel = NULL;
	((ns4__ERelationVO*)this)->srcEntityVO = NULL;
	((ns4__ERelationVO*)this)->tgtEntityVO = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ERelationVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ERelationVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ERelationVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ERelationVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ERelationVO(struct soap *soap, const char *tag, int id, const ns4__ERelationVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ERelationVO), "ns4:ERelationVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__ERelationVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__ERelationVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__ERelationVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__ERelationVO*)a)->allScalars), "");
	soap_out_PointerToxsd__decimal(soap, "ns4:conf", -1, &(((ns4__ERelationVO*)a)->conf), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__ERelationVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__ERelationVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:relationType", -1, &(((ns4__ERelationVO*)a)->relationType), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__ERelationVO*)a)->securityLabel), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:srcEntityVO", -1, &(((ns4__ERelationVO*)a)->srcEntityVO), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:tgtEntityVO", -1, &(((ns4__ERelationVO*)a)->tgtEntityVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ERelationVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ERelationVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ERelationVO * SOAP_FMAC4 soap_get_ns4__ERelationVO(struct soap *soap, ns4__ERelationVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ERelationVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ERelationVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ERelationVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ERelationVO * SOAP_FMAC4 soap_in_ns4__ERelationVO(struct soap *soap, const char *tag, ns4__ERelationVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ERelationVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ERelationVO, sizeof(ns4__ERelationVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ERelationVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ERelationVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_conf1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_relationType1 = 1, soap_flag_securityLabel1 = 1, soap_flag_srcEntityVO1 = 1, soap_flag_tgtEntityVO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__ERelationVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__ERelationVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__ERelationVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__ERelationVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_conf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "ns4:conf", &(((ns4__ERelationVO*)a)->conf), "xsd:decimal"))
				{	soap_flag_conf1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__ERelationVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__ERelationVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_relationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:relationType", &(((ns4__ERelationVO*)a)->relationType), "xsd:string"))
				{	soap_flag_relationType1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__ERelationVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_srcEntityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:srcEntityVO", &(((ns4__ERelationVO*)a)->srcEntityVO), "ns4:EntityVO"))
				{	soap_flag_srcEntityVO1--;
					continue;
				}
			if (soap_flag_tgtEntityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:tgtEntityVO", &(((ns4__ERelationVO*)a)->tgtEntityVO), "ns4:EntityVO"))
				{	soap_flag_tgtEntityVO1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ERelationVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ERelationVO, 0, sizeof(ns4__ERelationVO), 0, soap_copy_ns4__ERelationVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ERelationVO * SOAP_FMAC6 soap_new_ns4__ERelationVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ERelationVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ERelationVO(struct soap *soap, ns4__ERelationVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ERelationVO * SOAP_FMAC4 soap_instantiate_ns4__ERelationVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ERelationVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ERelationVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ERelationVO;
		if (size)
			*size = sizeof(ns4__ERelationVO);
		((ns4__ERelationVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ERelationVO[n];
		if (size)
			*size = n * sizeof(ns4__ERelationVO);
		for (int i = 0; i < n; i++)
			((ns4__ERelationVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ERelationVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ERelationVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ERelationVO %p -> %p\n", q, p));
	*(ns4__ERelationVO*)p = *(ns4__ERelationVO*)q;
}

void ns4__ImageVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__ImageVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__ImageVO*)this)->allScalars);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__ImageVO*)this)->entityVO);
	soap_serialize_PointerToint(soap, &((ns4__ImageVO*)this)->height);
	soap_serialize_PointerToLONG64(soap, &((ns4__ImageVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->imageType);
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->pffUrl);
	soap_serialize_PointerToLONG64(soap, &((ns4__ImageVO*)this)->securityLabel);
	soap_serialize_PointerToxsd__base64Binary(soap, &((ns4__ImageVO*)this)->thumbS);
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->thumbSMimetype);
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->thumbUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__ImageVO*)this)->tileUrl);
	soap_serialize_PointerToint(soap, &((ns4__ImageVO*)this)->width);
	/* transient soap skipped */
}

void ns4__ImageVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__ImageVO*)this)->DBTableName = NULL;
	((ns4__ImageVO*)this)->VOName = NULL;
	((ns4__ImageVO*)this)->allDBColumns = NULL;
	((ns4__ImageVO*)this)->allScalars = NULL;
	((ns4__ImageVO*)this)->entityVO = NULL;
	((ns4__ImageVO*)this)->height = NULL;
	((ns4__ImageVO*)this)->id = NULL;
	((ns4__ImageVO*)this)->identifier = NULL;
	((ns4__ImageVO*)this)->imageType = NULL;
	((ns4__ImageVO*)this)->pffUrl = NULL;
	((ns4__ImageVO*)this)->securityLabel = NULL;
	((ns4__ImageVO*)this)->thumbS = NULL;
	((ns4__ImageVO*)this)->thumbSMimetype = NULL;
	((ns4__ImageVO*)this)->thumbUrl = NULL;
	((ns4__ImageVO*)this)->tileUrl = NULL;
	((ns4__ImageVO*)this)->width = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ImageVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ImageVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ImageVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ImageVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ImageVO(struct soap *soap, const char *tag, int id, const ns4__ImageVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ImageVO), "ns4:ImageVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__ImageVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__ImageVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__ImageVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__ImageVO*)a)->allScalars), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__ImageVO*)a)->entityVO), "");
	soap_out_PointerToint(soap, "ns4:height", -1, &(((ns4__ImageVO*)a)->height), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__ImageVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__ImageVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:imageType", -1, &(((ns4__ImageVO*)a)->imageType), "");
	soap_out_PointerTostd__string(soap, "ns4:pffUrl", -1, &(((ns4__ImageVO*)a)->pffUrl), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__ImageVO*)a)->securityLabel), "");
	soap_out_PointerToxsd__base64Binary(soap, "ns4:thumbS", -1, &(((ns4__ImageVO*)a)->thumbS), "");
	soap_out_PointerTostd__string(soap, "ns4:thumbSMimetype", -1, &(((ns4__ImageVO*)a)->thumbSMimetype), "");
	soap_out_PointerTostd__string(soap, "ns4:thumbUrl", -1, &(((ns4__ImageVO*)a)->thumbUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:tileUrl", -1, &(((ns4__ImageVO*)a)->tileUrl), "");
	soap_out_PointerToint(soap, "ns4:width", -1, &(((ns4__ImageVO*)a)->width), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ImageVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ImageVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ImageVO * SOAP_FMAC4 soap_get_ns4__ImageVO(struct soap *soap, ns4__ImageVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ImageVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ImageVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ImageVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ImageVO * SOAP_FMAC4 soap_in_ns4__ImageVO(struct soap *soap, const char *tag, ns4__ImageVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ImageVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ImageVO, sizeof(ns4__ImageVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ImageVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ImageVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_entityVO1 = 1, soap_flag_height1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_imageType1 = 1, soap_flag_pffUrl1 = 1, soap_flag_securityLabel1 = 1, soap_flag_thumbS1 = 1, soap_flag_thumbSMimetype1 = 1, soap_flag_thumbUrl1 = 1, soap_flag_tileUrl1 = 1, soap_flag_width1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__ImageVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__ImageVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__ImageVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__ImageVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__ImageVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_height1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:height", &(((ns4__ImageVO*)a)->height), "xsd:int"))
				{	soap_flag_height1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__ImageVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__ImageVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_imageType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:imageType", &(((ns4__ImageVO*)a)->imageType), "xsd:string"))
				{	soap_flag_imageType1--;
					continue;
				}
			if (soap_flag_pffUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:pffUrl", &(((ns4__ImageVO*)a)->pffUrl), "xsd:string"))
				{	soap_flag_pffUrl1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__ImageVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_thumbS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns4:thumbS", &(((ns4__ImageVO*)a)->thumbS), "xsd:base64Binary"))
				{	soap_flag_thumbS1--;
					continue;
				}
			if (soap_flag_thumbSMimetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:thumbSMimetype", &(((ns4__ImageVO*)a)->thumbSMimetype), "xsd:string"))
				{	soap_flag_thumbSMimetype1--;
					continue;
				}
			if (soap_flag_thumbUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:thumbUrl", &(((ns4__ImageVO*)a)->thumbUrl), "xsd:string"))
				{	soap_flag_thumbUrl1--;
					continue;
				}
			if (soap_flag_tileUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:tileUrl", &(((ns4__ImageVO*)a)->tileUrl), "xsd:string"))
				{	soap_flag_tileUrl1--;
					continue;
				}
			if (soap_flag_width1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:width", &(((ns4__ImageVO*)a)->width), "xsd:int"))
				{	soap_flag_width1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ImageVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ImageVO, 0, sizeof(ns4__ImageVO), 0, soap_copy_ns4__ImageVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ImageVO * SOAP_FMAC6 soap_new_ns4__ImageVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ImageVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ImageVO(struct soap *soap, ns4__ImageVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ImageVO * SOAP_FMAC4 soap_instantiate_ns4__ImageVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ImageVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ImageVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ImageVO;
		if (size)
			*size = sizeof(ns4__ImageVO);
		((ns4__ImageVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ImageVO[n];
		if (size)
			*size = n * sizeof(ns4__ImageVO);
		for (int i = 0; i < n; i++)
			((ns4__ImageVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ImageVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ImageVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ImageVO %p -> %p\n", q, p));
	*(ns4__ImageVO*)p = *(ns4__ImageVO*)q;
}

void ns4__ArrayOfEActivityVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__EActivityVO(soap, &((ns4__ArrayOfEActivityVO*)this)->EActivityVO);
	/* transient soap skipped */
}

void ns4__ArrayOfEActivityVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__EActivityVO(soap, &((ns4__ArrayOfEActivityVO*)this)->EActivityVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfEActivityVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfEActivityVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfEActivityVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfEActivityVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfEActivityVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfEActivityVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfEActivityVO), "ns4:ArrayOfEActivityVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__EActivityVO(soap, "ns4:EActivityVO", -1, &(((ns4__ArrayOfEActivityVO*)a)->EActivityVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfEActivityVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfEActivityVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfEActivityVO * SOAP_FMAC4 soap_get_ns4__ArrayOfEActivityVO(struct soap *soap, ns4__ArrayOfEActivityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfEActivityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfEActivityVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfEActivityVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfEActivityVO * SOAP_FMAC4 soap_in_ns4__ArrayOfEActivityVO(struct soap *soap, const char *tag, ns4__ArrayOfEActivityVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfEActivityVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfEActivityVO, sizeof(ns4__ArrayOfEActivityVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfEActivityVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfEActivityVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__EActivityVO(soap, "ns4:EActivityVO", &(((ns4__ArrayOfEActivityVO*)a)->EActivityVO), "ns4:EActivityVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfEActivityVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfEActivityVO, 0, sizeof(ns4__ArrayOfEActivityVO), 0, soap_copy_ns4__ArrayOfEActivityVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfEActivityVO * SOAP_FMAC6 soap_new_ns4__ArrayOfEActivityVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfEActivityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfEActivityVO(struct soap *soap, ns4__ArrayOfEActivityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfEActivityVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfEActivityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfEActivityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfEActivityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfEActivityVO;
		if (size)
			*size = sizeof(ns4__ArrayOfEActivityVO);
		((ns4__ArrayOfEActivityVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfEActivityVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfEActivityVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfEActivityVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfEActivityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfEActivityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfEActivityVO %p -> %p\n", q, p));
	*(ns4__ArrayOfEActivityVO*)p = *(ns4__ArrayOfEActivityVO*)q;
}

void ns4__PPTSlideVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__PPTSlideVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__PPTSlideVO*)this)->allScalars);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__PPTSlideVO*)this)->entityVO);
	soap_serialize_PointerToint(soap, &((ns4__PPTSlideVO*)this)->height);
	soap_serialize_PointerToLONG64(soap, &((ns4__PPTSlideVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->imageMimetype);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->imageType);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->imageUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->keywords);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->rawText);
	soap_serialize_PointerToLONG64(soap, &((ns4__PPTSlideVO*)this)->securityLabel);
	soap_serialize_PointerToxsd__base64Binary(soap, &((ns4__PPTSlideVO*)this)->thumbS);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->thumbSMimetype);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->thumbUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->tileUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__PPTSlideVO*)this)->title);
	soap_serialize_PointerToint(soap, &((ns4__PPTSlideVO*)this)->width);
	/* transient soap skipped */
}

void ns4__PPTSlideVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__PPTSlideVO*)this)->DBTableName = NULL;
	((ns4__PPTSlideVO*)this)->VOName = NULL;
	((ns4__PPTSlideVO*)this)->allDBColumns = NULL;
	((ns4__PPTSlideVO*)this)->allScalars = NULL;
	((ns4__PPTSlideVO*)this)->entityVO = NULL;
	((ns4__PPTSlideVO*)this)->height = NULL;
	((ns4__PPTSlideVO*)this)->id = NULL;
	((ns4__PPTSlideVO*)this)->identifier = NULL;
	((ns4__PPTSlideVO*)this)->imageMimetype = NULL;
	((ns4__PPTSlideVO*)this)->imageType = NULL;
	((ns4__PPTSlideVO*)this)->imageUrl = NULL;
	((ns4__PPTSlideVO*)this)->keywords = NULL;
	((ns4__PPTSlideVO*)this)->rawText = NULL;
	((ns4__PPTSlideVO*)this)->securityLabel = NULL;
	((ns4__PPTSlideVO*)this)->thumbS = NULL;
	((ns4__PPTSlideVO*)this)->thumbSMimetype = NULL;
	((ns4__PPTSlideVO*)this)->thumbUrl = NULL;
	((ns4__PPTSlideVO*)this)->tileUrl = NULL;
	((ns4__PPTSlideVO*)this)->title = NULL;
	((ns4__PPTSlideVO*)this)->width = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__PPTSlideVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__PPTSlideVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__PPTSlideVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__PPTSlideVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PPTSlideVO(struct soap *soap, const char *tag, int id, const ns4__PPTSlideVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__PPTSlideVO), "ns4:PPTSlideVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__PPTSlideVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__PPTSlideVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__PPTSlideVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__PPTSlideVO*)a)->allScalars), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__PPTSlideVO*)a)->entityVO), "");
	soap_out_PointerToint(soap, "ns4:height", -1, &(((ns4__PPTSlideVO*)a)->height), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__PPTSlideVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__PPTSlideVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:imageMimetype", -1, &(((ns4__PPTSlideVO*)a)->imageMimetype), "");
	soap_out_PointerTostd__string(soap, "ns4:imageType", -1, &(((ns4__PPTSlideVO*)a)->imageType), "");
	soap_out_PointerTostd__string(soap, "ns4:imageUrl", -1, &(((ns4__PPTSlideVO*)a)->imageUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:keywords", -1, &(((ns4__PPTSlideVO*)a)->keywords), "");
	soap_out_PointerTostd__string(soap, "ns4:rawText", -1, &(((ns4__PPTSlideVO*)a)->rawText), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__PPTSlideVO*)a)->securityLabel), "");
	soap_out_PointerToxsd__base64Binary(soap, "ns4:thumbS", -1, &(((ns4__PPTSlideVO*)a)->thumbS), "");
	soap_out_PointerTostd__string(soap, "ns4:thumbSMimetype", -1, &(((ns4__PPTSlideVO*)a)->thumbSMimetype), "");
	soap_out_PointerTostd__string(soap, "ns4:thumbUrl", -1, &(((ns4__PPTSlideVO*)a)->thumbUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:tileUrl", -1, &(((ns4__PPTSlideVO*)a)->tileUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:title", -1, &(((ns4__PPTSlideVO*)a)->title), "");
	soap_out_PointerToint(soap, "ns4:width", -1, &(((ns4__PPTSlideVO*)a)->width), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__PPTSlideVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__PPTSlideVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__PPTSlideVO * SOAP_FMAC4 soap_get_ns4__PPTSlideVO(struct soap *soap, ns4__PPTSlideVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PPTSlideVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__PPTSlideVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__PPTSlideVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__PPTSlideVO * SOAP_FMAC4 soap_in_ns4__PPTSlideVO(struct soap *soap, const char *tag, ns4__PPTSlideVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__PPTSlideVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__PPTSlideVO, sizeof(ns4__PPTSlideVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__PPTSlideVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__PPTSlideVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_entityVO1 = 1, soap_flag_height1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_imageMimetype1 = 1, soap_flag_imageType1 = 1, soap_flag_imageUrl1 = 1, soap_flag_keywords1 = 1, soap_flag_rawText1 = 1, soap_flag_securityLabel1 = 1, soap_flag_thumbS1 = 1, soap_flag_thumbSMimetype1 = 1, soap_flag_thumbUrl1 = 1, soap_flag_tileUrl1 = 1, soap_flag_title1 = 1, soap_flag_width1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__PPTSlideVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__PPTSlideVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__PPTSlideVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__PPTSlideVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__PPTSlideVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_height1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:height", &(((ns4__PPTSlideVO*)a)->height), "xsd:int"))
				{	soap_flag_height1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__PPTSlideVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__PPTSlideVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_imageMimetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:imageMimetype", &(((ns4__PPTSlideVO*)a)->imageMimetype), "xsd:string"))
				{	soap_flag_imageMimetype1--;
					continue;
				}
			if (soap_flag_imageType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:imageType", &(((ns4__PPTSlideVO*)a)->imageType), "xsd:string"))
				{	soap_flag_imageType1--;
					continue;
				}
			if (soap_flag_imageUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:imageUrl", &(((ns4__PPTSlideVO*)a)->imageUrl), "xsd:string"))
				{	soap_flag_imageUrl1--;
					continue;
				}
			if (soap_flag_keywords1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:keywords", &(((ns4__PPTSlideVO*)a)->keywords), "xsd:string"))
				{	soap_flag_keywords1--;
					continue;
				}
			if (soap_flag_rawText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:rawText", &(((ns4__PPTSlideVO*)a)->rawText), "xsd:string"))
				{	soap_flag_rawText1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__PPTSlideVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_thumbS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns4:thumbS", &(((ns4__PPTSlideVO*)a)->thumbS), "xsd:base64Binary"))
				{	soap_flag_thumbS1--;
					continue;
				}
			if (soap_flag_thumbSMimetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:thumbSMimetype", &(((ns4__PPTSlideVO*)a)->thumbSMimetype), "xsd:string"))
				{	soap_flag_thumbSMimetype1--;
					continue;
				}
			if (soap_flag_thumbUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:thumbUrl", &(((ns4__PPTSlideVO*)a)->thumbUrl), "xsd:string"))
				{	soap_flag_thumbUrl1--;
					continue;
				}
			if (soap_flag_tileUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:tileUrl", &(((ns4__PPTSlideVO*)a)->tileUrl), "xsd:string"))
				{	soap_flag_tileUrl1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:title", &(((ns4__PPTSlideVO*)a)->title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_width1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:width", &(((ns4__PPTSlideVO*)a)->width), "xsd:int"))
				{	soap_flag_width1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__PPTSlideVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__PPTSlideVO, 0, sizeof(ns4__PPTSlideVO), 0, soap_copy_ns4__PPTSlideVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__PPTSlideVO * SOAP_FMAC6 soap_new_ns4__PPTSlideVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__PPTSlideVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__PPTSlideVO(struct soap *soap, ns4__PPTSlideVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__PPTSlideVO * SOAP_FMAC4 soap_instantiate_ns4__PPTSlideVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__PPTSlideVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__PPTSlideVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__PPTSlideVO;
		if (size)
			*size = sizeof(ns4__PPTSlideVO);
		((ns4__PPTSlideVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__PPTSlideVO[n];
		if (size)
			*size = n * sizeof(ns4__PPTSlideVO);
		for (int i = 0; i < n; i++)
			((ns4__PPTSlideVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__PPTSlideVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__PPTSlideVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__PPTSlideVO %p -> %p\n", q, p));
	*(ns4__PPTSlideVO*)p = *(ns4__PPTSlideVO*)q;
}

void ns4__EActivityVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__EActivityVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__EActivityVO*)this)->VOName);
	soap_serialize_PointerTotime(soap, &((ns4__EActivityVO*)this)->activityTime);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__EActivityVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__EActivityVO*)this)->allScalars);
	soap_serialize_PointerTostd__string(soap, &((ns4__EActivityVO*)this)->description);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__EActivityVO*)this)->entityVO);
	soap_serialize_PointerTostd__string(soap, &((ns4__EActivityVO*)this)->event);
	soap_serialize_PointerToLONG64(soap, &((ns4__EActivityVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__EActivityVO*)this)->identifier);
	soap_serialize_PointerToLONG64(soap, &((ns4__EActivityVO*)this)->securityLabel);
	soap_serialize_PointerTons4__UserVO(soap, &((ns4__EActivityVO*)this)->userVO);
	/* transient soap skipped */
}

void ns4__EActivityVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__EActivityVO*)this)->DBTableName = NULL;
	((ns4__EActivityVO*)this)->VOName = NULL;
	((ns4__EActivityVO*)this)->activityTime = NULL;
	((ns4__EActivityVO*)this)->allDBColumns = NULL;
	((ns4__EActivityVO*)this)->allScalars = NULL;
	((ns4__EActivityVO*)this)->description = NULL;
	((ns4__EActivityVO*)this)->entityVO = NULL;
	((ns4__EActivityVO*)this)->event = NULL;
	((ns4__EActivityVO*)this)->id = NULL;
	((ns4__EActivityVO*)this)->identifier = NULL;
	((ns4__EActivityVO*)this)->securityLabel = NULL;
	((ns4__EActivityVO*)this)->userVO = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__EActivityVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__EActivityVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__EActivityVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__EActivityVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EActivityVO(struct soap *soap, const char *tag, int id, const ns4__EActivityVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EActivityVO), "ns4:EActivityVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__EActivityVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__EActivityVO*)a)->VOName), "");
	soap_out_PointerTotime(soap, "ns4:activityTime", -1, &(((ns4__EActivityVO*)a)->activityTime), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__EActivityVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__EActivityVO*)a)->allScalars), "");
	soap_out_PointerTostd__string(soap, "ns4:description", -1, &(((ns4__EActivityVO*)a)->description), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__EActivityVO*)a)->entityVO), "");
	soap_out_PointerTostd__string(soap, "ns4:event", -1, &(((ns4__EActivityVO*)a)->event), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__EActivityVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__EActivityVO*)a)->identifier), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__EActivityVO*)a)->securityLabel), "");
	soap_out_PointerTons4__UserVO(soap, "ns4:userVO", -1, &(((ns4__EActivityVO*)a)->userVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__EActivityVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__EActivityVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__EActivityVO * SOAP_FMAC4 soap_get_ns4__EActivityVO(struct soap *soap, ns4__EActivityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EActivityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__EActivityVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__EActivityVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__EActivityVO * SOAP_FMAC4 soap_in_ns4__EActivityVO(struct soap *soap, const char *tag, ns4__EActivityVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__EActivityVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EActivityVO, sizeof(ns4__EActivityVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__EActivityVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__EActivityVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_activityTime1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_description1 = 1, soap_flag_entityVO1 = 1, soap_flag_event1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_securityLabel1 = 1, soap_flag_userVO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__EActivityVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__EActivityVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_activityTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:activityTime", &(((ns4__EActivityVO*)a)->activityTime), "xsd:dateTime"))
				{	soap_flag_activityTime1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__EActivityVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__EActivityVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:description", &(((ns4__EActivityVO*)a)->description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__EActivityVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_event1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:event", &(((ns4__EActivityVO*)a)->event), "xsd:string"))
				{	soap_flag_event1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__EActivityVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__EActivityVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__EActivityVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_userVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns4:userVO", &(((ns4__EActivityVO*)a)->userVO), "ns4:UserVO"))
				{	soap_flag_userVO1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__EActivityVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EActivityVO, 0, sizeof(ns4__EActivityVO), 0, soap_copy_ns4__EActivityVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__EActivityVO * SOAP_FMAC6 soap_new_ns4__EActivityVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__EActivityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__EActivityVO(struct soap *soap, ns4__EActivityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__EActivityVO * SOAP_FMAC4 soap_instantiate_ns4__EActivityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__EActivityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__EActivityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__EActivityVO;
		if (size)
			*size = sizeof(ns4__EActivityVO);
		((ns4__EActivityVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__EActivityVO[n];
		if (size)
			*size = n * sizeof(ns4__EActivityVO);
		for (int i = 0; i < n; i++)
			((ns4__EActivityVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__EActivityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__EActivityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__EActivityVO %p -> %p\n", q, p));
	*(ns4__EActivityVO*)p = *(ns4__EActivityVO*)q;
}

void ns4__UserVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__UserVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__UserVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__UserVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__UserVO*)this)->allScalars);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__UserVO*)this)->entityVO);
	soap_serialize_PointerTostd__string(soap, &((ns4__UserVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__UserVO*)this)->password);
	soap_serialize_PointerToLONG64(soap, &((ns4__UserVO*)this)->securityLabel);
	soap_serialize_PointerTostd__string(soap, &((ns4__UserVO*)this)->userRole);
	soap_serialize_PointerTostd__string(soap, &((ns4__UserVO*)this)->username);
	/* transient soap skipped */
}

void ns4__UserVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__UserVO*)this)->DBTableName = NULL;
	((ns4__UserVO*)this)->VOName = NULL;
	((ns4__UserVO*)this)->allDBColumns = NULL;
	((ns4__UserVO*)this)->allScalars = NULL;
	((ns4__UserVO*)this)->entityVO = NULL;
	((ns4__UserVO*)this)->identifier = NULL;
	((ns4__UserVO*)this)->password = NULL;
	((ns4__UserVO*)this)->securityLabel = NULL;
	((ns4__UserVO*)this)->userRole = NULL;
	((ns4__UserVO*)this)->username = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__UserVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__UserVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__UserVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__UserVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UserVO(struct soap *soap, const char *tag, int id, const ns4__UserVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UserVO), "ns4:UserVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__UserVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__UserVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__UserVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__UserVO*)a)->allScalars), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__UserVO*)a)->entityVO), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__UserVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:password", -1, &(((ns4__UserVO*)a)->password), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__UserVO*)a)->securityLabel), "");
	soap_out_PointerTostd__string(soap, "ns4:userRole", -1, &(((ns4__UserVO*)a)->userRole), "");
	soap_out_PointerTostd__string(soap, "ns4:username", -1, &(((ns4__UserVO*)a)->username), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__UserVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__UserVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__UserVO * SOAP_FMAC4 soap_get_ns4__UserVO(struct soap *soap, ns4__UserVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UserVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__UserVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__UserVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__UserVO * SOAP_FMAC4 soap_in_ns4__UserVO(struct soap *soap, const char *tag, ns4__UserVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__UserVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UserVO, sizeof(ns4__UserVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__UserVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__UserVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_entityVO1 = 1, soap_flag_identifier1 = 1, soap_flag_password1 = 1, soap_flag_securityLabel1 = 1, soap_flag_userRole1 = 1, soap_flag_username1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__UserVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__UserVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__UserVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__UserVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__UserVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__UserVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:password", &(((ns4__UserVO*)a)->password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__UserVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_userRole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:userRole", &(((ns4__UserVO*)a)->userRole), "xsd:string"))
				{	soap_flag_userRole1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:username", &(((ns4__UserVO*)a)->username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__UserVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UserVO, 0, sizeof(ns4__UserVO), 0, soap_copy_ns4__UserVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__UserVO * SOAP_FMAC6 soap_new_ns4__UserVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__UserVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__UserVO(struct soap *soap, ns4__UserVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__UserVO * SOAP_FMAC4 soap_instantiate_ns4__UserVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__UserVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__UserVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__UserVO;
		if (size)
			*size = sizeof(ns4__UserVO);
		((ns4__UserVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__UserVO[n];
		if (size)
			*size = n * sizeof(ns4__UserVO);
		for (int i = 0; i < n; i++)
			((ns4__UserVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__UserVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__UserVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__UserVO %p -> %p\n", q, p));
	*(ns4__UserVO*)p = *(ns4__UserVO*)q;
}

void ns4__FeedbackVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__FeedbackVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__FeedbackVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__FeedbackVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__FeedbackVO*)this)->allScalars);
	soap_serialize_PointerTostd__string(soap, &((ns4__FeedbackVO*)this)->category);
	soap_serialize_PointerTostd__string(soap, &((ns4__FeedbackVO*)this)->comments);
	soap_serialize_PointerTotime(soap, &((ns4__FeedbackVO*)this)->dateCreated);
	soap_serialize_PointerToLONG64(soap, &((ns4__FeedbackVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__FeedbackVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__FeedbackVO*)this)->section);
	soap_serialize_PointerToLONG64(soap, &((ns4__FeedbackVO*)this)->securityLabel);
	soap_serialize_PointerTons4__UserVO(soap, &((ns4__FeedbackVO*)this)->userVO);
	/* transient soap skipped */
}

void ns4__FeedbackVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__FeedbackVO*)this)->DBTableName = NULL;
	((ns4__FeedbackVO*)this)->VOName = NULL;
	((ns4__FeedbackVO*)this)->allDBColumns = NULL;
	((ns4__FeedbackVO*)this)->allScalars = NULL;
	((ns4__FeedbackVO*)this)->category = NULL;
	((ns4__FeedbackVO*)this)->comments = NULL;
	((ns4__FeedbackVO*)this)->dateCreated = NULL;
	((ns4__FeedbackVO*)this)->id = NULL;
	((ns4__FeedbackVO*)this)->identifier = NULL;
	((ns4__FeedbackVO*)this)->section = NULL;
	((ns4__FeedbackVO*)this)->securityLabel = NULL;
	((ns4__FeedbackVO*)this)->userVO = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__FeedbackVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__FeedbackVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__FeedbackVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__FeedbackVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FeedbackVO(struct soap *soap, const char *tag, int id, const ns4__FeedbackVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FeedbackVO), "ns4:FeedbackVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__FeedbackVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__FeedbackVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__FeedbackVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__FeedbackVO*)a)->allScalars), "");
	soap_out_PointerTostd__string(soap, "ns4:category", -1, &(((ns4__FeedbackVO*)a)->category), "");
	soap_out_PointerTostd__string(soap, "ns4:comments", -1, &(((ns4__FeedbackVO*)a)->comments), "");
	soap_out_PointerTotime(soap, "ns4:dateCreated", -1, &(((ns4__FeedbackVO*)a)->dateCreated), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__FeedbackVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__FeedbackVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:section", -1, &(((ns4__FeedbackVO*)a)->section), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__FeedbackVO*)a)->securityLabel), "");
	soap_out_PointerTons4__UserVO(soap, "ns4:userVO", -1, &(((ns4__FeedbackVO*)a)->userVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__FeedbackVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__FeedbackVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__FeedbackVO * SOAP_FMAC4 soap_get_ns4__FeedbackVO(struct soap *soap, ns4__FeedbackVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FeedbackVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__FeedbackVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__FeedbackVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__FeedbackVO * SOAP_FMAC4 soap_in_ns4__FeedbackVO(struct soap *soap, const char *tag, ns4__FeedbackVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__FeedbackVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FeedbackVO, sizeof(ns4__FeedbackVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__FeedbackVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__FeedbackVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_category1 = 1, soap_flag_comments1 = 1, soap_flag_dateCreated1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_section1 = 1, soap_flag_securityLabel1 = 1, soap_flag_userVO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__FeedbackVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__FeedbackVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__FeedbackVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__FeedbackVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:category", &(((ns4__FeedbackVO*)a)->category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:comments", &(((ns4__FeedbackVO*)a)->comments), "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			if (soap_flag_dateCreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:dateCreated", &(((ns4__FeedbackVO*)a)->dateCreated), "xsd:dateTime"))
				{	soap_flag_dateCreated1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__FeedbackVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__FeedbackVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_section1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:section", &(((ns4__FeedbackVO*)a)->section), "xsd:string"))
				{	soap_flag_section1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__FeedbackVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_userVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns4:userVO", &(((ns4__FeedbackVO*)a)->userVO), "ns4:UserVO"))
				{	soap_flag_userVO1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__FeedbackVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FeedbackVO, 0, sizeof(ns4__FeedbackVO), 0, soap_copy_ns4__FeedbackVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__FeedbackVO * SOAP_FMAC6 soap_new_ns4__FeedbackVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__FeedbackVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__FeedbackVO(struct soap *soap, ns4__FeedbackVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__FeedbackVO * SOAP_FMAC4 soap_instantiate_ns4__FeedbackVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__FeedbackVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__FeedbackVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__FeedbackVO;
		if (size)
			*size = sizeof(ns4__FeedbackVO);
		((ns4__FeedbackVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__FeedbackVO[n];
		if (size)
			*size = n * sizeof(ns4__FeedbackVO);
		for (int i = 0; i < n; i++)
			((ns4__FeedbackVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__FeedbackVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__FeedbackVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__FeedbackVO %p -> %p\n", q, p));
	*(ns4__FeedbackVO*)p = *(ns4__FeedbackVO*)q;
}

void ns4__ArrayOfFeedbackVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__FeedbackVO(soap, &((ns4__ArrayOfFeedbackVO*)this)->FeedbackVO);
	/* transient soap skipped */
}

void ns4__ArrayOfFeedbackVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__FeedbackVO(soap, &((ns4__ArrayOfFeedbackVO*)this)->FeedbackVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfFeedbackVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfFeedbackVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfFeedbackVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfFeedbackVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfFeedbackVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfFeedbackVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfFeedbackVO), "ns4:ArrayOfFeedbackVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__FeedbackVO(soap, "ns4:FeedbackVO", -1, &(((ns4__ArrayOfFeedbackVO*)a)->FeedbackVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfFeedbackVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfFeedbackVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfFeedbackVO * SOAP_FMAC4 soap_get_ns4__ArrayOfFeedbackVO(struct soap *soap, ns4__ArrayOfFeedbackVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfFeedbackVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfFeedbackVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfFeedbackVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfFeedbackVO * SOAP_FMAC4 soap_in_ns4__ArrayOfFeedbackVO(struct soap *soap, const char *tag, ns4__ArrayOfFeedbackVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfFeedbackVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfFeedbackVO, sizeof(ns4__ArrayOfFeedbackVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfFeedbackVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfFeedbackVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__FeedbackVO(soap, "ns4:FeedbackVO", &(((ns4__ArrayOfFeedbackVO*)a)->FeedbackVO), "ns4:FeedbackVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfFeedbackVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfFeedbackVO, 0, sizeof(ns4__ArrayOfFeedbackVO), 0, soap_copy_ns4__ArrayOfFeedbackVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfFeedbackVO * SOAP_FMAC6 soap_new_ns4__ArrayOfFeedbackVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfFeedbackVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfFeedbackVO(struct soap *soap, ns4__ArrayOfFeedbackVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfFeedbackVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfFeedbackVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfFeedbackVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfFeedbackVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfFeedbackVO;
		if (size)
			*size = sizeof(ns4__ArrayOfFeedbackVO);
		((ns4__ArrayOfFeedbackVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfFeedbackVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfFeedbackVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfFeedbackVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfFeedbackVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfFeedbackVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfFeedbackVO %p -> %p\n", q, p));
	*(ns4__ArrayOfFeedbackVO*)p = *(ns4__ArrayOfFeedbackVO*)q;
}

void ns4__EntityVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__EntityVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__EntityVO*)this)->allScalars);
	soap_serialize_PointerTodouble(soap, &((ns4__EntityVO*)this)->altitude);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->dataUrl);
	soap_serialize_PointerTotime(soap, &((ns4__EntityVO*)this)->dateCreated);
	soap_serialize_PointerTotime(soap, &((ns4__EntityVO*)this)->dateInstalled);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->entityType);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->geometry);
	soap_serialize_PointerToLONG64(soap, &((ns4__EntityVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->identifier);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->locationId);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->metadataUrl);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->mimetype);
	soap_serialize_PointerToLONG64(soap, &((ns4__EntityVO*)this)->securityLabel);
	soap_serialize_PointerTostd__string(soap, &((ns4__EntityVO*)this)->sourceUrl);
	/* transient soap skipped */
}

void ns4__EntityVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__EntityVO*)this)->DBTableName = NULL;
	((ns4__EntityVO*)this)->VOName = NULL;
	((ns4__EntityVO*)this)->allDBColumns = NULL;
	((ns4__EntityVO*)this)->allScalars = NULL;
	((ns4__EntityVO*)this)->altitude = NULL;
	((ns4__EntityVO*)this)->dataUrl = NULL;
	((ns4__EntityVO*)this)->dateCreated = NULL;
	((ns4__EntityVO*)this)->dateInstalled = NULL;
	((ns4__EntityVO*)this)->entityType = NULL;
	((ns4__EntityVO*)this)->geometry = NULL;
	((ns4__EntityVO*)this)->id = NULL;
	((ns4__EntityVO*)this)->identifier = NULL;
	((ns4__EntityVO*)this)->locationId = NULL;
	((ns4__EntityVO*)this)->metadataUrl = NULL;
	((ns4__EntityVO*)this)->mimetype = NULL;
	((ns4__EntityVO*)this)->securityLabel = NULL;
	((ns4__EntityVO*)this)->sourceUrl = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__EntityVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__EntityVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__EntityVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__EntityVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EntityVO(struct soap *soap, const char *tag, int id, const ns4__EntityVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EntityVO), "ns4:EntityVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__EntityVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__EntityVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__EntityVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__EntityVO*)a)->allScalars), "");
	soap_out_PointerTodouble(soap, "ns4:altitude", -1, &(((ns4__EntityVO*)a)->altitude), "");
	soap_out_PointerTostd__string(soap, "ns4:dataUrl", -1, &(((ns4__EntityVO*)a)->dataUrl), "");
	soap_out_PointerTotime(soap, "ns4:dateCreated", -1, &(((ns4__EntityVO*)a)->dateCreated), "");
	soap_out_PointerTotime(soap, "ns4:dateInstalled", -1, &(((ns4__EntityVO*)a)->dateInstalled), "");
	soap_out_PointerTostd__string(soap, "ns4:entityType", -1, &(((ns4__EntityVO*)a)->entityType), "");
	soap_out_PointerTostd__string(soap, "ns4:geometry", -1, &(((ns4__EntityVO*)a)->geometry), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__EntityVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__EntityVO*)a)->identifier), "");
	soap_out_PointerTostd__string(soap, "ns4:locationId", -1, &(((ns4__EntityVO*)a)->locationId), "");
	soap_out_PointerTostd__string(soap, "ns4:metadataUrl", -1, &(((ns4__EntityVO*)a)->metadataUrl), "");
	soap_out_PointerTostd__string(soap, "ns4:mimetype", -1, &(((ns4__EntityVO*)a)->mimetype), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__EntityVO*)a)->securityLabel), "");
	soap_out_PointerTostd__string(soap, "ns4:sourceUrl", -1, &(((ns4__EntityVO*)a)->sourceUrl), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__EntityVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__EntityVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__EntityVO * SOAP_FMAC4 soap_get_ns4__EntityVO(struct soap *soap, ns4__EntityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EntityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__EntityVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__EntityVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__EntityVO * SOAP_FMAC4 soap_in_ns4__EntityVO(struct soap *soap, const char *tag, ns4__EntityVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__EntityVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EntityVO, sizeof(ns4__EntityVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__EntityVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__EntityVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_altitude1 = 1, soap_flag_dataUrl1 = 1, soap_flag_dateCreated1 = 1, soap_flag_dateInstalled1 = 1, soap_flag_entityType1 = 1, soap_flag_geometry1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_locationId1 = 1, soap_flag_metadataUrl1 = 1, soap_flag_mimetype1 = 1, soap_flag_securityLabel1 = 1, soap_flag_sourceUrl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__EntityVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__EntityVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__EntityVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__EntityVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_altitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:altitude", &(((ns4__EntityVO*)a)->altitude), "xsd:double"))
				{	soap_flag_altitude1--;
					continue;
				}
			if (soap_flag_dataUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:dataUrl", &(((ns4__EntityVO*)a)->dataUrl), "xsd:string"))
				{	soap_flag_dataUrl1--;
					continue;
				}
			if (soap_flag_dateCreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:dateCreated", &(((ns4__EntityVO*)a)->dateCreated), "xsd:dateTime"))
				{	soap_flag_dateCreated1--;
					continue;
				}
			if (soap_flag_dateInstalled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:dateInstalled", &(((ns4__EntityVO*)a)->dateInstalled), "xsd:dateTime"))
				{	soap_flag_dateInstalled1--;
					continue;
				}
			if (soap_flag_entityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:entityType", &(((ns4__EntityVO*)a)->entityType), "xsd:string"))
				{	soap_flag_entityType1--;
					continue;
				}
			if (soap_flag_geometry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:geometry", &(((ns4__EntityVO*)a)->geometry), "xsd:string"))
				{	soap_flag_geometry1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__EntityVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__EntityVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_locationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:locationId", &(((ns4__EntityVO*)a)->locationId), "xsd:string"))
				{	soap_flag_locationId1--;
					continue;
				}
			if (soap_flag_metadataUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:metadataUrl", &(((ns4__EntityVO*)a)->metadataUrl), "xsd:string"))
				{	soap_flag_metadataUrl1--;
					continue;
				}
			if (soap_flag_mimetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:mimetype", &(((ns4__EntityVO*)a)->mimetype), "xsd:string"))
				{	soap_flag_mimetype1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__EntityVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_sourceUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:sourceUrl", &(((ns4__EntityVO*)a)->sourceUrl), "xsd:string"))
				{	soap_flag_sourceUrl1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__EntityVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EntityVO, 0, sizeof(ns4__EntityVO), 0, soap_copy_ns4__EntityVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__EntityVO * SOAP_FMAC6 soap_new_ns4__EntityVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__EntityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__EntityVO(struct soap *soap, ns4__EntityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__EntityVO * SOAP_FMAC4 soap_instantiate_ns4__EntityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__EntityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__EntityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__EntityVO;
		if (size)
			*size = sizeof(ns4__EntityVO);
		((ns4__EntityVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__EntityVO[n];
		if (size)
			*size = n * sizeof(ns4__EntityVO);
		for (int i = 0; i < n; i++)
			((ns4__EntityVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__EntityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__EntityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__EntityVO %p -> %p\n", q, p));
	*(ns4__EntityVO*)p = *(ns4__EntityVO*)q;
}

void ns4__ESignatureVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__ESignatureVO*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns4__ESignatureVO*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns4__ESignatureVO*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns4__ESignatureVO*)this)->allScalars);
	soap_serialize_PointerTons4__EntityVO(soap, &((ns4__ESignatureVO*)this)->entityVO);
	soap_serialize_PointerToLONG64(soap, &((ns4__ESignatureVO*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((ns4__ESignatureVO*)this)->identifier);
	soap_serialize_PointerToLONG64(soap, &((ns4__ESignatureVO*)this)->securityLabel);
	soap_serialize_PointerTostd__string(soap, &((ns4__ESignatureVO*)this)->signature);
	soap_serialize_PointerTostd__string(soap, &((ns4__ESignatureVO*)this)->signatureType);
	/* transient soap skipped */
}

void ns4__ESignatureVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__ESignatureVO*)this)->DBTableName = NULL;
	((ns4__ESignatureVO*)this)->VOName = NULL;
	((ns4__ESignatureVO*)this)->allDBColumns = NULL;
	((ns4__ESignatureVO*)this)->allScalars = NULL;
	((ns4__ESignatureVO*)this)->entityVO = NULL;
	((ns4__ESignatureVO*)this)->id = NULL;
	((ns4__ESignatureVO*)this)->identifier = NULL;
	((ns4__ESignatureVO*)this)->securityLabel = NULL;
	((ns4__ESignatureVO*)this)->signature = NULL;
	((ns4__ESignatureVO*)this)->signatureType = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ESignatureVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ESignatureVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ESignatureVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ESignatureVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ESignatureVO(struct soap *soap, const char *tag, int id, const ns4__ESignatureVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ESignatureVO), "ns4:ESignatureVO");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns4:DBTableName", -1, &(((ns4__ESignatureVO*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns4:VOName", -1, &(((ns4__ESignatureVO*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", -1, &(((ns4__ESignatureVO*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", -1, &(((ns4__ESignatureVO*)a)->allScalars), "");
	soap_out_PointerTons4__EntityVO(soap, "ns4:entityVO", -1, &(((ns4__ESignatureVO*)a)->entityVO), "");
	soap_out_PointerToLONG64(soap, "ns4:id", -1, &(((ns4__ESignatureVO*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns4:identifier", -1, &(((ns4__ESignatureVO*)a)->identifier), "");
	soap_out_PointerToLONG64(soap, "ns4:securityLabel", -1, &(((ns4__ESignatureVO*)a)->securityLabel), "");
	soap_out_PointerTostd__string(soap, "ns4:signature", -1, &(((ns4__ESignatureVO*)a)->signature), "");
	soap_out_PointerTostd__string(soap, "ns4:signatureType", -1, &(((ns4__ESignatureVO*)a)->signatureType), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ESignatureVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ESignatureVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ESignatureVO * SOAP_FMAC4 soap_get_ns4__ESignatureVO(struct soap *soap, ns4__ESignatureVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ESignatureVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ESignatureVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ESignatureVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ESignatureVO * SOAP_FMAC4 soap_in_ns4__ESignatureVO(struct soap *soap, const char *tag, ns4__ESignatureVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ESignatureVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ESignatureVO, sizeof(ns4__ESignatureVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ESignatureVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ESignatureVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_entityVO1 = 1, soap_flag_id1 = 1, soap_flag_identifier1 = 1, soap_flag_securityLabel1 = 1, soap_flag_signature1 = 1, soap_flag_signatureType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:DBTableName", &(((ns4__ESignatureVO*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:VOName", &(((ns4__ESignatureVO*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns4:allDBColumns", &(((ns4__ESignatureVO*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns4:allScalars", &(((ns4__ESignatureVO*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_entityVO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns4:entityVO", &(((ns4__ESignatureVO*)a)->entityVO), "ns4:EntityVO"))
				{	soap_flag_entityVO1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:id", &(((ns4__ESignatureVO*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:identifier", &(((ns4__ESignatureVO*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_securityLabel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:securityLabel", &(((ns4__ESignatureVO*)a)->securityLabel), "xsd:long"))
				{	soap_flag_securityLabel1--;
					continue;
				}
			if (soap_flag_signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:signature", &(((ns4__ESignatureVO*)a)->signature), "xsd:string"))
				{	soap_flag_signature1--;
					continue;
				}
			if (soap_flag_signatureType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:signatureType", &(((ns4__ESignatureVO*)a)->signatureType), "xsd:string"))
				{	soap_flag_signatureType1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ESignatureVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ESignatureVO, 0, sizeof(ns4__ESignatureVO), 0, soap_copy_ns4__ESignatureVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ESignatureVO * SOAP_FMAC6 soap_new_ns4__ESignatureVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ESignatureVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ESignatureVO(struct soap *soap, ns4__ESignatureVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ESignatureVO * SOAP_FMAC4 soap_instantiate_ns4__ESignatureVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ESignatureVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ESignatureVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ESignatureVO;
		if (size)
			*size = sizeof(ns4__ESignatureVO);
		((ns4__ESignatureVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ESignatureVO[n];
		if (size)
			*size = n * sizeof(ns4__ESignatureVO);
		for (int i = 0; i < n; i++)
			((ns4__ESignatureVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ESignatureVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ESignatureVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ESignatureVO %p -> %p\n", q, p));
	*(ns4__ESignatureVO*)p = *(ns4__ESignatureVO*)q;
}

void ns4__ArrayOfESignatureVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__ESignatureVO(soap, &((ns4__ArrayOfESignatureVO*)this)->ESignatureVO);
	/* transient soap skipped */
}

void ns4__ArrayOfESignatureVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__ESignatureVO(soap, &((ns4__ArrayOfESignatureVO*)this)->ESignatureVO);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns4__ArrayOfESignatureVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfESignatureVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfESignatureVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfESignatureVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfESignatureVO(struct soap *soap, const char *tag, int id, const ns4__ArrayOfESignatureVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfESignatureVO), "ns4:ArrayOfESignatureVO");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons4__ESignatureVO(soap, "ns4:ESignatureVO", -1, &(((ns4__ArrayOfESignatureVO*)a)->ESignatureVO), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__ArrayOfESignatureVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfESignatureVO(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfESignatureVO * SOAP_FMAC4 soap_get_ns4__ArrayOfESignatureVO(struct soap *soap, ns4__ArrayOfESignatureVO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfESignatureVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__ArrayOfESignatureVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfESignatureVO(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfESignatureVO * SOAP_FMAC4 soap_in_ns4__ArrayOfESignatureVO(struct soap *soap, const char *tag, ns4__ArrayOfESignatureVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfESignatureVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfESignatureVO, sizeof(ns4__ArrayOfESignatureVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfESignatureVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfESignatureVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__ESignatureVO(soap, "ns4:ESignatureVO", &(((ns4__ArrayOfESignatureVO*)a)->ESignatureVO), "ns4:ESignatureVO"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfESignatureVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfESignatureVO, 0, sizeof(ns4__ArrayOfESignatureVO), 0, soap_copy_ns4__ArrayOfESignatureVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ArrayOfESignatureVO * SOAP_FMAC6 soap_new_ns4__ArrayOfESignatureVO(struct soap *soap, int n)
{	return soap_instantiate_ns4__ArrayOfESignatureVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ArrayOfESignatureVO(struct soap *soap, ns4__ArrayOfESignatureVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ArrayOfESignatureVO * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfESignatureVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfESignatureVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfESignatureVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfESignatureVO;
		if (size)
			*size = sizeof(ns4__ArrayOfESignatureVO);
		((ns4__ArrayOfESignatureVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfESignatureVO[n];
		if (size)
			*size = n * sizeof(ns4__ArrayOfESignatureVO);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfESignatureVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfESignatureVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfESignatureVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfESignatureVO %p -> %p\n", q, p));
	*(ns4__ArrayOfESignatureVO*)p = *(ns4__ArrayOfESignatureVO*)q;
}

void _ns1__create4Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ERelationVO(soap, &((_ns1__create4Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create4Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create4Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create4Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create4Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create4Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create4Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create4Response(struct soap *soap, const char *tag, int id, const _ns1__create4Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create4Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ERelationVO(soap, "ns1:out", -1, &(((_ns1__create4Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create4Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create4Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create4Response * SOAP_FMAC4 soap_get__ns1__create4Response(struct soap *soap, _ns1__create4Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create4Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create4Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create4Response * SOAP_FMAC4 soap_in__ns1__create4Response(struct soap *soap, const char *tag, _ns1__create4Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create4Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create4Response, sizeof(_ns1__create4Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create4Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create4Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ERelationVO(soap, "ns1:out", &(((_ns1__create4Response*)a)->out), "ns4:ERelationVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create4Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create4Response, 0, sizeof(_ns1__create4Response), 0, soap_copy__ns1__create4Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create4Response * SOAP_FMAC6 soap_new__ns1__create4Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create4Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create4Response(struct soap *soap, _ns1__create4Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create4Response * SOAP_FMAC4 soap_instantiate__ns1__create4Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create4Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create4Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create4Response;
		if (size)
			*size = sizeof(_ns1__create4Response);
		((_ns1__create4Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create4Response[n];
		if (size)
			*size = n * sizeof(_ns1__create4Response);
		for (int i = 0; i < n; i++)
			((_ns1__create4Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create4Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create4Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create4Response %p -> %p\n", q, p));
	*(_ns1__create4Response*)p = *(_ns1__create4Response*)q;
}

void _ns1__create4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ERelationVO(soap, &((_ns1__create4*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create4::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create4*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create4);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create4(struct soap *soap, const char *tag, int id, const _ns1__create4 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create4), type);
	soap_out_PointerTons4__ERelationVO(soap, "ns1:in0", -1, &(((_ns1__create4*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create4(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create4 * SOAP_FMAC4 soap_get__ns1__create4(struct soap *soap, _ns1__create4 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create4::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create4(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create4 * SOAP_FMAC4 soap_in__ns1__create4(struct soap *soap, const char *tag, _ns1__create4 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create4 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create4, sizeof(_ns1__create4), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create4)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create4 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ERelationVO(soap, "ns1:in0", &(((_ns1__create4*)a)->in0), "ns4:ERelationVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create4, 0, sizeof(_ns1__create4), 0, soap_copy__ns1__create4);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create4 * SOAP_FMAC6 soap_new__ns1__create4(struct soap *soap, int n)
{	return soap_instantiate__ns1__create4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create4(struct soap *soap, _ns1__create4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create4 * SOAP_FMAC4 soap_instantiate__ns1__create4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create4;
		if (size)
			*size = sizeof(_ns1__create4);
		((_ns1__create4*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create4[n];
		if (size)
			*size = n * sizeof(_ns1__create4);
		for (int i = 0; i < n; i++)
			((_ns1__create4*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create4 %p -> %p\n", q, p));
	*(_ns1__create4*)p = *(_ns1__create4*)q;
}

void _ns1__create9Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTSlideVO(soap, &((_ns1__create9Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create9Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create9Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create9Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create9Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create9Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create9Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create9Response(struct soap *soap, const char *tag, int id, const _ns1__create9Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create9Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__PPTSlideVO(soap, "ns1:out", -1, &(((_ns1__create9Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create9Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create9Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create9Response * SOAP_FMAC4 soap_get__ns1__create9Response(struct soap *soap, _ns1__create9Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create9Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create9Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create9Response * SOAP_FMAC4 soap_in__ns1__create9Response(struct soap *soap, const char *tag, _ns1__create9Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create9Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create9Response, sizeof(_ns1__create9Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create9Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create9Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTSlideVO(soap, "ns1:out", &(((_ns1__create9Response*)a)->out), "ns4:PPTSlideVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create9Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create9Response, 0, sizeof(_ns1__create9Response), 0, soap_copy__ns1__create9Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create9Response * SOAP_FMAC6 soap_new__ns1__create9Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create9Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create9Response(struct soap *soap, _ns1__create9Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create9Response * SOAP_FMAC4 soap_instantiate__ns1__create9Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create9Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create9Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create9Response;
		if (size)
			*size = sizeof(_ns1__create9Response);
		((_ns1__create9Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create9Response[n];
		if (size)
			*size = n * sizeof(_ns1__create9Response);
		for (int i = 0; i < n; i++)
			((_ns1__create9Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create9Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create9Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create9Response %p -> %p\n", q, p));
	*(_ns1__create9Response*)p = *(_ns1__create9Response*)q;
}

void _ns1__create9::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTSlideVO(soap, &((_ns1__create9*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create9::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create9*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create9::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create9);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create9::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create9(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create9(struct soap *soap, const char *tag, int id, const _ns1__create9 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create9), type);
	soap_out_PointerTons4__PPTSlideVO(soap, "ns1:in0", -1, &(((_ns1__create9*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create9::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create9(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create9 * SOAP_FMAC4 soap_get__ns1__create9(struct soap *soap, _ns1__create9 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create9::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create9(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create9 * SOAP_FMAC4 soap_in__ns1__create9(struct soap *soap, const char *tag, _ns1__create9 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create9 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create9, sizeof(_ns1__create9), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create9)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create9 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTSlideVO(soap, "ns1:in0", &(((_ns1__create9*)a)->in0), "ns4:PPTSlideVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create9 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create9, 0, sizeof(_ns1__create9), 0, soap_copy__ns1__create9);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create9 * SOAP_FMAC6 soap_new__ns1__create9(struct soap *soap, int n)
{	return soap_instantiate__ns1__create9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create9(struct soap *soap, _ns1__create9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create9 * SOAP_FMAC4 soap_instantiate__ns1__create9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create9;
		if (size)
			*size = sizeof(_ns1__create9);
		((_ns1__create9*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create9[n];
		if (size)
			*size = n * sizeof(_ns1__create9);
		for (int i = 0; i < n; i++)
			((_ns1__create9*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create9 %p -> %p\n", q, p));
	*(_ns1__create9*)p = *(_ns1__create9*)q;
}

void _ns1__findByPK11Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserVO(soap, &((_ns1__findByPK11Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK11Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK11Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK11Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK11Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK11Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK11Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK11Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK11Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK11Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__UserVO(soap, "ns1:out", -1, &(((_ns1__findByPK11Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK11Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK11Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK11Response * SOAP_FMAC4 soap_get__ns1__findByPK11Response(struct soap *soap, _ns1__findByPK11Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK11Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK11Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK11Response * SOAP_FMAC4 soap_in__ns1__findByPK11Response(struct soap *soap, const char *tag, _ns1__findByPK11Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK11Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK11Response, sizeof(_ns1__findByPK11Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK11Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK11Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns1:out", &(((_ns1__findByPK11Response*)a)->out), "ns4:UserVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK11Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK11Response, 0, sizeof(_ns1__findByPK11Response), 0, soap_copy__ns1__findByPK11Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK11Response * SOAP_FMAC6 soap_new__ns1__findByPK11Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK11Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK11Response(struct soap *soap, _ns1__findByPK11Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK11Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK11Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK11Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK11Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK11Response;
		if (size)
			*size = sizeof(_ns1__findByPK11Response);
		((_ns1__findByPK11Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK11Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK11Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK11Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK11Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK11Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK11Response %p -> %p\n", q, p));
	*(_ns1__findByPK11Response*)p = *(_ns1__findByPK11Response*)q;
}

void _ns1__findByPK11::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserVO(soap, &((_ns1__findByPK11*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK11::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK11*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK11::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK11);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK11::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK11(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK11(struct soap *soap, const char *tag, int id, const _ns1__findByPK11 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK11), type);
	soap_out_PointerTons4__UserVO(soap, "ns1:in0", -1, &(((_ns1__findByPK11*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK11::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK11(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK11 * SOAP_FMAC4 soap_get__ns1__findByPK11(struct soap *soap, _ns1__findByPK11 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK11::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK11(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK11 * SOAP_FMAC4 soap_in__ns1__findByPK11(struct soap *soap, const char *tag, _ns1__findByPK11 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK11 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK11, sizeof(_ns1__findByPK11), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK11)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK11 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns1:in0", &(((_ns1__findByPK11*)a)->in0), "ns4:UserVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK11 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK11, 0, sizeof(_ns1__findByPK11), 0, soap_copy__ns1__findByPK11);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK11 * SOAP_FMAC6 soap_new__ns1__findByPK11(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK11(struct soap *soap, _ns1__findByPK11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK11 * SOAP_FMAC4 soap_instantiate__ns1__findByPK11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK11;
		if (size)
			*size = sizeof(_ns1__findByPK11);
		((_ns1__findByPK11*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK11[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK11);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK11*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK11 %p -> %p\n", q, p));
	*(_ns1__findByPK11*)p = *(_ns1__findByPK11*)q;
}

void _ns1__update1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update1Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update1Response(struct soap *soap, const char *tag, int id, const _ns1__update1Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update1Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update1Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update1Response * SOAP_FMAC4 soap_get__ns1__update1Response(struct soap *soap, _ns1__update1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update1Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update1Response * SOAP_FMAC4 soap_in__ns1__update1Response(struct soap *soap, const char *tag, _ns1__update1Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update1Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update1Response, sizeof(_ns1__update1Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update1Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update1Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update1Response, 0, sizeof(_ns1__update1Response), 0, soap_copy__ns1__update1Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update1Response * SOAP_FMAC6 soap_new__ns1__update1Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update1Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update1Response(struct soap *soap, _ns1__update1Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update1Response * SOAP_FMAC4 soap_instantiate__ns1__update1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update1Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update1Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update1Response;
		if (size)
			*size = sizeof(_ns1__update1Response);
		((_ns1__update1Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update1Response[n];
		if (size)
			*size = n * sizeof(_ns1__update1Response);
		for (int i = 0; i < n; i++)
			((_ns1__update1Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update1Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update1Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update1Response %p -> %p\n", q, p));
	*(_ns1__update1Response*)p = *(_ns1__update1Response*)q;
}

void _ns1__update1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ContainerVO(soap, &((_ns1__update1*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update1::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update1*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update1);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update1(struct soap *soap, const char *tag, int id, const _ns1__update1 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update1), type);
	soap_out_PointerTons4__ContainerVO(soap, "ns1:in0", -1, &(((_ns1__update1*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update1(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update1 * SOAP_FMAC4 soap_get__ns1__update1(struct soap *soap, _ns1__update1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update1(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update1 * SOAP_FMAC4 soap_in__ns1__update1(struct soap *soap, const char *tag, _ns1__update1 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update1, sizeof(_ns1__update1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update1 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ContainerVO(soap, "ns1:in0", &(((_ns1__update1*)a)->in0), "ns4:ContainerVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update1, 0, sizeof(_ns1__update1), 0, soap_copy__ns1__update1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update1 * SOAP_FMAC6 soap_new__ns1__update1(struct soap *soap, int n)
{	return soap_instantiate__ns1__update1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update1(struct soap *soap, _ns1__update1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update1 * SOAP_FMAC4 soap_instantiate__ns1__update1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update1;
		if (size)
			*size = sizeof(_ns1__update1);
		((_ns1__update1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update1[n];
		if (size)
			*size = n * sizeof(_ns1__update1);
		for (int i = 0; i < n; i++)
			((_ns1__update1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update1 %p -> %p\n", q, p));
	*(_ns1__update1*)p = *(_ns1__update1*)q;
}

void _ns1__create10Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTVO(soap, &((_ns1__create10Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create10Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create10Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create10Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create10Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create10Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create10Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create10Response(struct soap *soap, const char *tag, int id, const _ns1__create10Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create10Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__PPTVO(soap, "ns1:out", -1, &(((_ns1__create10Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create10Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create10Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create10Response * SOAP_FMAC4 soap_get__ns1__create10Response(struct soap *soap, _ns1__create10Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create10Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create10Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create10Response * SOAP_FMAC4 soap_in__ns1__create10Response(struct soap *soap, const char *tag, _ns1__create10Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create10Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create10Response, sizeof(_ns1__create10Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create10Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create10Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTVO(soap, "ns1:out", &(((_ns1__create10Response*)a)->out), "ns4:PPTVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create10Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create10Response, 0, sizeof(_ns1__create10Response), 0, soap_copy__ns1__create10Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create10Response * SOAP_FMAC6 soap_new__ns1__create10Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create10Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create10Response(struct soap *soap, _ns1__create10Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create10Response * SOAP_FMAC4 soap_instantiate__ns1__create10Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create10Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create10Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create10Response;
		if (size)
			*size = sizeof(_ns1__create10Response);
		((_ns1__create10Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create10Response[n];
		if (size)
			*size = n * sizeof(_ns1__create10Response);
		for (int i = 0; i < n; i++)
			((_ns1__create10Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create10Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create10Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create10Response %p -> %p\n", q, p));
	*(_ns1__create10Response*)p = *(_ns1__create10Response*)q;
}

void _ns1__create10::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTVO(soap, &((_ns1__create10*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create10::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create10*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create10::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create10);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create10::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create10(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create10(struct soap *soap, const char *tag, int id, const _ns1__create10 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create10), type);
	soap_out_PointerTons4__PPTVO(soap, "ns1:in0", -1, &(((_ns1__create10*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create10::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create10(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create10 * SOAP_FMAC4 soap_get__ns1__create10(struct soap *soap, _ns1__create10 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create10::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create10(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create10 * SOAP_FMAC4 soap_in__ns1__create10(struct soap *soap, const char *tag, _ns1__create10 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create10 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create10, sizeof(_ns1__create10), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create10)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create10 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTVO(soap, "ns1:in0", &(((_ns1__create10*)a)->in0), "ns4:PPTVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create10 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create10, 0, sizeof(_ns1__create10), 0, soap_copy__ns1__create10);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create10 * SOAP_FMAC6 soap_new__ns1__create10(struct soap *soap, int n)
{	return soap_instantiate__ns1__create10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create10(struct soap *soap, _ns1__create10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create10 * SOAP_FMAC4 soap_instantiate__ns1__create10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create10;
		if (size)
			*size = sizeof(_ns1__create10);
		((_ns1__create10*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create10[n];
		if (size)
			*size = n * sizeof(_ns1__create10);
		for (int i = 0; i < n; i++)
			((_ns1__create10*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create10 %p -> %p\n", q, p));
	*(_ns1__create10*)p = *(_ns1__create10*)q;
}

void _ns1__findByPK1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ContainerVO(soap, &((_ns1__findByPK1Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK1Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK1Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK1Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK1Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK1Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ContainerVO(soap, "ns1:out", -1, &(((_ns1__findByPK1Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK1Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK1Response * SOAP_FMAC4 soap_get__ns1__findByPK1Response(struct soap *soap, _ns1__findByPK1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK1Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK1Response * SOAP_FMAC4 soap_in__ns1__findByPK1Response(struct soap *soap, const char *tag, _ns1__findByPK1Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK1Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK1Response, sizeof(_ns1__findByPK1Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK1Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK1Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ContainerVO(soap, "ns1:out", &(((_ns1__findByPK1Response*)a)->out), "ns4:ContainerVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK1Response, 0, sizeof(_ns1__findByPK1Response), 0, soap_copy__ns1__findByPK1Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK1Response * SOAP_FMAC6 soap_new__ns1__findByPK1Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK1Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK1Response(struct soap *soap, _ns1__findByPK1Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK1Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK1Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK1Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK1Response;
		if (size)
			*size = sizeof(_ns1__findByPK1Response);
		((_ns1__findByPK1Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK1Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK1Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK1Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK1Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK1Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK1Response %p -> %p\n", q, p));
	*(_ns1__findByPK1Response*)p = *(_ns1__findByPK1Response*)q;
}

void _ns1__findByPK1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ContainerVO(soap, &((_ns1__findByPK1*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK1::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK1*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK1);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK1(struct soap *soap, const char *tag, int id, const _ns1__findByPK1 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK1), type);
	soap_out_PointerTons4__ContainerVO(soap, "ns1:in0", -1, &(((_ns1__findByPK1*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK1(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK1 * SOAP_FMAC4 soap_get__ns1__findByPK1(struct soap *soap, _ns1__findByPK1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK1(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK1 * SOAP_FMAC4 soap_in__ns1__findByPK1(struct soap *soap, const char *tag, _ns1__findByPK1 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK1, sizeof(_ns1__findByPK1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK1 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ContainerVO(soap, "ns1:in0", &(((_ns1__findByPK1*)a)->in0), "ns4:ContainerVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK1, 0, sizeof(_ns1__findByPK1), 0, soap_copy__ns1__findByPK1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK1 * SOAP_FMAC6 soap_new__ns1__findByPK1(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK1(struct soap *soap, _ns1__findByPK1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK1 * SOAP_FMAC4 soap_instantiate__ns1__findByPK1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK1;
		if (size)
			*size = sizeof(_ns1__findByPK1);
		((_ns1__findByPK1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK1[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK1);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK1 %p -> %p\n", q, p));
	*(_ns1__findByPK1*)p = *(_ns1__findByPK1*)q;
}

void _ns1__removeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__removeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__removeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__removeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeResponse(struct soap *soap, const char *tag, int id, const _ns1__removeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeResponse), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeResponse * SOAP_FMAC4 soap_get__ns1__removeResponse(struct soap *soap, _ns1__removeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeResponse * SOAP_FMAC4 soap_in__ns1__removeResponse(struct soap *soap, const char *tag, _ns1__removeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeResponse, sizeof(_ns1__removeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeResponse, 0, sizeof(_ns1__removeResponse), 0, soap_copy__ns1__removeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeResponse * SOAP_FMAC6 soap_new__ns1__removeResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeResponse(struct soap *soap, _ns1__removeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__removeResponse * SOAP_FMAC4 soap_instantiate__ns1__removeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeResponse;
		if (size)
			*size = sizeof(_ns1__removeResponse);
		((_ns1__removeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeResponse[n];
		if (size)
			*size = n * sizeof(_ns1__removeResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeResponse %p -> %p\n", q, p));
	*(_ns1__removeResponse*)p = *(_ns1__removeResponse*)q;
}

void _ns1__remove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CommentVO(soap, &((_ns1__remove*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove(struct soap *soap, const char *tag, int id, const _ns1__remove *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove), type);
	soap_out_PointerTons4__CommentVO(soap, "ns1:in0", -1, &(((_ns1__remove*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove * SOAP_FMAC4 soap_get__ns1__remove(struct soap *soap, _ns1__remove *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove * SOAP_FMAC4 soap_in__ns1__remove(struct soap *soap, const char *tag, _ns1__remove *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove, sizeof(_ns1__remove), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CommentVO(soap, "ns1:in0", &(((_ns1__remove*)a)->in0), "ns4:CommentVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove, 0, sizeof(_ns1__remove), 0, soap_copy__ns1__remove);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove * SOAP_FMAC6 soap_new__ns1__remove(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove(struct soap *soap, _ns1__remove *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove * SOAP_FMAC4 soap_instantiate__ns1__remove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove;
		if (size)
			*size = sizeof(_ns1__remove);
		((_ns1__remove*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove[n];
		if (size)
			*size = n * sizeof(_ns1__remove);
		for (int i = 0; i < n; i++)
			((_ns1__remove*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove %p -> %p\n", q, p));
	*(_ns1__remove*)p = *(_ns1__remove*)q;
}

void _ns1__findBySQLQueryReturnCommentVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfCommentVO(soap, &((_ns1__findBySQLQueryReturnCommentVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnCommentVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnCommentVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnCommentVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnCommentVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnCommentVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnCommentVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfCommentVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnCommentVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnCommentVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnCommentVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnCommentVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnCommentVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnCommentVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnCommentVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnCommentVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnCommentVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse, sizeof(_ns1__findBySQLQueryReturnCommentVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnCommentVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfCommentVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnCommentVOResponse*)a)->out), "ns4:ArrayOfCommentVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnCommentVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnCommentVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnCommentVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnCommentVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnCommentVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnCommentVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnCommentVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnCommentVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnCommentVOResponse);
		((_ns1__findBySQLQueryReturnCommentVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnCommentVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnCommentVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnCommentVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnCommentVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnCommentVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnCommentVOResponse*)p = *(_ns1__findBySQLQueryReturnCommentVOResponse*)q;
}

void _ns1__findBySQLQueryReturnCommentVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnCommentVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnCommentVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnCommentVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnCommentVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnCommentVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnCommentVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnCommentVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnCommentVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnCommentVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnCommentVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnCommentVO(struct soap *soap, _ns1__findBySQLQueryReturnCommentVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnCommentVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnCommentVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnCommentVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnCommentVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnCommentVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO, sizeof(_ns1__findBySQLQueryReturnCommentVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnCommentVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnCommentVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnCommentVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO, 0, sizeof(_ns1__findBySQLQueryReturnCommentVO), 0, soap_copy__ns1__findBySQLQueryReturnCommentVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnCommentVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnCommentVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnCommentVO(struct soap *soap, _ns1__findBySQLQueryReturnCommentVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnCommentVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnCommentVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnCommentVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnCommentVO);
		((_ns1__findBySQLQueryReturnCommentVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnCommentVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnCommentVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnCommentVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnCommentVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnCommentVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnCommentVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnCommentVO*)p = *(_ns1__findBySQLQueryReturnCommentVO*)q;
}

void _ns1__findByPK10Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTVO(soap, &((_ns1__findByPK10Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK10Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK10Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK10Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK10Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK10Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK10Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK10Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK10Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK10Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__PPTVO(soap, "ns1:out", -1, &(((_ns1__findByPK10Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK10Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK10Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK10Response * SOAP_FMAC4 soap_get__ns1__findByPK10Response(struct soap *soap, _ns1__findByPK10Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK10Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK10Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK10Response * SOAP_FMAC4 soap_in__ns1__findByPK10Response(struct soap *soap, const char *tag, _ns1__findByPK10Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK10Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK10Response, sizeof(_ns1__findByPK10Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK10Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK10Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTVO(soap, "ns1:out", &(((_ns1__findByPK10Response*)a)->out), "ns4:PPTVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK10Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK10Response, 0, sizeof(_ns1__findByPK10Response), 0, soap_copy__ns1__findByPK10Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK10Response * SOAP_FMAC6 soap_new__ns1__findByPK10Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK10Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK10Response(struct soap *soap, _ns1__findByPK10Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK10Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK10Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK10Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK10Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK10Response;
		if (size)
			*size = sizeof(_ns1__findByPK10Response);
		((_ns1__findByPK10Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK10Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK10Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK10Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK10Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK10Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK10Response %p -> %p\n", q, p));
	*(_ns1__findByPK10Response*)p = *(_ns1__findByPK10Response*)q;
}

void _ns1__findByPK10::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTVO(soap, &((_ns1__findByPK10*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK10::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK10*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK10::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK10);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK10::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK10(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK10(struct soap *soap, const char *tag, int id, const _ns1__findByPK10 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK10), type);
	soap_out_PointerTons4__PPTVO(soap, "ns1:in0", -1, &(((_ns1__findByPK10*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK10::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK10(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK10 * SOAP_FMAC4 soap_get__ns1__findByPK10(struct soap *soap, _ns1__findByPK10 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK10::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK10(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK10 * SOAP_FMAC4 soap_in__ns1__findByPK10(struct soap *soap, const char *tag, _ns1__findByPK10 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK10 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK10, sizeof(_ns1__findByPK10), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK10)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK10 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTVO(soap, "ns1:in0", &(((_ns1__findByPK10*)a)->in0), "ns4:PPTVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK10 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK10, 0, sizeof(_ns1__findByPK10), 0, soap_copy__ns1__findByPK10);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK10 * SOAP_FMAC6 soap_new__ns1__findByPK10(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK10(struct soap *soap, _ns1__findByPK10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK10 * SOAP_FMAC4 soap_instantiate__ns1__findByPK10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK10;
		if (size)
			*size = sizeof(_ns1__findByPK10);
		((_ns1__findByPK10*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK10[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK10);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK10*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK10 %p -> %p\n", q, p));
	*(_ns1__findByPK10*)p = *(_ns1__findByPK10*)q;
}

void _ns1__findBySQLQueryReturnImageVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfImageVO(soap, &((_ns1__findBySQLQueryReturnImageVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnImageVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnImageVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnImageVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnImageVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnImageVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnImageVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfImageVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnImageVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnImageVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnImageVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnImageVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnImageVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnImageVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnImageVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnImageVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnImageVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse, sizeof(_ns1__findBySQLQueryReturnImageVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnImageVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfImageVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnImageVOResponse*)a)->out), "ns4:ArrayOfImageVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnImageVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnImageVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnImageVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnImageVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnImageVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnImageVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnImageVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnImageVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnImageVOResponse);
		((_ns1__findBySQLQueryReturnImageVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnImageVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnImageVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnImageVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnImageVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnImageVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnImageVOResponse*)p = *(_ns1__findBySQLQueryReturnImageVOResponse*)q;
}

void _ns1__findBySQLQueryReturnImageVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnImageVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnImageVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnImageVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnImageVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnImageVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnImageVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnImageVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnImageVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnImageVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnImageVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnImageVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnImageVO(struct soap *soap, _ns1__findBySQLQueryReturnImageVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnImageVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnImageVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnImageVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnImageVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnImageVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnImageVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO, sizeof(_ns1__findBySQLQueryReturnImageVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnImageVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnImageVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnImageVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnImageVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO, 0, sizeof(_ns1__findBySQLQueryReturnImageVO), 0, soap_copy__ns1__findBySQLQueryReturnImageVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnImageVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnImageVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnImageVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnImageVO(struct soap *soap, _ns1__findBySQLQueryReturnImageVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnImageVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnImageVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnImageVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnImageVO);
		((_ns1__findBySQLQueryReturnImageVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnImageVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnImageVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnImageVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnImageVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnImageVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnImageVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnImageVO*)p = *(_ns1__findBySQLQueryReturnImageVO*)q;
}

void _ns1__update2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update2Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update2Response(struct soap *soap, const char *tag, int id, const _ns1__update2Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update2Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update2Response * SOAP_FMAC4 soap_get__ns1__update2Response(struct soap *soap, _ns1__update2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update2Response * SOAP_FMAC4 soap_in__ns1__update2Response(struct soap *soap, const char *tag, _ns1__update2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update2Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update2Response, sizeof(_ns1__update2Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update2Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update2Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update2Response, 0, sizeof(_ns1__update2Response), 0, soap_copy__ns1__update2Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update2Response * SOAP_FMAC6 soap_new__ns1__update2Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update2Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update2Response(struct soap *soap, _ns1__update2Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update2Response * SOAP_FMAC4 soap_instantiate__ns1__update2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update2Response;
		if (size)
			*size = sizeof(_ns1__update2Response);
		((_ns1__update2Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update2Response[n];
		if (size)
			*size = n * sizeof(_ns1__update2Response);
		for (int i = 0; i < n; i++)
			((_ns1__update2Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update2Response %p -> %p\n", q, p));
	*(_ns1__update2Response*)p = *(_ns1__update2Response*)q;
}

void _ns1__update2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__DictionaryVO(soap, &((_ns1__update2*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update2::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update2*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update2(struct soap *soap, const char *tag, int id, const _ns1__update2 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update2), type);
	soap_out_PointerTons4__DictionaryVO(soap, "ns1:in0", -1, &(((_ns1__update2*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update2 * SOAP_FMAC4 soap_get__ns1__update2(struct soap *soap, _ns1__update2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update2 * SOAP_FMAC4 soap_in__ns1__update2(struct soap *soap, const char *tag, _ns1__update2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update2, sizeof(_ns1__update2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update2 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DictionaryVO(soap, "ns1:in0", &(((_ns1__update2*)a)->in0), "ns4:DictionaryVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update2, 0, sizeof(_ns1__update2), 0, soap_copy__ns1__update2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update2 * SOAP_FMAC6 soap_new__ns1__update2(struct soap *soap, int n)
{	return soap_instantiate__ns1__update2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update2(struct soap *soap, _ns1__update2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update2 * SOAP_FMAC4 soap_instantiate__ns1__update2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update2;
		if (size)
			*size = sizeof(_ns1__update2);
		((_ns1__update2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update2[n];
		if (size)
			*size = n * sizeof(_ns1__update2);
		for (int i = 0; i < n; i++)
			((_ns1__update2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update2 %p -> %p\n", q, p));
	*(_ns1__update2*)p = *(_ns1__update2*)q;
}

void _ns1__findByPK3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EActivityVO(soap, &((_ns1__findByPK3Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK3Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK3Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK3Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK3Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK3Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__EActivityVO(soap, "ns1:out", -1, &(((_ns1__findByPK3Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK3Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK3Response * SOAP_FMAC4 soap_get__ns1__findByPK3Response(struct soap *soap, _ns1__findByPK3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK3Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK3Response * SOAP_FMAC4 soap_in__ns1__findByPK3Response(struct soap *soap, const char *tag, _ns1__findByPK3Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK3Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK3Response, sizeof(_ns1__findByPK3Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK3Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK3Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EActivityVO(soap, "ns1:out", &(((_ns1__findByPK3Response*)a)->out), "ns4:EActivityVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK3Response, 0, sizeof(_ns1__findByPK3Response), 0, soap_copy__ns1__findByPK3Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK3Response * SOAP_FMAC6 soap_new__ns1__findByPK3Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK3Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK3Response(struct soap *soap, _ns1__findByPK3Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK3Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK3Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK3Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK3Response;
		if (size)
			*size = sizeof(_ns1__findByPK3Response);
		((_ns1__findByPK3Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK3Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK3Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK3Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK3Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK3Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK3Response %p -> %p\n", q, p));
	*(_ns1__findByPK3Response*)p = *(_ns1__findByPK3Response*)q;
}

void _ns1__findByPK3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EActivityVO(soap, &((_ns1__findByPK3*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK3::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK3*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK3);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK3(struct soap *soap, const char *tag, int id, const _ns1__findByPK3 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK3), type);
	soap_out_PointerTons4__EActivityVO(soap, "ns1:in0", -1, &(((_ns1__findByPK3*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK3(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK3 * SOAP_FMAC4 soap_get__ns1__findByPK3(struct soap *soap, _ns1__findByPK3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK3(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK3 * SOAP_FMAC4 soap_in__ns1__findByPK3(struct soap *soap, const char *tag, _ns1__findByPK3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK3 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK3, sizeof(_ns1__findByPK3), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK3)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK3 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EActivityVO(soap, "ns1:in0", &(((_ns1__findByPK3*)a)->in0), "ns4:EActivityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK3, 0, sizeof(_ns1__findByPK3), 0, soap_copy__ns1__findByPK3);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK3 * SOAP_FMAC6 soap_new__ns1__findByPK3(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK3(struct soap *soap, _ns1__findByPK3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK3 * SOAP_FMAC4 soap_instantiate__ns1__findByPK3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK3;
		if (size)
			*size = sizeof(_ns1__findByPK3);
		((_ns1__findByPK3*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK3[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK3);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK3*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK3 %p -> %p\n", q, p));
	*(_ns1__findByPK3*)p = *(_ns1__findByPK3*)q;
}

void _ns1__update5Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update5Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update5Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update5Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update5Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update5Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update5Response(struct soap *soap, const char *tag, int id, const _ns1__update5Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update5Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update5Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update5Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update5Response * SOAP_FMAC4 soap_get__ns1__update5Response(struct soap *soap, _ns1__update5Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update5Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update5Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update5Response * SOAP_FMAC4 soap_in__ns1__update5Response(struct soap *soap, const char *tag, _ns1__update5Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update5Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update5Response, sizeof(_ns1__update5Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update5Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update5Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update5Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update5Response, 0, sizeof(_ns1__update5Response), 0, soap_copy__ns1__update5Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update5Response * SOAP_FMAC6 soap_new__ns1__update5Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update5Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update5Response(struct soap *soap, _ns1__update5Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update5Response * SOAP_FMAC4 soap_instantiate__ns1__update5Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update5Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update5Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update5Response;
		if (size)
			*size = sizeof(_ns1__update5Response);
		((_ns1__update5Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update5Response[n];
		if (size)
			*size = n * sizeof(_ns1__update5Response);
		for (int i = 0; i < n; i++)
			((_ns1__update5Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update5Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update5Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update5Response %p -> %p\n", q, p));
	*(_ns1__update5Response*)p = *(_ns1__update5Response*)q;
}

void _ns1__update5::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ESignatureVO(soap, &((_ns1__update5*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update5::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update5*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update5::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update5);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update5::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update5(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update5(struct soap *soap, const char *tag, int id, const _ns1__update5 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update5), type);
	soap_out_PointerTons4__ESignatureVO(soap, "ns1:in0", -1, &(((_ns1__update5*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update5::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update5(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update5 * SOAP_FMAC4 soap_get__ns1__update5(struct soap *soap, _ns1__update5 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update5::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update5(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update5 * SOAP_FMAC4 soap_in__ns1__update5(struct soap *soap, const char *tag, _ns1__update5 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update5 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update5, sizeof(_ns1__update5), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update5)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update5 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ESignatureVO(soap, "ns1:in0", &(((_ns1__update5*)a)->in0), "ns4:ESignatureVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update5 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update5, 0, sizeof(_ns1__update5), 0, soap_copy__ns1__update5);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update5 * SOAP_FMAC6 soap_new__ns1__update5(struct soap *soap, int n)
{	return soap_instantiate__ns1__update5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update5(struct soap *soap, _ns1__update5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update5 * SOAP_FMAC4 soap_instantiate__ns1__update5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update5;
		if (size)
			*size = sizeof(_ns1__update5);
		((_ns1__update5*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update5[n];
		if (size)
			*size = n * sizeof(_ns1__update5);
		for (int i = 0; i < n; i++)
			((_ns1__update5*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update5 %p -> %p\n", q, p));
	*(_ns1__update5*)p = *(_ns1__update5*)q;
}

void _ns1__remove2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove2Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove2Response(struct soap *soap, const char *tag, int id, const _ns1__remove2Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove2Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove2Response * SOAP_FMAC4 soap_get__ns1__remove2Response(struct soap *soap, _ns1__remove2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove2Response * SOAP_FMAC4 soap_in__ns1__remove2Response(struct soap *soap, const char *tag, _ns1__remove2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove2Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove2Response, sizeof(_ns1__remove2Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove2Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove2Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove2Response, 0, sizeof(_ns1__remove2Response), 0, soap_copy__ns1__remove2Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove2Response * SOAP_FMAC6 soap_new__ns1__remove2Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove2Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove2Response(struct soap *soap, _ns1__remove2Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove2Response * SOAP_FMAC4 soap_instantiate__ns1__remove2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove2Response;
		if (size)
			*size = sizeof(_ns1__remove2Response);
		((_ns1__remove2Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove2Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove2Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove2Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove2Response %p -> %p\n", q, p));
	*(_ns1__remove2Response*)p = *(_ns1__remove2Response*)q;
}

void _ns1__remove2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__DictionaryVO(soap, &((_ns1__remove2*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove2::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove2*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove2(struct soap *soap, const char *tag, int id, const _ns1__remove2 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove2), type);
	soap_out_PointerTons4__DictionaryVO(soap, "ns1:in0", -1, &(((_ns1__remove2*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove2 * SOAP_FMAC4 soap_get__ns1__remove2(struct soap *soap, _ns1__remove2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove2 * SOAP_FMAC4 soap_in__ns1__remove2(struct soap *soap, const char *tag, _ns1__remove2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove2, sizeof(_ns1__remove2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove2 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DictionaryVO(soap, "ns1:in0", &(((_ns1__remove2*)a)->in0), "ns4:DictionaryVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove2, 0, sizeof(_ns1__remove2), 0, soap_copy__ns1__remove2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove2 * SOAP_FMAC6 soap_new__ns1__remove2(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove2(struct soap *soap, _ns1__remove2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove2 * SOAP_FMAC4 soap_instantiate__ns1__remove2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove2;
		if (size)
			*size = sizeof(_ns1__remove2);
		((_ns1__remove2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove2[n];
		if (size)
			*size = n * sizeof(_ns1__remove2);
		for (int i = 0; i < n; i++)
			((_ns1__remove2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove2 %p -> %p\n", q, p));
	*(_ns1__remove2*)p = *(_ns1__remove2*)q;
}

void _ns1__create5Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ESignatureVO(soap, &((_ns1__create5Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create5Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create5Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create5Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create5Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create5Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create5Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create5Response(struct soap *soap, const char *tag, int id, const _ns1__create5Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create5Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ESignatureVO(soap, "ns1:out", -1, &(((_ns1__create5Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create5Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create5Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create5Response * SOAP_FMAC4 soap_get__ns1__create5Response(struct soap *soap, _ns1__create5Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create5Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create5Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create5Response * SOAP_FMAC4 soap_in__ns1__create5Response(struct soap *soap, const char *tag, _ns1__create5Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create5Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create5Response, sizeof(_ns1__create5Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create5Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create5Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ESignatureVO(soap, "ns1:out", &(((_ns1__create5Response*)a)->out), "ns4:ESignatureVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create5Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create5Response, 0, sizeof(_ns1__create5Response), 0, soap_copy__ns1__create5Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create5Response * SOAP_FMAC6 soap_new__ns1__create5Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create5Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create5Response(struct soap *soap, _ns1__create5Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create5Response * SOAP_FMAC4 soap_instantiate__ns1__create5Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create5Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create5Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create5Response;
		if (size)
			*size = sizeof(_ns1__create5Response);
		((_ns1__create5Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create5Response[n];
		if (size)
			*size = n * sizeof(_ns1__create5Response);
		for (int i = 0; i < n; i++)
			((_ns1__create5Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create5Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create5Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create5Response %p -> %p\n", q, p));
	*(_ns1__create5Response*)p = *(_ns1__create5Response*)q;
}

void _ns1__create5::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ESignatureVO(soap, &((_ns1__create5*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create5::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create5*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create5::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create5);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create5::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create5(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create5(struct soap *soap, const char *tag, int id, const _ns1__create5 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create5), type);
	soap_out_PointerTons4__ESignatureVO(soap, "ns1:in0", -1, &(((_ns1__create5*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create5::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create5(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create5 * SOAP_FMAC4 soap_get__ns1__create5(struct soap *soap, _ns1__create5 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create5::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create5(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create5 * SOAP_FMAC4 soap_in__ns1__create5(struct soap *soap, const char *tag, _ns1__create5 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create5 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create5, sizeof(_ns1__create5), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create5)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create5 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ESignatureVO(soap, "ns1:in0", &(((_ns1__create5*)a)->in0), "ns4:ESignatureVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create5 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create5, 0, sizeof(_ns1__create5), 0, soap_copy__ns1__create5);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create5 * SOAP_FMAC6 soap_new__ns1__create5(struct soap *soap, int n)
{	return soap_instantiate__ns1__create5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create5(struct soap *soap, _ns1__create5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create5 * SOAP_FMAC4 soap_instantiate__ns1__create5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create5;
		if (size)
			*size = sizeof(_ns1__create5);
		((_ns1__create5*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create5[n];
		if (size)
			*size = n * sizeof(_ns1__create5);
		for (int i = 0; i < n; i++)
			((_ns1__create5*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create5 %p -> %p\n", q, p));
	*(_ns1__create5*)p = *(_ns1__create5*)q;
}

void _ns1__remove11Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove11Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove11Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove11Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove11Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove11Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove11Response(struct soap *soap, const char *tag, int id, const _ns1__remove11Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove11Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove11Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove11Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove11Response * SOAP_FMAC4 soap_get__ns1__remove11Response(struct soap *soap, _ns1__remove11Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove11Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove11Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove11Response * SOAP_FMAC4 soap_in__ns1__remove11Response(struct soap *soap, const char *tag, _ns1__remove11Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove11Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove11Response, sizeof(_ns1__remove11Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove11Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove11Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove11Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove11Response, 0, sizeof(_ns1__remove11Response), 0, soap_copy__ns1__remove11Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove11Response * SOAP_FMAC6 soap_new__ns1__remove11Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove11Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove11Response(struct soap *soap, _ns1__remove11Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove11Response * SOAP_FMAC4 soap_instantiate__ns1__remove11Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove11Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove11Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove11Response;
		if (size)
			*size = sizeof(_ns1__remove11Response);
		((_ns1__remove11Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove11Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove11Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove11Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove11Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove11Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove11Response %p -> %p\n", q, p));
	*(_ns1__remove11Response*)p = *(_ns1__remove11Response*)q;
}

void _ns1__remove11::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserVO(soap, &((_ns1__remove11*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove11::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove11*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove11::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove11);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove11::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove11(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove11(struct soap *soap, const char *tag, int id, const _ns1__remove11 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove11), type);
	soap_out_PointerTons4__UserVO(soap, "ns1:in0", -1, &(((_ns1__remove11*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove11::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove11(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove11 * SOAP_FMAC4 soap_get__ns1__remove11(struct soap *soap, _ns1__remove11 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove11::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove11(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove11 * SOAP_FMAC4 soap_in__ns1__remove11(struct soap *soap, const char *tag, _ns1__remove11 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove11 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove11, sizeof(_ns1__remove11), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove11)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove11 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns1:in0", &(((_ns1__remove11*)a)->in0), "ns4:UserVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove11 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove11, 0, sizeof(_ns1__remove11), 0, soap_copy__ns1__remove11);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove11 * SOAP_FMAC6 soap_new__ns1__remove11(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove11(struct soap *soap, _ns1__remove11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove11 * SOAP_FMAC4 soap_instantiate__ns1__remove11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove11;
		if (size)
			*size = sizeof(_ns1__remove11);
		((_ns1__remove11*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove11[n];
		if (size)
			*size = n * sizeof(_ns1__remove11);
		for (int i = 0; i < n; i++)
			((_ns1__remove11*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove11 %p -> %p\n", q, p));
	*(_ns1__remove11*)p = *(_ns1__remove11*)q;
}

void _ns1__findBySQLQueryReturnUserVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfUserVO(soap, &((_ns1__findBySQLQueryReturnUserVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnUserVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnUserVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnUserVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnUserVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnUserVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnUserVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfUserVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnUserVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnUserVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnUserVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnUserVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnUserVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnUserVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnUserVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnUserVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnUserVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse, sizeof(_ns1__findBySQLQueryReturnUserVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnUserVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfUserVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnUserVOResponse*)a)->out), "ns4:ArrayOfUserVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnUserVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnUserVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnUserVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnUserVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnUserVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnUserVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnUserVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnUserVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnUserVOResponse);
		((_ns1__findBySQLQueryReturnUserVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnUserVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnUserVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnUserVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnUserVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnUserVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnUserVOResponse*)p = *(_ns1__findBySQLQueryReturnUserVOResponse*)q;
}

void _ns1__findBySQLQueryReturnUserVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnUserVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnUserVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnUserVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnUserVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnUserVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnUserVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnUserVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnUserVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnUserVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnUserVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnUserVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnUserVO(struct soap *soap, _ns1__findBySQLQueryReturnUserVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnUserVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnUserVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnUserVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnUserVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnUserVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnUserVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO, sizeof(_ns1__findBySQLQueryReturnUserVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnUserVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnUserVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnUserVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnUserVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO, 0, sizeof(_ns1__findBySQLQueryReturnUserVO), 0, soap_copy__ns1__findBySQLQueryReturnUserVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnUserVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnUserVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnUserVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnUserVO(struct soap *soap, _ns1__findBySQLQueryReturnUserVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnUserVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnUserVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnUserVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnUserVO);
		((_ns1__findBySQLQueryReturnUserVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnUserVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnUserVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnUserVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnUserVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnUserVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnUserVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnUserVO*)p = *(_ns1__findBySQLQueryReturnUserVO*)q;
}

void _ns1__findBySQLQueryReturnEntityVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfEntityVO(soap, &((_ns1__findBySQLQueryReturnEntityVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnEntityVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnEntityVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnEntityVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnEntityVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnEntityVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnEntityVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfEntityVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnEntityVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnEntityVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnEntityVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEntityVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnEntityVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnEntityVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnEntityVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEntityVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnEntityVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse, sizeof(_ns1__findBySQLQueryReturnEntityVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnEntityVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfEntityVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnEntityVOResponse*)a)->out), "ns4:ArrayOfEntityVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEntityVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnEntityVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnEntityVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnEntityVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnEntityVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEntityVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnEntityVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEntityVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnEntityVOResponse);
		((_ns1__findBySQLQueryReturnEntityVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEntityVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnEntityVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnEntityVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnEntityVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnEntityVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnEntityVOResponse*)p = *(_ns1__findBySQLQueryReturnEntityVOResponse*)q;
}

void _ns1__findBySQLQueryReturnEntityVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnEntityVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnEntityVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnEntityVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnEntityVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnEntityVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnEntityVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnEntityVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnEntityVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnEntityVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnEntityVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnEntityVO(struct soap *soap, _ns1__findBySQLQueryReturnEntityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnEntityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnEntityVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnEntityVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEntityVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnEntityVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO, sizeof(_ns1__findBySQLQueryReturnEntityVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnEntityVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnEntityVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEntityVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO, 0, sizeof(_ns1__findBySQLQueryReturnEntityVO), 0, soap_copy__ns1__findBySQLQueryReturnEntityVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnEntityVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnEntityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnEntityVO(struct soap *soap, _ns1__findBySQLQueryReturnEntityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnEntityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnEntityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEntityVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnEntityVO);
		((_ns1__findBySQLQueryReturnEntityVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEntityVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnEntityVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnEntityVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnEntityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnEntityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnEntityVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnEntityVO*)p = *(_ns1__findBySQLQueryReturnEntityVO*)q;
}

void _ns1__createResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CommentVO(soap, &((_ns1__createResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__createResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__createResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__createResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__createResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__createResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createResponse(struct soap *soap, const char *tag, int id, const _ns1__createResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__CommentVO(soap, "ns1:out", -1, &(((_ns1__createResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__createResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createResponse * SOAP_FMAC4 soap_get__ns1__createResponse(struct soap *soap, _ns1__createResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__createResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createResponse * SOAP_FMAC4 soap_in__ns1__createResponse(struct soap *soap, const char *tag, _ns1__createResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__createResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createResponse, sizeof(_ns1__createResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__createResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__createResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CommentVO(soap, "ns1:out", &(((_ns1__createResponse*)a)->out), "ns4:CommentVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__createResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createResponse, 0, sizeof(_ns1__createResponse), 0, soap_copy__ns1__createResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__createResponse * SOAP_FMAC6 soap_new__ns1__createResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__createResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__createResponse(struct soap *soap, _ns1__createResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__createResponse * SOAP_FMAC4 soap_instantiate__ns1__createResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__createResponse;
		if (size)
			*size = sizeof(_ns1__createResponse);
		((_ns1__createResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__createResponse[n];
		if (size)
			*size = n * sizeof(_ns1__createResponse);
		for (int i = 0; i < n; i++)
			((_ns1__createResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__createResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__createResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__createResponse %p -> %p\n", q, p));
	*(_ns1__createResponse*)p = *(_ns1__createResponse*)q;
}

void _ns1__create::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CommentVO(soap, &((_ns1__create*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create(struct soap *soap, const char *tag, int id, const _ns1__create *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create), type);
	soap_out_PointerTons4__CommentVO(soap, "ns1:in0", -1, &(((_ns1__create*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create * SOAP_FMAC4 soap_get__ns1__create(struct soap *soap, _ns1__create *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create * SOAP_FMAC4 soap_in__ns1__create(struct soap *soap, const char *tag, _ns1__create *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create, sizeof(_ns1__create), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CommentVO(soap, "ns1:in0", &(((_ns1__create*)a)->in0), "ns4:CommentVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create, 0, sizeof(_ns1__create), 0, soap_copy__ns1__create);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create * SOAP_FMAC6 soap_new__ns1__create(struct soap *soap, int n)
{	return soap_instantiate__ns1__create(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create(struct soap *soap, _ns1__create *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create * SOAP_FMAC4 soap_instantiate__ns1__create(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create;
		if (size)
			*size = sizeof(_ns1__create);
		((_ns1__create*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create[n];
		if (size)
			*size = n * sizeof(_ns1__create);
		for (int i = 0; i < n; i++)
			((_ns1__create*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create %p -> %p\n", q, p));
	*(_ns1__create*)p = *(_ns1__create*)q;
}

void _ns1__remove1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove1Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove1Response(struct soap *soap, const char *tag, int id, const _ns1__remove1Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove1Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove1Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove1Response * SOAP_FMAC4 soap_get__ns1__remove1Response(struct soap *soap, _ns1__remove1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove1Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove1Response * SOAP_FMAC4 soap_in__ns1__remove1Response(struct soap *soap, const char *tag, _ns1__remove1Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove1Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove1Response, sizeof(_ns1__remove1Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove1Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove1Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove1Response, 0, sizeof(_ns1__remove1Response), 0, soap_copy__ns1__remove1Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove1Response * SOAP_FMAC6 soap_new__ns1__remove1Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove1Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove1Response(struct soap *soap, _ns1__remove1Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove1Response * SOAP_FMAC4 soap_instantiate__ns1__remove1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove1Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove1Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove1Response;
		if (size)
			*size = sizeof(_ns1__remove1Response);
		((_ns1__remove1Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove1Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove1Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove1Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove1Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove1Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove1Response %p -> %p\n", q, p));
	*(_ns1__remove1Response*)p = *(_ns1__remove1Response*)q;
}

void _ns1__remove1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ContainerVO(soap, &((_ns1__remove1*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove1::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove1*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove1);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove1(struct soap *soap, const char *tag, int id, const _ns1__remove1 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove1), type);
	soap_out_PointerTons4__ContainerVO(soap, "ns1:in0", -1, &(((_ns1__remove1*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove1(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove1 * SOAP_FMAC4 soap_get__ns1__remove1(struct soap *soap, _ns1__remove1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove1(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove1 * SOAP_FMAC4 soap_in__ns1__remove1(struct soap *soap, const char *tag, _ns1__remove1 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove1, sizeof(_ns1__remove1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove1 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ContainerVO(soap, "ns1:in0", &(((_ns1__remove1*)a)->in0), "ns4:ContainerVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove1, 0, sizeof(_ns1__remove1), 0, soap_copy__ns1__remove1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove1 * SOAP_FMAC6 soap_new__ns1__remove1(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove1(struct soap *soap, _ns1__remove1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove1 * SOAP_FMAC4 soap_instantiate__ns1__remove1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove1;
		if (size)
			*size = sizeof(_ns1__remove1);
		((_ns1__remove1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove1[n];
		if (size)
			*size = n * sizeof(_ns1__remove1);
		for (int i = 0; i < n; i++)
			((_ns1__remove1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove1 %p -> %p\n", q, p));
	*(_ns1__remove1*)p = *(_ns1__remove1*)q;
}

void _ns1__findByPK7Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__FeedbackVO(soap, &((_ns1__findByPK7Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK7Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK7Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK7Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK7Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK7Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK7Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK7Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK7Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK7Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__FeedbackVO(soap, "ns1:out", -1, &(((_ns1__findByPK7Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK7Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK7Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK7Response * SOAP_FMAC4 soap_get__ns1__findByPK7Response(struct soap *soap, _ns1__findByPK7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK7Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK7Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK7Response * SOAP_FMAC4 soap_in__ns1__findByPK7Response(struct soap *soap, const char *tag, _ns1__findByPK7Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK7Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK7Response, sizeof(_ns1__findByPK7Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK7Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK7Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FeedbackVO(soap, "ns1:out", &(((_ns1__findByPK7Response*)a)->out), "ns4:FeedbackVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK7Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK7Response, 0, sizeof(_ns1__findByPK7Response), 0, soap_copy__ns1__findByPK7Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK7Response * SOAP_FMAC6 soap_new__ns1__findByPK7Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK7Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK7Response(struct soap *soap, _ns1__findByPK7Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK7Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK7Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK7Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK7Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK7Response;
		if (size)
			*size = sizeof(_ns1__findByPK7Response);
		((_ns1__findByPK7Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK7Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK7Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK7Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK7Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK7Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK7Response %p -> %p\n", q, p));
	*(_ns1__findByPK7Response*)p = *(_ns1__findByPK7Response*)q;
}

void _ns1__findByPK7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__FeedbackVO(soap, &((_ns1__findByPK7*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK7::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK7*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK7);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK7(struct soap *soap, const char *tag, int id, const _ns1__findByPK7 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK7), type);
	soap_out_PointerTons4__FeedbackVO(soap, "ns1:in0", -1, &(((_ns1__findByPK7*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK7(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK7 * SOAP_FMAC4 soap_get__ns1__findByPK7(struct soap *soap, _ns1__findByPK7 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK7::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK7(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK7 * SOAP_FMAC4 soap_in__ns1__findByPK7(struct soap *soap, const char *tag, _ns1__findByPK7 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK7 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK7, sizeof(_ns1__findByPK7), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK7)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK7 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FeedbackVO(soap, "ns1:in0", &(((_ns1__findByPK7*)a)->in0), "ns4:FeedbackVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK7, 0, sizeof(_ns1__findByPK7), 0, soap_copy__ns1__findByPK7);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK7 * SOAP_FMAC6 soap_new__ns1__findByPK7(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK7(struct soap *soap, _ns1__findByPK7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK7 * SOAP_FMAC4 soap_instantiate__ns1__findByPK7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK7;
		if (size)
			*size = sizeof(_ns1__findByPK7);
		((_ns1__findByPK7*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK7[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK7);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK7*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK7 %p -> %p\n", q, p));
	*(_ns1__findByPK7*)p = *(_ns1__findByPK7*)q;
}

void _ns1__echoStringResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns1__echoStringResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__echoStringResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__echoStringResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__echoStringResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__echoStringResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__echoStringResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__echoStringResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__echoStringResponse(struct soap *soap, const char *tag, int id, const _ns1__echoStringResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__echoStringResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTostd__string(soap, "ns1:out", -1, &(((_ns1__echoStringResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__echoStringResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__echoStringResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__echoStringResponse * SOAP_FMAC4 soap_get__ns1__echoStringResponse(struct soap *soap, _ns1__echoStringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__echoStringResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__echoStringResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__echoStringResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__echoStringResponse * SOAP_FMAC4 soap_in__ns1__echoStringResponse(struct soap *soap, const char *tag, _ns1__echoStringResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__echoStringResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__echoStringResponse, sizeof(_ns1__echoStringResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__echoStringResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__echoStringResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &(((_ns1__echoStringResponse*)a)->out), "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__echoStringResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__echoStringResponse, 0, sizeof(_ns1__echoStringResponse), 0, soap_copy__ns1__echoStringResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__echoStringResponse * SOAP_FMAC6 soap_new__ns1__echoStringResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__echoStringResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__echoStringResponse(struct soap *soap, _ns1__echoStringResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__echoStringResponse * SOAP_FMAC4 soap_instantiate__ns1__echoStringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__echoStringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__echoStringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__echoStringResponse;
		if (size)
			*size = sizeof(_ns1__echoStringResponse);
		((_ns1__echoStringResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__echoStringResponse[n];
		if (size)
			*size = n * sizeof(_ns1__echoStringResponse);
		for (int i = 0; i < n; i++)
			((_ns1__echoStringResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__echoStringResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__echoStringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__echoStringResponse %p -> %p\n", q, p));
	*(_ns1__echoStringResponse*)p = *(_ns1__echoStringResponse*)q;
}

void _ns1__echoString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns1__echoString*)this)->in0);
	/* transient soap skipped */
}

void _ns1__echoString::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__echoString*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__echoString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__echoString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__echoString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__echoString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__echoString(struct soap *soap, const char *tag, int id, const _ns1__echoString *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__echoString), type);
	soap_out_PointerTostd__string(soap, "ns1:in0", -1, &(((_ns1__echoString*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__echoString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__echoString(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__echoString * SOAP_FMAC4 soap_get__ns1__echoString(struct soap *soap, _ns1__echoString *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__echoString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__echoString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__echoString(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__echoString * SOAP_FMAC4 soap_in__ns1__echoString(struct soap *soap, const char *tag, _ns1__echoString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__echoString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__echoString, sizeof(_ns1__echoString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__echoString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__echoString *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &(((_ns1__echoString*)a)->in0), "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__echoString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__echoString, 0, sizeof(_ns1__echoString), 0, soap_copy__ns1__echoString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__echoString * SOAP_FMAC6 soap_new__ns1__echoString(struct soap *soap, int n)
{	return soap_instantiate__ns1__echoString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__echoString(struct soap *soap, _ns1__echoString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__echoString * SOAP_FMAC4 soap_instantiate__ns1__echoString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__echoString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__echoString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__echoString;
		if (size)
			*size = sizeof(_ns1__echoString);
		((_ns1__echoString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__echoString[n];
		if (size)
			*size = n * sizeof(_ns1__echoString);
		for (int i = 0; i < n; i++)
			((_ns1__echoString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__echoString*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__echoString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__echoString %p -> %p\n", q, p));
	*(_ns1__echoString*)p = *(_ns1__echoString*)q;
}

void _ns1__create2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__DictionaryVO(soap, &((_ns1__create2Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create2Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create2Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create2Response(struct soap *soap, const char *tag, int id, const _ns1__create2Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create2Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__DictionaryVO(soap, "ns1:out", -1, &(((_ns1__create2Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create2Response * SOAP_FMAC4 soap_get__ns1__create2Response(struct soap *soap, _ns1__create2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create2Response * SOAP_FMAC4 soap_in__ns1__create2Response(struct soap *soap, const char *tag, _ns1__create2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create2Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create2Response, sizeof(_ns1__create2Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create2Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create2Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DictionaryVO(soap, "ns1:out", &(((_ns1__create2Response*)a)->out), "ns4:DictionaryVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create2Response, 0, sizeof(_ns1__create2Response), 0, soap_copy__ns1__create2Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create2Response * SOAP_FMAC6 soap_new__ns1__create2Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create2Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create2Response(struct soap *soap, _ns1__create2Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create2Response * SOAP_FMAC4 soap_instantiate__ns1__create2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create2Response;
		if (size)
			*size = sizeof(_ns1__create2Response);
		((_ns1__create2Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create2Response[n];
		if (size)
			*size = n * sizeof(_ns1__create2Response);
		for (int i = 0; i < n; i++)
			((_ns1__create2Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create2Response %p -> %p\n", q, p));
	*(_ns1__create2Response*)p = *(_ns1__create2Response*)q;
}

void _ns1__create2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__DictionaryVO(soap, &((_ns1__create2*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create2::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create2*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create2(struct soap *soap, const char *tag, int id, const _ns1__create2 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create2), type);
	soap_out_PointerTons4__DictionaryVO(soap, "ns1:in0", -1, &(((_ns1__create2*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create2 * SOAP_FMAC4 soap_get__ns1__create2(struct soap *soap, _ns1__create2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create2 * SOAP_FMAC4 soap_in__ns1__create2(struct soap *soap, const char *tag, _ns1__create2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create2, sizeof(_ns1__create2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create2 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DictionaryVO(soap, "ns1:in0", &(((_ns1__create2*)a)->in0), "ns4:DictionaryVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create2, 0, sizeof(_ns1__create2), 0, soap_copy__ns1__create2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create2 * SOAP_FMAC6 soap_new__ns1__create2(struct soap *soap, int n)
{	return soap_instantiate__ns1__create2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create2(struct soap *soap, _ns1__create2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create2 * SOAP_FMAC4 soap_instantiate__ns1__create2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create2;
		if (size)
			*size = sizeof(_ns1__create2);
		((_ns1__create2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create2[n];
		if (size)
			*size = n * sizeof(_ns1__create2);
		for (int i = 0; i < n; i++)
			((_ns1__create2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create2 %p -> %p\n", q, p));
	*(_ns1__create2*)p = *(_ns1__create2*)q;
}

void _ns1__findByPK6Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EntityVO(soap, &((_ns1__findByPK6Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK6Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK6Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK6Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK6Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK6Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK6Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK6Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK6Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK6Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__EntityVO(soap, "ns1:out", -1, &(((_ns1__findByPK6Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK6Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK6Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK6Response * SOAP_FMAC4 soap_get__ns1__findByPK6Response(struct soap *soap, _ns1__findByPK6Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK6Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK6Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK6Response * SOAP_FMAC4 soap_in__ns1__findByPK6Response(struct soap *soap, const char *tag, _ns1__findByPK6Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK6Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK6Response, sizeof(_ns1__findByPK6Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK6Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK6Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns1:out", &(((_ns1__findByPK6Response*)a)->out), "ns4:EntityVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK6Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK6Response, 0, sizeof(_ns1__findByPK6Response), 0, soap_copy__ns1__findByPK6Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK6Response * SOAP_FMAC6 soap_new__ns1__findByPK6Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK6Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK6Response(struct soap *soap, _ns1__findByPK6Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK6Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK6Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK6Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK6Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK6Response;
		if (size)
			*size = sizeof(_ns1__findByPK6Response);
		((_ns1__findByPK6Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK6Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK6Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK6Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK6Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK6Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK6Response %p -> %p\n", q, p));
	*(_ns1__findByPK6Response*)p = *(_ns1__findByPK6Response*)q;
}

void _ns1__findByPK6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EntityVO(soap, &((_ns1__findByPK6*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK6::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK6*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK6);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK6(struct soap *soap, const char *tag, int id, const _ns1__findByPK6 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK6), type);
	soap_out_PointerTons4__EntityVO(soap, "ns1:in0", -1, &(((_ns1__findByPK6*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK6(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK6 * SOAP_FMAC4 soap_get__ns1__findByPK6(struct soap *soap, _ns1__findByPK6 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK6::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK6(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK6 * SOAP_FMAC4 soap_in__ns1__findByPK6(struct soap *soap, const char *tag, _ns1__findByPK6 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK6 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK6, sizeof(_ns1__findByPK6), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK6)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK6 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns1:in0", &(((_ns1__findByPK6*)a)->in0), "ns4:EntityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK6, 0, sizeof(_ns1__findByPK6), 0, soap_copy__ns1__findByPK6);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK6 * SOAP_FMAC6 soap_new__ns1__findByPK6(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK6(struct soap *soap, _ns1__findByPK6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK6 * SOAP_FMAC4 soap_instantiate__ns1__findByPK6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK6;
		if (size)
			*size = sizeof(_ns1__findByPK6);
		((_ns1__findByPK6*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK6[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK6);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK6*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK6 %p -> %p\n", q, p));
	*(_ns1__findByPK6*)p = *(_ns1__findByPK6*)q;
}

void _ns1__updateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__updateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__updateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__updateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__updateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__updateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateResponse(struct soap *soap, const char *tag, int id, const _ns1__updateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateResponse), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__updateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__updateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__updateResponse * SOAP_FMAC4 soap_get__ns1__updateResponse(struct soap *soap, _ns1__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__updateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__updateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__updateResponse * SOAP_FMAC4 soap_in__ns1__updateResponse(struct soap *soap, const char *tag, _ns1__updateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__updateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateResponse, sizeof(_ns1__updateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__updateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__updateResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateResponse, 0, sizeof(_ns1__updateResponse), 0, soap_copy__ns1__updateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__updateResponse * SOAP_FMAC6 soap_new__ns1__updateResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__updateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__updateResponse(struct soap *soap, _ns1__updateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__updateResponse * SOAP_FMAC4 soap_instantiate__ns1__updateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__updateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__updateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__updateResponse;
		if (size)
			*size = sizeof(_ns1__updateResponse);
		((_ns1__updateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__updateResponse[n];
		if (size)
			*size = n * sizeof(_ns1__updateResponse);
		for (int i = 0; i < n; i++)
			((_ns1__updateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__updateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__updateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__updateResponse %p -> %p\n", q, p));
	*(_ns1__updateResponse*)p = *(_ns1__updateResponse*)q;
}

void _ns1__update::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CommentVO(soap, &((_ns1__update*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update(struct soap *soap, const char *tag, int id, const _ns1__update *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update), type);
	soap_out_PointerTons4__CommentVO(soap, "ns1:in0", -1, &(((_ns1__update*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update * SOAP_FMAC4 soap_get__ns1__update(struct soap *soap, _ns1__update *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update * SOAP_FMAC4 soap_in__ns1__update(struct soap *soap, const char *tag, _ns1__update *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update, sizeof(_ns1__update), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CommentVO(soap, "ns1:in0", &(((_ns1__update*)a)->in0), "ns4:CommentVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update, 0, sizeof(_ns1__update), 0, soap_copy__ns1__update);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update * SOAP_FMAC6 soap_new__ns1__update(struct soap *soap, int n)
{	return soap_instantiate__ns1__update(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update(struct soap *soap, _ns1__update *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update * SOAP_FMAC4 soap_instantiate__ns1__update(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update;
		if (size)
			*size = sizeof(_ns1__update);
		((_ns1__update*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update[n];
		if (size)
			*size = n * sizeof(_ns1__update);
		for (int i = 0; i < n; i++)
			((_ns1__update*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update %p -> %p\n", q, p));
	*(_ns1__update*)p = *(_ns1__update*)q;
}

void _ns1__remove10Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove10Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove10Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove10Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove10Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove10Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove10Response(struct soap *soap, const char *tag, int id, const _ns1__remove10Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove10Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove10Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove10Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove10Response * SOAP_FMAC4 soap_get__ns1__remove10Response(struct soap *soap, _ns1__remove10Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove10Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove10Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove10Response * SOAP_FMAC4 soap_in__ns1__remove10Response(struct soap *soap, const char *tag, _ns1__remove10Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove10Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove10Response, sizeof(_ns1__remove10Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove10Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove10Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove10Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove10Response, 0, sizeof(_ns1__remove10Response), 0, soap_copy__ns1__remove10Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove10Response * SOAP_FMAC6 soap_new__ns1__remove10Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove10Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove10Response(struct soap *soap, _ns1__remove10Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove10Response * SOAP_FMAC4 soap_instantiate__ns1__remove10Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove10Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove10Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove10Response;
		if (size)
			*size = sizeof(_ns1__remove10Response);
		((_ns1__remove10Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove10Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove10Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove10Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove10Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove10Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove10Response %p -> %p\n", q, p));
	*(_ns1__remove10Response*)p = *(_ns1__remove10Response*)q;
}

void _ns1__remove10::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTVO(soap, &((_ns1__remove10*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove10::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove10*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove10::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove10);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove10::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove10(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove10(struct soap *soap, const char *tag, int id, const _ns1__remove10 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove10), type);
	soap_out_PointerTons4__PPTVO(soap, "ns1:in0", -1, &(((_ns1__remove10*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove10::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove10(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove10 * SOAP_FMAC4 soap_get__ns1__remove10(struct soap *soap, _ns1__remove10 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove10::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove10(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove10 * SOAP_FMAC4 soap_in__ns1__remove10(struct soap *soap, const char *tag, _ns1__remove10 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove10 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove10, sizeof(_ns1__remove10), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove10)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove10 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTVO(soap, "ns1:in0", &(((_ns1__remove10*)a)->in0), "ns4:PPTVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove10 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove10, 0, sizeof(_ns1__remove10), 0, soap_copy__ns1__remove10);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove10 * SOAP_FMAC6 soap_new__ns1__remove10(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove10(struct soap *soap, _ns1__remove10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove10 * SOAP_FMAC4 soap_instantiate__ns1__remove10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove10;
		if (size)
			*size = sizeof(_ns1__remove10);
		((_ns1__remove10*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove10[n];
		if (size)
			*size = n * sizeof(_ns1__remove10);
		for (int i = 0; i < n; i++)
			((_ns1__remove10*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove10 %p -> %p\n", q, p));
	*(_ns1__remove10*)p = *(_ns1__remove10*)q;
}

void _ns1__create3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EActivityVO(soap, &((_ns1__create3Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create3Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create3Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create3Response(struct soap *soap, const char *tag, int id, const _ns1__create3Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create3Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__EActivityVO(soap, "ns1:out", -1, &(((_ns1__create3Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create3Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create3Response * SOAP_FMAC4 soap_get__ns1__create3Response(struct soap *soap, _ns1__create3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create3Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create3Response * SOAP_FMAC4 soap_in__ns1__create3Response(struct soap *soap, const char *tag, _ns1__create3Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create3Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create3Response, sizeof(_ns1__create3Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create3Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create3Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EActivityVO(soap, "ns1:out", &(((_ns1__create3Response*)a)->out), "ns4:EActivityVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create3Response, 0, sizeof(_ns1__create3Response), 0, soap_copy__ns1__create3Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create3Response * SOAP_FMAC6 soap_new__ns1__create3Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create3Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create3Response(struct soap *soap, _ns1__create3Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create3Response * SOAP_FMAC4 soap_instantiate__ns1__create3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create3Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create3Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create3Response;
		if (size)
			*size = sizeof(_ns1__create3Response);
		((_ns1__create3Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create3Response[n];
		if (size)
			*size = n * sizeof(_ns1__create3Response);
		for (int i = 0; i < n; i++)
			((_ns1__create3Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create3Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create3Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create3Response %p -> %p\n", q, p));
	*(_ns1__create3Response*)p = *(_ns1__create3Response*)q;
}

void _ns1__create3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EActivityVO(soap, &((_ns1__create3*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create3::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create3*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create3);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create3(struct soap *soap, const char *tag, int id, const _ns1__create3 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create3), type);
	soap_out_PointerTons4__EActivityVO(soap, "ns1:in0", -1, &(((_ns1__create3*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create3(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create3 * SOAP_FMAC4 soap_get__ns1__create3(struct soap *soap, _ns1__create3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create3(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create3 * SOAP_FMAC4 soap_in__ns1__create3(struct soap *soap, const char *tag, _ns1__create3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create3 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create3, sizeof(_ns1__create3), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create3)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create3 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EActivityVO(soap, "ns1:in0", &(((_ns1__create3*)a)->in0), "ns4:EActivityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create3, 0, sizeof(_ns1__create3), 0, soap_copy__ns1__create3);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create3 * SOAP_FMAC6 soap_new__ns1__create3(struct soap *soap, int n)
{	return soap_instantiate__ns1__create3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create3(struct soap *soap, _ns1__create3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create3 * SOAP_FMAC4 soap_instantiate__ns1__create3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create3;
		if (size)
			*size = sizeof(_ns1__create3);
		((_ns1__create3*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create3[n];
		if (size)
			*size = n * sizeof(_ns1__create3);
		for (int i = 0; i < n; i++)
			((_ns1__create3*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create3 %p -> %p\n", q, p));
	*(_ns1__create3*)p = *(_ns1__create3*)q;
}

void _ns1__findByPKResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CommentVO(soap, &((_ns1__findByPKResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPKResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPKResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPKResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPKResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPKResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPKResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPKResponse(struct soap *soap, const char *tag, int id, const _ns1__findByPKResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPKResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__CommentVO(soap, "ns1:out", -1, &(((_ns1__findByPKResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPKResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPKResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPKResponse * SOAP_FMAC4 soap_get__ns1__findByPKResponse(struct soap *soap, _ns1__findByPKResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPKResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPKResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPKResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPKResponse * SOAP_FMAC4 soap_in__ns1__findByPKResponse(struct soap *soap, const char *tag, _ns1__findByPKResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPKResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPKResponse, sizeof(_ns1__findByPKResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPKResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPKResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CommentVO(soap, "ns1:out", &(((_ns1__findByPKResponse*)a)->out), "ns4:CommentVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPKResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPKResponse, 0, sizeof(_ns1__findByPKResponse), 0, soap_copy__ns1__findByPKResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPKResponse * SOAP_FMAC6 soap_new__ns1__findByPKResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPKResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPKResponse(struct soap *soap, _ns1__findByPKResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPKResponse * SOAP_FMAC4 soap_instantiate__ns1__findByPKResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPKResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPKResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPKResponse;
		if (size)
			*size = sizeof(_ns1__findByPKResponse);
		((_ns1__findByPKResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPKResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findByPKResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findByPKResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPKResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPKResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPKResponse %p -> %p\n", q, p));
	*(_ns1__findByPKResponse*)p = *(_ns1__findByPKResponse*)q;
}

void _ns1__findByPK::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CommentVO(soap, &((_ns1__findByPK*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK(struct soap *soap, const char *tag, int id, const _ns1__findByPK *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK), type);
	soap_out_PointerTons4__CommentVO(soap, "ns1:in0", -1, &(((_ns1__findByPK*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK * SOAP_FMAC4 soap_get__ns1__findByPK(struct soap *soap, _ns1__findByPK *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK * SOAP_FMAC4 soap_in__ns1__findByPK(struct soap *soap, const char *tag, _ns1__findByPK *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK, sizeof(_ns1__findByPK), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CommentVO(soap, "ns1:in0", &(((_ns1__findByPK*)a)->in0), "ns4:CommentVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK, 0, sizeof(_ns1__findByPK), 0, soap_copy__ns1__findByPK);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK * SOAP_FMAC6 soap_new__ns1__findByPK(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK(struct soap *soap, _ns1__findByPK *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK * SOAP_FMAC4 soap_instantiate__ns1__findByPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK;
		if (size)
			*size = sizeof(_ns1__findByPK);
		((_ns1__findByPK*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK %p -> %p\n", q, p));
	*(_ns1__findByPK*)p = *(_ns1__findByPK*)q;
}

void _ns1__update6Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update6Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update6Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update6Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update6Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update6Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update6Response(struct soap *soap, const char *tag, int id, const _ns1__update6Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update6Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update6Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update6Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update6Response * SOAP_FMAC4 soap_get__ns1__update6Response(struct soap *soap, _ns1__update6Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update6Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update6Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update6Response * SOAP_FMAC4 soap_in__ns1__update6Response(struct soap *soap, const char *tag, _ns1__update6Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update6Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update6Response, sizeof(_ns1__update6Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update6Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update6Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update6Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update6Response, 0, sizeof(_ns1__update6Response), 0, soap_copy__ns1__update6Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update6Response * SOAP_FMAC6 soap_new__ns1__update6Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update6Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update6Response(struct soap *soap, _ns1__update6Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update6Response * SOAP_FMAC4 soap_instantiate__ns1__update6Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update6Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update6Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update6Response;
		if (size)
			*size = sizeof(_ns1__update6Response);
		((_ns1__update6Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update6Response[n];
		if (size)
			*size = n * sizeof(_ns1__update6Response);
		for (int i = 0; i < n; i++)
			((_ns1__update6Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update6Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update6Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update6Response %p -> %p\n", q, p));
	*(_ns1__update6Response*)p = *(_ns1__update6Response*)q;
}

void _ns1__update6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EntityVO(soap, &((_ns1__update6*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update6::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update6*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update6);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update6(struct soap *soap, const char *tag, int id, const _ns1__update6 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update6), type);
	soap_out_PointerTons4__EntityVO(soap, "ns1:in0", -1, &(((_ns1__update6*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update6(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update6 * SOAP_FMAC4 soap_get__ns1__update6(struct soap *soap, _ns1__update6 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update6::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update6(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update6 * SOAP_FMAC4 soap_in__ns1__update6(struct soap *soap, const char *tag, _ns1__update6 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update6 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update6, sizeof(_ns1__update6), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update6)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update6 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns1:in0", &(((_ns1__update6*)a)->in0), "ns4:EntityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update6, 0, sizeof(_ns1__update6), 0, soap_copy__ns1__update6);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update6 * SOAP_FMAC6 soap_new__ns1__update6(struct soap *soap, int n)
{	return soap_instantiate__ns1__update6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update6(struct soap *soap, _ns1__update6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update6 * SOAP_FMAC4 soap_instantiate__ns1__update6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update6;
		if (size)
			*size = sizeof(_ns1__update6);
		((_ns1__update6*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update6[n];
		if (size)
			*size = n * sizeof(_ns1__update6);
		for (int i = 0; i < n; i++)
			((_ns1__update6*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update6 %p -> %p\n", q, p));
	*(_ns1__update6*)p = *(_ns1__update6*)q;
}

void _ns1__update9Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update9Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update9Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update9Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update9Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update9Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update9Response(struct soap *soap, const char *tag, int id, const _ns1__update9Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update9Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update9Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update9Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update9Response * SOAP_FMAC4 soap_get__ns1__update9Response(struct soap *soap, _ns1__update9Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update9Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update9Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update9Response * SOAP_FMAC4 soap_in__ns1__update9Response(struct soap *soap, const char *tag, _ns1__update9Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update9Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update9Response, sizeof(_ns1__update9Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update9Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update9Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update9Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update9Response, 0, sizeof(_ns1__update9Response), 0, soap_copy__ns1__update9Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update9Response * SOAP_FMAC6 soap_new__ns1__update9Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update9Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update9Response(struct soap *soap, _ns1__update9Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update9Response * SOAP_FMAC4 soap_instantiate__ns1__update9Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update9Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update9Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update9Response;
		if (size)
			*size = sizeof(_ns1__update9Response);
		((_ns1__update9Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update9Response[n];
		if (size)
			*size = n * sizeof(_ns1__update9Response);
		for (int i = 0; i < n; i++)
			((_ns1__update9Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update9Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update9Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update9Response %p -> %p\n", q, p));
	*(_ns1__update9Response*)p = *(_ns1__update9Response*)q;
}

void _ns1__update9::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTSlideVO(soap, &((_ns1__update9*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update9::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update9*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update9::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update9);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update9::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update9(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update9(struct soap *soap, const char *tag, int id, const _ns1__update9 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update9), type);
	soap_out_PointerTons4__PPTSlideVO(soap, "ns1:in0", -1, &(((_ns1__update9*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update9::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update9(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update9 * SOAP_FMAC4 soap_get__ns1__update9(struct soap *soap, _ns1__update9 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update9::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update9(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update9 * SOAP_FMAC4 soap_in__ns1__update9(struct soap *soap, const char *tag, _ns1__update9 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update9 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update9, sizeof(_ns1__update9), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update9)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update9 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTSlideVO(soap, "ns1:in0", &(((_ns1__update9*)a)->in0), "ns4:PPTSlideVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update9 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update9, 0, sizeof(_ns1__update9), 0, soap_copy__ns1__update9);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update9 * SOAP_FMAC6 soap_new__ns1__update9(struct soap *soap, int n)
{	return soap_instantiate__ns1__update9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update9(struct soap *soap, _ns1__update9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update9 * SOAP_FMAC4 soap_instantiate__ns1__update9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update9;
		if (size)
			*size = sizeof(_ns1__update9);
		((_ns1__update9*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update9[n];
		if (size)
			*size = n * sizeof(_ns1__update9);
		for (int i = 0; i < n; i++)
			((_ns1__update9*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update9 %p -> %p\n", q, p));
	*(_ns1__update9*)p = *(_ns1__update9*)q;
}

void _ns1__update11Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update11Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update11Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update11Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update11Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update11Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update11Response(struct soap *soap, const char *tag, int id, const _ns1__update11Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update11Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update11Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update11Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update11Response * SOAP_FMAC4 soap_get__ns1__update11Response(struct soap *soap, _ns1__update11Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update11Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update11Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update11Response * SOAP_FMAC4 soap_in__ns1__update11Response(struct soap *soap, const char *tag, _ns1__update11Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update11Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update11Response, sizeof(_ns1__update11Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update11Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update11Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update11Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update11Response, 0, sizeof(_ns1__update11Response), 0, soap_copy__ns1__update11Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update11Response * SOAP_FMAC6 soap_new__ns1__update11Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update11Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update11Response(struct soap *soap, _ns1__update11Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update11Response * SOAP_FMAC4 soap_instantiate__ns1__update11Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update11Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update11Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update11Response;
		if (size)
			*size = sizeof(_ns1__update11Response);
		((_ns1__update11Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update11Response[n];
		if (size)
			*size = n * sizeof(_ns1__update11Response);
		for (int i = 0; i < n; i++)
			((_ns1__update11Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update11Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update11Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update11Response %p -> %p\n", q, p));
	*(_ns1__update11Response*)p = *(_ns1__update11Response*)q;
}

void _ns1__update11::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserVO(soap, &((_ns1__update11*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update11::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update11*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update11::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update11);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update11::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update11(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update11(struct soap *soap, const char *tag, int id, const _ns1__update11 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update11), type);
	soap_out_PointerTons4__UserVO(soap, "ns1:in0", -1, &(((_ns1__update11*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update11::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update11(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update11 * SOAP_FMAC4 soap_get__ns1__update11(struct soap *soap, _ns1__update11 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update11::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update11(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update11 * SOAP_FMAC4 soap_in__ns1__update11(struct soap *soap, const char *tag, _ns1__update11 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update11 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update11, sizeof(_ns1__update11), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update11)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update11 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns1:in0", &(((_ns1__update11*)a)->in0), "ns4:UserVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update11 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update11, 0, sizeof(_ns1__update11), 0, soap_copy__ns1__update11);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update11 * SOAP_FMAC6 soap_new__ns1__update11(struct soap *soap, int n)
{	return soap_instantiate__ns1__update11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update11(struct soap *soap, _ns1__update11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update11 * SOAP_FMAC4 soap_instantiate__ns1__update11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update11;
		if (size)
			*size = sizeof(_ns1__update11);
		((_ns1__update11*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update11[n];
		if (size)
			*size = n * sizeof(_ns1__update11);
		for (int i = 0; i < n; i++)
			((_ns1__update11*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update11 %p -> %p\n", q, p));
	*(_ns1__update11*)p = *(_ns1__update11*)q;
}

void _ns1__remove7Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove7Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove7Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove7Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove7Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove7Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove7Response(struct soap *soap, const char *tag, int id, const _ns1__remove7Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove7Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove7Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove7Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove7Response * SOAP_FMAC4 soap_get__ns1__remove7Response(struct soap *soap, _ns1__remove7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove7Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove7Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove7Response * SOAP_FMAC4 soap_in__ns1__remove7Response(struct soap *soap, const char *tag, _ns1__remove7Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove7Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove7Response, sizeof(_ns1__remove7Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove7Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove7Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove7Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove7Response, 0, sizeof(_ns1__remove7Response), 0, soap_copy__ns1__remove7Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove7Response * SOAP_FMAC6 soap_new__ns1__remove7Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove7Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove7Response(struct soap *soap, _ns1__remove7Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove7Response * SOAP_FMAC4 soap_instantiate__ns1__remove7Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove7Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove7Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove7Response;
		if (size)
			*size = sizeof(_ns1__remove7Response);
		((_ns1__remove7Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove7Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove7Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove7Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove7Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove7Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove7Response %p -> %p\n", q, p));
	*(_ns1__remove7Response*)p = *(_ns1__remove7Response*)q;
}

void _ns1__remove7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__FeedbackVO(soap, &((_ns1__remove7*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove7::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove7*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove7);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove7(struct soap *soap, const char *tag, int id, const _ns1__remove7 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove7), type);
	soap_out_PointerTons4__FeedbackVO(soap, "ns1:in0", -1, &(((_ns1__remove7*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove7(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove7 * SOAP_FMAC4 soap_get__ns1__remove7(struct soap *soap, _ns1__remove7 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove7::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove7(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove7 * SOAP_FMAC4 soap_in__ns1__remove7(struct soap *soap, const char *tag, _ns1__remove7 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove7 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove7, sizeof(_ns1__remove7), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove7)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove7 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FeedbackVO(soap, "ns1:in0", &(((_ns1__remove7*)a)->in0), "ns4:FeedbackVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove7, 0, sizeof(_ns1__remove7), 0, soap_copy__ns1__remove7);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove7 * SOAP_FMAC6 soap_new__ns1__remove7(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove7(struct soap *soap, _ns1__remove7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove7 * SOAP_FMAC4 soap_instantiate__ns1__remove7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove7;
		if (size)
			*size = sizeof(_ns1__remove7);
		((_ns1__remove7*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove7[n];
		if (size)
			*size = n * sizeof(_ns1__remove7);
		for (int i = 0; i < n; i++)
			((_ns1__remove7*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove7 %p -> %p\n", q, p));
	*(_ns1__remove7*)p = *(_ns1__remove7*)q;
}

void _ns1__findBySQLQueryReturnDictionaryVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfDictionaryVO(soap, &((_ns1__findBySQLQueryReturnDictionaryVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnDictionaryVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnDictionaryVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnDictionaryVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnDictionaryVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnDictionaryVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfDictionaryVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnDictionaryVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnDictionaryVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnDictionaryVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnDictionaryVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnDictionaryVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse, sizeof(_ns1__findBySQLQueryReturnDictionaryVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnDictionaryVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfDictionaryVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnDictionaryVOResponse*)a)->out), "ns4:ArrayOfDictionaryVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnDictionaryVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnDictionaryVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnDictionaryVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnDictionaryVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnDictionaryVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnDictionaryVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnDictionaryVOResponse);
		((_ns1__findBySQLQueryReturnDictionaryVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnDictionaryVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnDictionaryVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnDictionaryVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnDictionaryVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnDictionaryVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnDictionaryVOResponse*)p = *(_ns1__findBySQLQueryReturnDictionaryVOResponse*)q;
}

void _ns1__findBySQLQueryReturnDictionaryVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnDictionaryVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnDictionaryVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnDictionaryVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnDictionaryVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnDictionaryVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnDictionaryVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnDictionaryVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnDictionaryVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnDictionaryVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnDictionaryVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnDictionaryVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnDictionaryVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnDictionaryVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnDictionaryVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnDictionaryVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO, sizeof(_ns1__findBySQLQueryReturnDictionaryVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnDictionaryVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnDictionaryVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnDictionaryVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO, 0, sizeof(_ns1__findBySQLQueryReturnDictionaryVO), 0, soap_copy__ns1__findBySQLQueryReturnDictionaryVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnDictionaryVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnDictionaryVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnDictionaryVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnDictionaryVO);
		((_ns1__findBySQLQueryReturnDictionaryVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnDictionaryVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnDictionaryVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnDictionaryVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnDictionaryVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnDictionaryVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnDictionaryVO*)p = *(_ns1__findBySQLQueryReturnDictionaryVO*)q;
}

void _ns1__findBySQLQueryReturnERelationVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfERelationVO(soap, &((_ns1__findBySQLQueryReturnERelationVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnERelationVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnERelationVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnERelationVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnERelationVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnERelationVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnERelationVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfERelationVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnERelationVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnERelationVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnERelationVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnERelationVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnERelationVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnERelationVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnERelationVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnERelationVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnERelationVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse, sizeof(_ns1__findBySQLQueryReturnERelationVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnERelationVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfERelationVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnERelationVOResponse*)a)->out), "ns4:ArrayOfERelationVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnERelationVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnERelationVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnERelationVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnERelationVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnERelationVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnERelationVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnERelationVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnERelationVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnERelationVOResponse);
		((_ns1__findBySQLQueryReturnERelationVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnERelationVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnERelationVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnERelationVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnERelationVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnERelationVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnERelationVOResponse*)p = *(_ns1__findBySQLQueryReturnERelationVOResponse*)q;
}

void _ns1__findBySQLQueryReturnERelationVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnERelationVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnERelationVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnERelationVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnERelationVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnERelationVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnERelationVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnERelationVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnERelationVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnERelationVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnERelationVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnERelationVO(struct soap *soap, _ns1__findBySQLQueryReturnERelationVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnERelationVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnERelationVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnERelationVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnERelationVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnERelationVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO, sizeof(_ns1__findBySQLQueryReturnERelationVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnERelationVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnERelationVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnERelationVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO, 0, sizeof(_ns1__findBySQLQueryReturnERelationVO), 0, soap_copy__ns1__findBySQLQueryReturnERelationVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnERelationVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnERelationVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnERelationVO(struct soap *soap, _ns1__findBySQLQueryReturnERelationVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnERelationVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnERelationVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnERelationVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnERelationVO);
		((_ns1__findBySQLQueryReturnERelationVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnERelationVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnERelationVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnERelationVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnERelationVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnERelationVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnERelationVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnERelationVO*)p = *(_ns1__findBySQLQueryReturnERelationVO*)q;
}

void _ns1__findByPK4Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ERelationVO(soap, &((_ns1__findByPK4Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK4Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK4Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK4Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK4Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK4Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK4Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK4Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK4Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK4Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ERelationVO(soap, "ns1:out", -1, &(((_ns1__findByPK4Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK4Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK4Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK4Response * SOAP_FMAC4 soap_get__ns1__findByPK4Response(struct soap *soap, _ns1__findByPK4Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK4Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK4Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK4Response * SOAP_FMAC4 soap_in__ns1__findByPK4Response(struct soap *soap, const char *tag, _ns1__findByPK4Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK4Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK4Response, sizeof(_ns1__findByPK4Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK4Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK4Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ERelationVO(soap, "ns1:out", &(((_ns1__findByPK4Response*)a)->out), "ns4:ERelationVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK4Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK4Response, 0, sizeof(_ns1__findByPK4Response), 0, soap_copy__ns1__findByPK4Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK4Response * SOAP_FMAC6 soap_new__ns1__findByPK4Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK4Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK4Response(struct soap *soap, _ns1__findByPK4Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK4Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK4Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK4Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK4Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK4Response;
		if (size)
			*size = sizeof(_ns1__findByPK4Response);
		((_ns1__findByPK4Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK4Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK4Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK4Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK4Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK4Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK4Response %p -> %p\n", q, p));
	*(_ns1__findByPK4Response*)p = *(_ns1__findByPK4Response*)q;
}

void _ns1__findByPK4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ERelationVO(soap, &((_ns1__findByPK4*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK4::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK4*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK4);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK4(struct soap *soap, const char *tag, int id, const _ns1__findByPK4 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK4), type);
	soap_out_PointerTons4__ERelationVO(soap, "ns1:in0", -1, &(((_ns1__findByPK4*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK4(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK4 * SOAP_FMAC4 soap_get__ns1__findByPK4(struct soap *soap, _ns1__findByPK4 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK4::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK4(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK4 * SOAP_FMAC4 soap_in__ns1__findByPK4(struct soap *soap, const char *tag, _ns1__findByPK4 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK4 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK4, sizeof(_ns1__findByPK4), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK4)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK4 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ERelationVO(soap, "ns1:in0", &(((_ns1__findByPK4*)a)->in0), "ns4:ERelationVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK4, 0, sizeof(_ns1__findByPK4), 0, soap_copy__ns1__findByPK4);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK4 * SOAP_FMAC6 soap_new__ns1__findByPK4(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK4(struct soap *soap, _ns1__findByPK4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK4 * SOAP_FMAC4 soap_instantiate__ns1__findByPK4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK4;
		if (size)
			*size = sizeof(_ns1__findByPK4);
		((_ns1__findByPK4*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK4[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK4);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK4*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK4 %p -> %p\n", q, p));
	*(_ns1__findByPK4*)p = *(_ns1__findByPK4*)q;
}

void _ns1__findByPK9Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTSlideVO(soap, &((_ns1__findByPK9Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK9Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK9Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK9Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK9Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK9Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK9Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK9Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK9Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK9Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__PPTSlideVO(soap, "ns1:out", -1, &(((_ns1__findByPK9Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK9Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK9Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK9Response * SOAP_FMAC4 soap_get__ns1__findByPK9Response(struct soap *soap, _ns1__findByPK9Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK9Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK9Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK9Response * SOAP_FMAC4 soap_in__ns1__findByPK9Response(struct soap *soap, const char *tag, _ns1__findByPK9Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK9Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK9Response, sizeof(_ns1__findByPK9Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK9Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK9Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTSlideVO(soap, "ns1:out", &(((_ns1__findByPK9Response*)a)->out), "ns4:PPTSlideVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK9Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK9Response, 0, sizeof(_ns1__findByPK9Response), 0, soap_copy__ns1__findByPK9Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK9Response * SOAP_FMAC6 soap_new__ns1__findByPK9Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK9Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK9Response(struct soap *soap, _ns1__findByPK9Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK9Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK9Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK9Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK9Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK9Response;
		if (size)
			*size = sizeof(_ns1__findByPK9Response);
		((_ns1__findByPK9Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK9Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK9Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK9Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK9Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK9Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK9Response %p -> %p\n", q, p));
	*(_ns1__findByPK9Response*)p = *(_ns1__findByPK9Response*)q;
}

void _ns1__findByPK9::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTSlideVO(soap, &((_ns1__findByPK9*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK9::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK9*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK9::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK9);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK9::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK9(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK9(struct soap *soap, const char *tag, int id, const _ns1__findByPK9 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK9), type);
	soap_out_PointerTons4__PPTSlideVO(soap, "ns1:in0", -1, &(((_ns1__findByPK9*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK9::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK9(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK9 * SOAP_FMAC4 soap_get__ns1__findByPK9(struct soap *soap, _ns1__findByPK9 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK9::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK9(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK9 * SOAP_FMAC4 soap_in__ns1__findByPK9(struct soap *soap, const char *tag, _ns1__findByPK9 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK9 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK9, sizeof(_ns1__findByPK9), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK9)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK9 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTSlideVO(soap, "ns1:in0", &(((_ns1__findByPK9*)a)->in0), "ns4:PPTSlideVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK9 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK9, 0, sizeof(_ns1__findByPK9), 0, soap_copy__ns1__findByPK9);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK9 * SOAP_FMAC6 soap_new__ns1__findByPK9(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK9(struct soap *soap, _ns1__findByPK9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK9 * SOAP_FMAC4 soap_instantiate__ns1__findByPK9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK9;
		if (size)
			*size = sizeof(_ns1__findByPK9);
		((_ns1__findByPK9*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK9[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK9);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK9*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK9 %p -> %p\n", q, p));
	*(_ns1__findByPK9*)p = *(_ns1__findByPK9*)q;
}

void _ns1__update10Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update10Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update10Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update10Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update10Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update10Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update10Response(struct soap *soap, const char *tag, int id, const _ns1__update10Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update10Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update10Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update10Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update10Response * SOAP_FMAC4 soap_get__ns1__update10Response(struct soap *soap, _ns1__update10Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update10Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update10Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update10Response * SOAP_FMAC4 soap_in__ns1__update10Response(struct soap *soap, const char *tag, _ns1__update10Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update10Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update10Response, sizeof(_ns1__update10Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update10Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update10Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update10Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update10Response, 0, sizeof(_ns1__update10Response), 0, soap_copy__ns1__update10Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update10Response * SOAP_FMAC6 soap_new__ns1__update10Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update10Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update10Response(struct soap *soap, _ns1__update10Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update10Response * SOAP_FMAC4 soap_instantiate__ns1__update10Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update10Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update10Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update10Response;
		if (size)
			*size = sizeof(_ns1__update10Response);
		((_ns1__update10Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update10Response[n];
		if (size)
			*size = n * sizeof(_ns1__update10Response);
		for (int i = 0; i < n; i++)
			((_ns1__update10Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update10Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update10Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update10Response %p -> %p\n", q, p));
	*(_ns1__update10Response*)p = *(_ns1__update10Response*)q;
}

void _ns1__update10::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTVO(soap, &((_ns1__update10*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update10::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update10*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update10::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update10);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update10::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update10(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update10(struct soap *soap, const char *tag, int id, const _ns1__update10 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update10), type);
	soap_out_PointerTons4__PPTVO(soap, "ns1:in0", -1, &(((_ns1__update10*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update10::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update10(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update10 * SOAP_FMAC4 soap_get__ns1__update10(struct soap *soap, _ns1__update10 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update10::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update10(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update10 * SOAP_FMAC4 soap_in__ns1__update10(struct soap *soap, const char *tag, _ns1__update10 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update10 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update10, sizeof(_ns1__update10), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update10)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update10 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTVO(soap, "ns1:in0", &(((_ns1__update10*)a)->in0), "ns4:PPTVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update10 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update10, 0, sizeof(_ns1__update10), 0, soap_copy__ns1__update10);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update10 * SOAP_FMAC6 soap_new__ns1__update10(struct soap *soap, int n)
{	return soap_instantiate__ns1__update10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update10(struct soap *soap, _ns1__update10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update10 * SOAP_FMAC4 soap_instantiate__ns1__update10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update10;
		if (size)
			*size = sizeof(_ns1__update10);
		((_ns1__update10*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update10[n];
		if (size)
			*size = n * sizeof(_ns1__update10);
		for (int i = 0; i < n; i++)
			((_ns1__update10*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update10 %p -> %p\n", q, p));
	*(_ns1__update10*)p = *(_ns1__update10*)q;
}

void _ns1__update8Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update8Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update8Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update8Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update8Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update8Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update8Response(struct soap *soap, const char *tag, int id, const _ns1__update8Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update8Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update8Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update8Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update8Response * SOAP_FMAC4 soap_get__ns1__update8Response(struct soap *soap, _ns1__update8Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update8Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update8Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update8Response * SOAP_FMAC4 soap_in__ns1__update8Response(struct soap *soap, const char *tag, _ns1__update8Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update8Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update8Response, sizeof(_ns1__update8Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update8Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update8Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update8Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update8Response, 0, sizeof(_ns1__update8Response), 0, soap_copy__ns1__update8Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update8Response * SOAP_FMAC6 soap_new__ns1__update8Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update8Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update8Response(struct soap *soap, _ns1__update8Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update8Response * SOAP_FMAC4 soap_instantiate__ns1__update8Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update8Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update8Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update8Response;
		if (size)
			*size = sizeof(_ns1__update8Response);
		((_ns1__update8Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update8Response[n];
		if (size)
			*size = n * sizeof(_ns1__update8Response);
		for (int i = 0; i < n; i++)
			((_ns1__update8Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update8Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update8Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update8Response %p -> %p\n", q, p));
	*(_ns1__update8Response*)p = *(_ns1__update8Response*)q;
}

void _ns1__update8::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ImageVO(soap, &((_ns1__update8*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update8::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update8*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update8::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update8);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update8::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update8(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update8(struct soap *soap, const char *tag, int id, const _ns1__update8 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update8), type);
	soap_out_PointerTons4__ImageVO(soap, "ns1:in0", -1, &(((_ns1__update8*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update8::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update8(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update8 * SOAP_FMAC4 soap_get__ns1__update8(struct soap *soap, _ns1__update8 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update8::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update8(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update8 * SOAP_FMAC4 soap_in__ns1__update8(struct soap *soap, const char *tag, _ns1__update8 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update8 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update8, sizeof(_ns1__update8), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update8)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update8 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ImageVO(soap, "ns1:in0", &(((_ns1__update8*)a)->in0), "ns4:ImageVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update8 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update8, 0, sizeof(_ns1__update8), 0, soap_copy__ns1__update8);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update8 * SOAP_FMAC6 soap_new__ns1__update8(struct soap *soap, int n)
{	return soap_instantiate__ns1__update8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update8(struct soap *soap, _ns1__update8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update8 * SOAP_FMAC4 soap_instantiate__ns1__update8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update8;
		if (size)
			*size = sizeof(_ns1__update8);
		((_ns1__update8*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update8[n];
		if (size)
			*size = n * sizeof(_ns1__update8);
		for (int i = 0; i < n; i++)
			((_ns1__update8*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update8 %p -> %p\n", q, p));
	*(_ns1__update8*)p = *(_ns1__update8*)q;
}

void _ns1__create1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ContainerVO(soap, &((_ns1__create1Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create1Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create1Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create1Response(struct soap *soap, const char *tag, int id, const _ns1__create1Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create1Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ContainerVO(soap, "ns1:out", -1, &(((_ns1__create1Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create1Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create1Response * SOAP_FMAC4 soap_get__ns1__create1Response(struct soap *soap, _ns1__create1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create1Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create1Response * SOAP_FMAC4 soap_in__ns1__create1Response(struct soap *soap, const char *tag, _ns1__create1Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create1Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create1Response, sizeof(_ns1__create1Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create1Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create1Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ContainerVO(soap, "ns1:out", &(((_ns1__create1Response*)a)->out), "ns4:ContainerVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create1Response, 0, sizeof(_ns1__create1Response), 0, soap_copy__ns1__create1Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create1Response * SOAP_FMAC6 soap_new__ns1__create1Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create1Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create1Response(struct soap *soap, _ns1__create1Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create1Response * SOAP_FMAC4 soap_instantiate__ns1__create1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create1Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create1Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create1Response;
		if (size)
			*size = sizeof(_ns1__create1Response);
		((_ns1__create1Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create1Response[n];
		if (size)
			*size = n * sizeof(_ns1__create1Response);
		for (int i = 0; i < n; i++)
			((_ns1__create1Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create1Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create1Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create1Response %p -> %p\n", q, p));
	*(_ns1__create1Response*)p = *(_ns1__create1Response*)q;
}

void _ns1__create1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ContainerVO(soap, &((_ns1__create1*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create1::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create1*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create1);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create1(struct soap *soap, const char *tag, int id, const _ns1__create1 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create1), type);
	soap_out_PointerTons4__ContainerVO(soap, "ns1:in0", -1, &(((_ns1__create1*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create1(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create1 * SOAP_FMAC4 soap_get__ns1__create1(struct soap *soap, _ns1__create1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create1(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create1 * SOAP_FMAC4 soap_in__ns1__create1(struct soap *soap, const char *tag, _ns1__create1 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create1, sizeof(_ns1__create1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create1 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ContainerVO(soap, "ns1:in0", &(((_ns1__create1*)a)->in0), "ns4:ContainerVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create1, 0, sizeof(_ns1__create1), 0, soap_copy__ns1__create1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create1 * SOAP_FMAC6 soap_new__ns1__create1(struct soap *soap, int n)
{	return soap_instantiate__ns1__create1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create1(struct soap *soap, _ns1__create1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create1 * SOAP_FMAC4 soap_instantiate__ns1__create1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create1;
		if (size)
			*size = sizeof(_ns1__create1);
		((_ns1__create1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create1[n];
		if (size)
			*size = n * sizeof(_ns1__create1);
		for (int i = 0; i < n; i++)
			((_ns1__create1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create1 %p -> %p\n", q, p));
	*(_ns1__create1*)p = *(_ns1__create1*)q;
}

void _ns1__remove8Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove8Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove8Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove8Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove8Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove8Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove8Response(struct soap *soap, const char *tag, int id, const _ns1__remove8Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove8Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove8Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove8Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove8Response * SOAP_FMAC4 soap_get__ns1__remove8Response(struct soap *soap, _ns1__remove8Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove8Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove8Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove8Response * SOAP_FMAC4 soap_in__ns1__remove8Response(struct soap *soap, const char *tag, _ns1__remove8Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove8Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove8Response, sizeof(_ns1__remove8Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove8Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove8Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove8Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove8Response, 0, sizeof(_ns1__remove8Response), 0, soap_copy__ns1__remove8Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove8Response * SOAP_FMAC6 soap_new__ns1__remove8Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove8Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove8Response(struct soap *soap, _ns1__remove8Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove8Response * SOAP_FMAC4 soap_instantiate__ns1__remove8Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove8Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove8Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove8Response;
		if (size)
			*size = sizeof(_ns1__remove8Response);
		((_ns1__remove8Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove8Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove8Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove8Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove8Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove8Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove8Response %p -> %p\n", q, p));
	*(_ns1__remove8Response*)p = *(_ns1__remove8Response*)q;
}

void _ns1__remove8::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ImageVO(soap, &((_ns1__remove8*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove8::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove8*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove8::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove8);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove8::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove8(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove8(struct soap *soap, const char *tag, int id, const _ns1__remove8 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove8), type);
	soap_out_PointerTons4__ImageVO(soap, "ns1:in0", -1, &(((_ns1__remove8*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove8::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove8(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove8 * SOAP_FMAC4 soap_get__ns1__remove8(struct soap *soap, _ns1__remove8 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove8::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove8(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove8 * SOAP_FMAC4 soap_in__ns1__remove8(struct soap *soap, const char *tag, _ns1__remove8 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove8 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove8, sizeof(_ns1__remove8), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove8)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove8 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ImageVO(soap, "ns1:in0", &(((_ns1__remove8*)a)->in0), "ns4:ImageVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove8 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove8, 0, sizeof(_ns1__remove8), 0, soap_copy__ns1__remove8);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove8 * SOAP_FMAC6 soap_new__ns1__remove8(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove8(struct soap *soap, _ns1__remove8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove8 * SOAP_FMAC4 soap_instantiate__ns1__remove8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove8;
		if (size)
			*size = sizeof(_ns1__remove8);
		((_ns1__remove8*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove8[n];
		if (size)
			*size = n * sizeof(_ns1__remove8);
		for (int i = 0; i < n; i++)
			((_ns1__remove8*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove8 %p -> %p\n", q, p));
	*(_ns1__remove8*)p = *(_ns1__remove8*)q;
}

void _ns1__update7Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update7Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update7Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update7Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update7Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update7Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update7Response(struct soap *soap, const char *tag, int id, const _ns1__update7Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update7Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update7Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update7Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update7Response * SOAP_FMAC4 soap_get__ns1__update7Response(struct soap *soap, _ns1__update7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update7Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update7Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update7Response * SOAP_FMAC4 soap_in__ns1__update7Response(struct soap *soap, const char *tag, _ns1__update7Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update7Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update7Response, sizeof(_ns1__update7Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update7Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update7Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update7Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update7Response, 0, sizeof(_ns1__update7Response), 0, soap_copy__ns1__update7Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update7Response * SOAP_FMAC6 soap_new__ns1__update7Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update7Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update7Response(struct soap *soap, _ns1__update7Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update7Response * SOAP_FMAC4 soap_instantiate__ns1__update7Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update7Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update7Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update7Response;
		if (size)
			*size = sizeof(_ns1__update7Response);
		((_ns1__update7Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update7Response[n];
		if (size)
			*size = n * sizeof(_ns1__update7Response);
		for (int i = 0; i < n; i++)
			((_ns1__update7Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update7Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update7Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update7Response %p -> %p\n", q, p));
	*(_ns1__update7Response*)p = *(_ns1__update7Response*)q;
}

void _ns1__update7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__FeedbackVO(soap, &((_ns1__update7*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update7::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update7*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update7);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update7(struct soap *soap, const char *tag, int id, const _ns1__update7 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update7), type);
	soap_out_PointerTons4__FeedbackVO(soap, "ns1:in0", -1, &(((_ns1__update7*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update7(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update7 * SOAP_FMAC4 soap_get__ns1__update7(struct soap *soap, _ns1__update7 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update7::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update7(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update7 * SOAP_FMAC4 soap_in__ns1__update7(struct soap *soap, const char *tag, _ns1__update7 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update7 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update7, sizeof(_ns1__update7), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update7)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update7 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FeedbackVO(soap, "ns1:in0", &(((_ns1__update7*)a)->in0), "ns4:FeedbackVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update7, 0, sizeof(_ns1__update7), 0, soap_copy__ns1__update7);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update7 * SOAP_FMAC6 soap_new__ns1__update7(struct soap *soap, int n)
{	return soap_instantiate__ns1__update7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update7(struct soap *soap, _ns1__update7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update7 * SOAP_FMAC4 soap_instantiate__ns1__update7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update7;
		if (size)
			*size = sizeof(_ns1__update7);
		((_ns1__update7*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update7[n];
		if (size)
			*size = n * sizeof(_ns1__update7);
		for (int i = 0; i < n; i++)
			((_ns1__update7*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update7 %p -> %p\n", q, p));
	*(_ns1__update7*)p = *(_ns1__update7*)q;
}

void _ns1__remove5Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove5Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove5Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove5Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove5Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove5Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove5Response(struct soap *soap, const char *tag, int id, const _ns1__remove5Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove5Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove5Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove5Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove5Response * SOAP_FMAC4 soap_get__ns1__remove5Response(struct soap *soap, _ns1__remove5Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove5Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove5Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove5Response * SOAP_FMAC4 soap_in__ns1__remove5Response(struct soap *soap, const char *tag, _ns1__remove5Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove5Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove5Response, sizeof(_ns1__remove5Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove5Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove5Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove5Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove5Response, 0, sizeof(_ns1__remove5Response), 0, soap_copy__ns1__remove5Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove5Response * SOAP_FMAC6 soap_new__ns1__remove5Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove5Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove5Response(struct soap *soap, _ns1__remove5Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove5Response * SOAP_FMAC4 soap_instantiate__ns1__remove5Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove5Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove5Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove5Response;
		if (size)
			*size = sizeof(_ns1__remove5Response);
		((_ns1__remove5Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove5Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove5Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove5Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove5Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove5Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove5Response %p -> %p\n", q, p));
	*(_ns1__remove5Response*)p = *(_ns1__remove5Response*)q;
}

void _ns1__remove5::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ESignatureVO(soap, &((_ns1__remove5*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove5::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove5*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove5::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove5);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove5::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove5(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove5(struct soap *soap, const char *tag, int id, const _ns1__remove5 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove5), type);
	soap_out_PointerTons4__ESignatureVO(soap, "ns1:in0", -1, &(((_ns1__remove5*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove5::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove5(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove5 * SOAP_FMAC4 soap_get__ns1__remove5(struct soap *soap, _ns1__remove5 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove5::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove5(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove5 * SOAP_FMAC4 soap_in__ns1__remove5(struct soap *soap, const char *tag, _ns1__remove5 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove5 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove5, sizeof(_ns1__remove5), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove5)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove5 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ESignatureVO(soap, "ns1:in0", &(((_ns1__remove5*)a)->in0), "ns4:ESignatureVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove5 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove5, 0, sizeof(_ns1__remove5), 0, soap_copy__ns1__remove5);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove5 * SOAP_FMAC6 soap_new__ns1__remove5(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove5(struct soap *soap, _ns1__remove5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove5 * SOAP_FMAC4 soap_instantiate__ns1__remove5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove5;
		if (size)
			*size = sizeof(_ns1__remove5);
		((_ns1__remove5*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove5[n];
		if (size)
			*size = n * sizeof(_ns1__remove5);
		for (int i = 0; i < n; i++)
			((_ns1__remove5*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove5 %p -> %p\n", q, p));
	*(_ns1__remove5*)p = *(_ns1__remove5*)q;
}

void _ns1__remove4Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove4Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove4Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove4Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove4Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove4Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove4Response(struct soap *soap, const char *tag, int id, const _ns1__remove4Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove4Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove4Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove4Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove4Response * SOAP_FMAC4 soap_get__ns1__remove4Response(struct soap *soap, _ns1__remove4Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove4Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove4Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove4Response * SOAP_FMAC4 soap_in__ns1__remove4Response(struct soap *soap, const char *tag, _ns1__remove4Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove4Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove4Response, sizeof(_ns1__remove4Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove4Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove4Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove4Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove4Response, 0, sizeof(_ns1__remove4Response), 0, soap_copy__ns1__remove4Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove4Response * SOAP_FMAC6 soap_new__ns1__remove4Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove4Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove4Response(struct soap *soap, _ns1__remove4Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove4Response * SOAP_FMAC4 soap_instantiate__ns1__remove4Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove4Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove4Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove4Response;
		if (size)
			*size = sizeof(_ns1__remove4Response);
		((_ns1__remove4Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove4Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove4Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove4Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove4Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove4Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove4Response %p -> %p\n", q, p));
	*(_ns1__remove4Response*)p = *(_ns1__remove4Response*)q;
}

void _ns1__remove4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ERelationVO(soap, &((_ns1__remove4*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove4::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove4*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove4);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove4(struct soap *soap, const char *tag, int id, const _ns1__remove4 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove4), type);
	soap_out_PointerTons4__ERelationVO(soap, "ns1:in0", -1, &(((_ns1__remove4*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove4(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove4 * SOAP_FMAC4 soap_get__ns1__remove4(struct soap *soap, _ns1__remove4 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove4::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove4(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove4 * SOAP_FMAC4 soap_in__ns1__remove4(struct soap *soap, const char *tag, _ns1__remove4 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove4 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove4, sizeof(_ns1__remove4), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove4)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove4 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ERelationVO(soap, "ns1:in0", &(((_ns1__remove4*)a)->in0), "ns4:ERelationVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove4, 0, sizeof(_ns1__remove4), 0, soap_copy__ns1__remove4);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove4 * SOAP_FMAC6 soap_new__ns1__remove4(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove4(struct soap *soap, _ns1__remove4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove4 * SOAP_FMAC4 soap_instantiate__ns1__remove4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove4;
		if (size)
			*size = sizeof(_ns1__remove4);
		((_ns1__remove4*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove4[n];
		if (size)
			*size = n * sizeof(_ns1__remove4);
		for (int i = 0; i < n; i++)
			((_ns1__remove4*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove4 %p -> %p\n", q, p));
	*(_ns1__remove4*)p = *(_ns1__remove4*)q;
}

void _ns1__create7Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__FeedbackVO(soap, &((_ns1__create7Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create7Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create7Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create7Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create7Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create7Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create7Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create7Response(struct soap *soap, const char *tag, int id, const _ns1__create7Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create7Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__FeedbackVO(soap, "ns1:out", -1, &(((_ns1__create7Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create7Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create7Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create7Response * SOAP_FMAC4 soap_get__ns1__create7Response(struct soap *soap, _ns1__create7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create7Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create7Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create7Response * SOAP_FMAC4 soap_in__ns1__create7Response(struct soap *soap, const char *tag, _ns1__create7Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create7Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create7Response, sizeof(_ns1__create7Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create7Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create7Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FeedbackVO(soap, "ns1:out", &(((_ns1__create7Response*)a)->out), "ns4:FeedbackVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create7Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create7Response, 0, sizeof(_ns1__create7Response), 0, soap_copy__ns1__create7Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create7Response * SOAP_FMAC6 soap_new__ns1__create7Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create7Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create7Response(struct soap *soap, _ns1__create7Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create7Response * SOAP_FMAC4 soap_instantiate__ns1__create7Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create7Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create7Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create7Response;
		if (size)
			*size = sizeof(_ns1__create7Response);
		((_ns1__create7Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create7Response[n];
		if (size)
			*size = n * sizeof(_ns1__create7Response);
		for (int i = 0; i < n; i++)
			((_ns1__create7Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create7Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create7Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create7Response %p -> %p\n", q, p));
	*(_ns1__create7Response*)p = *(_ns1__create7Response*)q;
}

void _ns1__create7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__FeedbackVO(soap, &((_ns1__create7*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create7::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create7*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create7);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create7(struct soap *soap, const char *tag, int id, const _ns1__create7 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create7), type);
	soap_out_PointerTons4__FeedbackVO(soap, "ns1:in0", -1, &(((_ns1__create7*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create7(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create7 * SOAP_FMAC4 soap_get__ns1__create7(struct soap *soap, _ns1__create7 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create7::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create7(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create7 * SOAP_FMAC4 soap_in__ns1__create7(struct soap *soap, const char *tag, _ns1__create7 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create7 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create7, sizeof(_ns1__create7), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create7)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create7 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FeedbackVO(soap, "ns1:in0", &(((_ns1__create7*)a)->in0), "ns4:FeedbackVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create7, 0, sizeof(_ns1__create7), 0, soap_copy__ns1__create7);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create7 * SOAP_FMAC6 soap_new__ns1__create7(struct soap *soap, int n)
{	return soap_instantiate__ns1__create7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create7(struct soap *soap, _ns1__create7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create7 * SOAP_FMAC4 soap_instantiate__ns1__create7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create7;
		if (size)
			*size = sizeof(_ns1__create7);
		((_ns1__create7*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create7[n];
		if (size)
			*size = n * sizeof(_ns1__create7);
		for (int i = 0; i < n; i++)
			((_ns1__create7*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create7 %p -> %p\n", q, p));
	*(_ns1__create7*)p = *(_ns1__create7*)q;
}

void _ns1__findByPK2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__DictionaryVO(soap, &((_ns1__findByPK2Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK2Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK2Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK2Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK2Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK2Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__DictionaryVO(soap, "ns1:out", -1, &(((_ns1__findByPK2Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK2Response * SOAP_FMAC4 soap_get__ns1__findByPK2Response(struct soap *soap, _ns1__findByPK2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK2Response * SOAP_FMAC4 soap_in__ns1__findByPK2Response(struct soap *soap, const char *tag, _ns1__findByPK2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK2Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK2Response, sizeof(_ns1__findByPK2Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK2Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK2Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DictionaryVO(soap, "ns1:out", &(((_ns1__findByPK2Response*)a)->out), "ns4:DictionaryVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK2Response, 0, sizeof(_ns1__findByPK2Response), 0, soap_copy__ns1__findByPK2Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK2Response * SOAP_FMAC6 soap_new__ns1__findByPK2Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK2Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK2Response(struct soap *soap, _ns1__findByPK2Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK2Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK2Response;
		if (size)
			*size = sizeof(_ns1__findByPK2Response);
		((_ns1__findByPK2Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK2Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK2Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK2Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK2Response %p -> %p\n", q, p));
	*(_ns1__findByPK2Response*)p = *(_ns1__findByPK2Response*)q;
}

void _ns1__findByPK2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__DictionaryVO(soap, &((_ns1__findByPK2*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK2::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK2*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK2(struct soap *soap, const char *tag, int id, const _ns1__findByPK2 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK2), type);
	soap_out_PointerTons4__DictionaryVO(soap, "ns1:in0", -1, &(((_ns1__findByPK2*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK2 * SOAP_FMAC4 soap_get__ns1__findByPK2(struct soap *soap, _ns1__findByPK2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK2 * SOAP_FMAC4 soap_in__ns1__findByPK2(struct soap *soap, const char *tag, _ns1__findByPK2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK2, sizeof(_ns1__findByPK2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK2 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DictionaryVO(soap, "ns1:in0", &(((_ns1__findByPK2*)a)->in0), "ns4:DictionaryVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK2, 0, sizeof(_ns1__findByPK2), 0, soap_copy__ns1__findByPK2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK2 * SOAP_FMAC6 soap_new__ns1__findByPK2(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK2(struct soap *soap, _ns1__findByPK2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK2 * SOAP_FMAC4 soap_instantiate__ns1__findByPK2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK2;
		if (size)
			*size = sizeof(_ns1__findByPK2);
		((_ns1__findByPK2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK2[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK2);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK2 %p -> %p\n", q, p));
	*(_ns1__findByPK2*)p = *(_ns1__findByPK2*)q;
}

void _ns1__generateSQLQueryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns1__generateSQLQueryResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__generateSQLQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__generateSQLQueryResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__generateSQLQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__generateSQLQueryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__generateSQLQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__generateSQLQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__generateSQLQueryResponse(struct soap *soap, const char *tag, int id, const _ns1__generateSQLQueryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__generateSQLQueryResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTostd__string(soap, "ns1:out", -1, &(((_ns1__generateSQLQueryResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__generateSQLQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__generateSQLQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__generateSQLQueryResponse * SOAP_FMAC4 soap_get__ns1__generateSQLQueryResponse(struct soap *soap, _ns1__generateSQLQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__generateSQLQueryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__generateSQLQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__generateSQLQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__generateSQLQueryResponse * SOAP_FMAC4 soap_in__ns1__generateSQLQueryResponse(struct soap *soap, const char *tag, _ns1__generateSQLQueryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__generateSQLQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__generateSQLQueryResponse, sizeof(_ns1__generateSQLQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__generateSQLQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__generateSQLQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &(((_ns1__generateSQLQueryResponse*)a)->out), "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__generateSQLQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__generateSQLQueryResponse, 0, sizeof(_ns1__generateSQLQueryResponse), 0, soap_copy__ns1__generateSQLQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__generateSQLQueryResponse * SOAP_FMAC6 soap_new__ns1__generateSQLQueryResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__generateSQLQueryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__generateSQLQueryResponse(struct soap *soap, _ns1__generateSQLQueryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__generateSQLQueryResponse * SOAP_FMAC4 soap_instantiate__ns1__generateSQLQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__generateSQLQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__generateSQLQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__generateSQLQueryResponse;
		if (size)
			*size = sizeof(_ns1__generateSQLQueryResponse);
		((_ns1__generateSQLQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__generateSQLQueryResponse[n];
		if (size)
			*size = n * sizeof(_ns1__generateSQLQueryResponse);
		for (int i = 0; i < n; i++)
			((_ns1__generateSQLQueryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__generateSQLQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__generateSQLQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__generateSQLQueryResponse %p -> %p\n", q, p));
	*(_ns1__generateSQLQueryResponse*)p = *(_ns1__generateSQLQueryResponse*)q;
}

void _ns1__generateSQLQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__generateSQLQuery*)this)->in0);
	/* transient soap skipped */
}

void _ns1__generateSQLQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__generateSQLQuery*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__generateSQLQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__generateSQLQuery);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__generateSQLQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__generateSQLQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__generateSQLQuery(struct soap *soap, const char *tag, int id, const _ns1__generateSQLQuery *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__generateSQLQuery), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__generateSQLQuery*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__generateSQLQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__generateSQLQuery(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__generateSQLQuery * SOAP_FMAC4 soap_get__ns1__generateSQLQuery(struct soap *soap, _ns1__generateSQLQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__generateSQLQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__generateSQLQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__generateSQLQuery(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__generateSQLQuery * SOAP_FMAC4 soap_in__ns1__generateSQLQuery(struct soap *soap, const char *tag, _ns1__generateSQLQuery *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__generateSQLQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__generateSQLQuery, sizeof(_ns1__generateSQLQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__generateSQLQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__generateSQLQuery *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__generateSQLQuery*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__generateSQLQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__generateSQLQuery, 0, sizeof(_ns1__generateSQLQuery), 0, soap_copy__ns1__generateSQLQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__generateSQLQuery * SOAP_FMAC6 soap_new__ns1__generateSQLQuery(struct soap *soap, int n)
{	return soap_instantiate__ns1__generateSQLQuery(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__generateSQLQuery(struct soap *soap, _ns1__generateSQLQuery *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__generateSQLQuery * SOAP_FMAC4 soap_instantiate__ns1__generateSQLQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__generateSQLQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__generateSQLQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__generateSQLQuery;
		if (size)
			*size = sizeof(_ns1__generateSQLQuery);
		((_ns1__generateSQLQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__generateSQLQuery[n];
		if (size)
			*size = n * sizeof(_ns1__generateSQLQuery);
		for (int i = 0; i < n; i++)
			((_ns1__generateSQLQuery*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__generateSQLQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__generateSQLQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__generateSQLQuery %p -> %p\n", q, p));
	*(_ns1__generateSQLQuery*)p = *(_ns1__generateSQLQuery*)q;
}

void _ns1__findBySQLQueryReturnPPTVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfPPTVO(soap, &((_ns1__findBySQLQueryReturnPPTVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnPPTVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnPPTVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnPPTVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnPPTVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnPPTVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnPPTVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfPPTVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnPPTVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnPPTVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnPPTVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnPPTVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnPPTVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnPPTVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnPPTVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse, sizeof(_ns1__findBySQLQueryReturnPPTVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnPPTVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfPPTVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnPPTVOResponse*)a)->out), "ns4:ArrayOfPPTVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnPPTVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnPPTVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnPPTVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnPPTVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnPPTVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnPPTVOResponse);
		((_ns1__findBySQLQueryReturnPPTVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnPPTVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnPPTVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnPPTVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnPPTVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnPPTVOResponse*)p = *(_ns1__findBySQLQueryReturnPPTVOResponse*)q;
}

void _ns1__findBySQLQueryReturnPPTVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnPPTVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnPPTVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnPPTVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnPPTVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnPPTVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnPPTVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnPPTVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnPPTVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnPPTVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnPPTVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnPPTVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnPPTVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnPPTVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnPPTVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnPPTVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO, sizeof(_ns1__findBySQLQueryReturnPPTVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnPPTVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnPPTVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO, 0, sizeof(_ns1__findBySQLQueryReturnPPTVO), 0, soap_copy__ns1__findBySQLQueryReturnPPTVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnPPTVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnPPTVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnPPTVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnPPTVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnPPTVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnPPTVO);
		((_ns1__findBySQLQueryReturnPPTVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnPPTVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnPPTVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnPPTVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnPPTVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnPPTVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnPPTVO*)p = *(_ns1__findBySQLQueryReturnPPTVO*)q;
}

void _ns1__findBySQLQueryReturnContainerVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfContainerVO(soap, &((_ns1__findBySQLQueryReturnContainerVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnContainerVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnContainerVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnContainerVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnContainerVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnContainerVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnContainerVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfContainerVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnContainerVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnContainerVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnContainerVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnContainerVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnContainerVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnContainerVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnContainerVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnContainerVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnContainerVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse, sizeof(_ns1__findBySQLQueryReturnContainerVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnContainerVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfContainerVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnContainerVOResponse*)a)->out), "ns4:ArrayOfContainerVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnContainerVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnContainerVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnContainerVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnContainerVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnContainerVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnContainerVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnContainerVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnContainerVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnContainerVOResponse);
		((_ns1__findBySQLQueryReturnContainerVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnContainerVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnContainerVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnContainerVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnContainerVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnContainerVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnContainerVOResponse*)p = *(_ns1__findBySQLQueryReturnContainerVOResponse*)q;
}

void _ns1__findBySQLQueryReturnContainerVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnContainerVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnContainerVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnContainerVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnContainerVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnContainerVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnContainerVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnContainerVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnContainerVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnContainerVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnContainerVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnContainerVO(struct soap *soap, _ns1__findBySQLQueryReturnContainerVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnContainerVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnContainerVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnContainerVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnContainerVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnContainerVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO, sizeof(_ns1__findBySQLQueryReturnContainerVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnContainerVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnContainerVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnContainerVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO, 0, sizeof(_ns1__findBySQLQueryReturnContainerVO), 0, soap_copy__ns1__findBySQLQueryReturnContainerVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnContainerVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnContainerVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnContainerVO(struct soap *soap, _ns1__findBySQLQueryReturnContainerVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnContainerVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnContainerVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnContainerVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnContainerVO);
		((_ns1__findBySQLQueryReturnContainerVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnContainerVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnContainerVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnContainerVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnContainerVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnContainerVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnContainerVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnContainerVO*)p = *(_ns1__findBySQLQueryReturnContainerVO*)q;
}

void _ns1__create6Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EntityVO(soap, &((_ns1__create6Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create6Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create6Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create6Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create6Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create6Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create6Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create6Response(struct soap *soap, const char *tag, int id, const _ns1__create6Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create6Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__EntityVO(soap, "ns1:out", -1, &(((_ns1__create6Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create6Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create6Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create6Response * SOAP_FMAC4 soap_get__ns1__create6Response(struct soap *soap, _ns1__create6Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create6Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create6Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create6Response * SOAP_FMAC4 soap_in__ns1__create6Response(struct soap *soap, const char *tag, _ns1__create6Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create6Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create6Response, sizeof(_ns1__create6Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create6Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create6Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns1:out", &(((_ns1__create6Response*)a)->out), "ns4:EntityVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create6Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create6Response, 0, sizeof(_ns1__create6Response), 0, soap_copy__ns1__create6Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create6Response * SOAP_FMAC6 soap_new__ns1__create6Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create6Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create6Response(struct soap *soap, _ns1__create6Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create6Response * SOAP_FMAC4 soap_instantiate__ns1__create6Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create6Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create6Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create6Response;
		if (size)
			*size = sizeof(_ns1__create6Response);
		((_ns1__create6Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create6Response[n];
		if (size)
			*size = n * sizeof(_ns1__create6Response);
		for (int i = 0; i < n; i++)
			((_ns1__create6Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create6Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create6Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create6Response %p -> %p\n", q, p));
	*(_ns1__create6Response*)p = *(_ns1__create6Response*)q;
}

void _ns1__create6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EntityVO(soap, &((_ns1__create6*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create6::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create6*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create6);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create6(struct soap *soap, const char *tag, int id, const _ns1__create6 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create6), type);
	soap_out_PointerTons4__EntityVO(soap, "ns1:in0", -1, &(((_ns1__create6*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create6(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create6 * SOAP_FMAC4 soap_get__ns1__create6(struct soap *soap, _ns1__create6 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create6::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create6(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create6 * SOAP_FMAC4 soap_in__ns1__create6(struct soap *soap, const char *tag, _ns1__create6 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create6 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create6, sizeof(_ns1__create6), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create6)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create6 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns1:in0", &(((_ns1__create6*)a)->in0), "ns4:EntityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create6, 0, sizeof(_ns1__create6), 0, soap_copy__ns1__create6);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create6 * SOAP_FMAC6 soap_new__ns1__create6(struct soap *soap, int n)
{	return soap_instantiate__ns1__create6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create6(struct soap *soap, _ns1__create6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create6 * SOAP_FMAC4 soap_instantiate__ns1__create6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create6;
		if (size)
			*size = sizeof(_ns1__create6);
		((_ns1__create6*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create6[n];
		if (size)
			*size = n * sizeof(_ns1__create6);
		for (int i = 0; i < n; i++)
			((_ns1__create6*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create6 %p -> %p\n", q, p));
	*(_ns1__create6*)p = *(_ns1__create6*)q;
}

void _ns1__findByPK5Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ESignatureVO(soap, &((_ns1__findByPK5Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK5Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK5Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK5Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK5Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK5Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK5Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK5Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK5Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK5Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ESignatureVO(soap, "ns1:out", -1, &(((_ns1__findByPK5Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK5Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK5Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK5Response * SOAP_FMAC4 soap_get__ns1__findByPK5Response(struct soap *soap, _ns1__findByPK5Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK5Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK5Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK5Response * SOAP_FMAC4 soap_in__ns1__findByPK5Response(struct soap *soap, const char *tag, _ns1__findByPK5Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK5Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK5Response, sizeof(_ns1__findByPK5Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK5Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK5Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ESignatureVO(soap, "ns1:out", &(((_ns1__findByPK5Response*)a)->out), "ns4:ESignatureVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK5Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK5Response, 0, sizeof(_ns1__findByPK5Response), 0, soap_copy__ns1__findByPK5Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK5Response * SOAP_FMAC6 soap_new__ns1__findByPK5Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK5Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK5Response(struct soap *soap, _ns1__findByPK5Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK5Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK5Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK5Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK5Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK5Response;
		if (size)
			*size = sizeof(_ns1__findByPK5Response);
		((_ns1__findByPK5Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK5Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK5Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK5Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK5Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK5Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK5Response %p -> %p\n", q, p));
	*(_ns1__findByPK5Response*)p = *(_ns1__findByPK5Response*)q;
}

void _ns1__findByPK5::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ESignatureVO(soap, &((_ns1__findByPK5*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK5::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK5*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK5::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK5);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK5::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK5(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK5(struct soap *soap, const char *tag, int id, const _ns1__findByPK5 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK5), type);
	soap_out_PointerTons4__ESignatureVO(soap, "ns1:in0", -1, &(((_ns1__findByPK5*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK5::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK5(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK5 * SOAP_FMAC4 soap_get__ns1__findByPK5(struct soap *soap, _ns1__findByPK5 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK5::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK5(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK5 * SOAP_FMAC4 soap_in__ns1__findByPK5(struct soap *soap, const char *tag, _ns1__findByPK5 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK5 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK5, sizeof(_ns1__findByPK5), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK5)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK5 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ESignatureVO(soap, "ns1:in0", &(((_ns1__findByPK5*)a)->in0), "ns4:ESignatureVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK5 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK5, 0, sizeof(_ns1__findByPK5), 0, soap_copy__ns1__findByPK5);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK5 * SOAP_FMAC6 soap_new__ns1__findByPK5(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK5(struct soap *soap, _ns1__findByPK5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK5 * SOAP_FMAC4 soap_instantiate__ns1__findByPK5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK5;
		if (size)
			*size = sizeof(_ns1__findByPK5);
		((_ns1__findByPK5*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK5[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK5);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK5*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK5 %p -> %p\n", q, p));
	*(_ns1__findByPK5*)p = *(_ns1__findByPK5*)q;
}

void _ns1__findBySQLQueryReturnPPTSlideVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfPPTSlideVO(soap, &((_ns1__findBySQLQueryReturnPPTSlideVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnPPTSlideVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnPPTSlideVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnPPTSlideVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnPPTSlideVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnPPTSlideVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfPPTSlideVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnPPTSlideVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnPPTSlideVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnPPTSlideVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTSlideVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnPPTSlideVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse, sizeof(_ns1__findBySQLQueryReturnPPTSlideVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnPPTSlideVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfPPTSlideVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnPPTSlideVOResponse*)a)->out), "ns4:ArrayOfPPTSlideVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTSlideVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnPPTSlideVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnPPTSlideVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnPPTSlideVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTSlideVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnPPTSlideVOResponse);
		((_ns1__findBySQLQueryReturnPPTSlideVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTSlideVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnPPTSlideVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnPPTSlideVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnPPTSlideVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnPPTSlideVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnPPTSlideVOResponse*)p = *(_ns1__findBySQLQueryReturnPPTSlideVOResponse*)q;
}

void _ns1__findBySQLQueryReturnPPTSlideVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnPPTSlideVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnPPTSlideVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnPPTSlideVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnPPTSlideVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnPPTSlideVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnPPTSlideVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnPPTSlideVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnPPTSlideVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnPPTSlideVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnPPTSlideVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTSlideVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnPPTSlideVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO, sizeof(_ns1__findBySQLQueryReturnPPTSlideVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnPPTSlideVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnPPTSlideVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTSlideVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO, 0, sizeof(_ns1__findBySQLQueryReturnPPTSlideVO), 0, soap_copy__ns1__findBySQLQueryReturnPPTSlideVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTSlideVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnPPTSlideVO);
		((_ns1__findBySQLQueryReturnPPTSlideVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnPPTSlideVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnPPTSlideVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnPPTSlideVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnPPTSlideVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnPPTSlideVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnPPTSlideVO*)p = *(_ns1__findBySQLQueryReturnPPTSlideVO*)q;
}

void _ns1__update4Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update4Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update4Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update4Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update4Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update4Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update4Response(struct soap *soap, const char *tag, int id, const _ns1__update4Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update4Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update4Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update4Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update4Response * SOAP_FMAC4 soap_get__ns1__update4Response(struct soap *soap, _ns1__update4Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update4Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update4Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update4Response * SOAP_FMAC4 soap_in__ns1__update4Response(struct soap *soap, const char *tag, _ns1__update4Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update4Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update4Response, sizeof(_ns1__update4Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update4Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update4Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update4Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update4Response, 0, sizeof(_ns1__update4Response), 0, soap_copy__ns1__update4Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update4Response * SOAP_FMAC6 soap_new__ns1__update4Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update4Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update4Response(struct soap *soap, _ns1__update4Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update4Response * SOAP_FMAC4 soap_instantiate__ns1__update4Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update4Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update4Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update4Response;
		if (size)
			*size = sizeof(_ns1__update4Response);
		((_ns1__update4Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update4Response[n];
		if (size)
			*size = n * sizeof(_ns1__update4Response);
		for (int i = 0; i < n; i++)
			((_ns1__update4Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update4Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update4Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update4Response %p -> %p\n", q, p));
	*(_ns1__update4Response*)p = *(_ns1__update4Response*)q;
}

void _ns1__update4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ERelationVO(soap, &((_ns1__update4*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update4::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update4*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update4);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update4(struct soap *soap, const char *tag, int id, const _ns1__update4 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update4), type);
	soap_out_PointerTons4__ERelationVO(soap, "ns1:in0", -1, &(((_ns1__update4*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update4(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update4 * SOAP_FMAC4 soap_get__ns1__update4(struct soap *soap, _ns1__update4 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update4::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update4(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update4 * SOAP_FMAC4 soap_in__ns1__update4(struct soap *soap, const char *tag, _ns1__update4 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update4 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update4, sizeof(_ns1__update4), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update4)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update4 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ERelationVO(soap, "ns1:in0", &(((_ns1__update4*)a)->in0), "ns4:ERelationVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update4, 0, sizeof(_ns1__update4), 0, soap_copy__ns1__update4);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update4 * SOAP_FMAC6 soap_new__ns1__update4(struct soap *soap, int n)
{	return soap_instantiate__ns1__update4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update4(struct soap *soap, _ns1__update4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update4 * SOAP_FMAC4 soap_instantiate__ns1__update4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update4;
		if (size)
			*size = sizeof(_ns1__update4);
		((_ns1__update4*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update4[n];
		if (size)
			*size = n * sizeof(_ns1__update4);
		for (int i = 0; i < n; i++)
			((_ns1__update4*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update4 %p -> %p\n", q, p));
	*(_ns1__update4*)p = *(_ns1__update4*)q;
}

void _ns1__create8Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ImageVO(soap, &((_ns1__create8Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create8Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create8Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create8Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create8Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create8Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create8Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create8Response(struct soap *soap, const char *tag, int id, const _ns1__create8Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create8Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ImageVO(soap, "ns1:out", -1, &(((_ns1__create8Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create8Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create8Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create8Response * SOAP_FMAC4 soap_get__ns1__create8Response(struct soap *soap, _ns1__create8Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create8Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create8Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create8Response * SOAP_FMAC4 soap_in__ns1__create8Response(struct soap *soap, const char *tag, _ns1__create8Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create8Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create8Response, sizeof(_ns1__create8Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create8Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create8Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ImageVO(soap, "ns1:out", &(((_ns1__create8Response*)a)->out), "ns4:ImageVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create8Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create8Response, 0, sizeof(_ns1__create8Response), 0, soap_copy__ns1__create8Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create8Response * SOAP_FMAC6 soap_new__ns1__create8Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create8Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create8Response(struct soap *soap, _ns1__create8Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create8Response * SOAP_FMAC4 soap_instantiate__ns1__create8Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create8Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create8Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create8Response;
		if (size)
			*size = sizeof(_ns1__create8Response);
		((_ns1__create8Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create8Response[n];
		if (size)
			*size = n * sizeof(_ns1__create8Response);
		for (int i = 0; i < n; i++)
			((_ns1__create8Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create8Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create8Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create8Response %p -> %p\n", q, p));
	*(_ns1__create8Response*)p = *(_ns1__create8Response*)q;
}

void _ns1__create8::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ImageVO(soap, &((_ns1__create8*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create8::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create8*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create8::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create8);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create8::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create8(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create8(struct soap *soap, const char *tag, int id, const _ns1__create8 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create8), type);
	soap_out_PointerTons4__ImageVO(soap, "ns1:in0", -1, &(((_ns1__create8*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create8::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create8(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create8 * SOAP_FMAC4 soap_get__ns1__create8(struct soap *soap, _ns1__create8 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create8::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create8(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create8 * SOAP_FMAC4 soap_in__ns1__create8(struct soap *soap, const char *tag, _ns1__create8 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create8 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create8, sizeof(_ns1__create8), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create8)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create8 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ImageVO(soap, "ns1:in0", &(((_ns1__create8*)a)->in0), "ns4:ImageVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create8 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create8, 0, sizeof(_ns1__create8), 0, soap_copy__ns1__create8);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create8 * SOAP_FMAC6 soap_new__ns1__create8(struct soap *soap, int n)
{	return soap_instantiate__ns1__create8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create8(struct soap *soap, _ns1__create8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create8 * SOAP_FMAC4 soap_instantiate__ns1__create8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create8;
		if (size)
			*size = sizeof(_ns1__create8);
		((_ns1__create8*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create8[n];
		if (size)
			*size = n * sizeof(_ns1__create8);
		for (int i = 0; i < n; i++)
			((_ns1__create8*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create8 %p -> %p\n", q, p));
	*(_ns1__create8*)p = *(_ns1__create8*)q;
}

void _ns1__findByPK8Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ImageVO(soap, &((_ns1__findByPK8Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__findByPK8Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK8Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK8Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK8Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK8Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK8Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK8Response(struct soap *soap, const char *tag, int id, const _ns1__findByPK8Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK8Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ImageVO(soap, "ns1:out", -1, &(((_ns1__findByPK8Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK8Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK8Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK8Response * SOAP_FMAC4 soap_get__ns1__findByPK8Response(struct soap *soap, _ns1__findByPK8Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK8Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK8Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK8Response * SOAP_FMAC4 soap_in__ns1__findByPK8Response(struct soap *soap, const char *tag, _ns1__findByPK8Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK8Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK8Response, sizeof(_ns1__findByPK8Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK8Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK8Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ImageVO(soap, "ns1:out", &(((_ns1__findByPK8Response*)a)->out), "ns4:ImageVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK8Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK8Response, 0, sizeof(_ns1__findByPK8Response), 0, soap_copy__ns1__findByPK8Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK8Response * SOAP_FMAC6 soap_new__ns1__findByPK8Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK8Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK8Response(struct soap *soap, _ns1__findByPK8Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK8Response * SOAP_FMAC4 soap_instantiate__ns1__findByPK8Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK8Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK8Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK8Response;
		if (size)
			*size = sizeof(_ns1__findByPK8Response);
		((_ns1__findByPK8Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK8Response[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK8Response);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK8Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK8Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK8Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK8Response %p -> %p\n", q, p));
	*(_ns1__findByPK8Response*)p = *(_ns1__findByPK8Response*)q;
}

void _ns1__findByPK8::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ImageVO(soap, &((_ns1__findByPK8*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findByPK8::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findByPK8*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findByPK8::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findByPK8);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findByPK8::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findByPK8(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findByPK8(struct soap *soap, const char *tag, int id, const _ns1__findByPK8 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findByPK8), type);
	soap_out_PointerTons4__ImageVO(soap, "ns1:in0", -1, &(((_ns1__findByPK8*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findByPK8::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findByPK8(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findByPK8 * SOAP_FMAC4 soap_get__ns1__findByPK8(struct soap *soap, _ns1__findByPK8 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findByPK8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findByPK8::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findByPK8(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findByPK8 * SOAP_FMAC4 soap_in__ns1__findByPK8(struct soap *soap, const char *tag, _ns1__findByPK8 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findByPK8 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findByPK8, sizeof(_ns1__findByPK8), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findByPK8)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findByPK8 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ImageVO(soap, "ns1:in0", &(((_ns1__findByPK8*)a)->in0), "ns4:ImageVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK8 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findByPK8, 0, sizeof(_ns1__findByPK8), 0, soap_copy__ns1__findByPK8);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findByPK8 * SOAP_FMAC6 soap_new__ns1__findByPK8(struct soap *soap, int n)
{	return soap_instantiate__ns1__findByPK8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findByPK8(struct soap *soap, _ns1__findByPK8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findByPK8 * SOAP_FMAC4 soap_instantiate__ns1__findByPK8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findByPK8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findByPK8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findByPK8;
		if (size)
			*size = sizeof(_ns1__findByPK8);
		((_ns1__findByPK8*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findByPK8[n];
		if (size)
			*size = n * sizeof(_ns1__findByPK8);
		for (int i = 0; i < n; i++)
			((_ns1__findByPK8*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findByPK8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findByPK8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findByPK8 %p -> %p\n", q, p));
	*(_ns1__findByPK8*)p = *(_ns1__findByPK8*)q;
}

void _ns1__findBySQLQueryReturnEActivityVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfEActivityVO(soap, &((_ns1__findBySQLQueryReturnEActivityVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnEActivityVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnEActivityVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnEActivityVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnEActivityVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnEActivityVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnEActivityVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfEActivityVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnEActivityVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnEActivityVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnEActivityVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnEActivityVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnEActivityVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnEActivityVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEActivityVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnEActivityVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse, sizeof(_ns1__findBySQLQueryReturnEActivityVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnEActivityVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfEActivityVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnEActivityVOResponse*)a)->out), "ns4:ArrayOfEActivityVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEActivityVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnEActivityVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnEActivityVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnEActivityVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnEActivityVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnEActivityVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEActivityVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnEActivityVOResponse);
		((_ns1__findBySQLQueryReturnEActivityVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEActivityVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnEActivityVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnEActivityVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnEActivityVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnEActivityVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnEActivityVOResponse*)p = *(_ns1__findBySQLQueryReturnEActivityVOResponse*)q;
}

void _ns1__findBySQLQueryReturnEActivityVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnEActivityVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnEActivityVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnEActivityVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnEActivityVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnEActivityVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnEActivityVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnEActivityVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnEActivityVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnEActivityVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnEActivityVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnEActivityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnEActivityVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnEActivityVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEActivityVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnEActivityVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO, sizeof(_ns1__findBySQLQueryReturnEActivityVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnEActivityVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnEActivityVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEActivityVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO, 0, sizeof(_ns1__findBySQLQueryReturnEActivityVO), 0, soap_copy__ns1__findBySQLQueryReturnEActivityVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnEActivityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnEActivityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEActivityVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnEActivityVO);
		((_ns1__findBySQLQueryReturnEActivityVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnEActivityVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnEActivityVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnEActivityVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnEActivityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnEActivityVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnEActivityVO*)p = *(_ns1__findBySQLQueryReturnEActivityVO*)q;
}

void _ns1__remove9Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove9Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove9Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove9Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove9Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove9Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove9Response(struct soap *soap, const char *tag, int id, const _ns1__remove9Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove9Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove9Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove9Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove9Response * SOAP_FMAC4 soap_get__ns1__remove9Response(struct soap *soap, _ns1__remove9Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove9Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove9Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove9Response * SOAP_FMAC4 soap_in__ns1__remove9Response(struct soap *soap, const char *tag, _ns1__remove9Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove9Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove9Response, sizeof(_ns1__remove9Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove9Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove9Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove9Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove9Response, 0, sizeof(_ns1__remove9Response), 0, soap_copy__ns1__remove9Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove9Response * SOAP_FMAC6 soap_new__ns1__remove9Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove9Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove9Response(struct soap *soap, _ns1__remove9Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove9Response * SOAP_FMAC4 soap_instantiate__ns1__remove9Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove9Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove9Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove9Response;
		if (size)
			*size = sizeof(_ns1__remove9Response);
		((_ns1__remove9Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove9Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove9Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove9Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove9Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove9Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove9Response %p -> %p\n", q, p));
	*(_ns1__remove9Response*)p = *(_ns1__remove9Response*)q;
}

void _ns1__remove9::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PPTSlideVO(soap, &((_ns1__remove9*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove9::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove9*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove9::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove9);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove9::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove9(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove9(struct soap *soap, const char *tag, int id, const _ns1__remove9 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove9), type);
	soap_out_PointerTons4__PPTSlideVO(soap, "ns1:in0", -1, &(((_ns1__remove9*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove9::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove9(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove9 * SOAP_FMAC4 soap_get__ns1__remove9(struct soap *soap, _ns1__remove9 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove9::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove9(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove9 * SOAP_FMAC4 soap_in__ns1__remove9(struct soap *soap, const char *tag, _ns1__remove9 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove9 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove9, sizeof(_ns1__remove9), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove9)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove9 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PPTSlideVO(soap, "ns1:in0", &(((_ns1__remove9*)a)->in0), "ns4:PPTSlideVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove9 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove9, 0, sizeof(_ns1__remove9), 0, soap_copy__ns1__remove9);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove9 * SOAP_FMAC6 soap_new__ns1__remove9(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove9(struct soap *soap, _ns1__remove9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove9 * SOAP_FMAC4 soap_instantiate__ns1__remove9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove9;
		if (size)
			*size = sizeof(_ns1__remove9);
		((_ns1__remove9*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove9[n];
		if (size)
			*size = n * sizeof(_ns1__remove9);
		for (int i = 0; i < n; i++)
			((_ns1__remove9*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove9 %p -> %p\n", q, p));
	*(_ns1__remove9*)p = *(_ns1__remove9*)q;
}

void _ns1__create11Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserVO(soap, &((_ns1__create11Response*)this)->out);
	/* transient soap skipped */
}

void _ns1__create11Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create11Response*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__create11Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create11Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create11Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create11Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create11Response(struct soap *soap, const char *tag, int id, const _ns1__create11Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create11Response), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__UserVO(soap, "ns1:out", -1, &(((_ns1__create11Response*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create11Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create11Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create11Response * SOAP_FMAC4 soap_get__ns1__create11Response(struct soap *soap, _ns1__create11Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create11Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create11Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create11Response * SOAP_FMAC4 soap_in__ns1__create11Response(struct soap *soap, const char *tag, _ns1__create11Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create11Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create11Response, sizeof(_ns1__create11Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create11Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create11Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns1:out", &(((_ns1__create11Response*)a)->out), "ns4:UserVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create11Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create11Response, 0, sizeof(_ns1__create11Response), 0, soap_copy__ns1__create11Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create11Response * SOAP_FMAC6 soap_new__ns1__create11Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__create11Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create11Response(struct soap *soap, _ns1__create11Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create11Response * SOAP_FMAC4 soap_instantiate__ns1__create11Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create11Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create11Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create11Response;
		if (size)
			*size = sizeof(_ns1__create11Response);
		((_ns1__create11Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create11Response[n];
		if (size)
			*size = n * sizeof(_ns1__create11Response);
		for (int i = 0; i < n; i++)
			((_ns1__create11Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create11Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create11Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create11Response %p -> %p\n", q, p));
	*(_ns1__create11Response*)p = *(_ns1__create11Response*)q;
}

void _ns1__create11::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserVO(soap, &((_ns1__create11*)this)->in0);
	/* transient soap skipped */
}

void _ns1__create11::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__create11*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__create11::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__create11);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__create11::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__create11(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__create11(struct soap *soap, const char *tag, int id, const _ns1__create11 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__create11), type);
	soap_out_PointerTons4__UserVO(soap, "ns1:in0", -1, &(((_ns1__create11*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__create11::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__create11(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__create11 * SOAP_FMAC4 soap_get__ns1__create11(struct soap *soap, _ns1__create11 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__create11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__create11::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__create11(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__create11 * SOAP_FMAC4 soap_in__ns1__create11(struct soap *soap, const char *tag, _ns1__create11 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__create11 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__create11, sizeof(_ns1__create11), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__create11)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__create11 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserVO(soap, "ns1:in0", &(((_ns1__create11*)a)->in0), "ns4:UserVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__create11 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__create11, 0, sizeof(_ns1__create11), 0, soap_copy__ns1__create11);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__create11 * SOAP_FMAC6 soap_new__ns1__create11(struct soap *soap, int n)
{	return soap_instantiate__ns1__create11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__create11(struct soap *soap, _ns1__create11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__create11 * SOAP_FMAC4 soap_instantiate__ns1__create11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__create11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__create11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__create11;
		if (size)
			*size = sizeof(_ns1__create11);
		((_ns1__create11*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__create11[n];
		if (size)
			*size = n * sizeof(_ns1__create11);
		for (int i = 0; i < n; i++)
			((_ns1__create11*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__create11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__create11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__create11 %p -> %p\n", q, p));
	*(_ns1__create11*)p = *(_ns1__create11*)q;
}

void _ns1__update3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__update3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__update3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update3Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update3Response(struct soap *soap, const char *tag, int id, const _ns1__update3Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update3Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update3Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update3Response * SOAP_FMAC4 soap_get__ns1__update3Response(struct soap *soap, _ns1__update3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update3Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update3Response * SOAP_FMAC4 soap_in__ns1__update3Response(struct soap *soap, const char *tag, _ns1__update3Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update3Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update3Response, sizeof(_ns1__update3Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update3Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update3Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update3Response, 0, sizeof(_ns1__update3Response), 0, soap_copy__ns1__update3Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update3Response * SOAP_FMAC6 soap_new__ns1__update3Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__update3Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update3Response(struct soap *soap, _ns1__update3Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update3Response * SOAP_FMAC4 soap_instantiate__ns1__update3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update3Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update3Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update3Response;
		if (size)
			*size = sizeof(_ns1__update3Response);
		((_ns1__update3Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update3Response[n];
		if (size)
			*size = n * sizeof(_ns1__update3Response);
		for (int i = 0; i < n; i++)
			((_ns1__update3Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update3Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update3Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update3Response %p -> %p\n", q, p));
	*(_ns1__update3Response*)p = *(_ns1__update3Response*)q;
}

void _ns1__update3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EActivityVO(soap, &((_ns1__update3*)this)->in0);
	/* transient soap skipped */
}

void _ns1__update3::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__update3*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__update3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__update3);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__update3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__update3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__update3(struct soap *soap, const char *tag, int id, const _ns1__update3 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__update3), type);
	soap_out_PointerTons4__EActivityVO(soap, "ns1:in0", -1, &(((_ns1__update3*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__update3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__update3(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__update3 * SOAP_FMAC4 soap_get__ns1__update3(struct soap *soap, _ns1__update3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__update3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__update3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__update3(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__update3 * SOAP_FMAC4 soap_in__ns1__update3(struct soap *soap, const char *tag, _ns1__update3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__update3 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__update3, sizeof(_ns1__update3), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__update3)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__update3 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EActivityVO(soap, "ns1:in0", &(((_ns1__update3*)a)->in0), "ns4:EActivityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__update3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__update3, 0, sizeof(_ns1__update3), 0, soap_copy__ns1__update3);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__update3 * SOAP_FMAC6 soap_new__ns1__update3(struct soap *soap, int n)
{	return soap_instantiate__ns1__update3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__update3(struct soap *soap, _ns1__update3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__update3 * SOAP_FMAC4 soap_instantiate__ns1__update3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__update3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__update3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__update3;
		if (size)
			*size = sizeof(_ns1__update3);
		((_ns1__update3*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__update3[n];
		if (size)
			*size = n * sizeof(_ns1__update3);
		for (int i = 0; i < n; i++)
			((_ns1__update3*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__update3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__update3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__update3 %p -> %p\n", q, p));
	*(_ns1__update3*)p = *(_ns1__update3*)q;
}

void _ns1__remove6Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove6Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove6Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove6Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove6Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove6Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove6Response(struct soap *soap, const char *tag, int id, const _ns1__remove6Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove6Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove6Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove6Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove6Response * SOAP_FMAC4 soap_get__ns1__remove6Response(struct soap *soap, _ns1__remove6Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove6Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove6Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove6Response * SOAP_FMAC4 soap_in__ns1__remove6Response(struct soap *soap, const char *tag, _ns1__remove6Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove6Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove6Response, sizeof(_ns1__remove6Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove6Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove6Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove6Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove6Response, 0, sizeof(_ns1__remove6Response), 0, soap_copy__ns1__remove6Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove6Response * SOAP_FMAC6 soap_new__ns1__remove6Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove6Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove6Response(struct soap *soap, _ns1__remove6Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove6Response * SOAP_FMAC4 soap_instantiate__ns1__remove6Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove6Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove6Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove6Response;
		if (size)
			*size = sizeof(_ns1__remove6Response);
		((_ns1__remove6Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove6Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove6Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove6Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove6Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove6Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove6Response %p -> %p\n", q, p));
	*(_ns1__remove6Response*)p = *(_ns1__remove6Response*)q;
}

void _ns1__remove6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EntityVO(soap, &((_ns1__remove6*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove6::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove6*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove6);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove6(struct soap *soap, const char *tag, int id, const _ns1__remove6 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove6), type);
	soap_out_PointerTons4__EntityVO(soap, "ns1:in0", -1, &(((_ns1__remove6*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove6(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove6 * SOAP_FMAC4 soap_get__ns1__remove6(struct soap *soap, _ns1__remove6 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove6::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove6(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove6 * SOAP_FMAC4 soap_in__ns1__remove6(struct soap *soap, const char *tag, _ns1__remove6 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove6 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove6, sizeof(_ns1__remove6), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove6)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove6 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EntityVO(soap, "ns1:in0", &(((_ns1__remove6*)a)->in0), "ns4:EntityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove6, 0, sizeof(_ns1__remove6), 0, soap_copy__ns1__remove6);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove6 * SOAP_FMAC6 soap_new__ns1__remove6(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove6(struct soap *soap, _ns1__remove6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove6 * SOAP_FMAC4 soap_instantiate__ns1__remove6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove6;
		if (size)
			*size = sizeof(_ns1__remove6);
		((_ns1__remove6*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove6[n];
		if (size)
			*size = n * sizeof(_ns1__remove6);
		for (int i = 0; i < n; i++)
			((_ns1__remove6*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove6 %p -> %p\n", q, p));
	*(_ns1__remove6*)p = *(_ns1__remove6*)q;
}

void _ns1__remove3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ns1__remove3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__remove3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove3Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove3Response(struct soap *soap, const char *tag, int id, const _ns1__remove3Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove3Response), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove3Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove3Response * SOAP_FMAC4 soap_get__ns1__remove3Response(struct soap *soap, _ns1__remove3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove3Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove3Response * SOAP_FMAC4 soap_in__ns1__remove3Response(struct soap *soap, const char *tag, _ns1__remove3Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove3Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove3Response, sizeof(_ns1__remove3Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove3Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove3Response *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove3Response, 0, sizeof(_ns1__remove3Response), 0, soap_copy__ns1__remove3Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove3Response * SOAP_FMAC6 soap_new__ns1__remove3Response(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove3Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove3Response(struct soap *soap, _ns1__remove3Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove3Response * SOAP_FMAC4 soap_instantiate__ns1__remove3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove3Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove3Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove3Response;
		if (size)
			*size = sizeof(_ns1__remove3Response);
		((_ns1__remove3Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove3Response[n];
		if (size)
			*size = n * sizeof(_ns1__remove3Response);
		for (int i = 0; i < n; i++)
			((_ns1__remove3Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove3Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove3Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove3Response %p -> %p\n", q, p));
	*(_ns1__remove3Response*)p = *(_ns1__remove3Response*)q;
}

void _ns1__remove3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__EActivityVO(soap, &((_ns1__remove3*)this)->in0);
	/* transient soap skipped */
}

void _ns1__remove3::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__remove3*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__remove3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__remove3);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__remove3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__remove3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__remove3(struct soap *soap, const char *tag, int id, const _ns1__remove3 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__remove3), type);
	soap_out_PointerTons4__EActivityVO(soap, "ns1:in0", -1, &(((_ns1__remove3*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__remove3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__remove3(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__remove3 * SOAP_FMAC4 soap_get__ns1__remove3(struct soap *soap, _ns1__remove3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__remove3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__remove3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__remove3(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__remove3 * SOAP_FMAC4 soap_in__ns1__remove3(struct soap *soap, const char *tag, _ns1__remove3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__remove3 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__remove3, sizeof(_ns1__remove3), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__remove3)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__remove3 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EActivityVO(soap, "ns1:in0", &(((_ns1__remove3*)a)->in0), "ns4:EActivityVO"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__remove3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__remove3, 0, sizeof(_ns1__remove3), 0, soap_copy__ns1__remove3);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__remove3 * SOAP_FMAC6 soap_new__ns1__remove3(struct soap *soap, int n)
{	return soap_instantiate__ns1__remove3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__remove3(struct soap *soap, _ns1__remove3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__remove3 * SOAP_FMAC4 soap_instantiate__ns1__remove3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__remove3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__remove3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__remove3;
		if (size)
			*size = sizeof(_ns1__remove3);
		((_ns1__remove3*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__remove3[n];
		if (size)
			*size = n * sizeof(_ns1__remove3);
		for (int i = 0; i < n; i++)
			((_ns1__remove3*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__remove3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__remove3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__remove3 %p -> %p\n", q, p));
	*(_ns1__remove3*)p = *(_ns1__remove3*)q;
}

void _ns1__findBySQLQueryReturnFeedbackVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfFeedbackVO(soap, &((_ns1__findBySQLQueryReturnFeedbackVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnFeedbackVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnFeedbackVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnFeedbackVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnFeedbackVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnFeedbackVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfFeedbackVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnFeedbackVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnFeedbackVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnFeedbackVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnFeedbackVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnFeedbackVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse, sizeof(_ns1__findBySQLQueryReturnFeedbackVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnFeedbackVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfFeedbackVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnFeedbackVOResponse*)a)->out), "ns4:ArrayOfFeedbackVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnFeedbackVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnFeedbackVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnFeedbackVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnFeedbackVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnFeedbackVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnFeedbackVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnFeedbackVOResponse);
		((_ns1__findBySQLQueryReturnFeedbackVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnFeedbackVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnFeedbackVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnFeedbackVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnFeedbackVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnFeedbackVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnFeedbackVOResponse*)p = *(_ns1__findBySQLQueryReturnFeedbackVOResponse*)q;
}

void _ns1__findBySQLQueryReturnFeedbackVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnFeedbackVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnFeedbackVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnFeedbackVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnFeedbackVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnFeedbackVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnFeedbackVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnFeedbackVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnFeedbackVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnFeedbackVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnFeedbackVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnFeedbackVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnFeedbackVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnFeedbackVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnFeedbackVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnFeedbackVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO, sizeof(_ns1__findBySQLQueryReturnFeedbackVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnFeedbackVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnFeedbackVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnFeedbackVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO, 0, sizeof(_ns1__findBySQLQueryReturnFeedbackVO), 0, soap_copy__ns1__findBySQLQueryReturnFeedbackVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnFeedbackVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnFeedbackVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnFeedbackVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnFeedbackVO);
		((_ns1__findBySQLQueryReturnFeedbackVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnFeedbackVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnFeedbackVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnFeedbackVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnFeedbackVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnFeedbackVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnFeedbackVO*)p = *(_ns1__findBySQLQueryReturnFeedbackVO*)q;
}

void _ns1__findBySQLQueryReturnESignatureVOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfESignatureVO(soap, &((_ns1__findBySQLQueryReturnESignatureVOResponse*)this)->out);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnESignatureVOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnESignatureVOResponse*)this)->out = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnESignatureVOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnESignatureVOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnESignatureVOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnESignatureVOResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse), type);
	if (a->out)
		soap_element_result(soap, "ns1:out");
	soap_out_PointerTons4__ArrayOfESignatureVO(soap, "ns1:out", -1, &(((_ns1__findBySQLQueryReturnESignatureVOResponse*)a)->out), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnESignatureVOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnESignatureVOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVOResponse * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnESignatureVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnESignatureVOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnESignatureVOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVOResponse * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnESignatureVOResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnESignatureVOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse, sizeof(_ns1__findBySQLQueryReturnESignatureVOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnESignatureVOResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfESignatureVO(soap, "ns1:out", &(((_ns1__findBySQLQueryReturnESignatureVOResponse*)a)->out), "ns4:ArrayOfESignatureVO"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnESignatureVOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse, 0, sizeof(_ns1__findBySQLQueryReturnESignatureVOResponse), 0, soap_copy__ns1__findBySQLQueryReturnESignatureVOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnESignatureVOResponse * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnESignatureVOResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVOResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVOResponse * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnESignatureVOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnESignatureVOResponse;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnESignatureVOResponse);
		((_ns1__findBySQLQueryReturnESignatureVOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnESignatureVOResponse[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnESignatureVOResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnESignatureVOResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnESignatureVOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnESignatureVOResponse %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnESignatureVOResponse*)p = *(_ns1__findBySQLQueryReturnESignatureVOResponse*)q;
}

void _ns1__findBySQLQueryReturnESignatureVO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SKSQuery(soap, &((_ns1__findBySQLQueryReturnESignatureVO*)this)->in0);
	/* transient soap skipped */
}

void _ns1__findBySQLQueryReturnESignatureVO::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__findBySQLQueryReturnESignatureVO*)this)->in0 = NULL;
	/* transient soap skipped */
}

int _ns1__findBySQLQueryReturnESignatureVO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findBySQLQueryReturnESignatureVO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findBySQLQueryReturnESignatureVO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const char *tag, int id, const _ns1__findBySQLQueryReturnESignatureVO *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO), type);
	soap_out_PointerTons2__SKSQuery(soap, "ns1:in0", -1, &(((_ns1__findBySQLQueryReturnESignatureVO*)a)->in0), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__findBySQLQueryReturnESignatureVO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findBySQLQueryReturnESignatureVO(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC4 soap_get__ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVO *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findBySQLQueryReturnESignatureVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__findBySQLQueryReturnESignatureVO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findBySQLQueryReturnESignatureVO(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC4 soap_in__ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnESignatureVO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findBySQLQueryReturnESignatureVO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO, sizeof(_ns1__findBySQLQueryReturnESignatureVO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findBySQLQueryReturnESignatureVO *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SKSQuery(soap, "ns1:in0", &(((_ns1__findBySQLQueryReturnESignatureVO*)a)->in0), "ns2:SKSQuery"))
				{	soap_flag_in01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnESignatureVO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO, 0, sizeof(_ns1__findBySQLQueryReturnESignatureVO), 0, soap_copy__ns1__findBySQLQueryReturnESignatureVO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC6 soap_new__ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, int n)
{	return soap_instantiate__ns1__findBySQLQueryReturnESignatureVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC4 soap_instantiate__ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findBySQLQueryReturnESignatureVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnESignatureVO;
		if (size)
			*size = sizeof(_ns1__findBySQLQueryReturnESignatureVO);
		((_ns1__findBySQLQueryReturnESignatureVO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findBySQLQueryReturnESignatureVO[n];
		if (size)
			*size = n * sizeof(_ns1__findBySQLQueryReturnESignatureVO);
		for (int i = 0; i < n; i++)
			((_ns1__findBySQLQueryReturnESignatureVO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findBySQLQueryReturnESignatureVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findBySQLQueryReturnESignatureVO %p -> %p\n", q, p));
	*(_ns1__findBySQLQueryReturnESignatureVO*)p = *(_ns1__findBySQLQueryReturnESignatureVO*)q;
}

void ns1__ArrayOfLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfLONG64(soap, &((ns1__ArrayOfLong*)this)->long_);
	/* transient soap skipped */
}

void ns1__ArrayOfLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfLONG64(soap, &((ns1__ArrayOfLong*)this)->long_);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns1__ArrayOfLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfLong(struct soap *soap, const char *tag, int id, const ns1__ArrayOfLong *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfLong), "ns1:ArrayOfLong");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfLONG64(soap, "ns1:long", -1, &(((ns1__ArrayOfLong*)a)->long_), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfLong(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfLong * SOAP_FMAC4 soap_get_ns1__ArrayOfLong(struct soap *soap, ns1__ArrayOfLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfLong(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfLong * SOAP_FMAC4 soap_in_ns1__ArrayOfLong(struct soap *soap, const char *tag, ns1__ArrayOfLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfLong, sizeof(ns1__ArrayOfLong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfLong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfLong *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "ns1:long", &(((ns1__ArrayOfLong*)a)->long_), "xsd:long"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfLong, 0, sizeof(ns1__ArrayOfLong), 0, soap_copy_ns1__ArrayOfLong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfLong * SOAP_FMAC6 soap_new_ns1__ArrayOfLong(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfLong(struct soap *soap, ns1__ArrayOfLong *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfLong * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfLong;
		if (size)
			*size = sizeof(ns1__ArrayOfLong);
		((ns1__ArrayOfLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfLong[n];
		if (size)
			*size = n * sizeof(ns1__ArrayOfLong);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfLong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfLong %p -> %p\n", q, p));
	*(ns1__ArrayOfLong*)p = *(ns1__ArrayOfLong*)q;
}

void ns1__ArrayOfDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftime(soap, &((ns1__ArrayOfDateTime*)this)->dateTime);
	/* transient soap skipped */
}

void ns1__ArrayOfDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftime(soap, &((ns1__ArrayOfDateTime*)this)->dateTime);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns1__ArrayOfDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDateTime(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDateTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDateTime), "ns1:ArrayOfDateTime");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOftime(soap, "ns1:dateTime", -1, &(((ns1__ArrayOfDateTime*)a)->dateTime), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDateTime(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDateTime * SOAP_FMAC4 soap_get_ns1__ArrayOfDateTime(struct soap *soap, ns1__ArrayOfDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDateTime(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDateTime * SOAP_FMAC4 soap_in_ns1__ArrayOfDateTime(struct soap *soap, const char *tag, ns1__ArrayOfDateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDateTime, sizeof(ns1__ArrayOfDateTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDateTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDateTime *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftime(soap, "ns1:dateTime", &(((ns1__ArrayOfDateTime*)a)->dateTime), "xsd:dateTime"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDateTime, 0, sizeof(ns1__ArrayOfDateTime), 0, soap_copy_ns1__ArrayOfDateTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfDateTime * SOAP_FMAC6 soap_new_ns1__ArrayOfDateTime(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfDateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfDateTime(struct soap *soap, ns1__ArrayOfDateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfDateTime * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfDateTime;
		if (size)
			*size = sizeof(ns1__ArrayOfDateTime);
		((ns1__ArrayOfDateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfDateTime[n];
		if (size)
			*size = n * sizeof(ns1__ArrayOfDateTime);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDateTime %p -> %p\n", q, p));
	*(ns1__ArrayOfDateTime*)p = *(ns1__ArrayOfDateTime*)q;
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns1__ArrayOfString*)this)->string);
	/* transient soap skipped */
}

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns1__ArrayOfString*)this)->string);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), "ns1:ArrayOfString");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfstd__string(soap, "ns1:string", -1, &(((ns1__ArrayOfString*)a)->string), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:string", &(((ns1__ArrayOfString*)a)->string), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(ns1__ArrayOfString), 0, soap_copy_ns1__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfString * SOAP_FMAC6 soap_new_ns1__ArrayOfString(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfString;
		if (size)
			*size = sizeof(ns1__ArrayOfString);
		((ns1__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfString[n];
		if (size)
			*size = n * sizeof(ns1__ArrayOfString);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfString*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfString %p -> %p\n", q, p));
	*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
}

void ns1__anyType2anyTypeMap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (((ns1__anyType2anyTypeMap*)this)->entry)
	{	int i;
		for (i = 0; i < ((ns1__anyType2anyTypeMap*)this)->__sizeentry; i++)
		{
			soap_embedded(soap, ((ns1__anyType2anyTypeMap*)this)->entry + i, SOAP_TYPE__ns1__anyType2anyTypeMap_entry);
			soap_serialize__ns1__anyType2anyTypeMap_entry(soap, ((ns1__anyType2anyTypeMap*)this)->entry + i);
		}
	}
	/* transient soap skipped */
}

void ns1__anyType2anyTypeMap::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__anyType2anyTypeMap*)this)->__sizeentry = 0;
	((ns1__anyType2anyTypeMap*)this)->entry = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns1__anyType2anyTypeMap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__anyType2anyTypeMap);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__anyType2anyTypeMap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__anyType2anyTypeMap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__anyType2anyTypeMap(struct soap *soap, const char *tag, int id, const ns1__anyType2anyTypeMap *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__anyType2anyTypeMap), "ns1:anyType2anyTypeMap");
	/* transient soap skipped */
	if (((ns1__anyType2anyTypeMap*)a)->entry)
	{	int i;
		for (i = 0; i < ((ns1__anyType2anyTypeMap*)a)->__sizeentry; i++)
			soap_out__ns1__anyType2anyTypeMap_entry(soap, "ns1:entry", -1, ((ns1__anyType2anyTypeMap*)a)->entry + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__anyType2anyTypeMap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__anyType2anyTypeMap(soap, this, tag, type);
}

SOAP_FMAC3 ns1__anyType2anyTypeMap * SOAP_FMAC4 soap_get_ns1__anyType2anyTypeMap(struct soap *soap, ns1__anyType2anyTypeMap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__anyType2anyTypeMap(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__anyType2anyTypeMap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__anyType2anyTypeMap(soap, tag, this, type);
}

SOAP_FMAC3 ns1__anyType2anyTypeMap * SOAP_FMAC4 soap_in_ns1__anyType2anyTypeMap(struct soap *soap, const char *tag, ns1__anyType2anyTypeMap *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__anyType2anyTypeMap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__anyType2anyTypeMap, sizeof(ns1__anyType2anyTypeMap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__anyType2anyTypeMap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__anyType2anyTypeMap *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_entry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
			{	struct _ns1__anyType2anyTypeMap_entry *p;
				soap_new_block(soap);
				for (((ns1__anyType2anyTypeMap*)a)->__sizeentry = 0; !soap_element_begin_in(soap, "ns1:entry", 1, NULL); ((ns1__anyType2anyTypeMap*)a)->__sizeentry++)
				{	p = (struct _ns1__anyType2anyTypeMap_entry *)soap_push_block(soap, sizeof(struct _ns1__anyType2anyTypeMap_entry));
					if (!p)
						return NULL;
					soap_default__ns1__anyType2anyTypeMap_entry(soap, p);
					soap_revert(soap);
					if (!soap_in__ns1__anyType2anyTypeMap_entry(soap, "ns1:entry", p, ""))
						break;
					soap_flag_entry1 = 0;
				}
				((ns1__anyType2anyTypeMap*)a)->entry = (struct _ns1__anyType2anyTypeMap_entry *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__anyType2anyTypeMap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__anyType2anyTypeMap, 0, sizeof(ns1__anyType2anyTypeMap), 0, soap_copy_ns1__anyType2anyTypeMap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__anyType2anyTypeMap * SOAP_FMAC6 soap_new_ns1__anyType2anyTypeMap(struct soap *soap, int n)
{	return soap_instantiate_ns1__anyType2anyTypeMap(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__anyType2anyTypeMap(struct soap *soap, ns1__anyType2anyTypeMap *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__anyType2anyTypeMap * SOAP_FMAC4 soap_instantiate_ns1__anyType2anyTypeMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__anyType2anyTypeMap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__anyType2anyTypeMap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__anyType2anyTypeMap;
		if (size)
			*size = sizeof(ns1__anyType2anyTypeMap);
		((ns1__anyType2anyTypeMap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__anyType2anyTypeMap[n];
		if (size)
			*size = n * sizeof(ns1__anyType2anyTypeMap);
		for (int i = 0; i < n; i++)
			((ns1__anyType2anyTypeMap*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__anyType2anyTypeMap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__anyType2anyTypeMap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__anyType2anyTypeMap %p -> %p\n", q, p));
	*(ns1__anyType2anyTypeMap*)p = *(ns1__anyType2anyTypeMap*)q;
}

void ns3__OperatorIntf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns3__OperatorIntf*)this)->operatorValue);
	/* transient soap skipped */
}

void ns3__OperatorIntf::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns3__OperatorIntf*)this)->operatorValue = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns3__OperatorIntf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__OperatorIntf);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__OperatorIntf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__OperatorIntf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__OperatorIntf(struct soap *soap, const char *tag, int id, const ns3__OperatorIntf *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__OperatorIntf), "ns3:OperatorIntf");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns3:operatorValue", -1, &(((ns3__OperatorIntf*)a)->operatorValue), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__OperatorIntf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__OperatorIntf(soap, this, tag, type);
}

SOAP_FMAC3 ns3__OperatorIntf * SOAP_FMAC4 soap_get_ns3__OperatorIntf(struct soap *soap, ns3__OperatorIntf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__OperatorIntf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__OperatorIntf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__OperatorIntf(soap, tag, this, type);
}

SOAP_FMAC3 ns3__OperatorIntf * SOAP_FMAC4 soap_in_ns3__OperatorIntf(struct soap *soap, const char *tag, ns3__OperatorIntf *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__OperatorIntf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__OperatorIntf, sizeof(ns3__OperatorIntf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__OperatorIntf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__OperatorIntf *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_operatorValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_operatorValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:operatorValue", &(((ns3__OperatorIntf*)a)->operatorValue), "xsd:string"))
				{	soap_flag_operatorValue1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__OperatorIntf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__OperatorIntf, 0, sizeof(ns3__OperatorIntf), 0, soap_copy_ns3__OperatorIntf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__OperatorIntf * SOAP_FMAC6 soap_new_ns3__OperatorIntf(struct soap *soap, int n)
{	return soap_instantiate_ns3__OperatorIntf(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__OperatorIntf(struct soap *soap, ns3__OperatorIntf *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__OperatorIntf * SOAP_FMAC4 soap_instantiate_ns3__OperatorIntf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__OperatorIntf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__OperatorIntf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__OperatorIntf;
		if (size)
			*size = sizeof(ns3__OperatorIntf);
		((ns3__OperatorIntf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__OperatorIntf[n];
		if (size)
			*size = n * sizeof(ns3__OperatorIntf);
		for (int i = 0; i < n; i++)
			((ns3__OperatorIntf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__OperatorIntf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__OperatorIntf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__OperatorIntf %p -> %p\n", q, p));
	*(ns3__OperatorIntf*)p = *(ns3__OperatorIntf*)q;
}

void ns3__ArrayOfDBColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__DBColumn(soap, &((ns3__ArrayOfDBColumn*)this)->DBColumn);
	/* transient soap skipped */
}

void ns3__ArrayOfDBColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__DBColumn(soap, &((ns3__ArrayOfDBColumn*)this)->DBColumn);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns3__ArrayOfDBColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfDBColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfDBColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfDBColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfDBColumn(struct soap *soap, const char *tag, int id, const ns3__ArrayOfDBColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfDBColumn), "ns3:ArrayOfDBColumn");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons3__DBColumn(soap, "ns3:DBColumn", -1, &(((ns3__ArrayOfDBColumn*)a)->DBColumn), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__ArrayOfDBColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfDBColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfDBColumn * SOAP_FMAC4 soap_get_ns3__ArrayOfDBColumn(struct soap *soap, ns3__ArrayOfDBColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfDBColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__ArrayOfDBColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfDBColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfDBColumn * SOAP_FMAC4 soap_in_ns3__ArrayOfDBColumn(struct soap *soap, const char *tag, ns3__ArrayOfDBColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfDBColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfDBColumn, sizeof(ns3__ArrayOfDBColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfDBColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfDBColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__DBColumn(soap, "ns3:DBColumn", &(((ns3__ArrayOfDBColumn*)a)->DBColumn), "ns3:DBColumn"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfDBColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfDBColumn, 0, sizeof(ns3__ArrayOfDBColumn), 0, soap_copy_ns3__ArrayOfDBColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__ArrayOfDBColumn * SOAP_FMAC6 soap_new_ns3__ArrayOfDBColumn(struct soap *soap, int n)
{	return soap_instantiate_ns3__ArrayOfDBColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__ArrayOfDBColumn(struct soap *soap, ns3__ArrayOfDBColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__ArrayOfDBColumn * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfDBColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfDBColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfDBColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfDBColumn;
		if (size)
			*size = sizeof(ns3__ArrayOfDBColumn);
		((ns3__ArrayOfDBColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfDBColumn[n];
		if (size)
			*size = n * sizeof(ns3__ArrayOfDBColumn);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfDBColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfDBColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfDBColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfDBColumn %p -> %p\n", q, p));
	*(ns3__ArrayOfDBColumn*)p = *(ns3__ArrayOfDBColumn*)q;
}

void ns3__SKSObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns3__SKSObject*)this)->DBTableName);
	soap_serialize_PointerTostd__string(soap, &((ns3__SKSObject*)this)->VOName);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns3__SKSObject*)this)->allDBColumns);
	soap_serialize_PointerTons1__anyType2anyTypeMap(soap, &((ns3__SKSObject*)this)->allScalars);
	soap_serialize_PointerTostd__string(soap, &((ns3__SKSObject*)this)->identifier);
	/* transient soap skipped */
}

void ns3__SKSObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns3__SKSObject*)this)->DBTableName = NULL;
	((ns3__SKSObject*)this)->VOName = NULL;
	((ns3__SKSObject*)this)->allDBColumns = NULL;
	((ns3__SKSObject*)this)->allScalars = NULL;
	((ns3__SKSObject*)this)->identifier = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns3__SKSObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__SKSObject);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__SKSObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SKSObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SKSObject(struct soap *soap, const char *tag, int id, const ns3__SKSObject *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SKSObject), "ns3:SKSObject");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns3:DBTableName", -1, &(((ns3__SKSObject*)a)->DBTableName), "");
	soap_out_PointerTostd__string(soap, "ns3:VOName", -1, &(((ns3__SKSObject*)a)->VOName), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns3:allDBColumns", -1, &(((ns3__SKSObject*)a)->allDBColumns), "");
	soap_out_PointerTons1__anyType2anyTypeMap(soap, "ns3:allScalars", -1, &(((ns3__SKSObject*)a)->allScalars), "");
	soap_out_PointerTostd__string(soap, "ns3:identifier", -1, &(((ns3__SKSObject*)a)->identifier), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__SKSObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SKSObject(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SKSObject * SOAP_FMAC4 soap_get_ns3__SKSObject(struct soap *soap, ns3__SKSObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SKSObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__SKSObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SKSObject(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SKSObject * SOAP_FMAC4 soap_in_ns3__SKSObject(struct soap *soap, const char *tag, ns3__SKSObject *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SKSObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SKSObject, sizeof(ns3__SKSObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__SKSObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__SKSObject *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBTableName1 = 1, soap_flag_VOName1 = 1, soap_flag_allDBColumns1 = 1, soap_flag_allScalars1 = 1, soap_flag_identifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:DBTableName", &(((ns3__SKSObject*)a)->DBTableName), "xsd:string"))
				{	soap_flag_DBTableName1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:VOName", &(((ns3__SKSObject*)a)->VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_allDBColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns3:allDBColumns", &(((ns3__SKSObject*)a)->allDBColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_allDBColumns1--;
					continue;
				}
			if (soap_flag_allScalars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__anyType2anyTypeMap(soap, "ns3:allScalars", &(((ns3__SKSObject*)a)->allScalars), "ns1:anyType2anyTypeMap"))
				{	soap_flag_allScalars1--;
					continue;
				}
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:identifier", &(((ns3__SKSObject*)a)->identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__SKSObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SKSObject, 0, sizeof(ns3__SKSObject), 0, soap_copy_ns3__SKSObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__SKSObject * SOAP_FMAC6 soap_new_ns3__SKSObject(struct soap *soap, int n)
{	return soap_instantiate_ns3__SKSObject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__SKSObject(struct soap *soap, ns3__SKSObject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__SKSObject * SOAP_FMAC4 soap_instantiate_ns3__SKSObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__SKSObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__SKSObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__SKSObject;
		if (size)
			*size = sizeof(ns3__SKSObject);
		((ns3__SKSObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__SKSObject[n];
		if (size)
			*size = n * sizeof(ns3__SKSObject);
		for (int i = 0; i < n; i++)
			((ns3__SKSObject*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__SKSObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__SKSObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__SKSObject %p -> %p\n", q, p));
	*(ns3__SKSObject*)p = *(ns3__SKSObject*)q;
}

void ns3__ArrayOfSKSObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__SKSObject(soap, &((ns3__ArrayOfSKSObject*)this)->SKSObject);
	/* transient soap skipped */
}

void ns3__ArrayOfSKSObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__SKSObject(soap, &((ns3__ArrayOfSKSObject*)this)->SKSObject);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns3__ArrayOfSKSObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfSKSObject);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfSKSObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfSKSObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfSKSObject(struct soap *soap, const char *tag, int id, const ns3__ArrayOfSKSObject *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfSKSObject), "ns3:ArrayOfSKSObject");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons3__SKSObject(soap, "ns3:SKSObject", -1, &(((ns3__ArrayOfSKSObject*)a)->SKSObject), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__ArrayOfSKSObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfSKSObject(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfSKSObject * SOAP_FMAC4 soap_get_ns3__ArrayOfSKSObject(struct soap *soap, ns3__ArrayOfSKSObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfSKSObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__ArrayOfSKSObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfSKSObject(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfSKSObject * SOAP_FMAC4 soap_in_ns3__ArrayOfSKSObject(struct soap *soap, const char *tag, ns3__ArrayOfSKSObject *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfSKSObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfSKSObject, sizeof(ns3__ArrayOfSKSObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfSKSObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfSKSObject *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__SKSObject(soap, "ns3:SKSObject", &(((ns3__ArrayOfSKSObject*)a)->SKSObject), "ns3:SKSObject"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfSKSObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfSKSObject, 0, sizeof(ns3__ArrayOfSKSObject), 0, soap_copy_ns3__ArrayOfSKSObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__ArrayOfSKSObject * SOAP_FMAC6 soap_new_ns3__ArrayOfSKSObject(struct soap *soap, int n)
{	return soap_instantiate_ns3__ArrayOfSKSObject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__ArrayOfSKSObject(struct soap *soap, ns3__ArrayOfSKSObject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__ArrayOfSKSObject * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfSKSObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfSKSObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfSKSObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfSKSObject;
		if (size)
			*size = sizeof(ns3__ArrayOfSKSObject);
		((ns3__ArrayOfSKSObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfSKSObject[n];
		if (size)
			*size = n * sizeof(ns3__ArrayOfSKSObject);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfSKSObject*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfSKSObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfSKSObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfSKSObject %p -> %p\n", q, p));
	*(ns3__ArrayOfSKSObject*)p = *(ns3__ArrayOfSKSObject*)q;
}

void ns3__ColumnOperatorIntf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns3__ColumnOperatorIntf*)this)->beginOperation);
	soap_serialize_PointerTostd__string(soap, &((ns3__ColumnOperatorIntf*)this)->endOperation);
	/* transient soap skipped */
}

void ns3__ColumnOperatorIntf::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns3__ColumnOperatorIntf*)this)->beginOperation = NULL;
	((ns3__ColumnOperatorIntf*)this)->endOperation = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns3__ColumnOperatorIntf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ColumnOperatorIntf);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ColumnOperatorIntf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ColumnOperatorIntf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ColumnOperatorIntf(struct soap *soap, const char *tag, int id, const ns3__ColumnOperatorIntf *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ColumnOperatorIntf), "ns3:ColumnOperatorIntf");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns3:beginOperation", -1, &(((ns3__ColumnOperatorIntf*)a)->beginOperation), "");
	soap_out_PointerTostd__string(soap, "ns3:endOperation", -1, &(((ns3__ColumnOperatorIntf*)a)->endOperation), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__ColumnOperatorIntf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ColumnOperatorIntf(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ColumnOperatorIntf * SOAP_FMAC4 soap_get_ns3__ColumnOperatorIntf(struct soap *soap, ns3__ColumnOperatorIntf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ColumnOperatorIntf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__ColumnOperatorIntf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ColumnOperatorIntf(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ColumnOperatorIntf * SOAP_FMAC4 soap_in_ns3__ColumnOperatorIntf(struct soap *soap, const char *tag, ns3__ColumnOperatorIntf *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ColumnOperatorIntf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ColumnOperatorIntf, sizeof(ns3__ColumnOperatorIntf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ColumnOperatorIntf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ColumnOperatorIntf *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_beginOperation1 = 1, soap_flag_endOperation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_beginOperation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:beginOperation", &(((ns3__ColumnOperatorIntf*)a)->beginOperation), "xsd:string"))
				{	soap_flag_beginOperation1--;
					continue;
				}
			if (soap_flag_endOperation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:endOperation", &(((ns3__ColumnOperatorIntf*)a)->endOperation), "xsd:string"))
				{	soap_flag_endOperation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ColumnOperatorIntf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ColumnOperatorIntf, 0, sizeof(ns3__ColumnOperatorIntf), 0, soap_copy_ns3__ColumnOperatorIntf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__ColumnOperatorIntf * SOAP_FMAC6 soap_new_ns3__ColumnOperatorIntf(struct soap *soap, int n)
{	return soap_instantiate_ns3__ColumnOperatorIntf(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__ColumnOperatorIntf(struct soap *soap, ns3__ColumnOperatorIntf *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__ColumnOperatorIntf * SOAP_FMAC4 soap_instantiate_ns3__ColumnOperatorIntf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ColumnOperatorIntf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ColumnOperatorIntf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ColumnOperatorIntf;
		if (size)
			*size = sizeof(ns3__ColumnOperatorIntf);
		((ns3__ColumnOperatorIntf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ColumnOperatorIntf[n];
		if (size)
			*size = n * sizeof(ns3__ColumnOperatorIntf);
		for (int i = 0; i < n; i++)
			((ns3__ColumnOperatorIntf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ColumnOperatorIntf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ColumnOperatorIntf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ColumnOperatorIntf %p -> %p\n", q, p));
	*(ns3__ColumnOperatorIntf*)p = *(ns3__ColumnOperatorIntf*)q;
}

void ns3__ScalarIntf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns3__ScalarIntf*)this)->type);
	soap_serialize_PointerTostd__string(soap, &((ns3__ScalarIntf*)this)->columnName);
	soap_serialize_PointerTostd__string(soap, &((ns3__ScalarIntf*)this)->tablePrefixedColumnName);
	/* transient soap skipped */
}

void ns3__ScalarIntf::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns3__ScalarIntf*)this)->type = NULL;
	((ns3__ScalarIntf*)this)->columnName = NULL;
	((ns3__ScalarIntf*)this)->tablePrefixedColumnName = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns3__ScalarIntf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ScalarIntf);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ScalarIntf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ScalarIntf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ScalarIntf(struct soap *soap, const char *tag, int id, const ns3__ScalarIntf *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ScalarIntf), "ns3:ScalarIntf");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns3:type", -1, &(((ns3__ScalarIntf*)a)->type), "");
	soap_out_PointerTostd__string(soap, "ns3:columnName", -1, &(((ns3__ScalarIntf*)a)->columnName), "");
	soap_out_PointerTostd__string(soap, "ns3:tablePrefixedColumnName", -1, &(((ns3__ScalarIntf*)a)->tablePrefixedColumnName), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__ScalarIntf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ScalarIntf(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ScalarIntf * SOAP_FMAC4 soap_get_ns3__ScalarIntf(struct soap *soap, ns3__ScalarIntf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ScalarIntf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__ScalarIntf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ScalarIntf(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ScalarIntf * SOAP_FMAC4 soap_in_ns3__ScalarIntf(struct soap *soap, const char *tag, ns3__ScalarIntf *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ScalarIntf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ScalarIntf, sizeof(ns3__ScalarIntf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ScalarIntf)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ScalarIntf *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_type1 = 1, soap_flag_columnName1 = 1, soap_flag_tablePrefixedColumnName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:type", &(((ns3__ScalarIntf*)a)->type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_columnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:columnName", &(((ns3__ScalarIntf*)a)->columnName), "xsd:string"))
				{	soap_flag_columnName1--;
					continue;
				}
			if (soap_flag_tablePrefixedColumnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:tablePrefixedColumnName", &(((ns3__ScalarIntf*)a)->tablePrefixedColumnName), "xsd:string"))
				{	soap_flag_tablePrefixedColumnName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ScalarIntf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ScalarIntf, 0, sizeof(ns3__ScalarIntf), 0, soap_copy_ns3__ScalarIntf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__ScalarIntf * SOAP_FMAC6 soap_new_ns3__ScalarIntf(struct soap *soap, int n)
{	return soap_instantiate_ns3__ScalarIntf(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__ScalarIntf(struct soap *soap, ns3__ScalarIntf *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__ScalarIntf * SOAP_FMAC4 soap_instantiate_ns3__ScalarIntf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ScalarIntf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ScalarIntf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ScalarIntf;
		if (size)
			*size = sizeof(ns3__ScalarIntf);
		((ns3__ScalarIntf*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ScalarIntf[n];
		if (size)
			*size = n * sizeof(ns3__ScalarIntf);
		for (int i = 0; i < n; i++)
			((ns3__ScalarIntf*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ScalarIntf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ScalarIntf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ScalarIntf %p -> %p\n", q, p));
	*(ns3__ScalarIntf*)p = *(ns3__ScalarIntf*)q;
}

void ns3__DBColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns3__DBColumn*)this)->columnName);
	soap_serialize_PointerTostd__string(soap, &((ns3__DBColumn*)this)->tablePrefixedColumnName);
	/* transient soap skipped */
}

void ns3__DBColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns3__DBColumn*)this)->columnName = NULL;
	((ns3__DBColumn*)this)->tablePrefixedColumnName = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns3__DBColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__DBColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__DBColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DBColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DBColumn(struct soap *soap, const char *tag, int id, const ns3__DBColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__DBColumn), "ns3:DBColumn");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ns3:columnName", -1, &(((ns3__DBColumn*)a)->columnName), "");
	soap_out_PointerTostd__string(soap, "ns3:tablePrefixedColumnName", -1, &(((ns3__DBColumn*)a)->tablePrefixedColumnName), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__DBColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DBColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DBColumn * SOAP_FMAC4 soap_get_ns3__DBColumn(struct soap *soap, ns3__DBColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DBColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__DBColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__DBColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DBColumn * SOAP_FMAC4 soap_in_ns3__DBColumn(struct soap *soap, const char *tag, ns3__DBColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DBColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__DBColumn, sizeof(ns3__DBColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__DBColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DBColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_columnName1 = 1, soap_flag_tablePrefixedColumnName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_columnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:columnName", &(((ns3__DBColumn*)a)->columnName), "xsd:string"))
				{	soap_flag_columnName1--;
					continue;
				}
			if (soap_flag_tablePrefixedColumnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:tablePrefixedColumnName", &(((ns3__DBColumn*)a)->tablePrefixedColumnName), "xsd:string"))
				{	soap_flag_tablePrefixedColumnName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DBColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__DBColumn, 0, sizeof(ns3__DBColumn), 0, soap_copy_ns3__DBColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__DBColumn * SOAP_FMAC6 soap_new_ns3__DBColumn(struct soap *soap, int n)
{	return soap_instantiate_ns3__DBColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__DBColumn(struct soap *soap, ns3__DBColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__DBColumn * SOAP_FMAC4 soap_instantiate_ns3__DBColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DBColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__DBColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__DBColumn;
		if (size)
			*size = sizeof(ns3__DBColumn);
		((ns3__DBColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__DBColumn[n];
		if (size)
			*size = n * sizeof(ns3__DBColumn);
		for (int i = 0; i < n; i++)
			((ns3__DBColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__DBColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DBColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DBColumn %p -> %p\n", q, p));
	*(ns3__DBColumn*)p = *(ns3__DBColumn*)q;
}

void ns2__QueryColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__DBColumn(soap, &((ns2__QueryColumn*)this)->DBColumn);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns2__QueryColumn*)this)->DBColumnList);
	soap_serialize_PointerTons3__ColumnOperatorIntf(soap, &((ns2__QueryColumn*)this)->columnOperator);
	soap_serialize_PointerTobool(soap, &((ns2__QueryColumn*)this)->concatenateOperation);
	soap_serialize_PointerTons1__ArrayOfLong(soap, &((ns2__QueryColumn*)this)->longList);
	soap_serialize_PointerToLONG64(soap, &((ns2__QueryColumn*)this)->longValue);
	soap_serialize_PointerTons3__OperatorIntf(soap, &((ns2__QueryColumn*)this)->operator_);
	soap_serialize_PointerTobool(soap, &((ns2__QueryColumn*)this)->parameterizeColumn);
	soap_serialize_PointerTons1__ArrayOfString(soap, &((ns2__QueryColumn*)this)->stringList);
	soap_serialize_PointerTostd__string(soap, &((ns2__QueryColumn*)this)->stringValue);
	soap_serialize_PointerTons1__ArrayOfDateTime(soap, &((ns2__QueryColumn*)this)->timestampList);
	soap_serialize_PointerTotime(soap, &((ns2__QueryColumn*)this)->timestampValue);
	/* transient soap skipped */
}

void ns2__QueryColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns2__QueryColumn*)this)->DBColumn = NULL;
	((ns2__QueryColumn*)this)->DBColumnList = NULL;
	((ns2__QueryColumn*)this)->columnOperator = NULL;
	((ns2__QueryColumn*)this)->concatenateOperation = NULL;
	((ns2__QueryColumn*)this)->longList = NULL;
	((ns2__QueryColumn*)this)->longValue = NULL;
	((ns2__QueryColumn*)this)->operator_ = NULL;
	((ns2__QueryColumn*)this)->parameterizeColumn = NULL;
	((ns2__QueryColumn*)this)->stringList = NULL;
	((ns2__QueryColumn*)this)->stringValue = NULL;
	((ns2__QueryColumn*)this)->timestampList = NULL;
	((ns2__QueryColumn*)this)->timestampValue = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__QueryColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__QueryColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__QueryColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__QueryColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__QueryColumn(struct soap *soap, const char *tag, int id, const ns2__QueryColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__QueryColumn), "ns2:QueryColumn");
	/* transient soap skipped */
	soap_out_PointerTons3__DBColumn(soap, "ns2:DBColumn", -1, &(((ns2__QueryColumn*)a)->DBColumn), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns2:DBColumnList", -1, &(((ns2__QueryColumn*)a)->DBColumnList), "");
	soap_out_PointerTons3__ColumnOperatorIntf(soap, "ns2:columnOperator", -1, &(((ns2__QueryColumn*)a)->columnOperator), "");
	soap_out_PointerTobool(soap, "ns2:concatenateOperation", -1, &(((ns2__QueryColumn*)a)->concatenateOperation), "");
	soap_out_PointerTons1__ArrayOfLong(soap, "ns2:longList", -1, &(((ns2__QueryColumn*)a)->longList), "");
	soap_out_PointerToLONG64(soap, "ns2:longValue", -1, &(((ns2__QueryColumn*)a)->longValue), "");
	soap_out_PointerTons3__OperatorIntf(soap, "ns2:operator", -1, &(((ns2__QueryColumn*)a)->operator_), "");
	soap_out_PointerTobool(soap, "ns2:parameterizeColumn", -1, &(((ns2__QueryColumn*)a)->parameterizeColumn), "");
	soap_out_PointerTons1__ArrayOfString(soap, "ns2:stringList", -1, &(((ns2__QueryColumn*)a)->stringList), "");
	soap_out_PointerTostd__string(soap, "ns2:stringValue", -1, &(((ns2__QueryColumn*)a)->stringValue), "");
	soap_out_PointerTons1__ArrayOfDateTime(soap, "ns2:timestampList", -1, &(((ns2__QueryColumn*)a)->timestampList), "");
	soap_out_PointerTotime(soap, "ns2:timestampValue", -1, &(((ns2__QueryColumn*)a)->timestampValue), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__QueryColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__QueryColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__QueryColumn * SOAP_FMAC4 soap_get_ns2__QueryColumn(struct soap *soap, ns2__QueryColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__QueryColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__QueryColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__QueryColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__QueryColumn * SOAP_FMAC4 soap_in_ns2__QueryColumn(struct soap *soap, const char *tag, ns2__QueryColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__QueryColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__QueryColumn, sizeof(ns2__QueryColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__QueryColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__QueryColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_DBColumn1 = 1, soap_flag_DBColumnList1 = 1, soap_flag_columnOperator1 = 1, soap_flag_concatenateOperation1 = 1, soap_flag_longList1 = 1, soap_flag_longValue1 = 1, soap_flag_operator_1 = 1, soap_flag_parameterizeColumn1 = 1, soap_flag_stringList1 = 1, soap_flag_stringValue1 = 1, soap_flag_timestampList1 = 1, soap_flag_timestampValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DBColumn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__DBColumn(soap, "ns2:DBColumn", &(((ns2__QueryColumn*)a)->DBColumn), "ns3:DBColumn"))
				{	soap_flag_DBColumn1--;
					continue;
				}
			if (soap_flag_DBColumnList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns2:DBColumnList", &(((ns2__QueryColumn*)a)->DBColumnList), "ns3:ArrayOfDBColumn"))
				{	soap_flag_DBColumnList1--;
					continue;
				}
			if (soap_flag_columnOperator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ColumnOperatorIntf(soap, "ns2:columnOperator", &(((ns2__QueryColumn*)a)->columnOperator), "ns3:ColumnOperatorIntf"))
				{	soap_flag_columnOperator1--;
					continue;
				}
			if (soap_flag_concatenateOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:concatenateOperation", &(((ns2__QueryColumn*)a)->concatenateOperation), "xsd:boolean"))
				{	soap_flag_concatenateOperation1--;
					continue;
				}
			if (soap_flag_longList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLong(soap, "ns2:longList", &(((ns2__QueryColumn*)a)->longList), "ns1:ArrayOfLong"))
				{	soap_flag_longList1--;
					continue;
				}
			if (soap_flag_longValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns2:longValue", &(((ns2__QueryColumn*)a)->longValue), "xsd:long"))
				{	soap_flag_longValue1--;
					continue;
				}
			if (soap_flag_operator_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__OperatorIntf(soap, "ns2:operator", &(((ns2__QueryColumn*)a)->operator_), "ns3:OperatorIntf"))
				{	soap_flag_operator_1--;
					continue;
				}
			if (soap_flag_parameterizeColumn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:parameterizeColumn", &(((ns2__QueryColumn*)a)->parameterizeColumn), "xsd:boolean"))
				{	soap_flag_parameterizeColumn1--;
					continue;
				}
			if (soap_flag_stringList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns2:stringList", &(((ns2__QueryColumn*)a)->stringList), "ns1:ArrayOfString"))
				{	soap_flag_stringList1--;
					continue;
				}
			if (soap_flag_stringValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:stringValue", &(((ns2__QueryColumn*)a)->stringValue), "xsd:string"))
				{	soap_flag_stringValue1--;
					continue;
				}
			if (soap_flag_timestampList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDateTime(soap, "ns2:timestampList", &(((ns2__QueryColumn*)a)->timestampList), "ns1:ArrayOfDateTime"))
				{	soap_flag_timestampList1--;
					continue;
				}
			if (soap_flag_timestampValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns2:timestampValue", &(((ns2__QueryColumn*)a)->timestampValue), "xsd:dateTime"))
				{	soap_flag_timestampValue1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__QueryColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__QueryColumn, 0, sizeof(ns2__QueryColumn), 0, soap_copy_ns2__QueryColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__QueryColumn * SOAP_FMAC6 soap_new_ns2__QueryColumn(struct soap *soap, int n)
{	return soap_instantiate_ns2__QueryColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__QueryColumn(struct soap *soap, ns2__QueryColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__QueryColumn * SOAP_FMAC4 soap_instantiate_ns2__QueryColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__QueryColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__QueryColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__QueryColumn;
		if (size)
			*size = sizeof(ns2__QueryColumn);
		((ns2__QueryColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__QueryColumn[n];
		if (size)
			*size = n * sizeof(ns2__QueryColumn);
		for (int i = 0; i < n; i++)
			((ns2__QueryColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__QueryColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__QueryColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__QueryColumn %p -> %p\n", q, p));
	*(ns2__QueryColumn*)p = *(ns2__QueryColumn*)q;
}

void ns2__ArrayOfQueryColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__QueryColumn(soap, &((ns2__ArrayOfQueryColumn*)this)->QueryColumn);
	/* transient soap skipped */
}

void ns2__ArrayOfQueryColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__QueryColumn(soap, &((ns2__ArrayOfQueryColumn*)this)->QueryColumn);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__ArrayOfQueryColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ArrayOfQueryColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__ArrayOfQueryColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ArrayOfQueryColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ArrayOfQueryColumn(struct soap *soap, const char *tag, int id, const ns2__ArrayOfQueryColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ArrayOfQueryColumn), "ns2:ArrayOfQueryColumn");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons2__QueryColumn(soap, "ns2:QueryColumn", -1, &(((ns2__ArrayOfQueryColumn*)a)->QueryColumn), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__ArrayOfQueryColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ArrayOfQueryColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ArrayOfQueryColumn * SOAP_FMAC4 soap_get_ns2__ArrayOfQueryColumn(struct soap *soap, ns2__ArrayOfQueryColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ArrayOfQueryColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__ArrayOfQueryColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ArrayOfQueryColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ArrayOfQueryColumn * SOAP_FMAC4 soap_in_ns2__ArrayOfQueryColumn(struct soap *soap, const char *tag, ns2__ArrayOfQueryColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ArrayOfQueryColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ArrayOfQueryColumn, sizeof(ns2__ArrayOfQueryColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ArrayOfQueryColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ArrayOfQueryColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__QueryColumn(soap, "ns2:QueryColumn", &(((ns2__ArrayOfQueryColumn*)a)->QueryColumn), "ns2:QueryColumn"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfQueryColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ArrayOfQueryColumn, 0, sizeof(ns2__ArrayOfQueryColumn), 0, soap_copy_ns2__ArrayOfQueryColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__ArrayOfQueryColumn * SOAP_FMAC6 soap_new_ns2__ArrayOfQueryColumn(struct soap *soap, int n)
{	return soap_instantiate_ns2__ArrayOfQueryColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__ArrayOfQueryColumn(struct soap *soap, ns2__ArrayOfQueryColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__ArrayOfQueryColumn * SOAP_FMAC4 soap_instantiate_ns2__ArrayOfQueryColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ArrayOfQueryColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ArrayOfQueryColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__ArrayOfQueryColumn;
		if (size)
			*size = sizeof(ns2__ArrayOfQueryColumn);
		((ns2__ArrayOfQueryColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__ArrayOfQueryColumn[n];
		if (size)
			*size = n * sizeof(ns2__ArrayOfQueryColumn);
		for (int i = 0; i < n; i++)
			((ns2__ArrayOfQueryColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ArrayOfQueryColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ArrayOfQueryColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ArrayOfQueryColumn %p -> %p\n", q, p));
	*(ns2__ArrayOfQueryColumn*)p = *(ns2__ArrayOfQueryColumn*)q;
}

void ns2__ReturnColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__DBColumn(soap, &((ns2__ReturnColumn*)this)->ASColumn);
	soap_serialize_PointerTons3__DBColumn(soap, &((ns2__ReturnColumn*)this)->DBColumn);
	soap_serialize_PointerTons3__ScalarIntf(soap, &((ns2__ReturnColumn*)this)->asColumnScalarIntf);
	soap_serialize_PointerTostd__string(soap, &((ns2__ReturnColumn*)this)->columnName);
	soap_serialize_PointerTons3__ColumnOperatorIntf(soap, &((ns2__ReturnColumn*)this)->columnOperator);
	soap_serialize_PointerTostd__string(soap, &((ns2__ReturnColumn*)this)->columnValue);
	soap_serialize_PointerTobool(soap, &((ns2__ReturnColumn*)this)->returnOnlySetColumns);
	soap_serialize_PointerTobool(soap, &((ns2__ReturnColumn*)this)->scalar);
	soap_serialize_PointerTostd__string(soap, &((ns2__ReturnColumn*)this)->tablePrefixedColumnName);
	/* transient soap skipped */
}

void ns2__ReturnColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns2__ReturnColumn*)this)->ASColumn = NULL;
	((ns2__ReturnColumn*)this)->DBColumn = NULL;
	((ns2__ReturnColumn*)this)->asColumnScalarIntf = NULL;
	((ns2__ReturnColumn*)this)->columnName = NULL;
	((ns2__ReturnColumn*)this)->columnOperator = NULL;
	((ns2__ReturnColumn*)this)->columnValue = NULL;
	((ns2__ReturnColumn*)this)->returnOnlySetColumns = NULL;
	((ns2__ReturnColumn*)this)->scalar = NULL;
	((ns2__ReturnColumn*)this)->tablePrefixedColumnName = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__ReturnColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ReturnColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__ReturnColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReturnColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReturnColumn(struct soap *soap, const char *tag, int id, const ns2__ReturnColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReturnColumn), "ns2:ReturnColumn");
	/* transient soap skipped */
	soap_out_PointerTons3__DBColumn(soap, "ns2:ASColumn", -1, &(((ns2__ReturnColumn*)a)->ASColumn), "");
	soap_out_PointerTons3__DBColumn(soap, "ns2:DBColumn", -1, &(((ns2__ReturnColumn*)a)->DBColumn), "");
	soap_out_PointerTons3__ScalarIntf(soap, "ns2:asColumnScalarIntf", -1, &(((ns2__ReturnColumn*)a)->asColumnScalarIntf), "");
	soap_out_PointerTostd__string(soap, "ns2:columnName", -1, &(((ns2__ReturnColumn*)a)->columnName), "");
	soap_out_PointerTons3__ColumnOperatorIntf(soap, "ns2:columnOperator", -1, &(((ns2__ReturnColumn*)a)->columnOperator), "");
	soap_out_PointerTostd__string(soap, "ns2:columnValue", -1, &(((ns2__ReturnColumn*)a)->columnValue), "");
	soap_out_PointerTobool(soap, "ns2:returnOnlySetColumns", -1, &(((ns2__ReturnColumn*)a)->returnOnlySetColumns), "");
	soap_out_PointerTobool(soap, "ns2:scalar", -1, &(((ns2__ReturnColumn*)a)->scalar), "");
	soap_out_PointerTostd__string(soap, "ns2:tablePrefixedColumnName", -1, &(((ns2__ReturnColumn*)a)->tablePrefixedColumnName), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__ReturnColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReturnColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReturnColumn * SOAP_FMAC4 soap_get_ns2__ReturnColumn(struct soap *soap, ns2__ReturnColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReturnColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__ReturnColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReturnColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReturnColumn * SOAP_FMAC4 soap_in_ns2__ReturnColumn(struct soap *soap, const char *tag, ns2__ReturnColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReturnColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReturnColumn, sizeof(ns2__ReturnColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ReturnColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ReturnColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_ASColumn1 = 1, soap_flag_DBColumn1 = 1, soap_flag_asColumnScalarIntf1 = 1, soap_flag_columnName1 = 1, soap_flag_columnOperator1 = 1, soap_flag_columnValue1 = 1, soap_flag_returnOnlySetColumns1 = 1, soap_flag_scalar1 = 1, soap_flag_tablePrefixedColumnName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ASColumn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__DBColumn(soap, "ns2:ASColumn", &(((ns2__ReturnColumn*)a)->ASColumn), "ns3:DBColumn"))
				{	soap_flag_ASColumn1--;
					continue;
				}
			if (soap_flag_DBColumn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__DBColumn(soap, "ns2:DBColumn", &(((ns2__ReturnColumn*)a)->DBColumn), "ns3:DBColumn"))
				{	soap_flag_DBColumn1--;
					continue;
				}
			if (soap_flag_asColumnScalarIntf1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ScalarIntf(soap, "ns2:asColumnScalarIntf", &(((ns2__ReturnColumn*)a)->asColumnScalarIntf), "ns3:ScalarIntf"))
				{	soap_flag_asColumnScalarIntf1--;
					continue;
				}
			if (soap_flag_columnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:columnName", &(((ns2__ReturnColumn*)a)->columnName), "xsd:string"))
				{	soap_flag_columnName1--;
					continue;
				}
			if (soap_flag_columnOperator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ColumnOperatorIntf(soap, "ns2:columnOperator", &(((ns2__ReturnColumn*)a)->columnOperator), "ns3:ColumnOperatorIntf"))
				{	soap_flag_columnOperator1--;
					continue;
				}
			if (soap_flag_columnValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:columnValue", &(((ns2__ReturnColumn*)a)->columnValue), "xsd:string"))
				{	soap_flag_columnValue1--;
					continue;
				}
			if (soap_flag_returnOnlySetColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:returnOnlySetColumns", &(((ns2__ReturnColumn*)a)->returnOnlySetColumns), "xsd:boolean"))
				{	soap_flag_returnOnlySetColumns1--;
					continue;
				}
			if (soap_flag_scalar1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:scalar", &(((ns2__ReturnColumn*)a)->scalar), "xsd:boolean"))
				{	soap_flag_scalar1--;
					continue;
				}
			if (soap_flag_tablePrefixedColumnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:tablePrefixedColumnName", &(((ns2__ReturnColumn*)a)->tablePrefixedColumnName), "xsd:string"))
				{	soap_flag_tablePrefixedColumnName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ReturnColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReturnColumn, 0, sizeof(ns2__ReturnColumn), 0, soap_copy_ns2__ReturnColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__ReturnColumn * SOAP_FMAC6 soap_new_ns2__ReturnColumn(struct soap *soap, int n)
{	return soap_instantiate_ns2__ReturnColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__ReturnColumn(struct soap *soap, ns2__ReturnColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__ReturnColumn * SOAP_FMAC4 soap_instantiate_ns2__ReturnColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReturnColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ReturnColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__ReturnColumn;
		if (size)
			*size = sizeof(ns2__ReturnColumn);
		((ns2__ReturnColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__ReturnColumn[n];
		if (size)
			*size = n * sizeof(ns2__ReturnColumn);
		for (int i = 0; i < n; i++)
			((ns2__ReturnColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ReturnColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ReturnColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ReturnColumn %p -> %p\n", q, p));
	*(ns2__ReturnColumn*)p = *(ns2__ReturnColumn*)q;
}

void ns2__ArrayOfReturnColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ReturnColumn(soap, &((ns2__ArrayOfReturnColumn*)this)->ReturnColumn);
	/* transient soap skipped */
}

void ns2__ArrayOfReturnColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ReturnColumn(soap, &((ns2__ArrayOfReturnColumn*)this)->ReturnColumn);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__ArrayOfReturnColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ArrayOfReturnColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__ArrayOfReturnColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ArrayOfReturnColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ArrayOfReturnColumn(struct soap *soap, const char *tag, int id, const ns2__ArrayOfReturnColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ArrayOfReturnColumn), "ns2:ArrayOfReturnColumn");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons2__ReturnColumn(soap, "ns2:ReturnColumn", -1, &(((ns2__ArrayOfReturnColumn*)a)->ReturnColumn), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__ArrayOfReturnColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ArrayOfReturnColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ArrayOfReturnColumn * SOAP_FMAC4 soap_get_ns2__ArrayOfReturnColumn(struct soap *soap, ns2__ArrayOfReturnColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ArrayOfReturnColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__ArrayOfReturnColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ArrayOfReturnColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ArrayOfReturnColumn * SOAP_FMAC4 soap_in_ns2__ArrayOfReturnColumn(struct soap *soap, const char *tag, ns2__ArrayOfReturnColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ArrayOfReturnColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ArrayOfReturnColumn, sizeof(ns2__ArrayOfReturnColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ArrayOfReturnColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ArrayOfReturnColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ReturnColumn(soap, "ns2:ReturnColumn", &(((ns2__ArrayOfReturnColumn*)a)->ReturnColumn), "ns2:ReturnColumn"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfReturnColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ArrayOfReturnColumn, 0, sizeof(ns2__ArrayOfReturnColumn), 0, soap_copy_ns2__ArrayOfReturnColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__ArrayOfReturnColumn * SOAP_FMAC6 soap_new_ns2__ArrayOfReturnColumn(struct soap *soap, int n)
{	return soap_instantiate_ns2__ArrayOfReturnColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__ArrayOfReturnColumn(struct soap *soap, ns2__ArrayOfReturnColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__ArrayOfReturnColumn * SOAP_FMAC4 soap_instantiate_ns2__ArrayOfReturnColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ArrayOfReturnColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ArrayOfReturnColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__ArrayOfReturnColumn;
		if (size)
			*size = sizeof(ns2__ArrayOfReturnColumn);
		((ns2__ArrayOfReturnColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__ArrayOfReturnColumn[n];
		if (size)
			*size = n * sizeof(ns2__ArrayOfReturnColumn);
		for (int i = 0; i < n; i++)
			((ns2__ArrayOfReturnColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ArrayOfReturnColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ArrayOfReturnColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ArrayOfReturnColumn %p -> %p\n", q, p));
	*(ns2__ArrayOfReturnColumn*)p = *(ns2__ArrayOfReturnColumn*)q;
}

void ns2__LimitOffset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((ns2__LimitOffset*)this)->limit);
	soap_serialize_PointerToint(soap, &((ns2__LimitOffset*)this)->offset);
	/* transient soap skipped */
}

void ns2__LimitOffset::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns2__LimitOffset*)this)->limit = NULL;
	((ns2__LimitOffset*)this)->offset = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__LimitOffset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LimitOffset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__LimitOffset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LimitOffset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LimitOffset(struct soap *soap, const char *tag, int id, const ns2__LimitOffset *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LimitOffset), "ns2:LimitOffset");
	/* transient soap skipped */
	soap_out_PointerToint(soap, "ns2:limit", -1, &(((ns2__LimitOffset*)a)->limit), "");
	soap_out_PointerToint(soap, "ns2:offset", -1, &(((ns2__LimitOffset*)a)->offset), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__LimitOffset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LimitOffset(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LimitOffset * SOAP_FMAC4 soap_get_ns2__LimitOffset(struct soap *soap, ns2__LimitOffset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LimitOffset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__LimitOffset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LimitOffset(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LimitOffset * SOAP_FMAC4 soap_in_ns2__LimitOffset(struct soap *soap, const char *tag, ns2__LimitOffset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LimitOffset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LimitOffset, sizeof(ns2__LimitOffset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LimitOffset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LimitOffset *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_limit1 = 1, soap_flag_offset1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_limit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:limit", &(((ns2__LimitOffset*)a)->limit), "xsd:int"))
				{	soap_flag_limit1--;
					continue;
				}
			if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:offset", &(((ns2__LimitOffset*)a)->offset), "xsd:int"))
				{	soap_flag_offset1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LimitOffset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LimitOffset, 0, sizeof(ns2__LimitOffset), 0, soap_copy_ns2__LimitOffset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__LimitOffset * SOAP_FMAC6 soap_new_ns2__LimitOffset(struct soap *soap, int n)
{	return soap_instantiate_ns2__LimitOffset(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__LimitOffset(struct soap *soap, ns2__LimitOffset *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__LimitOffset * SOAP_FMAC4 soap_instantiate_ns2__LimitOffset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LimitOffset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LimitOffset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__LimitOffset;
		if (size)
			*size = sizeof(ns2__LimitOffset);
		((ns2__LimitOffset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__LimitOffset[n];
		if (size)
			*size = n * sizeof(ns2__LimitOffset);
		for (int i = 0; i < n; i++)
			((ns2__LimitOffset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LimitOffset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LimitOffset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LimitOffset %p -> %p\n", q, p));
	*(ns2__LimitOffset*)p = *(ns2__LimitOffset*)q;
}

void ns2__OrderColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &((ns2__OrderColumn*)this)->ASColumn);
	soap_serialize_PointerTons3__DBColumn(soap, &((ns2__OrderColumn*)this)->DBColumn);
	soap_serialize_PointerTons2__Order(soap, &((ns2__OrderColumn*)this)->order);
	/* transient soap skipped */
}

void ns2__OrderColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns2__OrderColumn*)this)->ASColumn = NULL;
	((ns2__OrderColumn*)this)->DBColumn = NULL;
	((ns2__OrderColumn*)this)->order = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__OrderColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OrderColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__OrderColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OrderColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OrderColumn(struct soap *soap, const char *tag, int id, const ns2__OrderColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OrderColumn), "ns2:OrderColumn");
	/* transient soap skipped */
	soap_out_PointerTobool(soap, "ns2:ASColumn", -1, &(((ns2__OrderColumn*)a)->ASColumn), "");
	soap_out_PointerTons3__DBColumn(soap, "ns2:DBColumn", -1, &(((ns2__OrderColumn*)a)->DBColumn), "");
	soap_out_PointerTons2__Order(soap, "ns2:order", -1, &(((ns2__OrderColumn*)a)->order), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__OrderColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OrderColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OrderColumn * SOAP_FMAC4 soap_get_ns2__OrderColumn(struct soap *soap, ns2__OrderColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OrderColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__OrderColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OrderColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OrderColumn * SOAP_FMAC4 soap_in_ns2__OrderColumn(struct soap *soap, const char *tag, ns2__OrderColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OrderColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OrderColumn, sizeof(ns2__OrderColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OrderColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OrderColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_ASColumn1 = 1, soap_flag_DBColumn1 = 1, soap_flag_order1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ASColumn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:ASColumn", &(((ns2__OrderColumn*)a)->ASColumn), "xsd:boolean"))
				{	soap_flag_ASColumn1--;
					continue;
				}
			if (soap_flag_DBColumn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__DBColumn(soap, "ns2:DBColumn", &(((ns2__OrderColumn*)a)->DBColumn), "ns3:DBColumn"))
				{	soap_flag_DBColumn1--;
					continue;
				}
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Order(soap, "ns2:order", &(((ns2__OrderColumn*)a)->order), "ns2:Order"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OrderColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OrderColumn, 0, sizeof(ns2__OrderColumn), 0, soap_copy_ns2__OrderColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__OrderColumn * SOAP_FMAC6 soap_new_ns2__OrderColumn(struct soap *soap, int n)
{	return soap_instantiate_ns2__OrderColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__OrderColumn(struct soap *soap, ns2__OrderColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__OrderColumn * SOAP_FMAC4 soap_instantiate_ns2__OrderColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OrderColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OrderColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__OrderColumn;
		if (size)
			*size = sizeof(ns2__OrderColumn);
		((ns2__OrderColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__OrderColumn[n];
		if (size)
			*size = n * sizeof(ns2__OrderColumn);
		for (int i = 0; i < n; i++)
			((ns2__OrderColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__OrderColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OrderColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OrderColumn %p -> %p\n", q, p));
	*(ns2__OrderColumn*)p = *(ns2__OrderColumn*)q;
}

void ns2__ArrayOfOrderColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__OrderColumn(soap, &((ns2__ArrayOfOrderColumn*)this)->OrderColumn);
	/* transient soap skipped */
}

void ns2__ArrayOfOrderColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__OrderColumn(soap, &((ns2__ArrayOfOrderColumn*)this)->OrderColumn);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__ArrayOfOrderColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ArrayOfOrderColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__ArrayOfOrderColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ArrayOfOrderColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ArrayOfOrderColumn(struct soap *soap, const char *tag, int id, const ns2__ArrayOfOrderColumn *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ArrayOfOrderColumn), "ns2:ArrayOfOrderColumn");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTons2__OrderColumn(soap, "ns2:OrderColumn", -1, &(((ns2__ArrayOfOrderColumn*)a)->OrderColumn), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__ArrayOfOrderColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ArrayOfOrderColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ArrayOfOrderColumn * SOAP_FMAC4 soap_get_ns2__ArrayOfOrderColumn(struct soap *soap, ns2__ArrayOfOrderColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ArrayOfOrderColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__ArrayOfOrderColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ArrayOfOrderColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ArrayOfOrderColumn * SOAP_FMAC4 soap_in_ns2__ArrayOfOrderColumn(struct soap *soap, const char *tag, ns2__ArrayOfOrderColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ArrayOfOrderColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ArrayOfOrderColumn, sizeof(ns2__ArrayOfOrderColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ArrayOfOrderColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ArrayOfOrderColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__OrderColumn(soap, "ns2:OrderColumn", &(((ns2__ArrayOfOrderColumn*)a)->OrderColumn), "ns2:OrderColumn"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfOrderColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ArrayOfOrderColumn, 0, sizeof(ns2__ArrayOfOrderColumn), 0, soap_copy_ns2__ArrayOfOrderColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__ArrayOfOrderColumn * SOAP_FMAC6 soap_new_ns2__ArrayOfOrderColumn(struct soap *soap, int n)
{	return soap_instantiate_ns2__ArrayOfOrderColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__ArrayOfOrderColumn(struct soap *soap, ns2__ArrayOfOrderColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__ArrayOfOrderColumn * SOAP_FMAC4 soap_instantiate_ns2__ArrayOfOrderColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ArrayOfOrderColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ArrayOfOrderColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__ArrayOfOrderColumn;
		if (size)
			*size = sizeof(ns2__ArrayOfOrderColumn);
		((ns2__ArrayOfOrderColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__ArrayOfOrderColumn[n];
		if (size)
			*size = n * sizeof(ns2__ArrayOfOrderColumn);
		for (int i = 0; i < n; i++)
			((ns2__ArrayOfOrderColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ArrayOfOrderColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ArrayOfOrderColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ArrayOfOrderColumn %p -> %p\n", q, p));
	*(ns2__ArrayOfOrderColumn*)p = *(ns2__ArrayOfOrderColumn*)q;
}

void ns2__SKSQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &((ns2__SKSQuery*)this)->addDistinct);
	soap_serialize_PointerTons3__ArrayOfSKSObject(soap, &((ns2__SKSQuery*)this)->fromObjects);
	soap_serialize_PointerTons3__ArrayOfDBColumn(soap, &((ns2__SKSQuery*)this)->groupByColumns);
	soap_serialize_PointerTons2__LimitOffset(soap, &((ns2__SKSQuery*)this)->limitOffset);
	soap_serialize_PointerTons2__ArrayOfOrderColumn(soap, &((ns2__SKSQuery*)this)->orderColumns);
	soap_serialize_PointerTons2__ArrayOfQueryColumn(soap, &((ns2__SKSQuery*)this)->queryColumns);
	soap_serialize_PointerTons3__SKSObject(soap, &((ns2__SKSQuery*)this)->returnClass);
	soap_serialize_PointerTons2__ArrayOfReturnColumn(soap, &((ns2__SKSQuery*)this)->returnColumns);
	/* transient soap skipped */
}

void ns2__SKSQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns2__SKSQuery*)this)->addDistinct = NULL;
	((ns2__SKSQuery*)this)->fromObjects = NULL;
	((ns2__SKSQuery*)this)->groupByColumns = NULL;
	((ns2__SKSQuery*)this)->limitOffset = NULL;
	((ns2__SKSQuery*)this)->orderColumns = NULL;
	((ns2__SKSQuery*)this)->queryColumns = NULL;
	((ns2__SKSQuery*)this)->returnClass = NULL;
	((ns2__SKSQuery*)this)->returnColumns = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int ns2__SKSQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SKSQuery);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__SKSQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SKSQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SKSQuery(struct soap *soap, const char *tag, int id, const ns2__SKSQuery *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SKSQuery), "ns2:SKSQuery");
	/* transient soap skipped */
	soap_out_PointerTobool(soap, "ns2:addDistinct", -1, &(((ns2__SKSQuery*)a)->addDistinct), "");
	soap_out_PointerTons3__ArrayOfSKSObject(soap, "ns2:fromObjects", -1, &(((ns2__SKSQuery*)a)->fromObjects), "");
	soap_out_PointerTons3__ArrayOfDBColumn(soap, "ns2:groupByColumns", -1, &(((ns2__SKSQuery*)a)->groupByColumns), "");
	soap_out_PointerTons2__LimitOffset(soap, "ns2:limitOffset", -1, &(((ns2__SKSQuery*)a)->limitOffset), "");
	soap_out_PointerTons2__ArrayOfOrderColumn(soap, "ns2:orderColumns", -1, &(((ns2__SKSQuery*)a)->orderColumns), "");
	soap_out_PointerTons2__ArrayOfQueryColumn(soap, "ns2:queryColumns", -1, &(((ns2__SKSQuery*)a)->queryColumns), "");
	soap_out_PointerTons3__SKSObject(soap, "ns2:returnClass", -1, &(((ns2__SKSQuery*)a)->returnClass), "");
	soap_out_PointerTons2__ArrayOfReturnColumn(soap, "ns2:returnColumns", -1, &(((ns2__SKSQuery*)a)->returnColumns), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__SKSQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SKSQuery(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SKSQuery * SOAP_FMAC4 soap_get_ns2__SKSQuery(struct soap *soap, ns2__SKSQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SKSQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__SKSQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SKSQuery(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SKSQuery * SOAP_FMAC4 soap_in_ns2__SKSQuery(struct soap *soap, const char *tag, ns2__SKSQuery *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SKSQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SKSQuery, sizeof(ns2__SKSQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SKSQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SKSQuery *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_addDistinct1 = 1, soap_flag_fromObjects1 = 1, soap_flag_groupByColumns1 = 1, soap_flag_limitOffset1 = 1, soap_flag_orderColumns1 = 1, soap_flag_queryColumns1 = 1, soap_flag_returnClass1 = 1, soap_flag_returnColumns1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_addDistinct1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:addDistinct", &(((ns2__SKSQuery*)a)->addDistinct), "xsd:boolean"))
				{	soap_flag_addDistinct1--;
					continue;
				}
			if (soap_flag_fromObjects1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfSKSObject(soap, "ns2:fromObjects", &(((ns2__SKSQuery*)a)->fromObjects), "ns3:ArrayOfSKSObject"))
				{	soap_flag_fromObjects1--;
					continue;
				}
			if (soap_flag_groupByColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfDBColumn(soap, "ns2:groupByColumns", &(((ns2__SKSQuery*)a)->groupByColumns), "ns3:ArrayOfDBColumn"))
				{	soap_flag_groupByColumns1--;
					continue;
				}
			if (soap_flag_limitOffset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LimitOffset(soap, "ns2:limitOffset", &(((ns2__SKSQuery*)a)->limitOffset), "ns2:LimitOffset"))
				{	soap_flag_limitOffset1--;
					continue;
				}
			if (soap_flag_orderColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArrayOfOrderColumn(soap, "ns2:orderColumns", &(((ns2__SKSQuery*)a)->orderColumns), "ns2:ArrayOfOrderColumn"))
				{	soap_flag_orderColumns1--;
					continue;
				}
			if (soap_flag_queryColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArrayOfQueryColumn(soap, "ns2:queryColumns", &(((ns2__SKSQuery*)a)->queryColumns), "ns2:ArrayOfQueryColumn"))
				{	soap_flag_queryColumns1--;
					continue;
				}
			if (soap_flag_returnClass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__SKSObject(soap, "ns2:returnClass", &(((ns2__SKSQuery*)a)->returnClass), "ns3:SKSObject"))
				{	soap_flag_returnClass1--;
					continue;
				}
			if (soap_flag_returnColumns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArrayOfReturnColumn(soap, "ns2:returnColumns", &(((ns2__SKSQuery*)a)->returnColumns), "ns2:ArrayOfReturnColumn"))
				{	soap_flag_returnColumns1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SKSQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SKSQuery, 0, sizeof(ns2__SKSQuery), 0, soap_copy_ns2__SKSQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__SKSQuery * SOAP_FMAC6 soap_new_ns2__SKSQuery(struct soap *soap, int n)
{	return soap_instantiate_ns2__SKSQuery(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__SKSQuery(struct soap *soap, ns2__SKSQuery *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__SKSQuery * SOAP_FMAC4 soap_instantiate_ns2__SKSQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SKSQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SKSQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__SKSQuery;
		if (size)
			*size = sizeof(ns2__SKSQuery);
		((ns2__SKSQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__SKSQuery[n];
		if (size)
			*size = n * sizeof(ns2__SKSQuery);
		for (int i = 0; i < n; i++)
			((ns2__SKSQuery*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SKSQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SKSQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SKSQuery %p -> %p\n", q, p));
	*(ns2__SKSQuery*)p = *(ns2__SKSQuery*)q;
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__string*)this)->__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((xsd__string*)this)->__item);
	/* transient soap skipped */
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((xsd__string*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(((xsd__string*)a)->__item), "xsd:string");
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(((xsd__string*)a)->__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__string * SOAP_FMAC6 soap_new_xsd__string(struct soap *soap, int n)
{	return soap_instantiate_xsd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string(struct soap *soap, xsd__string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string;
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__string[n];
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__long::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__long*)this)->__item, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &((xsd__long*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(((xsd__long*)a)->__item), "xsd:long");
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(((xsd__long*)a)->__item), "xsd:long"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__long * SOAP_FMAC6 soap_new_xsd__long(struct soap *soap, int n)
{	return soap_instantiate_xsd__long(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__long(struct soap *soap, xsd__long *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__long;
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__long[n];
		if (size)
			*size = n * sizeof(xsd__long);
		for (int i = 0; i < n; i++)
			((xsd__long*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__long*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__int*)this)->__item, SOAP_TYPE_int);
	/* transient soap skipped */
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((xsd__int*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(((xsd__int*)a)->__item), "xsd:int");
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(((xsd__int*)a)->__item), "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__int * SOAP_FMAC6 soap_new_xsd__int(struct soap *soap, int n)
{	return soap_instantiate_xsd__int(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__int(struct soap *soap, xsd__int *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__int;
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__int[n];
		if (size)
			*size = n * sizeof(xsd__int);
		for (int i = 0; i < n; i++)
			((xsd__int*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__double::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__double*)this)->__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &((xsd__double*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(((xsd__double*)a)->__item), "xsd:double");
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(((xsd__double*)a)->__item), "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__double * SOAP_FMAC6 soap_new_xsd__double(struct soap *soap, int n)
{	return soap_instantiate_xsd__double(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__double(struct soap *soap, xsd__double *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__double;
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__double[n];
		if (size)
			*size = n * sizeof(xsd__double);
		for (int i = 0; i < n; i++)
			((xsd__double*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}

void xsd__decimal_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
	/* transient soap skipped */
}

void xsd__decimal_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__decimal_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__decimal_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__decimal_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__decimal_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal_(struct soap *soap, const char *tag, int id, const xsd__decimal_ *a, const char *type)
{
	return soap_out_xsd__decimal(soap, tag, id, &(((xsd__decimal_*)a)->__item), "xsd:decimal");
}

void *xsd__decimal_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__decimal_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_get_xsd__decimal_(struct soap *soap, xsd__decimal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__decimal_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__decimal_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_in_xsd__decimal_(struct soap *soap, const char *tag, xsd__decimal_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__decimal_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__decimal_)
			return (xsd__decimal_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__decimal(soap, tag, &(((xsd__decimal_*)a)->__item), "xsd:decimal"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__decimal_ * SOAP_FMAC6 soap_new_xsd__decimal_(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal_(struct soap *soap, xsd__decimal_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_instantiate_xsd__decimal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__decimal_;
		if (size)
			*size = sizeof(xsd__decimal_);
		((xsd__decimal_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__decimal_[n];
		if (size)
			*size = n * sizeof(xsd__decimal_);
		for (int i = 0; i < n; i++)
			((xsd__decimal_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__decimal_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__decimal_ %p -> %p\n", q, p));
	*(xsd__decimal_*)p = *(xsd__decimal_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__decimal(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__decimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__dateTime*)this)->__item, SOAP_TYPE_time);
	/* transient soap skipped */
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &((xsd__dateTime*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(((xsd__dateTime*)a)->__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(((xsd__dateTime*)a)->__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__dateTime * SOAP_FMAC6 soap_new_xsd__dateTime(struct soap *soap, int n)
{	return soap_instantiate_xsd__dateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime(struct soap *soap, xsd__dateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime;
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime[n];
		if (size)
			*size = n * sizeof(xsd__dateTime);
		for (int i = 0; i < n; i++)
			((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__boolean*)this)->__item, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((xsd__boolean*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(((xsd__boolean*)a)->__item), "xsd:boolean");
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(((xsd__boolean*)a)->__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__boolean * SOAP_FMAC6 soap_new_xsd__boolean(struct soap *soap, int n)
{	return soap_instantiate_xsd__boolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean(struct soap *soap, xsd__boolean *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean;
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__boolean[n];
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__base64Binary_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__base64Binary_*)this)->__item, SOAP_TYPE_xsd__base64Binary);
	((xsd__base64Binary_*)this)->__item.soap_serialize(soap);
	/* transient soap skipped */
}

void xsd__base64Binary_::soap_default(struct soap *soap)
{
	this->soap = soap;
	((xsd__base64Binary_*)this)->__item.xsd__base64Binary::soap_default(soap);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__base64Binary_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__base64Binary_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary_(struct soap *soap, const char *tag, int id, const xsd__base64Binary_ *a, const char *type)
{
	return (((xsd__base64Binary_*)a)->__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_get_xsd__base64Binary_(struct soap *soap, xsd__base64Binary_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__base64Binary_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_in_xsd__base64Binary_(struct soap *soap, const char *tag, xsd__base64Binary_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__base64Binary_)
			return (xsd__base64Binary_ *)a->soap_in(soap, tag, type);
	}
	if (!(((xsd__base64Binary_*)a)->__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__base64Binary_ * SOAP_FMAC6 soap_new_xsd__base64Binary_(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary_(struct soap *soap, xsd__base64Binary_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_instantiate_xsd__base64Binary_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary_;
		if (size)
			*size = sizeof(xsd__base64Binary_);
		((xsd__base64Binary_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary_[n];
		if (size)
			*size = n * sizeof(xsd__base64Binary_);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary_ %p -> %p\n", q, p));
	*(xsd__base64Binary_*)p = *(xsd__base64Binary_*)q;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), NULL);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__base64Binary_;
			if (size)
				*size = sizeof(xsd__base64Binary_);
			((xsd__base64Binary_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__base64Binary_[n];
			if (size)
				*size = n * sizeof(xsd__base64Binary_);
			for (int i = 0; i < n; i++)
				((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__base64Binary_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean;
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__boolean[n];
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime;
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime[n];
			if (size)
				*size = n * sizeof(xsd__dateTime);
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__decimal_;
			if (size)
				*size = sizeof(xsd__decimal_);
			((xsd__decimal_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__decimal_[n];
			if (size)
				*size = n * sizeof(xsd__decimal_);
			for (int i = 0; i < n; i++)
				((xsd__decimal_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double;
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__double[n];
			if (size)
				*size = n * sizeof(xsd__double);
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int;
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__int[n];
			if (size)
				*size = n * sizeof(xsd__int);
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long;
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__long[n];
			if (size)
				*size = n * sizeof(xsd__long);
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string;
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__string[n];
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:Order"))
	{	cp->type = SOAP_TYPE_ns2__Order_;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__Order_;
			if (size)
				*size = sizeof(ns2__Order_);
			((ns2__Order_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__Order_[n];
			if (size)
				*size = n * sizeof(ns2__Order_);
			for (int i = 0; i < n; i++)
				((ns2__Order_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__Order_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SKSQuery"))
	{	cp->type = SOAP_TYPE_ns2__SKSQuery;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__SKSQuery;
			if (size)
				*size = sizeof(ns2__SKSQuery);
			((ns2__SKSQuery*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__SKSQuery[n];
			if (size)
				*size = n * sizeof(ns2__SKSQuery);
			for (int i = 0; i < n; i++)
				((ns2__SKSQuery*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SKSQuery*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ArrayOfOrderColumn"))
	{	cp->type = SOAP_TYPE_ns2__ArrayOfOrderColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__ArrayOfOrderColumn;
			if (size)
				*size = sizeof(ns2__ArrayOfOrderColumn);
			((ns2__ArrayOfOrderColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__ArrayOfOrderColumn[n];
			if (size)
				*size = n * sizeof(ns2__ArrayOfOrderColumn);
			for (int i = 0; i < n; i++)
				((ns2__ArrayOfOrderColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ArrayOfOrderColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OrderColumn"))
	{	cp->type = SOAP_TYPE_ns2__OrderColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__OrderColumn;
			if (size)
				*size = sizeof(ns2__OrderColumn);
			((ns2__OrderColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__OrderColumn[n];
			if (size)
				*size = n * sizeof(ns2__OrderColumn);
			for (int i = 0; i < n; i++)
				((ns2__OrderColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__OrderColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:LimitOffset"))
	{	cp->type = SOAP_TYPE_ns2__LimitOffset;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__LimitOffset;
			if (size)
				*size = sizeof(ns2__LimitOffset);
			((ns2__LimitOffset*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__LimitOffset[n];
			if (size)
				*size = n * sizeof(ns2__LimitOffset);
			for (int i = 0; i < n; i++)
				((ns2__LimitOffset*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__LimitOffset*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ArrayOfReturnColumn"))
	{	cp->type = SOAP_TYPE_ns2__ArrayOfReturnColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__ArrayOfReturnColumn;
			if (size)
				*size = sizeof(ns2__ArrayOfReturnColumn);
			((ns2__ArrayOfReturnColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__ArrayOfReturnColumn[n];
			if (size)
				*size = n * sizeof(ns2__ArrayOfReturnColumn);
			for (int i = 0; i < n; i++)
				((ns2__ArrayOfReturnColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ArrayOfReturnColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ReturnColumn"))
	{	cp->type = SOAP_TYPE_ns2__ReturnColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__ReturnColumn;
			if (size)
				*size = sizeof(ns2__ReturnColumn);
			((ns2__ReturnColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__ReturnColumn[n];
			if (size)
				*size = n * sizeof(ns2__ReturnColumn);
			for (int i = 0; i < n; i++)
				((ns2__ReturnColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ReturnColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ArrayOfQueryColumn"))
	{	cp->type = SOAP_TYPE_ns2__ArrayOfQueryColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__ArrayOfQueryColumn;
			if (size)
				*size = sizeof(ns2__ArrayOfQueryColumn);
			((ns2__ArrayOfQueryColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__ArrayOfQueryColumn[n];
			if (size)
				*size = n * sizeof(ns2__ArrayOfQueryColumn);
			for (int i = 0; i < n; i++)
				((ns2__ArrayOfQueryColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ArrayOfQueryColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:QueryColumn"))
	{	cp->type = SOAP_TYPE_ns2__QueryColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__QueryColumn;
			if (size)
				*size = sizeof(ns2__QueryColumn);
			((ns2__QueryColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__QueryColumn[n];
			if (size)
				*size = n * sizeof(ns2__QueryColumn);
			for (int i = 0; i < n; i++)
				((ns2__QueryColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__QueryColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:DBColumn"))
	{	cp->type = SOAP_TYPE_ns3__DBColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__DBColumn;
			if (size)
				*size = sizeof(ns3__DBColumn);
			((ns3__DBColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__DBColumn[n];
			if (size)
				*size = n * sizeof(ns3__DBColumn);
			for (int i = 0; i < n; i++)
				((ns3__DBColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__DBColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:ScalarIntf"))
	{	cp->type = SOAP_TYPE_ns3__ScalarIntf;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__ScalarIntf;
			if (size)
				*size = sizeof(ns3__ScalarIntf);
			((ns3__ScalarIntf*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__ScalarIntf[n];
			if (size)
				*size = n * sizeof(ns3__ScalarIntf);
			for (int i = 0; i < n; i++)
				((ns3__ScalarIntf*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__ScalarIntf*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:ColumnOperatorIntf"))
	{	cp->type = SOAP_TYPE_ns3__ColumnOperatorIntf;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__ColumnOperatorIntf;
			if (size)
				*size = sizeof(ns3__ColumnOperatorIntf);
			((ns3__ColumnOperatorIntf*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__ColumnOperatorIntf[n];
			if (size)
				*size = n * sizeof(ns3__ColumnOperatorIntf);
			for (int i = 0; i < n; i++)
				((ns3__ColumnOperatorIntf*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__ColumnOperatorIntf*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:ArrayOfSKSObject"))
	{	cp->type = SOAP_TYPE_ns3__ArrayOfSKSObject;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__ArrayOfSKSObject;
			if (size)
				*size = sizeof(ns3__ArrayOfSKSObject);
			((ns3__ArrayOfSKSObject*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__ArrayOfSKSObject[n];
			if (size)
				*size = n * sizeof(ns3__ArrayOfSKSObject);
			for (int i = 0; i < n; i++)
				((ns3__ArrayOfSKSObject*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__ArrayOfSKSObject*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:SKSObject"))
	{	cp->type = SOAP_TYPE_ns3__SKSObject;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__SKSObject;
			if (size)
				*size = sizeof(ns3__SKSObject);
			((ns3__SKSObject*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__SKSObject[n];
			if (size)
				*size = n * sizeof(ns3__SKSObject);
			for (int i = 0; i < n; i++)
				((ns3__SKSObject*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__SKSObject*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:ArrayOfDBColumn"))
	{	cp->type = SOAP_TYPE_ns3__ArrayOfDBColumn;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__ArrayOfDBColumn;
			if (size)
				*size = sizeof(ns3__ArrayOfDBColumn);
			((ns3__ArrayOfDBColumn*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__ArrayOfDBColumn[n];
			if (size)
				*size = n * sizeof(ns3__ArrayOfDBColumn);
			for (int i = 0; i < n; i++)
				((ns3__ArrayOfDBColumn*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__ArrayOfDBColumn*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:OperatorIntf"))
	{	cp->type = SOAP_TYPE_ns3__OperatorIntf;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__OperatorIntf;
			if (size)
				*size = sizeof(ns3__OperatorIntf);
			((ns3__OperatorIntf*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__OperatorIntf[n];
			if (size)
				*size = n * sizeof(ns3__OperatorIntf);
			for (int i = 0; i < n; i++)
				((ns3__OperatorIntf*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__OperatorIntf*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:anyType2anyTypeMap"))
	{	cp->type = SOAP_TYPE_ns1__anyType2anyTypeMap;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__anyType2anyTypeMap;
			if (size)
				*size = sizeof(ns1__anyType2anyTypeMap);
			((ns1__anyType2anyTypeMap*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__anyType2anyTypeMap[n];
			if (size)
				*size = n * sizeof(ns1__anyType2anyTypeMap);
			for (int i = 0; i < n; i++)
				((ns1__anyType2anyTypeMap*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__anyType2anyTypeMap*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfString"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfString;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfString;
			if (size)
				*size = sizeof(ns1__ArrayOfString);
			((ns1__ArrayOfString*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfString[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfString);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfString*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfDateTime"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfDateTime;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfDateTime;
			if (size)
				*size = sizeof(ns1__ArrayOfDateTime);
			((ns1__ArrayOfDateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfDateTime[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfDateTime);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfDateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfDateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfLong"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfLong;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfLong;
			if (size)
				*size = sizeof(ns1__ArrayOfLong);
			((ns1__ArrayOfLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfLong[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfLong);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfESignatureVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfESignatureVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfESignatureVO;
			if (size)
				*size = sizeof(ns4__ArrayOfESignatureVO);
			((ns4__ArrayOfESignatureVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfESignatureVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfESignatureVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfESignatureVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfESignatureVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ESignatureVO"))
	{	cp->type = SOAP_TYPE_ns4__ESignatureVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ESignatureVO;
			if (size)
				*size = sizeof(ns4__ESignatureVO);
			((ns4__ESignatureVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ESignatureVO[n];
			if (size)
				*size = n * sizeof(ns4__ESignatureVO);
			for (int i = 0; i < n; i++)
				((ns4__ESignatureVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ESignatureVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:EntityVO"))
	{	cp->type = SOAP_TYPE_ns4__EntityVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__EntityVO;
			if (size)
				*size = sizeof(ns4__EntityVO);
			((ns4__EntityVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__EntityVO[n];
			if (size)
				*size = n * sizeof(ns4__EntityVO);
			for (int i = 0; i < n; i++)
				((ns4__EntityVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__EntityVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfFeedbackVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfFeedbackVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfFeedbackVO;
			if (size)
				*size = sizeof(ns4__ArrayOfFeedbackVO);
			((ns4__ArrayOfFeedbackVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfFeedbackVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfFeedbackVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfFeedbackVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfFeedbackVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:FeedbackVO"))
	{	cp->type = SOAP_TYPE_ns4__FeedbackVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__FeedbackVO;
			if (size)
				*size = sizeof(ns4__FeedbackVO);
			((ns4__FeedbackVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__FeedbackVO[n];
			if (size)
				*size = n * sizeof(ns4__FeedbackVO);
			for (int i = 0; i < n; i++)
				((ns4__FeedbackVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__FeedbackVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:UserVO"))
	{	cp->type = SOAP_TYPE_ns4__UserVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__UserVO;
			if (size)
				*size = sizeof(ns4__UserVO);
			((ns4__UserVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__UserVO[n];
			if (size)
				*size = n * sizeof(ns4__UserVO);
			for (int i = 0; i < n; i++)
				((ns4__UserVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__UserVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:EActivityVO"))
	{	cp->type = SOAP_TYPE_ns4__EActivityVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__EActivityVO;
			if (size)
				*size = sizeof(ns4__EActivityVO);
			((ns4__EActivityVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__EActivityVO[n];
			if (size)
				*size = n * sizeof(ns4__EActivityVO);
			for (int i = 0; i < n; i++)
				((ns4__EActivityVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__EActivityVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:PPTSlideVO"))
	{	cp->type = SOAP_TYPE_ns4__PPTSlideVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__PPTSlideVO;
			if (size)
				*size = sizeof(ns4__PPTSlideVO);
			((ns4__PPTSlideVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__PPTSlideVO[n];
			if (size)
				*size = n * sizeof(ns4__PPTSlideVO);
			for (int i = 0; i < n; i++)
				((ns4__PPTSlideVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__PPTSlideVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfEActivityVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfEActivityVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfEActivityVO;
			if (size)
				*size = sizeof(ns4__ArrayOfEActivityVO);
			((ns4__ArrayOfEActivityVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfEActivityVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfEActivityVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfEActivityVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfEActivityVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ImageVO"))
	{	cp->type = SOAP_TYPE_ns4__ImageVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ImageVO;
			if (size)
				*size = sizeof(ns4__ImageVO);
			((ns4__ImageVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ImageVO[n];
			if (size)
				*size = n * sizeof(ns4__ImageVO);
			for (int i = 0; i < n; i++)
				((ns4__ImageVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ImageVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ERelationVO"))
	{	cp->type = SOAP_TYPE_ns4__ERelationVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ERelationVO;
			if (size)
				*size = sizeof(ns4__ERelationVO);
			((ns4__ERelationVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ERelationVO[n];
			if (size)
				*size = n * sizeof(ns4__ERelationVO);
			for (int i = 0; i < n; i++)
				((ns4__ERelationVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ERelationVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfPPTSlideVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfPPTSlideVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfPPTSlideVO;
			if (size)
				*size = sizeof(ns4__ArrayOfPPTSlideVO);
			((ns4__ArrayOfPPTSlideVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfPPTSlideVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfPPTSlideVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfPPTSlideVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfPPTSlideVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfContainerVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfContainerVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfContainerVO;
			if (size)
				*size = sizeof(ns4__ArrayOfContainerVO);
			((ns4__ArrayOfContainerVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfContainerVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfContainerVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfContainerVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfContainerVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ContainerVO"))
	{	cp->type = SOAP_TYPE_ns4__ContainerVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ContainerVO;
			if (size)
				*size = sizeof(ns4__ContainerVO);
			((ns4__ContainerVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ContainerVO[n];
			if (size)
				*size = n * sizeof(ns4__ContainerVO);
			for (int i = 0; i < n; i++)
				((ns4__ContainerVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ContainerVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfPPTVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfPPTVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfPPTVO;
			if (size)
				*size = sizeof(ns4__ArrayOfPPTVO);
			((ns4__ArrayOfPPTVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfPPTVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfPPTVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfPPTVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfPPTVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:PPTVO"))
	{	cp->type = SOAP_TYPE_ns4__PPTVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__PPTVO;
			if (size)
				*size = sizeof(ns4__PPTVO);
			((ns4__PPTVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__PPTVO[n];
			if (size)
				*size = n * sizeof(ns4__PPTVO);
			for (int i = 0; i < n; i++)
				((ns4__PPTVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__PPTVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:DictionaryVO"))
	{	cp->type = SOAP_TYPE_ns4__DictionaryVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__DictionaryVO;
			if (size)
				*size = sizeof(ns4__DictionaryVO);
			((ns4__DictionaryVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__DictionaryVO[n];
			if (size)
				*size = n * sizeof(ns4__DictionaryVO);
			for (int i = 0; i < n; i++)
				((ns4__DictionaryVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__DictionaryVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfERelationVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfERelationVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfERelationVO;
			if (size)
				*size = sizeof(ns4__ArrayOfERelationVO);
			((ns4__ArrayOfERelationVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfERelationVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfERelationVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfERelationVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfERelationVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfDictionaryVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfDictionaryVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfDictionaryVO;
			if (size)
				*size = sizeof(ns4__ArrayOfDictionaryVO);
			((ns4__ArrayOfDictionaryVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfDictionaryVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfDictionaryVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfDictionaryVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfDictionaryVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:CommentVO"))
	{	cp->type = SOAP_TYPE_ns4__CommentVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__CommentVO;
			if (size)
				*size = sizeof(ns4__CommentVO);
			((ns4__CommentVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__CommentVO[n];
			if (size)
				*size = n * sizeof(ns4__CommentVO);
			for (int i = 0; i < n; i++)
				((ns4__CommentVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__CommentVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfEntityVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfEntityVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfEntityVO;
			if (size)
				*size = sizeof(ns4__ArrayOfEntityVO);
			((ns4__ArrayOfEntityVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfEntityVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfEntityVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfEntityVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfEntityVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfUserVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfUserVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfUserVO;
			if (size)
				*size = sizeof(ns4__ArrayOfUserVO);
			((ns4__ArrayOfUserVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfUserVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfUserVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfUserVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfUserVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfImageVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfImageVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfImageVO;
			if (size)
				*size = sizeof(ns4__ArrayOfImageVO);
			((ns4__ArrayOfImageVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfImageVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfImageVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfImageVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfImageVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfCommentVO"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfCommentVO;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfCommentVO;
			if (size)
				*size = sizeof(ns4__ArrayOfCommentVO);
			((ns4__ArrayOfCommentVO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfCommentVO[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfCommentVO);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfCommentVO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfCommentVO*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:SKSWSException"))
	{	cp->type = SOAP_TYPE_ns5__SKSWSException;
		if (n < 0)
		{	cp->ptr = (void*)new ns5__SKSWSException;
			if (size)
				*size = sizeof(ns5__SKSWSException);
			((ns5__SKSWSException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns5__SKSWSException[n];
			if (size)
				*size = n * sizeof(ns5__SKSWSException);
			for (int i = 0; i < n; i++)
				((ns5__SKSWSException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__SKSWSException*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create4(struct soap *soap, const struct __ns1__create4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create4(soap, &a->ns1__create4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create4(struct soap *soap, struct __ns1__create4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create4 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create4(struct soap *soap, const struct __ns1__create4 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create4(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create4(struct soap *soap, const char *tag, int id, const struct __ns1__create4 *a, const char *type)
{
	soap_out_PointerTo_ns1__create4(soap, "ns1:create4", -1, &a->ns1__create4, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create4 * SOAP_FMAC4 soap_get___ns1__create4(struct soap *soap, struct __ns1__create4 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create4 * SOAP_FMAC4 soap_in___ns1__create4(struct soap *soap, const char *tag, struct __ns1__create4 *a, const char *type)
{
	short soap_flag_ns1__create4 = 1;
	a = (struct __ns1__create4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create4, sizeof(struct __ns1__create4), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create4(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create4(soap, "ns1:create4", &a->ns1__create4, ""))
				{	soap_flag_ns1__create4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create4 * SOAP_FMAC6 soap_new___ns1__create4(struct soap *soap, int n)
{	return soap_instantiate___ns1__create4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create4(struct soap *soap, struct __ns1__create4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create4 * SOAP_FMAC4 soap_instantiate___ns1__create4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create4;
		if (size)
			*size = sizeof(struct __ns1__create4);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create4[n];
		if (size)
			*size = n * sizeof(struct __ns1__create4);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create4 %p -> %p\n", q, p));
	*(struct __ns1__create4*)p = *(struct __ns1__create4*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create9(struct soap *soap, const struct __ns1__create9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create9(soap, &a->ns1__create9);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create9(struct soap *soap, struct __ns1__create9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create9 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create9(struct soap *soap, const struct __ns1__create9 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create9(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create9(struct soap *soap, const char *tag, int id, const struct __ns1__create9 *a, const char *type)
{
	soap_out_PointerTo_ns1__create9(soap, "ns1:create9", -1, &a->ns1__create9, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create9 * SOAP_FMAC4 soap_get___ns1__create9(struct soap *soap, struct __ns1__create9 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create9 * SOAP_FMAC4 soap_in___ns1__create9(struct soap *soap, const char *tag, struct __ns1__create9 *a, const char *type)
{
	short soap_flag_ns1__create9 = 1;
	a = (struct __ns1__create9 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create9, sizeof(struct __ns1__create9), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create9(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create9 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create9(soap, "ns1:create9", &a->ns1__create9, ""))
				{	soap_flag_ns1__create9--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create9 * SOAP_FMAC6 soap_new___ns1__create9(struct soap *soap, int n)
{	return soap_instantiate___ns1__create9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create9(struct soap *soap, struct __ns1__create9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create9 * SOAP_FMAC4 soap_instantiate___ns1__create9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create9;
		if (size)
			*size = sizeof(struct __ns1__create9);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create9[n];
		if (size)
			*size = n * sizeof(struct __ns1__create9);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create9 %p -> %p\n", q, p));
	*(struct __ns1__create9*)p = *(struct __ns1__create9*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK11(struct soap *soap, const struct __ns1__findByPK11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK11(soap, &a->ns1__findByPK11);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK11(struct soap *soap, struct __ns1__findByPK11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK11 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK11(struct soap *soap, const struct __ns1__findByPK11 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK11(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK11(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK11 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK11(soap, "ns1:findByPK11", -1, &a->ns1__findByPK11, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK11 * SOAP_FMAC4 soap_get___ns1__findByPK11(struct soap *soap, struct __ns1__findByPK11 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK11 * SOAP_FMAC4 soap_in___ns1__findByPK11(struct soap *soap, const char *tag, struct __ns1__findByPK11 *a, const char *type)
{
	short soap_flag_ns1__findByPK11 = 1;
	a = (struct __ns1__findByPK11 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK11, sizeof(struct __ns1__findByPK11), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK11(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK11(soap, "ns1:findByPK11", &a->ns1__findByPK11, ""))
				{	soap_flag_ns1__findByPK11--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK11 * SOAP_FMAC6 soap_new___ns1__findByPK11(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK11(struct soap *soap, struct __ns1__findByPK11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK11 * SOAP_FMAC4 soap_instantiate___ns1__findByPK11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK11;
		if (size)
			*size = sizeof(struct __ns1__findByPK11);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK11[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK11);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK11 %p -> %p\n", q, p));
	*(struct __ns1__findByPK11*)p = *(struct __ns1__findByPK11*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update1(struct soap *soap, const struct __ns1__update1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update1(soap, &a->ns1__update1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update1(struct soap *soap, struct __ns1__update1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update1 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update1(struct soap *soap, const struct __ns1__update1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update1(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update1(struct soap *soap, const char *tag, int id, const struct __ns1__update1 *a, const char *type)
{
	soap_out_PointerTo_ns1__update1(soap, "ns1:update1", -1, &a->ns1__update1, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update1 * SOAP_FMAC4 soap_get___ns1__update1(struct soap *soap, struct __ns1__update1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update1 * SOAP_FMAC4 soap_in___ns1__update1(struct soap *soap, const char *tag, struct __ns1__update1 *a, const char *type)
{
	short soap_flag_ns1__update1 = 1;
	a = (struct __ns1__update1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update1, sizeof(struct __ns1__update1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update1(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update1(soap, "ns1:update1", &a->ns1__update1, ""))
				{	soap_flag_ns1__update1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update1 * SOAP_FMAC6 soap_new___ns1__update1(struct soap *soap, int n)
{	return soap_instantiate___ns1__update1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update1(struct soap *soap, struct __ns1__update1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update1 * SOAP_FMAC4 soap_instantiate___ns1__update1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update1;
		if (size)
			*size = sizeof(struct __ns1__update1);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update1[n];
		if (size)
			*size = n * sizeof(struct __ns1__update1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update1 %p -> %p\n", q, p));
	*(struct __ns1__update1*)p = *(struct __ns1__update1*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create10(struct soap *soap, const struct __ns1__create10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create10(soap, &a->ns1__create10);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create10(struct soap *soap, struct __ns1__create10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create10 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create10(struct soap *soap, const struct __ns1__create10 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create10(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create10(struct soap *soap, const char *tag, int id, const struct __ns1__create10 *a, const char *type)
{
	soap_out_PointerTo_ns1__create10(soap, "ns1:create10", -1, &a->ns1__create10, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create10 * SOAP_FMAC4 soap_get___ns1__create10(struct soap *soap, struct __ns1__create10 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create10 * SOAP_FMAC4 soap_in___ns1__create10(struct soap *soap, const char *tag, struct __ns1__create10 *a, const char *type)
{
	short soap_flag_ns1__create10 = 1;
	a = (struct __ns1__create10 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create10, sizeof(struct __ns1__create10), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create10(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create10 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create10(soap, "ns1:create10", &a->ns1__create10, ""))
				{	soap_flag_ns1__create10--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create10 * SOAP_FMAC6 soap_new___ns1__create10(struct soap *soap, int n)
{	return soap_instantiate___ns1__create10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create10(struct soap *soap, struct __ns1__create10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create10 * SOAP_FMAC4 soap_instantiate___ns1__create10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create10;
		if (size)
			*size = sizeof(struct __ns1__create10);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create10[n];
		if (size)
			*size = n * sizeof(struct __ns1__create10);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create10 %p -> %p\n", q, p));
	*(struct __ns1__create10*)p = *(struct __ns1__create10*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK1(struct soap *soap, const struct __ns1__findByPK1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK1(soap, &a->ns1__findByPK1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK1(struct soap *soap, struct __ns1__findByPK1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK1 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK1(struct soap *soap, const struct __ns1__findByPK1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK1(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK1(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK1 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK1(soap, "ns1:findByPK1", -1, &a->ns1__findByPK1, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK1 * SOAP_FMAC4 soap_get___ns1__findByPK1(struct soap *soap, struct __ns1__findByPK1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK1 * SOAP_FMAC4 soap_in___ns1__findByPK1(struct soap *soap, const char *tag, struct __ns1__findByPK1 *a, const char *type)
{
	short soap_flag_ns1__findByPK1 = 1;
	a = (struct __ns1__findByPK1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK1, sizeof(struct __ns1__findByPK1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK1(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK1(soap, "ns1:findByPK1", &a->ns1__findByPK1, ""))
				{	soap_flag_ns1__findByPK1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK1 * SOAP_FMAC6 soap_new___ns1__findByPK1(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK1(struct soap *soap, struct __ns1__findByPK1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK1 * SOAP_FMAC4 soap_instantiate___ns1__findByPK1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK1;
		if (size)
			*size = sizeof(struct __ns1__findByPK1);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK1[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK1 %p -> %p\n", q, p));
	*(struct __ns1__findByPK1*)p = *(struct __ns1__findByPK1*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove(struct soap *soap, const struct __ns1__remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove(soap, &a->ns1__remove);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove(struct soap *soap, struct __ns1__remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove(struct soap *soap, const struct __ns1__remove *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove(struct soap *soap, const char *tag, int id, const struct __ns1__remove *a, const char *type)
{
	soap_out_PointerTo_ns1__remove(soap, "ns1:remove", -1, &a->ns1__remove, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove * SOAP_FMAC4 soap_get___ns1__remove(struct soap *soap, struct __ns1__remove *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove * SOAP_FMAC4 soap_in___ns1__remove(struct soap *soap, const char *tag, struct __ns1__remove *a, const char *type)
{
	short soap_flag_ns1__remove = 1;
	a = (struct __ns1__remove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove, sizeof(struct __ns1__remove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove(soap, "ns1:remove", &a->ns1__remove, ""))
				{	soap_flag_ns1__remove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove * SOAP_FMAC6 soap_new___ns1__remove(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove(struct soap *soap, struct __ns1__remove *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove * SOAP_FMAC4 soap_instantiate___ns1__remove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove;
		if (size)
			*size = sizeof(struct __ns1__remove);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove %p -> %p\n", q, p));
	*(struct __ns1__remove*)p = *(struct __ns1__remove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnCommentVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, &a->ns1__findBySQLQueryReturnCommentVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, struct __ns1__findBySQLQueryReturnCommentVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnCommentVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnCommentVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnCommentVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnCommentVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, "ns1:findBySQLQueryReturnCommentVO", -1, &a->ns1__findBySQLQueryReturnCommentVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, struct __ns1__findBySQLQueryReturnCommentVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnCommentVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnCommentVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnCommentVO = 1;
	a = (struct __ns1__findBySQLQueryReturnCommentVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnCommentVO, sizeof(struct __ns1__findBySQLQueryReturnCommentVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnCommentVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnCommentVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, "ns1:findBySQLQueryReturnCommentVO", &a->ns1__findBySQLQueryReturnCommentVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnCommentVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnCommentVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, struct __ns1__findBySQLQueryReturnCommentVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnCommentVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnCommentVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnCommentVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnCommentVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnCommentVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnCommentVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnCommentVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnCommentVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnCommentVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnCommentVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnCommentVO*)p = *(struct __ns1__findBySQLQueryReturnCommentVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK10(struct soap *soap, const struct __ns1__findByPK10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK10(soap, &a->ns1__findByPK10);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK10(struct soap *soap, struct __ns1__findByPK10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK10 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK10(struct soap *soap, const struct __ns1__findByPK10 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK10(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK10(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK10 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK10(soap, "ns1:findByPK10", -1, &a->ns1__findByPK10, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK10 * SOAP_FMAC4 soap_get___ns1__findByPK10(struct soap *soap, struct __ns1__findByPK10 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK10 * SOAP_FMAC4 soap_in___ns1__findByPK10(struct soap *soap, const char *tag, struct __ns1__findByPK10 *a, const char *type)
{
	short soap_flag_ns1__findByPK10 = 1;
	a = (struct __ns1__findByPK10 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK10, sizeof(struct __ns1__findByPK10), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK10(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK10 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK10(soap, "ns1:findByPK10", &a->ns1__findByPK10, ""))
				{	soap_flag_ns1__findByPK10--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK10 * SOAP_FMAC6 soap_new___ns1__findByPK10(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK10(struct soap *soap, struct __ns1__findByPK10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK10 * SOAP_FMAC4 soap_instantiate___ns1__findByPK10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK10;
		if (size)
			*size = sizeof(struct __ns1__findByPK10);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK10[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK10);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK10 %p -> %p\n", q, p));
	*(struct __ns1__findByPK10*)p = *(struct __ns1__findByPK10*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnImageVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnImageVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, &a->ns1__findBySQLQueryReturnImageVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnImageVO(struct soap *soap, struct __ns1__findBySQLQueryReturnImageVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnImageVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnImageVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnImageVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnImageVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnImageVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnImageVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, "ns1:findBySQLQueryReturnImageVO", -1, &a->ns1__findBySQLQueryReturnImageVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnImageVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnImageVO(struct soap *soap, struct __ns1__findBySQLQueryReturnImageVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnImageVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnImageVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnImageVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnImageVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnImageVO = 1;
	a = (struct __ns1__findBySQLQueryReturnImageVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnImageVO, sizeof(struct __ns1__findBySQLQueryReturnImageVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnImageVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnImageVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, "ns1:findBySQLQueryReturnImageVO", &a->ns1__findBySQLQueryReturnImageVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnImageVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnImageVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnImageVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnImageVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnImageVO(struct soap *soap, struct __ns1__findBySQLQueryReturnImageVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnImageVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnImageVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnImageVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnImageVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnImageVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnImageVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnImageVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnImageVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnImageVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnImageVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnImageVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnImageVO*)p = *(struct __ns1__findBySQLQueryReturnImageVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update2(struct soap *soap, const struct __ns1__update2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update2(soap, &a->ns1__update2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update2(struct soap *soap, struct __ns1__update2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update2 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update2(struct soap *soap, const struct __ns1__update2 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update2(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update2(struct soap *soap, const char *tag, int id, const struct __ns1__update2 *a, const char *type)
{
	soap_out_PointerTo_ns1__update2(soap, "ns1:update2", -1, &a->ns1__update2, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update2 * SOAP_FMAC4 soap_get___ns1__update2(struct soap *soap, struct __ns1__update2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update2 * SOAP_FMAC4 soap_in___ns1__update2(struct soap *soap, const char *tag, struct __ns1__update2 *a, const char *type)
{
	short soap_flag_ns1__update2 = 1;
	a = (struct __ns1__update2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update2, sizeof(struct __ns1__update2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update2(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update2(soap, "ns1:update2", &a->ns1__update2, ""))
				{	soap_flag_ns1__update2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update2 * SOAP_FMAC6 soap_new___ns1__update2(struct soap *soap, int n)
{	return soap_instantiate___ns1__update2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update2(struct soap *soap, struct __ns1__update2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update2 * SOAP_FMAC4 soap_instantiate___ns1__update2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update2;
		if (size)
			*size = sizeof(struct __ns1__update2);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update2[n];
		if (size)
			*size = n * sizeof(struct __ns1__update2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update2 %p -> %p\n", q, p));
	*(struct __ns1__update2*)p = *(struct __ns1__update2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK3(struct soap *soap, const struct __ns1__findByPK3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK3(soap, &a->ns1__findByPK3);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK3(struct soap *soap, struct __ns1__findByPK3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK3 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK3(struct soap *soap, const struct __ns1__findByPK3 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK3(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK3(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK3 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK3(soap, "ns1:findByPK3", -1, &a->ns1__findByPK3, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK3 * SOAP_FMAC4 soap_get___ns1__findByPK3(struct soap *soap, struct __ns1__findByPK3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK3 * SOAP_FMAC4 soap_in___ns1__findByPK3(struct soap *soap, const char *tag, struct __ns1__findByPK3 *a, const char *type)
{
	short soap_flag_ns1__findByPK3 = 1;
	a = (struct __ns1__findByPK3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK3, sizeof(struct __ns1__findByPK3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK3(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK3(soap, "ns1:findByPK3", &a->ns1__findByPK3, ""))
				{	soap_flag_ns1__findByPK3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK3 * SOAP_FMAC6 soap_new___ns1__findByPK3(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK3(struct soap *soap, struct __ns1__findByPK3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK3 * SOAP_FMAC4 soap_instantiate___ns1__findByPK3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK3;
		if (size)
			*size = sizeof(struct __ns1__findByPK3);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK3[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK3);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK3 %p -> %p\n", q, p));
	*(struct __ns1__findByPK3*)p = *(struct __ns1__findByPK3*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update5(struct soap *soap, const struct __ns1__update5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update5(soap, &a->ns1__update5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update5(struct soap *soap, struct __ns1__update5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update5 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update5(struct soap *soap, const struct __ns1__update5 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update5(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update5(struct soap *soap, const char *tag, int id, const struct __ns1__update5 *a, const char *type)
{
	soap_out_PointerTo_ns1__update5(soap, "ns1:update5", -1, &a->ns1__update5, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update5 * SOAP_FMAC4 soap_get___ns1__update5(struct soap *soap, struct __ns1__update5 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update5 * SOAP_FMAC4 soap_in___ns1__update5(struct soap *soap, const char *tag, struct __ns1__update5 *a, const char *type)
{
	short soap_flag_ns1__update5 = 1;
	a = (struct __ns1__update5 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update5, sizeof(struct __ns1__update5), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update5(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update5(soap, "ns1:update5", &a->ns1__update5, ""))
				{	soap_flag_ns1__update5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update5 * SOAP_FMAC6 soap_new___ns1__update5(struct soap *soap, int n)
{	return soap_instantiate___ns1__update5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update5(struct soap *soap, struct __ns1__update5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update5 * SOAP_FMAC4 soap_instantiate___ns1__update5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update5;
		if (size)
			*size = sizeof(struct __ns1__update5);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update5[n];
		if (size)
			*size = n * sizeof(struct __ns1__update5);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update5 %p -> %p\n", q, p));
	*(struct __ns1__update5*)p = *(struct __ns1__update5*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove2(struct soap *soap, const struct __ns1__remove2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove2(soap, &a->ns1__remove2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove2(struct soap *soap, struct __ns1__remove2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove2 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove2(struct soap *soap, const struct __ns1__remove2 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove2(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove2(struct soap *soap, const char *tag, int id, const struct __ns1__remove2 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove2(soap, "ns1:remove2", -1, &a->ns1__remove2, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove2 * SOAP_FMAC4 soap_get___ns1__remove2(struct soap *soap, struct __ns1__remove2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove2 * SOAP_FMAC4 soap_in___ns1__remove2(struct soap *soap, const char *tag, struct __ns1__remove2 *a, const char *type)
{
	short soap_flag_ns1__remove2 = 1;
	a = (struct __ns1__remove2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove2, sizeof(struct __ns1__remove2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove2(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove2(soap, "ns1:remove2", &a->ns1__remove2, ""))
				{	soap_flag_ns1__remove2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove2 * SOAP_FMAC6 soap_new___ns1__remove2(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove2(struct soap *soap, struct __ns1__remove2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove2 * SOAP_FMAC4 soap_instantiate___ns1__remove2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove2;
		if (size)
			*size = sizeof(struct __ns1__remove2);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove2[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove2 %p -> %p\n", q, p));
	*(struct __ns1__remove2*)p = *(struct __ns1__remove2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create5(struct soap *soap, const struct __ns1__create5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create5(soap, &a->ns1__create5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create5(struct soap *soap, struct __ns1__create5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create5 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create5(struct soap *soap, const struct __ns1__create5 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create5(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create5(struct soap *soap, const char *tag, int id, const struct __ns1__create5 *a, const char *type)
{
	soap_out_PointerTo_ns1__create5(soap, "ns1:create5", -1, &a->ns1__create5, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create5 * SOAP_FMAC4 soap_get___ns1__create5(struct soap *soap, struct __ns1__create5 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create5 * SOAP_FMAC4 soap_in___ns1__create5(struct soap *soap, const char *tag, struct __ns1__create5 *a, const char *type)
{
	short soap_flag_ns1__create5 = 1;
	a = (struct __ns1__create5 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create5, sizeof(struct __ns1__create5), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create5(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create5(soap, "ns1:create5", &a->ns1__create5, ""))
				{	soap_flag_ns1__create5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create5 * SOAP_FMAC6 soap_new___ns1__create5(struct soap *soap, int n)
{	return soap_instantiate___ns1__create5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create5(struct soap *soap, struct __ns1__create5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create5 * SOAP_FMAC4 soap_instantiate___ns1__create5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create5;
		if (size)
			*size = sizeof(struct __ns1__create5);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create5[n];
		if (size)
			*size = n * sizeof(struct __ns1__create5);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create5 %p -> %p\n", q, p));
	*(struct __ns1__create5*)p = *(struct __ns1__create5*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove11(struct soap *soap, const struct __ns1__remove11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove11(soap, &a->ns1__remove11);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove11(struct soap *soap, struct __ns1__remove11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove11 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove11(struct soap *soap, const struct __ns1__remove11 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove11(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove11(struct soap *soap, const char *tag, int id, const struct __ns1__remove11 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove11(soap, "ns1:remove11", -1, &a->ns1__remove11, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove11 * SOAP_FMAC4 soap_get___ns1__remove11(struct soap *soap, struct __ns1__remove11 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove11 * SOAP_FMAC4 soap_in___ns1__remove11(struct soap *soap, const char *tag, struct __ns1__remove11 *a, const char *type)
{
	short soap_flag_ns1__remove11 = 1;
	a = (struct __ns1__remove11 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove11, sizeof(struct __ns1__remove11), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove11(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove11(soap, "ns1:remove11", &a->ns1__remove11, ""))
				{	soap_flag_ns1__remove11--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove11 * SOAP_FMAC6 soap_new___ns1__remove11(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove11(struct soap *soap, struct __ns1__remove11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove11 * SOAP_FMAC4 soap_instantiate___ns1__remove11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove11;
		if (size)
			*size = sizeof(struct __ns1__remove11);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove11[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove11);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove11 %p -> %p\n", q, p));
	*(struct __ns1__remove11*)p = *(struct __ns1__remove11*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnUserVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnUserVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, &a->ns1__findBySQLQueryReturnUserVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnUserVO(struct soap *soap, struct __ns1__findBySQLQueryReturnUserVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnUserVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnUserVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnUserVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnUserVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnUserVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnUserVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, "ns1:findBySQLQueryReturnUserVO", -1, &a->ns1__findBySQLQueryReturnUserVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnUserVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnUserVO(struct soap *soap, struct __ns1__findBySQLQueryReturnUserVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnUserVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnUserVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnUserVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnUserVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnUserVO = 1;
	a = (struct __ns1__findBySQLQueryReturnUserVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnUserVO, sizeof(struct __ns1__findBySQLQueryReturnUserVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnUserVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnUserVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, "ns1:findBySQLQueryReturnUserVO", &a->ns1__findBySQLQueryReturnUserVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnUserVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnUserVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnUserVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnUserVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnUserVO(struct soap *soap, struct __ns1__findBySQLQueryReturnUserVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnUserVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnUserVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnUserVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnUserVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnUserVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnUserVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnUserVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnUserVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnUserVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnUserVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnUserVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnUserVO*)p = *(struct __ns1__findBySQLQueryReturnUserVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnEntityVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, &a->ns1__findBySQLQueryReturnEntityVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, struct __ns1__findBySQLQueryReturnEntityVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnEntityVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnEntityVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnEntityVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnEntityVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, "ns1:findBySQLQueryReturnEntityVO", -1, &a->ns1__findBySQLQueryReturnEntityVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, struct __ns1__findBySQLQueryReturnEntityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnEntityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnEntityVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnEntityVO = 1;
	a = (struct __ns1__findBySQLQueryReturnEntityVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnEntityVO, sizeof(struct __ns1__findBySQLQueryReturnEntityVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnEntityVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnEntityVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, "ns1:findBySQLQueryReturnEntityVO", &a->ns1__findBySQLQueryReturnEntityVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnEntityVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnEntityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, struct __ns1__findBySQLQueryReturnEntityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnEntityVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnEntityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnEntityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnEntityVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnEntityVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnEntityVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnEntityVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnEntityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnEntityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnEntityVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnEntityVO*)p = *(struct __ns1__findBySQLQueryReturnEntityVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create(struct soap *soap, const struct __ns1__create *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create(soap, &a->ns1__create);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create(struct soap *soap, struct __ns1__create *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create(struct soap *soap, const struct __ns1__create *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create(struct soap *soap, const char *tag, int id, const struct __ns1__create *a, const char *type)
{
	soap_out_PointerTo_ns1__create(soap, "ns1:create", -1, &a->ns1__create, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create * SOAP_FMAC4 soap_get___ns1__create(struct soap *soap, struct __ns1__create *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create * SOAP_FMAC4 soap_in___ns1__create(struct soap *soap, const char *tag, struct __ns1__create *a, const char *type)
{
	short soap_flag_ns1__create = 1;
	a = (struct __ns1__create *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create, sizeof(struct __ns1__create), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create(soap, "ns1:create", &a->ns1__create, ""))
				{	soap_flag_ns1__create--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create * SOAP_FMAC6 soap_new___ns1__create(struct soap *soap, int n)
{	return soap_instantiate___ns1__create(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create(struct soap *soap, struct __ns1__create *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create * SOAP_FMAC4 soap_instantiate___ns1__create(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create;
		if (size)
			*size = sizeof(struct __ns1__create);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create[n];
		if (size)
			*size = n * sizeof(struct __ns1__create);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create %p -> %p\n", q, p));
	*(struct __ns1__create*)p = *(struct __ns1__create*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove1(struct soap *soap, const struct __ns1__remove1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove1(soap, &a->ns1__remove1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove1(struct soap *soap, struct __ns1__remove1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove1 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove1(struct soap *soap, const struct __ns1__remove1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove1(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove1(struct soap *soap, const char *tag, int id, const struct __ns1__remove1 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove1(soap, "ns1:remove1", -1, &a->ns1__remove1, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove1 * SOAP_FMAC4 soap_get___ns1__remove1(struct soap *soap, struct __ns1__remove1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove1 * SOAP_FMAC4 soap_in___ns1__remove1(struct soap *soap, const char *tag, struct __ns1__remove1 *a, const char *type)
{
	short soap_flag_ns1__remove1 = 1;
	a = (struct __ns1__remove1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove1, sizeof(struct __ns1__remove1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove1(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove1(soap, "ns1:remove1", &a->ns1__remove1, ""))
				{	soap_flag_ns1__remove1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove1 * SOAP_FMAC6 soap_new___ns1__remove1(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove1(struct soap *soap, struct __ns1__remove1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove1 * SOAP_FMAC4 soap_instantiate___ns1__remove1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove1;
		if (size)
			*size = sizeof(struct __ns1__remove1);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove1[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove1 %p -> %p\n", q, p));
	*(struct __ns1__remove1*)p = *(struct __ns1__remove1*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK7(struct soap *soap, const struct __ns1__findByPK7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK7(soap, &a->ns1__findByPK7);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK7(struct soap *soap, struct __ns1__findByPK7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK7 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK7(struct soap *soap, const struct __ns1__findByPK7 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK7(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK7(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK7 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK7(soap, "ns1:findByPK7", -1, &a->ns1__findByPK7, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK7 * SOAP_FMAC4 soap_get___ns1__findByPK7(struct soap *soap, struct __ns1__findByPK7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK7 * SOAP_FMAC4 soap_in___ns1__findByPK7(struct soap *soap, const char *tag, struct __ns1__findByPK7 *a, const char *type)
{
	short soap_flag_ns1__findByPK7 = 1;
	a = (struct __ns1__findByPK7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK7, sizeof(struct __ns1__findByPK7), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK7(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK7 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK7(soap, "ns1:findByPK7", &a->ns1__findByPK7, ""))
				{	soap_flag_ns1__findByPK7--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK7 * SOAP_FMAC6 soap_new___ns1__findByPK7(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK7(struct soap *soap, struct __ns1__findByPK7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK7 * SOAP_FMAC4 soap_instantiate___ns1__findByPK7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK7;
		if (size)
			*size = sizeof(struct __ns1__findByPK7);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK7[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK7);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK7 %p -> %p\n", q, p));
	*(struct __ns1__findByPK7*)p = *(struct __ns1__findByPK7*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__echoString(struct soap *soap, const struct __ns1__echoString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__echoString(soap, &a->ns1__echoString);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__echoString(struct soap *soap, struct __ns1__echoString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__echoString = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__echoString(struct soap *soap, const struct __ns1__echoString *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__echoString(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__echoString(struct soap *soap, const char *tag, int id, const struct __ns1__echoString *a, const char *type)
{
	soap_out_PointerTo_ns1__echoString(soap, "ns1:echoString", -1, &a->ns1__echoString, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__echoString * SOAP_FMAC4 soap_get___ns1__echoString(struct soap *soap, struct __ns1__echoString *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__echoString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__echoString * SOAP_FMAC4 soap_in___ns1__echoString(struct soap *soap, const char *tag, struct __ns1__echoString *a, const char *type)
{
	short soap_flag_ns1__echoString = 1;
	a = (struct __ns1__echoString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__echoString, sizeof(struct __ns1__echoString), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__echoString(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__echoString && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__echoString(soap, "ns1:echoString", &a->ns1__echoString, ""))
				{	soap_flag_ns1__echoString--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__echoString * SOAP_FMAC6 soap_new___ns1__echoString(struct soap *soap, int n)
{	return soap_instantiate___ns1__echoString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__echoString(struct soap *soap, struct __ns1__echoString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__echoString * SOAP_FMAC4 soap_instantiate___ns1__echoString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__echoString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__echoString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__echoString;
		if (size)
			*size = sizeof(struct __ns1__echoString);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__echoString[n];
		if (size)
			*size = n * sizeof(struct __ns1__echoString);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__echoString*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__echoString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__echoString %p -> %p\n", q, p));
	*(struct __ns1__echoString*)p = *(struct __ns1__echoString*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create2(struct soap *soap, const struct __ns1__create2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create2(soap, &a->ns1__create2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create2(struct soap *soap, struct __ns1__create2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create2 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create2(struct soap *soap, const struct __ns1__create2 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create2(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create2(struct soap *soap, const char *tag, int id, const struct __ns1__create2 *a, const char *type)
{
	soap_out_PointerTo_ns1__create2(soap, "ns1:create2", -1, &a->ns1__create2, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create2 * SOAP_FMAC4 soap_get___ns1__create2(struct soap *soap, struct __ns1__create2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create2 * SOAP_FMAC4 soap_in___ns1__create2(struct soap *soap, const char *tag, struct __ns1__create2 *a, const char *type)
{
	short soap_flag_ns1__create2 = 1;
	a = (struct __ns1__create2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create2, sizeof(struct __ns1__create2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create2(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create2(soap, "ns1:create2", &a->ns1__create2, ""))
				{	soap_flag_ns1__create2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create2 * SOAP_FMAC6 soap_new___ns1__create2(struct soap *soap, int n)
{	return soap_instantiate___ns1__create2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create2(struct soap *soap, struct __ns1__create2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create2 * SOAP_FMAC4 soap_instantiate___ns1__create2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create2;
		if (size)
			*size = sizeof(struct __ns1__create2);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create2[n];
		if (size)
			*size = n * sizeof(struct __ns1__create2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create2 %p -> %p\n", q, p));
	*(struct __ns1__create2*)p = *(struct __ns1__create2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK6(struct soap *soap, const struct __ns1__findByPK6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK6(soap, &a->ns1__findByPK6);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK6(struct soap *soap, struct __ns1__findByPK6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK6 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK6(struct soap *soap, const struct __ns1__findByPK6 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK6(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK6(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK6 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK6(soap, "ns1:findByPK6", -1, &a->ns1__findByPK6, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK6 * SOAP_FMAC4 soap_get___ns1__findByPK6(struct soap *soap, struct __ns1__findByPK6 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK6 * SOAP_FMAC4 soap_in___ns1__findByPK6(struct soap *soap, const char *tag, struct __ns1__findByPK6 *a, const char *type)
{
	short soap_flag_ns1__findByPK6 = 1;
	a = (struct __ns1__findByPK6 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK6, sizeof(struct __ns1__findByPK6), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK6(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK6(soap, "ns1:findByPK6", &a->ns1__findByPK6, ""))
				{	soap_flag_ns1__findByPK6--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK6 * SOAP_FMAC6 soap_new___ns1__findByPK6(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK6(struct soap *soap, struct __ns1__findByPK6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK6 * SOAP_FMAC4 soap_instantiate___ns1__findByPK6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK6;
		if (size)
			*size = sizeof(struct __ns1__findByPK6);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK6[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK6);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK6 %p -> %p\n", q, p));
	*(struct __ns1__findByPK6*)p = *(struct __ns1__findByPK6*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update(struct soap *soap, const struct __ns1__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update(soap, &a->ns1__update);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update(struct soap *soap, struct __ns1__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update(struct soap *soap, const struct __ns1__update *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update(struct soap *soap, const char *tag, int id, const struct __ns1__update *a, const char *type)
{
	soap_out_PointerTo_ns1__update(soap, "ns1:update", -1, &a->ns1__update, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update * SOAP_FMAC4 soap_get___ns1__update(struct soap *soap, struct __ns1__update *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update * SOAP_FMAC4 soap_in___ns1__update(struct soap *soap, const char *tag, struct __ns1__update *a, const char *type)
{
	short soap_flag_ns1__update = 1;
	a = (struct __ns1__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update, sizeof(struct __ns1__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update(soap, "ns1:update", &a->ns1__update, ""))
				{	soap_flag_ns1__update--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update * SOAP_FMAC6 soap_new___ns1__update(struct soap *soap, int n)
{	return soap_instantiate___ns1__update(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update(struct soap *soap, struct __ns1__update *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update * SOAP_FMAC4 soap_instantiate___ns1__update(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update;
		if (size)
			*size = sizeof(struct __ns1__update);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update[n];
		if (size)
			*size = n * sizeof(struct __ns1__update);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update %p -> %p\n", q, p));
	*(struct __ns1__update*)p = *(struct __ns1__update*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove10(struct soap *soap, const struct __ns1__remove10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove10(soap, &a->ns1__remove10);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove10(struct soap *soap, struct __ns1__remove10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove10 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove10(struct soap *soap, const struct __ns1__remove10 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove10(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove10(struct soap *soap, const char *tag, int id, const struct __ns1__remove10 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove10(soap, "ns1:remove10", -1, &a->ns1__remove10, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove10 * SOAP_FMAC4 soap_get___ns1__remove10(struct soap *soap, struct __ns1__remove10 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove10 * SOAP_FMAC4 soap_in___ns1__remove10(struct soap *soap, const char *tag, struct __ns1__remove10 *a, const char *type)
{
	short soap_flag_ns1__remove10 = 1;
	a = (struct __ns1__remove10 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove10, sizeof(struct __ns1__remove10), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove10(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove10 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove10(soap, "ns1:remove10", &a->ns1__remove10, ""))
				{	soap_flag_ns1__remove10--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove10 * SOAP_FMAC6 soap_new___ns1__remove10(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove10(struct soap *soap, struct __ns1__remove10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove10 * SOAP_FMAC4 soap_instantiate___ns1__remove10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove10;
		if (size)
			*size = sizeof(struct __ns1__remove10);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove10[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove10);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove10 %p -> %p\n", q, p));
	*(struct __ns1__remove10*)p = *(struct __ns1__remove10*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create3(struct soap *soap, const struct __ns1__create3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create3(soap, &a->ns1__create3);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create3(struct soap *soap, struct __ns1__create3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create3 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create3(struct soap *soap, const struct __ns1__create3 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create3(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create3(struct soap *soap, const char *tag, int id, const struct __ns1__create3 *a, const char *type)
{
	soap_out_PointerTo_ns1__create3(soap, "ns1:create3", -1, &a->ns1__create3, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create3 * SOAP_FMAC4 soap_get___ns1__create3(struct soap *soap, struct __ns1__create3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create3 * SOAP_FMAC4 soap_in___ns1__create3(struct soap *soap, const char *tag, struct __ns1__create3 *a, const char *type)
{
	short soap_flag_ns1__create3 = 1;
	a = (struct __ns1__create3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create3, sizeof(struct __ns1__create3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create3(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create3(soap, "ns1:create3", &a->ns1__create3, ""))
				{	soap_flag_ns1__create3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create3 * SOAP_FMAC6 soap_new___ns1__create3(struct soap *soap, int n)
{	return soap_instantiate___ns1__create3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create3(struct soap *soap, struct __ns1__create3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create3 * SOAP_FMAC4 soap_instantiate___ns1__create3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create3;
		if (size)
			*size = sizeof(struct __ns1__create3);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create3[n];
		if (size)
			*size = n * sizeof(struct __ns1__create3);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create3 %p -> %p\n", q, p));
	*(struct __ns1__create3*)p = *(struct __ns1__create3*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK(struct soap *soap, const struct __ns1__findByPK *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK(soap, &a->ns1__findByPK);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK(struct soap *soap, struct __ns1__findByPK *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK(struct soap *soap, const struct __ns1__findByPK *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK(soap, "ns1:findByPK", -1, &a->ns1__findByPK, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK * SOAP_FMAC4 soap_get___ns1__findByPK(struct soap *soap, struct __ns1__findByPK *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK * SOAP_FMAC4 soap_in___ns1__findByPK(struct soap *soap, const char *tag, struct __ns1__findByPK *a, const char *type)
{
	short soap_flag_ns1__findByPK = 1;
	a = (struct __ns1__findByPK *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK, sizeof(struct __ns1__findByPK), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK(soap, "ns1:findByPK", &a->ns1__findByPK, ""))
				{	soap_flag_ns1__findByPK--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK * SOAP_FMAC6 soap_new___ns1__findByPK(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK(struct soap *soap, struct __ns1__findByPK *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK * SOAP_FMAC4 soap_instantiate___ns1__findByPK(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK;
		if (size)
			*size = sizeof(struct __ns1__findByPK);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK %p -> %p\n", q, p));
	*(struct __ns1__findByPK*)p = *(struct __ns1__findByPK*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update6(struct soap *soap, const struct __ns1__update6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update6(soap, &a->ns1__update6);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update6(struct soap *soap, struct __ns1__update6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update6 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update6(struct soap *soap, const struct __ns1__update6 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update6(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update6(struct soap *soap, const char *tag, int id, const struct __ns1__update6 *a, const char *type)
{
	soap_out_PointerTo_ns1__update6(soap, "ns1:update6", -1, &a->ns1__update6, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update6 * SOAP_FMAC4 soap_get___ns1__update6(struct soap *soap, struct __ns1__update6 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update6 * SOAP_FMAC4 soap_in___ns1__update6(struct soap *soap, const char *tag, struct __ns1__update6 *a, const char *type)
{
	short soap_flag_ns1__update6 = 1;
	a = (struct __ns1__update6 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update6, sizeof(struct __ns1__update6), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update6(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update6(soap, "ns1:update6", &a->ns1__update6, ""))
				{	soap_flag_ns1__update6--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update6 * SOAP_FMAC6 soap_new___ns1__update6(struct soap *soap, int n)
{	return soap_instantiate___ns1__update6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update6(struct soap *soap, struct __ns1__update6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update6 * SOAP_FMAC4 soap_instantiate___ns1__update6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update6;
		if (size)
			*size = sizeof(struct __ns1__update6);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update6[n];
		if (size)
			*size = n * sizeof(struct __ns1__update6);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update6 %p -> %p\n", q, p));
	*(struct __ns1__update6*)p = *(struct __ns1__update6*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update9(struct soap *soap, const struct __ns1__update9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update9(soap, &a->ns1__update9);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update9(struct soap *soap, struct __ns1__update9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update9 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update9(struct soap *soap, const struct __ns1__update9 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update9(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update9(struct soap *soap, const char *tag, int id, const struct __ns1__update9 *a, const char *type)
{
	soap_out_PointerTo_ns1__update9(soap, "ns1:update9", -1, &a->ns1__update9, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update9 * SOAP_FMAC4 soap_get___ns1__update9(struct soap *soap, struct __ns1__update9 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update9 * SOAP_FMAC4 soap_in___ns1__update9(struct soap *soap, const char *tag, struct __ns1__update9 *a, const char *type)
{
	short soap_flag_ns1__update9 = 1;
	a = (struct __ns1__update9 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update9, sizeof(struct __ns1__update9), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update9(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update9 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update9(soap, "ns1:update9", &a->ns1__update9, ""))
				{	soap_flag_ns1__update9--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update9 * SOAP_FMAC6 soap_new___ns1__update9(struct soap *soap, int n)
{	return soap_instantiate___ns1__update9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update9(struct soap *soap, struct __ns1__update9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update9 * SOAP_FMAC4 soap_instantiate___ns1__update9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update9;
		if (size)
			*size = sizeof(struct __ns1__update9);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update9[n];
		if (size)
			*size = n * sizeof(struct __ns1__update9);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update9 %p -> %p\n", q, p));
	*(struct __ns1__update9*)p = *(struct __ns1__update9*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update11(struct soap *soap, const struct __ns1__update11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update11(soap, &a->ns1__update11);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update11(struct soap *soap, struct __ns1__update11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update11 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update11(struct soap *soap, const struct __ns1__update11 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update11(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update11(struct soap *soap, const char *tag, int id, const struct __ns1__update11 *a, const char *type)
{
	soap_out_PointerTo_ns1__update11(soap, "ns1:update11", -1, &a->ns1__update11, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update11 * SOAP_FMAC4 soap_get___ns1__update11(struct soap *soap, struct __ns1__update11 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update11 * SOAP_FMAC4 soap_in___ns1__update11(struct soap *soap, const char *tag, struct __ns1__update11 *a, const char *type)
{
	short soap_flag_ns1__update11 = 1;
	a = (struct __ns1__update11 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update11, sizeof(struct __ns1__update11), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update11(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update11(soap, "ns1:update11", &a->ns1__update11, ""))
				{	soap_flag_ns1__update11--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update11 * SOAP_FMAC6 soap_new___ns1__update11(struct soap *soap, int n)
{	return soap_instantiate___ns1__update11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update11(struct soap *soap, struct __ns1__update11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update11 * SOAP_FMAC4 soap_instantiate___ns1__update11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update11;
		if (size)
			*size = sizeof(struct __ns1__update11);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update11[n];
		if (size)
			*size = n * sizeof(struct __ns1__update11);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update11 %p -> %p\n", q, p));
	*(struct __ns1__update11*)p = *(struct __ns1__update11*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove7(struct soap *soap, const struct __ns1__remove7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove7(soap, &a->ns1__remove7);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove7(struct soap *soap, struct __ns1__remove7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove7 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove7(struct soap *soap, const struct __ns1__remove7 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove7(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove7(struct soap *soap, const char *tag, int id, const struct __ns1__remove7 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove7(soap, "ns1:remove7", -1, &a->ns1__remove7, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove7 * SOAP_FMAC4 soap_get___ns1__remove7(struct soap *soap, struct __ns1__remove7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove7 * SOAP_FMAC4 soap_in___ns1__remove7(struct soap *soap, const char *tag, struct __ns1__remove7 *a, const char *type)
{
	short soap_flag_ns1__remove7 = 1;
	a = (struct __ns1__remove7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove7, sizeof(struct __ns1__remove7), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove7(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove7 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove7(soap, "ns1:remove7", &a->ns1__remove7, ""))
				{	soap_flag_ns1__remove7--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove7 * SOAP_FMAC6 soap_new___ns1__remove7(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove7(struct soap *soap, struct __ns1__remove7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove7 * SOAP_FMAC4 soap_instantiate___ns1__remove7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove7;
		if (size)
			*size = sizeof(struct __ns1__remove7);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove7[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove7);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove7 %p -> %p\n", q, p));
	*(struct __ns1__remove7*)p = *(struct __ns1__remove7*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnDictionaryVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, &a->ns1__findBySQLQueryReturnDictionaryVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, struct __ns1__findBySQLQueryReturnDictionaryVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnDictionaryVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnDictionaryVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnDictionaryVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnDictionaryVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, "ns1:findBySQLQueryReturnDictionaryVO", -1, &a->ns1__findBySQLQueryReturnDictionaryVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, struct __ns1__findBySQLQueryReturnDictionaryVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnDictionaryVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnDictionaryVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnDictionaryVO = 1;
	a = (struct __ns1__findBySQLQueryReturnDictionaryVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnDictionaryVO, sizeof(struct __ns1__findBySQLQueryReturnDictionaryVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnDictionaryVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnDictionaryVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, "ns1:findBySQLQueryReturnDictionaryVO", &a->ns1__findBySQLQueryReturnDictionaryVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnDictionaryVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnDictionaryVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, struct __ns1__findBySQLQueryReturnDictionaryVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnDictionaryVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnDictionaryVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnDictionaryVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnDictionaryVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnDictionaryVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnDictionaryVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnDictionaryVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnDictionaryVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnDictionaryVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnDictionaryVO*)p = *(struct __ns1__findBySQLQueryReturnDictionaryVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnERelationVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, &a->ns1__findBySQLQueryReturnERelationVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, struct __ns1__findBySQLQueryReturnERelationVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnERelationVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnERelationVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnERelationVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnERelationVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, "ns1:findBySQLQueryReturnERelationVO", -1, &a->ns1__findBySQLQueryReturnERelationVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, struct __ns1__findBySQLQueryReturnERelationVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnERelationVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnERelationVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnERelationVO = 1;
	a = (struct __ns1__findBySQLQueryReturnERelationVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnERelationVO, sizeof(struct __ns1__findBySQLQueryReturnERelationVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnERelationVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnERelationVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, "ns1:findBySQLQueryReturnERelationVO", &a->ns1__findBySQLQueryReturnERelationVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnERelationVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnERelationVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, struct __ns1__findBySQLQueryReturnERelationVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnERelationVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnERelationVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnERelationVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnERelationVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnERelationVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnERelationVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnERelationVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnERelationVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnERelationVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnERelationVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnERelationVO*)p = *(struct __ns1__findBySQLQueryReturnERelationVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK4(struct soap *soap, const struct __ns1__findByPK4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK4(soap, &a->ns1__findByPK4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK4(struct soap *soap, struct __ns1__findByPK4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK4 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK4(struct soap *soap, const struct __ns1__findByPK4 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK4(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK4(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK4 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK4(soap, "ns1:findByPK4", -1, &a->ns1__findByPK4, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK4 * SOAP_FMAC4 soap_get___ns1__findByPK4(struct soap *soap, struct __ns1__findByPK4 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK4 * SOAP_FMAC4 soap_in___ns1__findByPK4(struct soap *soap, const char *tag, struct __ns1__findByPK4 *a, const char *type)
{
	short soap_flag_ns1__findByPK4 = 1;
	a = (struct __ns1__findByPK4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK4, sizeof(struct __ns1__findByPK4), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK4(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK4(soap, "ns1:findByPK4", &a->ns1__findByPK4, ""))
				{	soap_flag_ns1__findByPK4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK4 * SOAP_FMAC6 soap_new___ns1__findByPK4(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK4(struct soap *soap, struct __ns1__findByPK4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK4 * SOAP_FMAC4 soap_instantiate___ns1__findByPK4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK4;
		if (size)
			*size = sizeof(struct __ns1__findByPK4);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK4[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK4);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK4 %p -> %p\n", q, p));
	*(struct __ns1__findByPK4*)p = *(struct __ns1__findByPK4*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK9(struct soap *soap, const struct __ns1__findByPK9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK9(soap, &a->ns1__findByPK9);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK9(struct soap *soap, struct __ns1__findByPK9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK9 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK9(struct soap *soap, const struct __ns1__findByPK9 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK9(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK9(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK9 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK9(soap, "ns1:findByPK9", -1, &a->ns1__findByPK9, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK9 * SOAP_FMAC4 soap_get___ns1__findByPK9(struct soap *soap, struct __ns1__findByPK9 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK9 * SOAP_FMAC4 soap_in___ns1__findByPK9(struct soap *soap, const char *tag, struct __ns1__findByPK9 *a, const char *type)
{
	short soap_flag_ns1__findByPK9 = 1;
	a = (struct __ns1__findByPK9 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK9, sizeof(struct __ns1__findByPK9), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK9(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK9 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK9(soap, "ns1:findByPK9", &a->ns1__findByPK9, ""))
				{	soap_flag_ns1__findByPK9--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK9 * SOAP_FMAC6 soap_new___ns1__findByPK9(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK9(struct soap *soap, struct __ns1__findByPK9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK9 * SOAP_FMAC4 soap_instantiate___ns1__findByPK9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK9;
		if (size)
			*size = sizeof(struct __ns1__findByPK9);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK9[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK9);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK9 %p -> %p\n", q, p));
	*(struct __ns1__findByPK9*)p = *(struct __ns1__findByPK9*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update10(struct soap *soap, const struct __ns1__update10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update10(soap, &a->ns1__update10);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update10(struct soap *soap, struct __ns1__update10 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update10 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update10(struct soap *soap, const struct __ns1__update10 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update10(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update10(struct soap *soap, const char *tag, int id, const struct __ns1__update10 *a, const char *type)
{
	soap_out_PointerTo_ns1__update10(soap, "ns1:update10", -1, &a->ns1__update10, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update10 * SOAP_FMAC4 soap_get___ns1__update10(struct soap *soap, struct __ns1__update10 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update10 * SOAP_FMAC4 soap_in___ns1__update10(struct soap *soap, const char *tag, struct __ns1__update10 *a, const char *type)
{
	short soap_flag_ns1__update10 = 1;
	a = (struct __ns1__update10 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update10, sizeof(struct __ns1__update10), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update10(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update10 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update10(soap, "ns1:update10", &a->ns1__update10, ""))
				{	soap_flag_ns1__update10--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update10 * SOAP_FMAC6 soap_new___ns1__update10(struct soap *soap, int n)
{	return soap_instantiate___ns1__update10(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update10(struct soap *soap, struct __ns1__update10 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update10 * SOAP_FMAC4 soap_instantiate___ns1__update10(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update10(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update10, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update10;
		if (size)
			*size = sizeof(struct __ns1__update10);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update10[n];
		if (size)
			*size = n * sizeof(struct __ns1__update10);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update10*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update10(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update10 %p -> %p\n", q, p));
	*(struct __ns1__update10*)p = *(struct __ns1__update10*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update8(struct soap *soap, const struct __ns1__update8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update8(soap, &a->ns1__update8);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update8(struct soap *soap, struct __ns1__update8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update8 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update8(struct soap *soap, const struct __ns1__update8 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update8(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update8(struct soap *soap, const char *tag, int id, const struct __ns1__update8 *a, const char *type)
{
	soap_out_PointerTo_ns1__update8(soap, "ns1:update8", -1, &a->ns1__update8, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update8 * SOAP_FMAC4 soap_get___ns1__update8(struct soap *soap, struct __ns1__update8 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update8 * SOAP_FMAC4 soap_in___ns1__update8(struct soap *soap, const char *tag, struct __ns1__update8 *a, const char *type)
{
	short soap_flag_ns1__update8 = 1;
	a = (struct __ns1__update8 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update8, sizeof(struct __ns1__update8), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update8(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update8 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update8(soap, "ns1:update8", &a->ns1__update8, ""))
				{	soap_flag_ns1__update8--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update8 * SOAP_FMAC6 soap_new___ns1__update8(struct soap *soap, int n)
{	return soap_instantiate___ns1__update8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update8(struct soap *soap, struct __ns1__update8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update8 * SOAP_FMAC4 soap_instantiate___ns1__update8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update8;
		if (size)
			*size = sizeof(struct __ns1__update8);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update8[n];
		if (size)
			*size = n * sizeof(struct __ns1__update8);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update8 %p -> %p\n", q, p));
	*(struct __ns1__update8*)p = *(struct __ns1__update8*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create1(struct soap *soap, const struct __ns1__create1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create1(soap, &a->ns1__create1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create1(struct soap *soap, struct __ns1__create1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create1 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create1(struct soap *soap, const struct __ns1__create1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create1(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create1(struct soap *soap, const char *tag, int id, const struct __ns1__create1 *a, const char *type)
{
	soap_out_PointerTo_ns1__create1(soap, "ns1:create1", -1, &a->ns1__create1, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create1 * SOAP_FMAC4 soap_get___ns1__create1(struct soap *soap, struct __ns1__create1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create1 * SOAP_FMAC4 soap_in___ns1__create1(struct soap *soap, const char *tag, struct __ns1__create1 *a, const char *type)
{
	short soap_flag_ns1__create1 = 1;
	a = (struct __ns1__create1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create1, sizeof(struct __ns1__create1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create1(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create1(soap, "ns1:create1", &a->ns1__create1, ""))
				{	soap_flag_ns1__create1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create1 * SOAP_FMAC6 soap_new___ns1__create1(struct soap *soap, int n)
{	return soap_instantiate___ns1__create1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create1(struct soap *soap, struct __ns1__create1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create1 * SOAP_FMAC4 soap_instantiate___ns1__create1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create1;
		if (size)
			*size = sizeof(struct __ns1__create1);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create1[n];
		if (size)
			*size = n * sizeof(struct __ns1__create1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create1 %p -> %p\n", q, p));
	*(struct __ns1__create1*)p = *(struct __ns1__create1*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove8(struct soap *soap, const struct __ns1__remove8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove8(soap, &a->ns1__remove8);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove8(struct soap *soap, struct __ns1__remove8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove8 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove8(struct soap *soap, const struct __ns1__remove8 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove8(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove8(struct soap *soap, const char *tag, int id, const struct __ns1__remove8 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove8(soap, "ns1:remove8", -1, &a->ns1__remove8, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove8 * SOAP_FMAC4 soap_get___ns1__remove8(struct soap *soap, struct __ns1__remove8 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove8 * SOAP_FMAC4 soap_in___ns1__remove8(struct soap *soap, const char *tag, struct __ns1__remove8 *a, const char *type)
{
	short soap_flag_ns1__remove8 = 1;
	a = (struct __ns1__remove8 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove8, sizeof(struct __ns1__remove8), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove8(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove8 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove8(soap, "ns1:remove8", &a->ns1__remove8, ""))
				{	soap_flag_ns1__remove8--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove8 * SOAP_FMAC6 soap_new___ns1__remove8(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove8(struct soap *soap, struct __ns1__remove8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove8 * SOAP_FMAC4 soap_instantiate___ns1__remove8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove8;
		if (size)
			*size = sizeof(struct __ns1__remove8);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove8[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove8);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove8 %p -> %p\n", q, p));
	*(struct __ns1__remove8*)p = *(struct __ns1__remove8*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update7(struct soap *soap, const struct __ns1__update7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update7(soap, &a->ns1__update7);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update7(struct soap *soap, struct __ns1__update7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update7 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update7(struct soap *soap, const struct __ns1__update7 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update7(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update7(struct soap *soap, const char *tag, int id, const struct __ns1__update7 *a, const char *type)
{
	soap_out_PointerTo_ns1__update7(soap, "ns1:update7", -1, &a->ns1__update7, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update7 * SOAP_FMAC4 soap_get___ns1__update7(struct soap *soap, struct __ns1__update7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update7 * SOAP_FMAC4 soap_in___ns1__update7(struct soap *soap, const char *tag, struct __ns1__update7 *a, const char *type)
{
	short soap_flag_ns1__update7 = 1;
	a = (struct __ns1__update7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update7, sizeof(struct __ns1__update7), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update7(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update7 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update7(soap, "ns1:update7", &a->ns1__update7, ""))
				{	soap_flag_ns1__update7--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update7 * SOAP_FMAC6 soap_new___ns1__update7(struct soap *soap, int n)
{	return soap_instantiate___ns1__update7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update7(struct soap *soap, struct __ns1__update7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update7 * SOAP_FMAC4 soap_instantiate___ns1__update7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update7;
		if (size)
			*size = sizeof(struct __ns1__update7);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update7[n];
		if (size)
			*size = n * sizeof(struct __ns1__update7);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update7 %p -> %p\n", q, p));
	*(struct __ns1__update7*)p = *(struct __ns1__update7*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove5(struct soap *soap, const struct __ns1__remove5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove5(soap, &a->ns1__remove5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove5(struct soap *soap, struct __ns1__remove5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove5 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove5(struct soap *soap, const struct __ns1__remove5 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove5(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove5(struct soap *soap, const char *tag, int id, const struct __ns1__remove5 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove5(soap, "ns1:remove5", -1, &a->ns1__remove5, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove5 * SOAP_FMAC4 soap_get___ns1__remove5(struct soap *soap, struct __ns1__remove5 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove5 * SOAP_FMAC4 soap_in___ns1__remove5(struct soap *soap, const char *tag, struct __ns1__remove5 *a, const char *type)
{
	short soap_flag_ns1__remove5 = 1;
	a = (struct __ns1__remove5 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove5, sizeof(struct __ns1__remove5), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove5(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove5(soap, "ns1:remove5", &a->ns1__remove5, ""))
				{	soap_flag_ns1__remove5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove5 * SOAP_FMAC6 soap_new___ns1__remove5(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove5(struct soap *soap, struct __ns1__remove5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove5 * SOAP_FMAC4 soap_instantiate___ns1__remove5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove5;
		if (size)
			*size = sizeof(struct __ns1__remove5);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove5[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove5);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove5 %p -> %p\n", q, p));
	*(struct __ns1__remove5*)p = *(struct __ns1__remove5*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove4(struct soap *soap, const struct __ns1__remove4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove4(soap, &a->ns1__remove4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove4(struct soap *soap, struct __ns1__remove4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove4 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove4(struct soap *soap, const struct __ns1__remove4 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove4(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove4(struct soap *soap, const char *tag, int id, const struct __ns1__remove4 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove4(soap, "ns1:remove4", -1, &a->ns1__remove4, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove4 * SOAP_FMAC4 soap_get___ns1__remove4(struct soap *soap, struct __ns1__remove4 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove4 * SOAP_FMAC4 soap_in___ns1__remove4(struct soap *soap, const char *tag, struct __ns1__remove4 *a, const char *type)
{
	short soap_flag_ns1__remove4 = 1;
	a = (struct __ns1__remove4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove4, sizeof(struct __ns1__remove4), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove4(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove4(soap, "ns1:remove4", &a->ns1__remove4, ""))
				{	soap_flag_ns1__remove4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove4 * SOAP_FMAC6 soap_new___ns1__remove4(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove4(struct soap *soap, struct __ns1__remove4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove4 * SOAP_FMAC4 soap_instantiate___ns1__remove4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove4;
		if (size)
			*size = sizeof(struct __ns1__remove4);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove4[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove4);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove4 %p -> %p\n", q, p));
	*(struct __ns1__remove4*)p = *(struct __ns1__remove4*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create7(struct soap *soap, const struct __ns1__create7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create7(soap, &a->ns1__create7);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create7(struct soap *soap, struct __ns1__create7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create7 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create7(struct soap *soap, const struct __ns1__create7 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create7(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create7(struct soap *soap, const char *tag, int id, const struct __ns1__create7 *a, const char *type)
{
	soap_out_PointerTo_ns1__create7(soap, "ns1:create7", -1, &a->ns1__create7, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create7 * SOAP_FMAC4 soap_get___ns1__create7(struct soap *soap, struct __ns1__create7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create7 * SOAP_FMAC4 soap_in___ns1__create7(struct soap *soap, const char *tag, struct __ns1__create7 *a, const char *type)
{
	short soap_flag_ns1__create7 = 1;
	a = (struct __ns1__create7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create7, sizeof(struct __ns1__create7), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create7(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create7 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create7(soap, "ns1:create7", &a->ns1__create7, ""))
				{	soap_flag_ns1__create7--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create7 * SOAP_FMAC6 soap_new___ns1__create7(struct soap *soap, int n)
{	return soap_instantiate___ns1__create7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create7(struct soap *soap, struct __ns1__create7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create7 * SOAP_FMAC4 soap_instantiate___ns1__create7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create7;
		if (size)
			*size = sizeof(struct __ns1__create7);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create7[n];
		if (size)
			*size = n * sizeof(struct __ns1__create7);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create7 %p -> %p\n", q, p));
	*(struct __ns1__create7*)p = *(struct __ns1__create7*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK2(struct soap *soap, const struct __ns1__findByPK2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK2(soap, &a->ns1__findByPK2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK2(struct soap *soap, struct __ns1__findByPK2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK2 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK2(struct soap *soap, const struct __ns1__findByPK2 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK2(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK2(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK2 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK2(soap, "ns1:findByPK2", -1, &a->ns1__findByPK2, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK2 * SOAP_FMAC4 soap_get___ns1__findByPK2(struct soap *soap, struct __ns1__findByPK2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK2 * SOAP_FMAC4 soap_in___ns1__findByPK2(struct soap *soap, const char *tag, struct __ns1__findByPK2 *a, const char *type)
{
	short soap_flag_ns1__findByPK2 = 1;
	a = (struct __ns1__findByPK2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK2, sizeof(struct __ns1__findByPK2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK2(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK2(soap, "ns1:findByPK2", &a->ns1__findByPK2, ""))
				{	soap_flag_ns1__findByPK2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK2 * SOAP_FMAC6 soap_new___ns1__findByPK2(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK2(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK2(struct soap *soap, struct __ns1__findByPK2 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK2 * SOAP_FMAC4 soap_instantiate___ns1__findByPK2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK2;
		if (size)
			*size = sizeof(struct __ns1__findByPK2);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK2[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK2 %p -> %p\n", q, p));
	*(struct __ns1__findByPK2*)p = *(struct __ns1__findByPK2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__generateSQLQuery(struct soap *soap, const struct __ns1__generateSQLQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__generateSQLQuery(soap, &a->ns1__generateSQLQuery);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__generateSQLQuery(struct soap *soap, struct __ns1__generateSQLQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__generateSQLQuery = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__generateSQLQuery(struct soap *soap, const struct __ns1__generateSQLQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__generateSQLQuery(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__generateSQLQuery(struct soap *soap, const char *tag, int id, const struct __ns1__generateSQLQuery *a, const char *type)
{
	soap_out_PointerTo_ns1__generateSQLQuery(soap, "ns1:generateSQLQuery", -1, &a->ns1__generateSQLQuery, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__generateSQLQuery * SOAP_FMAC4 soap_get___ns1__generateSQLQuery(struct soap *soap, struct __ns1__generateSQLQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__generateSQLQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__generateSQLQuery * SOAP_FMAC4 soap_in___ns1__generateSQLQuery(struct soap *soap, const char *tag, struct __ns1__generateSQLQuery *a, const char *type)
{
	short soap_flag_ns1__generateSQLQuery = 1;
	a = (struct __ns1__generateSQLQuery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__generateSQLQuery, sizeof(struct __ns1__generateSQLQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__generateSQLQuery(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__generateSQLQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__generateSQLQuery(soap, "ns1:generateSQLQuery", &a->ns1__generateSQLQuery, ""))
				{	soap_flag_ns1__generateSQLQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__generateSQLQuery * SOAP_FMAC6 soap_new___ns1__generateSQLQuery(struct soap *soap, int n)
{	return soap_instantiate___ns1__generateSQLQuery(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__generateSQLQuery(struct soap *soap, struct __ns1__generateSQLQuery *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__generateSQLQuery * SOAP_FMAC4 soap_instantiate___ns1__generateSQLQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__generateSQLQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__generateSQLQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__generateSQLQuery;
		if (size)
			*size = sizeof(struct __ns1__generateSQLQuery);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__generateSQLQuery[n];
		if (size)
			*size = n * sizeof(struct __ns1__generateSQLQuery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__generateSQLQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__generateSQLQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__generateSQLQuery %p -> %p\n", q, p));
	*(struct __ns1__generateSQLQuery*)p = *(struct __ns1__generateSQLQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnPPTVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, &a->ns1__findBySQLQueryReturnPPTVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, struct __ns1__findBySQLQueryReturnPPTVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnPPTVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnPPTVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnPPTVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnPPTVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, "ns1:findBySQLQueryReturnPPTVO", -1, &a->ns1__findBySQLQueryReturnPPTVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, struct __ns1__findBySQLQueryReturnPPTVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnPPTVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnPPTVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnPPTVO = 1;
	a = (struct __ns1__findBySQLQueryReturnPPTVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnPPTVO, sizeof(struct __ns1__findBySQLQueryReturnPPTVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnPPTVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnPPTVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, "ns1:findBySQLQueryReturnPPTVO", &a->ns1__findBySQLQueryReturnPPTVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnPPTVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnPPTVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, struct __ns1__findBySQLQueryReturnPPTVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnPPTVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnPPTVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnPPTVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnPPTVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnPPTVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnPPTVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnPPTVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnPPTVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnPPTVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnPPTVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnPPTVO*)p = *(struct __ns1__findBySQLQueryReturnPPTVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnContainerVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, &a->ns1__findBySQLQueryReturnContainerVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, struct __ns1__findBySQLQueryReturnContainerVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnContainerVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnContainerVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnContainerVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnContainerVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, "ns1:findBySQLQueryReturnContainerVO", -1, &a->ns1__findBySQLQueryReturnContainerVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, struct __ns1__findBySQLQueryReturnContainerVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnContainerVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnContainerVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnContainerVO = 1;
	a = (struct __ns1__findBySQLQueryReturnContainerVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnContainerVO, sizeof(struct __ns1__findBySQLQueryReturnContainerVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnContainerVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnContainerVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, "ns1:findBySQLQueryReturnContainerVO", &a->ns1__findBySQLQueryReturnContainerVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnContainerVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnContainerVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, struct __ns1__findBySQLQueryReturnContainerVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnContainerVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnContainerVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnContainerVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnContainerVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnContainerVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnContainerVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnContainerVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnContainerVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnContainerVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnContainerVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnContainerVO*)p = *(struct __ns1__findBySQLQueryReturnContainerVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create6(struct soap *soap, const struct __ns1__create6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create6(soap, &a->ns1__create6);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create6(struct soap *soap, struct __ns1__create6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create6 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create6(struct soap *soap, const struct __ns1__create6 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create6(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create6(struct soap *soap, const char *tag, int id, const struct __ns1__create6 *a, const char *type)
{
	soap_out_PointerTo_ns1__create6(soap, "ns1:create6", -1, &a->ns1__create6, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create6 * SOAP_FMAC4 soap_get___ns1__create6(struct soap *soap, struct __ns1__create6 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create6 * SOAP_FMAC4 soap_in___ns1__create6(struct soap *soap, const char *tag, struct __ns1__create6 *a, const char *type)
{
	short soap_flag_ns1__create6 = 1;
	a = (struct __ns1__create6 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create6, sizeof(struct __ns1__create6), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create6(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create6(soap, "ns1:create6", &a->ns1__create6, ""))
				{	soap_flag_ns1__create6--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create6 * SOAP_FMAC6 soap_new___ns1__create6(struct soap *soap, int n)
{	return soap_instantiate___ns1__create6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create6(struct soap *soap, struct __ns1__create6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create6 * SOAP_FMAC4 soap_instantiate___ns1__create6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create6;
		if (size)
			*size = sizeof(struct __ns1__create6);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create6[n];
		if (size)
			*size = n * sizeof(struct __ns1__create6);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create6 %p -> %p\n", q, p));
	*(struct __ns1__create6*)p = *(struct __ns1__create6*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK5(struct soap *soap, const struct __ns1__findByPK5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK5(soap, &a->ns1__findByPK5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK5(struct soap *soap, struct __ns1__findByPK5 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK5 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK5(struct soap *soap, const struct __ns1__findByPK5 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK5(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK5(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK5 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK5(soap, "ns1:findByPK5", -1, &a->ns1__findByPK5, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK5 * SOAP_FMAC4 soap_get___ns1__findByPK5(struct soap *soap, struct __ns1__findByPK5 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK5 * SOAP_FMAC4 soap_in___ns1__findByPK5(struct soap *soap, const char *tag, struct __ns1__findByPK5 *a, const char *type)
{
	short soap_flag_ns1__findByPK5 = 1;
	a = (struct __ns1__findByPK5 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK5, sizeof(struct __ns1__findByPK5), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK5(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK5(soap, "ns1:findByPK5", &a->ns1__findByPK5, ""))
				{	soap_flag_ns1__findByPK5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK5 * SOAP_FMAC6 soap_new___ns1__findByPK5(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK5(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK5(struct soap *soap, struct __ns1__findByPK5 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK5 * SOAP_FMAC4 soap_instantiate___ns1__findByPK5(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK5(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK5, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK5;
		if (size)
			*size = sizeof(struct __ns1__findByPK5);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK5[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK5);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK5*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK5(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK5 %p -> %p\n", q, p));
	*(struct __ns1__findByPK5*)p = *(struct __ns1__findByPK5*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnPPTSlideVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, &a->ns1__findBySQLQueryReturnPPTSlideVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, struct __ns1__findBySQLQueryReturnPPTSlideVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnPPTSlideVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnPPTSlideVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnPPTSlideVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, "ns1:findBySQLQueryReturnPPTSlideVO", -1, &a->ns1__findBySQLQueryReturnPPTSlideVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, struct __ns1__findBySQLQueryReturnPPTSlideVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnPPTSlideVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnPPTSlideVO = 1;
	a = (struct __ns1__findBySQLQueryReturnPPTSlideVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnPPTSlideVO, sizeof(struct __ns1__findBySQLQueryReturnPPTSlideVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnPPTSlideVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnPPTSlideVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, "ns1:findBySQLQueryReturnPPTSlideVO", &a->ns1__findBySQLQueryReturnPPTSlideVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnPPTSlideVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnPPTSlideVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, struct __ns1__findBySQLQueryReturnPPTSlideVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnPPTSlideVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnPPTSlideVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnPPTSlideVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnPPTSlideVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnPPTSlideVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnPPTSlideVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnPPTSlideVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnPPTSlideVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnPPTSlideVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnPPTSlideVO*)p = *(struct __ns1__findBySQLQueryReturnPPTSlideVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update4(struct soap *soap, const struct __ns1__update4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update4(soap, &a->ns1__update4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update4(struct soap *soap, struct __ns1__update4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update4 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update4(struct soap *soap, const struct __ns1__update4 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update4(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update4(struct soap *soap, const char *tag, int id, const struct __ns1__update4 *a, const char *type)
{
	soap_out_PointerTo_ns1__update4(soap, "ns1:update4", -1, &a->ns1__update4, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update4 * SOAP_FMAC4 soap_get___ns1__update4(struct soap *soap, struct __ns1__update4 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update4 * SOAP_FMAC4 soap_in___ns1__update4(struct soap *soap, const char *tag, struct __ns1__update4 *a, const char *type)
{
	short soap_flag_ns1__update4 = 1;
	a = (struct __ns1__update4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update4, sizeof(struct __ns1__update4), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update4(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update4(soap, "ns1:update4", &a->ns1__update4, ""))
				{	soap_flag_ns1__update4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update4 * SOAP_FMAC6 soap_new___ns1__update4(struct soap *soap, int n)
{	return soap_instantiate___ns1__update4(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update4(struct soap *soap, struct __ns1__update4 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update4 * SOAP_FMAC4 soap_instantiate___ns1__update4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update4;
		if (size)
			*size = sizeof(struct __ns1__update4);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update4[n];
		if (size)
			*size = n * sizeof(struct __ns1__update4);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update4 %p -> %p\n", q, p));
	*(struct __ns1__update4*)p = *(struct __ns1__update4*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create8(struct soap *soap, const struct __ns1__create8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create8(soap, &a->ns1__create8);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create8(struct soap *soap, struct __ns1__create8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create8 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create8(struct soap *soap, const struct __ns1__create8 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create8(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create8(struct soap *soap, const char *tag, int id, const struct __ns1__create8 *a, const char *type)
{
	soap_out_PointerTo_ns1__create8(soap, "ns1:create8", -1, &a->ns1__create8, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create8 * SOAP_FMAC4 soap_get___ns1__create8(struct soap *soap, struct __ns1__create8 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create8 * SOAP_FMAC4 soap_in___ns1__create8(struct soap *soap, const char *tag, struct __ns1__create8 *a, const char *type)
{
	short soap_flag_ns1__create8 = 1;
	a = (struct __ns1__create8 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create8, sizeof(struct __ns1__create8), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create8(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create8 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create8(soap, "ns1:create8", &a->ns1__create8, ""))
				{	soap_flag_ns1__create8--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create8 * SOAP_FMAC6 soap_new___ns1__create8(struct soap *soap, int n)
{	return soap_instantiate___ns1__create8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create8(struct soap *soap, struct __ns1__create8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create8 * SOAP_FMAC4 soap_instantiate___ns1__create8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create8;
		if (size)
			*size = sizeof(struct __ns1__create8);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create8[n];
		if (size)
			*size = n * sizeof(struct __ns1__create8);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create8 %p -> %p\n", q, p));
	*(struct __ns1__create8*)p = *(struct __ns1__create8*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findByPK8(struct soap *soap, const struct __ns1__findByPK8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findByPK8(soap, &a->ns1__findByPK8);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findByPK8(struct soap *soap, struct __ns1__findByPK8 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findByPK8 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findByPK8(struct soap *soap, const struct __ns1__findByPK8 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findByPK8(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findByPK8(struct soap *soap, const char *tag, int id, const struct __ns1__findByPK8 *a, const char *type)
{
	soap_out_PointerTo_ns1__findByPK8(soap, "ns1:findByPK8", -1, &a->ns1__findByPK8, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findByPK8 * SOAP_FMAC4 soap_get___ns1__findByPK8(struct soap *soap, struct __ns1__findByPK8 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findByPK8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findByPK8 * SOAP_FMAC4 soap_in___ns1__findByPK8(struct soap *soap, const char *tag, struct __ns1__findByPK8 *a, const char *type)
{
	short soap_flag_ns1__findByPK8 = 1;
	a = (struct __ns1__findByPK8 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findByPK8, sizeof(struct __ns1__findByPK8), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findByPK8(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findByPK8 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findByPK8(soap, "ns1:findByPK8", &a->ns1__findByPK8, ""))
				{	soap_flag_ns1__findByPK8--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findByPK8 * SOAP_FMAC6 soap_new___ns1__findByPK8(struct soap *soap, int n)
{	return soap_instantiate___ns1__findByPK8(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findByPK8(struct soap *soap, struct __ns1__findByPK8 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findByPK8 * SOAP_FMAC4 soap_instantiate___ns1__findByPK8(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findByPK8(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findByPK8, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findByPK8;
		if (size)
			*size = sizeof(struct __ns1__findByPK8);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findByPK8[n];
		if (size)
			*size = n * sizeof(struct __ns1__findByPK8);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findByPK8*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findByPK8(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findByPK8 %p -> %p\n", q, p));
	*(struct __ns1__findByPK8*)p = *(struct __ns1__findByPK8*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnEActivityVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, &a->ns1__findBySQLQueryReturnEActivityVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, struct __ns1__findBySQLQueryReturnEActivityVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnEActivityVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnEActivityVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnEActivityVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnEActivityVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, "ns1:findBySQLQueryReturnEActivityVO", -1, &a->ns1__findBySQLQueryReturnEActivityVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, struct __ns1__findBySQLQueryReturnEActivityVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnEActivityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnEActivityVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnEActivityVO = 1;
	a = (struct __ns1__findBySQLQueryReturnEActivityVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnEActivityVO, sizeof(struct __ns1__findBySQLQueryReturnEActivityVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnEActivityVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnEActivityVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, "ns1:findBySQLQueryReturnEActivityVO", &a->ns1__findBySQLQueryReturnEActivityVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnEActivityVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnEActivityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, struct __ns1__findBySQLQueryReturnEActivityVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnEActivityVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnEActivityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnEActivityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnEActivityVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnEActivityVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnEActivityVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnEActivityVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnEActivityVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnEActivityVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnEActivityVO*)p = *(struct __ns1__findBySQLQueryReturnEActivityVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove9(struct soap *soap, const struct __ns1__remove9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove9(soap, &a->ns1__remove9);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove9(struct soap *soap, struct __ns1__remove9 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove9 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove9(struct soap *soap, const struct __ns1__remove9 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove9(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove9(struct soap *soap, const char *tag, int id, const struct __ns1__remove9 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove9(soap, "ns1:remove9", -1, &a->ns1__remove9, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove9 * SOAP_FMAC4 soap_get___ns1__remove9(struct soap *soap, struct __ns1__remove9 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove9 * SOAP_FMAC4 soap_in___ns1__remove9(struct soap *soap, const char *tag, struct __ns1__remove9 *a, const char *type)
{
	short soap_flag_ns1__remove9 = 1;
	a = (struct __ns1__remove9 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove9, sizeof(struct __ns1__remove9), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove9(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove9 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove9(soap, "ns1:remove9", &a->ns1__remove9, ""))
				{	soap_flag_ns1__remove9--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove9 * SOAP_FMAC6 soap_new___ns1__remove9(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove9(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove9(struct soap *soap, struct __ns1__remove9 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove9 * SOAP_FMAC4 soap_instantiate___ns1__remove9(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove9(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove9, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove9;
		if (size)
			*size = sizeof(struct __ns1__remove9);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove9[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove9);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove9*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove9(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove9 %p -> %p\n", q, p));
	*(struct __ns1__remove9*)p = *(struct __ns1__remove9*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create11(struct soap *soap, const struct __ns1__create11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__create11(soap, &a->ns1__create11);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create11(struct soap *soap, struct __ns1__create11 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__create11 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create11(struct soap *soap, const struct __ns1__create11 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create11(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create11(struct soap *soap, const char *tag, int id, const struct __ns1__create11 *a, const char *type)
{
	soap_out_PointerTo_ns1__create11(soap, "ns1:create11", -1, &a->ns1__create11, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create11 * SOAP_FMAC4 soap_get___ns1__create11(struct soap *soap, struct __ns1__create11 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__create11 * SOAP_FMAC4 soap_in___ns1__create11(struct soap *soap, const char *tag, struct __ns1__create11 *a, const char *type)
{
	short soap_flag_ns1__create11 = 1;
	a = (struct __ns1__create11 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__create11, sizeof(struct __ns1__create11), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create11(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__create11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__create11(soap, "ns1:create11", &a->ns1__create11, ""))
				{	soap_flag_ns1__create11--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__create11 * SOAP_FMAC6 soap_new___ns1__create11(struct soap *soap, int n)
{	return soap_instantiate___ns1__create11(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__create11(struct soap *soap, struct __ns1__create11 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__create11 * SOAP_FMAC4 soap_instantiate___ns1__create11(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create11(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create11, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__create11;
		if (size)
			*size = sizeof(struct __ns1__create11);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__create11[n];
		if (size)
			*size = n * sizeof(struct __ns1__create11);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create11*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create11(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create11 %p -> %p\n", q, p));
	*(struct __ns1__create11*)p = *(struct __ns1__create11*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update3(struct soap *soap, const struct __ns1__update3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__update3(soap, &a->ns1__update3);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update3(struct soap *soap, struct __ns1__update3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__update3 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update3(struct soap *soap, const struct __ns1__update3 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__update3(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update3(struct soap *soap, const char *tag, int id, const struct __ns1__update3 *a, const char *type)
{
	soap_out_PointerTo_ns1__update3(soap, "ns1:update3", -1, &a->ns1__update3, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update3 * SOAP_FMAC4 soap_get___ns1__update3(struct soap *soap, struct __ns1__update3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__update3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__update3 * SOAP_FMAC4 soap_in___ns1__update3(struct soap *soap, const char *tag, struct __ns1__update3 *a, const char *type)
{
	short soap_flag_ns1__update3 = 1;
	a = (struct __ns1__update3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__update3, sizeof(struct __ns1__update3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__update3(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__update3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__update3(soap, "ns1:update3", &a->ns1__update3, ""))
				{	soap_flag_ns1__update3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__update3 * SOAP_FMAC6 soap_new___ns1__update3(struct soap *soap, int n)
{	return soap_instantiate___ns1__update3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__update3(struct soap *soap, struct __ns1__update3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__update3 * SOAP_FMAC4 soap_instantiate___ns1__update3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__update3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__update3;
		if (size)
			*size = sizeof(struct __ns1__update3);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__update3[n];
		if (size)
			*size = n * sizeof(struct __ns1__update3);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__update3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update3 %p -> %p\n", q, p));
	*(struct __ns1__update3*)p = *(struct __ns1__update3*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove6(struct soap *soap, const struct __ns1__remove6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove6(soap, &a->ns1__remove6);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove6(struct soap *soap, struct __ns1__remove6 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove6 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove6(struct soap *soap, const struct __ns1__remove6 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove6(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove6(struct soap *soap, const char *tag, int id, const struct __ns1__remove6 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove6(soap, "ns1:remove6", -1, &a->ns1__remove6, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove6 * SOAP_FMAC4 soap_get___ns1__remove6(struct soap *soap, struct __ns1__remove6 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove6 * SOAP_FMAC4 soap_in___ns1__remove6(struct soap *soap, const char *tag, struct __ns1__remove6 *a, const char *type)
{
	short soap_flag_ns1__remove6 = 1;
	a = (struct __ns1__remove6 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove6, sizeof(struct __ns1__remove6), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove6(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove6(soap, "ns1:remove6", &a->ns1__remove6, ""))
				{	soap_flag_ns1__remove6--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove6 * SOAP_FMAC6 soap_new___ns1__remove6(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove6(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove6(struct soap *soap, struct __ns1__remove6 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove6 * SOAP_FMAC4 soap_instantiate___ns1__remove6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove6;
		if (size)
			*size = sizeof(struct __ns1__remove6);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove6[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove6);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove6*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove6 %p -> %p\n", q, p));
	*(struct __ns1__remove6*)p = *(struct __ns1__remove6*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__remove3(struct soap *soap, const struct __ns1__remove3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__remove3(soap, &a->ns1__remove3);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__remove3(struct soap *soap, struct __ns1__remove3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__remove3 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__remove3(struct soap *soap, const struct __ns1__remove3 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__remove3(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__remove3(struct soap *soap, const char *tag, int id, const struct __ns1__remove3 *a, const char *type)
{
	soap_out_PointerTo_ns1__remove3(soap, "ns1:remove3", -1, &a->ns1__remove3, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__remove3 * SOAP_FMAC4 soap_get___ns1__remove3(struct soap *soap, struct __ns1__remove3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__remove3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__remove3 * SOAP_FMAC4 soap_in___ns1__remove3(struct soap *soap, const char *tag, struct __ns1__remove3 *a, const char *type)
{
	short soap_flag_ns1__remove3 = 1;
	a = (struct __ns1__remove3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__remove3, sizeof(struct __ns1__remove3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__remove3(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__remove3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__remove3(soap, "ns1:remove3", &a->ns1__remove3, ""))
				{	soap_flag_ns1__remove3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__remove3 * SOAP_FMAC6 soap_new___ns1__remove3(struct soap *soap, int n)
{	return soap_instantiate___ns1__remove3(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__remove3(struct soap *soap, struct __ns1__remove3 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__remove3 * SOAP_FMAC4 soap_instantiate___ns1__remove3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__remove3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__remove3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__remove3;
		if (size)
			*size = sizeof(struct __ns1__remove3);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__remove3[n];
		if (size)
			*size = n * sizeof(struct __ns1__remove3);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__remove3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__remove3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__remove3 %p -> %p\n", q, p));
	*(struct __ns1__remove3*)p = *(struct __ns1__remove3*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnFeedbackVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, &a->ns1__findBySQLQueryReturnFeedbackVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, struct __ns1__findBySQLQueryReturnFeedbackVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnFeedbackVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnFeedbackVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnFeedbackVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnFeedbackVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, "ns1:findBySQLQueryReturnFeedbackVO", -1, &a->ns1__findBySQLQueryReturnFeedbackVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, struct __ns1__findBySQLQueryReturnFeedbackVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnFeedbackVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnFeedbackVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnFeedbackVO = 1;
	a = (struct __ns1__findBySQLQueryReturnFeedbackVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnFeedbackVO, sizeof(struct __ns1__findBySQLQueryReturnFeedbackVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnFeedbackVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnFeedbackVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, "ns1:findBySQLQueryReturnFeedbackVO", &a->ns1__findBySQLQueryReturnFeedbackVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnFeedbackVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnFeedbackVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, struct __ns1__findBySQLQueryReturnFeedbackVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnFeedbackVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnFeedbackVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnFeedbackVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnFeedbackVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnFeedbackVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnFeedbackVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnFeedbackVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnFeedbackVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnFeedbackVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnFeedbackVO*)p = *(struct __ns1__findBySQLQueryReturnFeedbackVO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnESignatureVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, &a->ns1__findBySQLQueryReturnESignatureVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, struct __ns1__findBySQLQueryReturnESignatureVO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findBySQLQueryReturnESignatureVO = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const struct __ns1__findBySQLQueryReturnESignatureVO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findBySQLQueryReturnESignatureVO(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const char *tag, int id, const struct __ns1__findBySQLQueryReturnESignatureVO *a, const char *type)
{
	soap_out_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, "ns1:findBySQLQueryReturnESignatureVO", -1, &a->ns1__findBySQLQueryReturnESignatureVO, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC4 soap_get___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, struct __ns1__findBySQLQueryReturnESignatureVO *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findBySQLQueryReturnESignatureVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC4 soap_in___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const char *tag, struct __ns1__findBySQLQueryReturnESignatureVO *a, const char *type)
{
	short soap_flag_ns1__findBySQLQueryReturnESignatureVO = 1;
	a = (struct __ns1__findBySQLQueryReturnESignatureVO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__findBySQLQueryReturnESignatureVO, sizeof(struct __ns1__findBySQLQueryReturnESignatureVO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findBySQLQueryReturnESignatureVO(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findBySQLQueryReturnESignatureVO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, "ns1:findBySQLQueryReturnESignatureVO", &a->ns1__findBySQLQueryReturnESignatureVO, ""))
				{	soap_flag_ns1__findBySQLQueryReturnESignatureVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC6 soap_new___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, int n)
{	return soap_instantiate___ns1__findBySQLQueryReturnESignatureVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, struct __ns1__findBySQLQueryReturnESignatureVO *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findBySQLQueryReturnESignatureVO * SOAP_FMAC4 soap_instantiate___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findBySQLQueryReturnESignatureVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findBySQLQueryReturnESignatureVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnESignatureVO;
		if (size)
			*size = sizeof(struct __ns1__findBySQLQueryReturnESignatureVO);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findBySQLQueryReturnESignatureVO[n];
		if (size)
			*size = n * sizeof(struct __ns1__findBySQLQueryReturnESignatureVO);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findBySQLQueryReturnESignatureVO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findBySQLQueryReturnESignatureVO %p -> %p\n", q, p));
	*(struct __ns1__findBySQLQueryReturnESignatureVO*)p = *(struct __ns1__findBySQLQueryReturnESignatureVO*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__SKSWSException(soap, &a->ns1__SKSWSException);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SKSWSException = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_out_PointerTons5__SKSWSException(soap, "ns1:SKSWSException", -1, &a->ns1__SKSWSException, "");
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_ns1__SKSWSException = 1, soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SKSWSException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__SKSWSException(soap, "ns1:SKSWSException", &a->ns1__SKSWSException, "ns5:SKSWSException"))
				{	soap_flag_ns1__SKSWSException--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__SKSWSException > 0 || soap_flag_fault > 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__anyType2anyTypeMap_entry(struct soap *soap, const struct _ns1__anyType2anyTypeMap_entry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->key);
	soap_serialize_PointerToxsd__anyType(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__anyType2anyTypeMap_entry(struct soap *soap, struct _ns1__anyType2anyTypeMap_entry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->key = NULL;
	a->value = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__anyType2anyTypeMap_entry(struct soap *soap, const struct _ns1__anyType2anyTypeMap_entry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__anyType2anyTypeMap_entry);
	if (soap_out__ns1__anyType2anyTypeMap_entry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__anyType2anyTypeMap_entry(struct soap *soap, const char *tag, int id, const struct _ns1__anyType2anyTypeMap_entry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__anyType2anyTypeMap_entry), type);
	soap_out_PointerToxsd__anyType(soap, "ns1:key", -1, &a->key, "");
	soap_out_PointerToxsd__anyType(soap, "ns1:value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _ns1__anyType2anyTypeMap_entry * SOAP_FMAC4 soap_get__ns1__anyType2anyTypeMap_entry(struct soap *soap, struct _ns1__anyType2anyTypeMap_entry *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__anyType2anyTypeMap_entry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _ns1__anyType2anyTypeMap_entry * SOAP_FMAC4 soap_in__ns1__anyType2anyTypeMap_entry(struct soap *soap, const char *tag, struct _ns1__anyType2anyTypeMap_entry *a, const char *type)
{
	short soap_flag_key = 1, soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__anyType2anyTypeMap_entry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__anyType2anyTypeMap_entry, sizeof(struct _ns1__anyType2anyTypeMap_entry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__anyType2anyTypeMap_entry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns1:key", &a->key, "xsd:anyType"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns1:value", &a->value, "xsd:anyType"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__anyType2anyTypeMap_entry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__anyType2anyTypeMap_entry, 0, sizeof(struct _ns1__anyType2anyTypeMap_entry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct _ns1__anyType2anyTypeMap_entry * SOAP_FMAC6 soap_new__ns1__anyType2anyTypeMap_entry(struct soap *soap, int n)
{	return soap_instantiate__ns1__anyType2anyTypeMap_entry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__anyType2anyTypeMap_entry(struct soap *soap, struct _ns1__anyType2anyTypeMap_entry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct _ns1__anyType2anyTypeMap_entry * SOAP_FMAC4 soap_instantiate__ns1__anyType2anyTypeMap_entry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__anyType2anyTypeMap_entry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__anyType2anyTypeMap_entry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _ns1__anyType2anyTypeMap_entry;
		if (size)
			*size = sizeof(struct _ns1__anyType2anyTypeMap_entry);
	}
	else
	{	cp->ptr = (void*)new struct _ns1__anyType2anyTypeMap_entry[n];
		if (size)
			*size = n * sizeof(struct _ns1__anyType2anyTypeMap_entry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _ns1__anyType2anyTypeMap_entry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__anyType2anyTypeMap_entry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _ns1__anyType2anyTypeMap_entry %p -> %p\n", q, p));
	*(struct _ns1__anyType2anyTypeMap_entry*)p = *(struct _ns1__anyType2anyTypeMap_entry*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create4Response(struct soap *soap, _ns1__create4Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create4Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create4Response(struct soap *soap, _ns1__create4Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create4Response);
	if (soap_out_PointerTo_ns1__create4Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create4Response(struct soap *soap, const char *tag, int id, _ns1__create4Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create4Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create4Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create4Response(struct soap *soap, _ns1__create4Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create4Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create4Response(struct soap *soap, const char *tag, _ns1__create4Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create4Response **)soap_malloc(soap, sizeof(_ns1__create4Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create4Response *)soap_instantiate__ns1__create4Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create4Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create4Response, sizeof(_ns1__create4Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create4(struct soap *soap, _ns1__create4 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create4))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create4(struct soap *soap, _ns1__create4 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create4);
	if (soap_out_PointerTo_ns1__create4(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create4(struct soap *soap, const char *tag, int id, _ns1__create4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create4);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create4 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create4(struct soap *soap, _ns1__create4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create4 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create4(struct soap *soap, const char *tag, _ns1__create4 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create4 **)soap_malloc(soap, sizeof(_ns1__create4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create4 *)soap_instantiate__ns1__create4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create4, sizeof(_ns1__create4), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create9Response(struct soap *soap, _ns1__create9Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create9Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create9Response(struct soap *soap, _ns1__create9Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create9Response);
	if (soap_out_PointerTo_ns1__create9Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create9Response(struct soap *soap, const char *tag, int id, _ns1__create9Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create9Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create9Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create9Response(struct soap *soap, _ns1__create9Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create9Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create9Response(struct soap *soap, const char *tag, _ns1__create9Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create9Response **)soap_malloc(soap, sizeof(_ns1__create9Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create9Response *)soap_instantiate__ns1__create9Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create9Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create9Response, sizeof(_ns1__create9Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create9(struct soap *soap, _ns1__create9 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create9))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create9(struct soap *soap, _ns1__create9 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create9);
	if (soap_out_PointerTo_ns1__create9(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create9(struct soap *soap, const char *tag, int id, _ns1__create9 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create9);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create9 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create9(struct soap *soap, _ns1__create9 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create9 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create9(struct soap *soap, const char *tag, _ns1__create9 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create9 **)soap_malloc(soap, sizeof(_ns1__create9 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create9 *)soap_instantiate__ns1__create9(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create9 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create9, sizeof(_ns1__create9), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK11Response(struct soap *soap, _ns1__findByPK11Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK11Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK11Response(struct soap *soap, _ns1__findByPK11Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK11Response);
	if (soap_out_PointerTo_ns1__findByPK11Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK11Response(struct soap *soap, const char *tag, int id, _ns1__findByPK11Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK11Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK11Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK11Response(struct soap *soap, _ns1__findByPK11Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK11Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK11Response(struct soap *soap, const char *tag, _ns1__findByPK11Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK11Response **)soap_malloc(soap, sizeof(_ns1__findByPK11Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK11Response *)soap_instantiate__ns1__findByPK11Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK11Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK11Response, sizeof(_ns1__findByPK11Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK11(struct soap *soap, _ns1__findByPK11 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK11))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK11(struct soap *soap, _ns1__findByPK11 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK11);
	if (soap_out_PointerTo_ns1__findByPK11(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK11(struct soap *soap, const char *tag, int id, _ns1__findByPK11 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK11);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK11 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK11(struct soap *soap, _ns1__findByPK11 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK11 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK11(struct soap *soap, const char *tag, _ns1__findByPK11 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK11 **)soap_malloc(soap, sizeof(_ns1__findByPK11 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK11 *)soap_instantiate__ns1__findByPK11(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK11 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK11, sizeof(_ns1__findByPK11), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update1Response(struct soap *soap, _ns1__update1Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update1Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update1Response(struct soap *soap, _ns1__update1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update1Response);
	if (soap_out_PointerTo_ns1__update1Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update1Response(struct soap *soap, const char *tag, int id, _ns1__update1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update1Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update1Response(struct soap *soap, _ns1__update1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update1Response(struct soap *soap, const char *tag, _ns1__update1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update1Response **)soap_malloc(soap, sizeof(_ns1__update1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update1Response *)soap_instantiate__ns1__update1Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update1Response, sizeof(_ns1__update1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update1(struct soap *soap, _ns1__update1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update1(struct soap *soap, _ns1__update1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update1);
	if (soap_out_PointerTo_ns1__update1(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update1(struct soap *soap, const char *tag, int id, _ns1__update1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update1(struct soap *soap, _ns1__update1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update1(struct soap *soap, const char *tag, _ns1__update1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update1 **)soap_malloc(soap, sizeof(_ns1__update1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update1 *)soap_instantiate__ns1__update1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update1, sizeof(_ns1__update1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create10Response(struct soap *soap, _ns1__create10Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create10Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create10Response(struct soap *soap, _ns1__create10Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create10Response);
	if (soap_out_PointerTo_ns1__create10Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create10Response(struct soap *soap, const char *tag, int id, _ns1__create10Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create10Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create10Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create10Response(struct soap *soap, _ns1__create10Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create10Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create10Response(struct soap *soap, const char *tag, _ns1__create10Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create10Response **)soap_malloc(soap, sizeof(_ns1__create10Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create10Response *)soap_instantiate__ns1__create10Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create10Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create10Response, sizeof(_ns1__create10Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create10(struct soap *soap, _ns1__create10 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create10))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create10(struct soap *soap, _ns1__create10 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create10);
	if (soap_out_PointerTo_ns1__create10(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create10(struct soap *soap, const char *tag, int id, _ns1__create10 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create10);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create10 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create10(struct soap *soap, _ns1__create10 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create10 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create10(struct soap *soap, const char *tag, _ns1__create10 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create10 **)soap_malloc(soap, sizeof(_ns1__create10 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create10 *)soap_instantiate__ns1__create10(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create10 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create10, sizeof(_ns1__create10), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK1Response(struct soap *soap, _ns1__findByPK1Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK1Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK1Response(struct soap *soap, _ns1__findByPK1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK1Response);
	if (soap_out_PointerTo_ns1__findByPK1Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK1Response(struct soap *soap, const char *tag, int id, _ns1__findByPK1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK1Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK1Response(struct soap *soap, _ns1__findByPK1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK1Response(struct soap *soap, const char *tag, _ns1__findByPK1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK1Response **)soap_malloc(soap, sizeof(_ns1__findByPK1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK1Response *)soap_instantiate__ns1__findByPK1Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK1Response, sizeof(_ns1__findByPK1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK1(struct soap *soap, _ns1__findByPK1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK1(struct soap *soap, _ns1__findByPK1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK1);
	if (soap_out_PointerTo_ns1__findByPK1(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK1(struct soap *soap, const char *tag, int id, _ns1__findByPK1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK1(struct soap *soap, _ns1__findByPK1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK1(struct soap *soap, const char *tag, _ns1__findByPK1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK1 **)soap_malloc(soap, sizeof(_ns1__findByPK1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK1 *)soap_instantiate__ns1__findByPK1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK1, sizeof(_ns1__findByPK1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeResponse(struct soap *soap, _ns1__removeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeResponse(struct soap *soap, _ns1__removeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeResponse);
	if (soap_out_PointerTo_ns1__removeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeResponse(struct soap *soap, const char *tag, int id, _ns1__removeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeResponse(struct soap *soap, _ns1__removeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__removeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeResponse(struct soap *soap, const char *tag, _ns1__removeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeResponse **)soap_malloc(soap, sizeof(_ns1__removeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeResponse *)soap_instantiate__ns1__removeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__removeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeResponse, sizeof(_ns1__removeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove(struct soap *soap, _ns1__remove *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove(struct soap *soap, _ns1__remove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove);
	if (soap_out_PointerTo_ns1__remove(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove(struct soap *soap, const char *tag, int id, _ns1__remove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove(struct soap *soap, _ns1__remove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove(struct soap *soap, const char *tag, _ns1__remove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove **)soap_malloc(soap, sizeof(_ns1__remove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove *)soap_instantiate__ns1__remove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove, sizeof(_ns1__remove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnCommentVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnCommentVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnCommentVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnCommentVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnCommentVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnCommentVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnCommentVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnCommentVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnCommentVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnCommentVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnCommentVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVOResponse, sizeof(_ns1__findBySQLQueryReturnCommentVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnCommentVO(struct soap *soap, _ns1__findBySQLQueryReturnCommentVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnCommentVO(struct soap *soap, _ns1__findBySQLQueryReturnCommentVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnCommentVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnCommentVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnCommentVO(struct soap *soap, _ns1__findBySQLQueryReturnCommentVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnCommentVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnCommentVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnCommentVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnCommentVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnCommentVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnCommentVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnCommentVO *)soap_instantiate__ns1__findBySQLQueryReturnCommentVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnCommentVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnCommentVO, sizeof(_ns1__findBySQLQueryReturnCommentVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK10Response(struct soap *soap, _ns1__findByPK10Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK10Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK10Response(struct soap *soap, _ns1__findByPK10Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK10Response);
	if (soap_out_PointerTo_ns1__findByPK10Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK10Response(struct soap *soap, const char *tag, int id, _ns1__findByPK10Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK10Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK10Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK10Response(struct soap *soap, _ns1__findByPK10Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK10Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK10Response(struct soap *soap, const char *tag, _ns1__findByPK10Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK10Response **)soap_malloc(soap, sizeof(_ns1__findByPK10Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK10Response *)soap_instantiate__ns1__findByPK10Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK10Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK10Response, sizeof(_ns1__findByPK10Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK10(struct soap *soap, _ns1__findByPK10 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK10))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK10(struct soap *soap, _ns1__findByPK10 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK10);
	if (soap_out_PointerTo_ns1__findByPK10(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK10(struct soap *soap, const char *tag, int id, _ns1__findByPK10 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK10);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK10 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK10(struct soap *soap, _ns1__findByPK10 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK10 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK10(struct soap *soap, const char *tag, _ns1__findByPK10 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK10 **)soap_malloc(soap, sizeof(_ns1__findByPK10 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK10 *)soap_instantiate__ns1__findByPK10(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK10 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK10, sizeof(_ns1__findByPK10), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnImageVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnImageVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnImageVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnImageVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnImageVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnImageVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnImageVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnImageVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnImageVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnImageVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnImageVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVOResponse, sizeof(_ns1__findBySQLQueryReturnImageVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnImageVO(struct soap *soap, _ns1__findBySQLQueryReturnImageVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnImageVO(struct soap *soap, _ns1__findBySQLQueryReturnImageVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnImageVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnImageVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnImageVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnImageVO(struct soap *soap, _ns1__findBySQLQueryReturnImageVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnImageVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnImageVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnImageVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnImageVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnImageVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnImageVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnImageVO *)soap_instantiate__ns1__findBySQLQueryReturnImageVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnImageVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnImageVO, sizeof(_ns1__findBySQLQueryReturnImageVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update2Response(struct soap *soap, _ns1__update2Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update2Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update2Response(struct soap *soap, _ns1__update2Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update2Response);
	if (soap_out_PointerTo_ns1__update2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update2Response(struct soap *soap, const char *tag, int id, _ns1__update2Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update2Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update2Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update2Response(struct soap *soap, _ns1__update2Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update2Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update2Response(struct soap *soap, const char *tag, _ns1__update2Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update2Response **)soap_malloc(soap, sizeof(_ns1__update2Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update2Response *)soap_instantiate__ns1__update2Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update2Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update2Response, sizeof(_ns1__update2Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update2(struct soap *soap, _ns1__update2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update2(struct soap *soap, _ns1__update2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update2);
	if (soap_out_PointerTo_ns1__update2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update2(struct soap *soap, const char *tag, int id, _ns1__update2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update2(struct soap *soap, _ns1__update2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update2(struct soap *soap, const char *tag, _ns1__update2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update2 **)soap_malloc(soap, sizeof(_ns1__update2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update2 *)soap_instantiate__ns1__update2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update2, sizeof(_ns1__update2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK3Response(struct soap *soap, _ns1__findByPK3Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK3Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK3Response(struct soap *soap, _ns1__findByPK3Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK3Response);
	if (soap_out_PointerTo_ns1__findByPK3Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK3Response(struct soap *soap, const char *tag, int id, _ns1__findByPK3Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK3Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK3Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK3Response(struct soap *soap, _ns1__findByPK3Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK3Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK3Response(struct soap *soap, const char *tag, _ns1__findByPK3Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK3Response **)soap_malloc(soap, sizeof(_ns1__findByPK3Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK3Response *)soap_instantiate__ns1__findByPK3Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK3Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK3Response, sizeof(_ns1__findByPK3Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK3(struct soap *soap, _ns1__findByPK3 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK3))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK3(struct soap *soap, _ns1__findByPK3 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK3);
	if (soap_out_PointerTo_ns1__findByPK3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK3(struct soap *soap, const char *tag, int id, _ns1__findByPK3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK3);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK3 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK3(struct soap *soap, _ns1__findByPK3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK3 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK3(struct soap *soap, const char *tag, _ns1__findByPK3 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK3 **)soap_malloc(soap, sizeof(_ns1__findByPK3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK3 *)soap_instantiate__ns1__findByPK3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK3, sizeof(_ns1__findByPK3), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update5Response(struct soap *soap, _ns1__update5Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update5Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update5Response(struct soap *soap, _ns1__update5Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update5Response);
	if (soap_out_PointerTo_ns1__update5Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update5Response(struct soap *soap, const char *tag, int id, _ns1__update5Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update5Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update5Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update5Response(struct soap *soap, _ns1__update5Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update5Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update5Response(struct soap *soap, const char *tag, _ns1__update5Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update5Response **)soap_malloc(soap, sizeof(_ns1__update5Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update5Response *)soap_instantiate__ns1__update5Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update5Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update5Response, sizeof(_ns1__update5Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update5(struct soap *soap, _ns1__update5 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update5))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update5(struct soap *soap, _ns1__update5 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update5);
	if (soap_out_PointerTo_ns1__update5(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update5(struct soap *soap, const char *tag, int id, _ns1__update5 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update5);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update5 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update5(struct soap *soap, _ns1__update5 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update5 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update5(struct soap *soap, const char *tag, _ns1__update5 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update5 **)soap_malloc(soap, sizeof(_ns1__update5 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update5 *)soap_instantiate__ns1__update5(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update5 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update5, sizeof(_ns1__update5), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove2Response(struct soap *soap, _ns1__remove2Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove2Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove2Response(struct soap *soap, _ns1__remove2Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove2Response);
	if (soap_out_PointerTo_ns1__remove2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove2Response(struct soap *soap, const char *tag, int id, _ns1__remove2Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove2Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove2Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove2Response(struct soap *soap, _ns1__remove2Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove2Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove2Response(struct soap *soap, const char *tag, _ns1__remove2Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove2Response **)soap_malloc(soap, sizeof(_ns1__remove2Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove2Response *)soap_instantiate__ns1__remove2Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove2Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove2Response, sizeof(_ns1__remove2Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove2(struct soap *soap, _ns1__remove2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove2(struct soap *soap, _ns1__remove2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove2);
	if (soap_out_PointerTo_ns1__remove2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove2(struct soap *soap, const char *tag, int id, _ns1__remove2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove2(struct soap *soap, _ns1__remove2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove2(struct soap *soap, const char *tag, _ns1__remove2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove2 **)soap_malloc(soap, sizeof(_ns1__remove2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove2 *)soap_instantiate__ns1__remove2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove2, sizeof(_ns1__remove2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create5Response(struct soap *soap, _ns1__create5Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create5Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create5Response(struct soap *soap, _ns1__create5Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create5Response);
	if (soap_out_PointerTo_ns1__create5Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create5Response(struct soap *soap, const char *tag, int id, _ns1__create5Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create5Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create5Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create5Response(struct soap *soap, _ns1__create5Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create5Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create5Response(struct soap *soap, const char *tag, _ns1__create5Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create5Response **)soap_malloc(soap, sizeof(_ns1__create5Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create5Response *)soap_instantiate__ns1__create5Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create5Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create5Response, sizeof(_ns1__create5Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create5(struct soap *soap, _ns1__create5 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create5))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create5(struct soap *soap, _ns1__create5 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create5);
	if (soap_out_PointerTo_ns1__create5(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create5(struct soap *soap, const char *tag, int id, _ns1__create5 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create5);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create5 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create5(struct soap *soap, _ns1__create5 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create5 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create5(struct soap *soap, const char *tag, _ns1__create5 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create5 **)soap_malloc(soap, sizeof(_ns1__create5 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create5 *)soap_instantiate__ns1__create5(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create5 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create5, sizeof(_ns1__create5), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove11Response(struct soap *soap, _ns1__remove11Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove11Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove11Response(struct soap *soap, _ns1__remove11Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove11Response);
	if (soap_out_PointerTo_ns1__remove11Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove11Response(struct soap *soap, const char *tag, int id, _ns1__remove11Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove11Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove11Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove11Response(struct soap *soap, _ns1__remove11Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove11Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove11Response(struct soap *soap, const char *tag, _ns1__remove11Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove11Response **)soap_malloc(soap, sizeof(_ns1__remove11Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove11Response *)soap_instantiate__ns1__remove11Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove11Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove11Response, sizeof(_ns1__remove11Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove11(struct soap *soap, _ns1__remove11 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove11))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove11(struct soap *soap, _ns1__remove11 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove11);
	if (soap_out_PointerTo_ns1__remove11(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove11(struct soap *soap, const char *tag, int id, _ns1__remove11 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove11);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove11 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove11(struct soap *soap, _ns1__remove11 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove11 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove11(struct soap *soap, const char *tag, _ns1__remove11 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove11 **)soap_malloc(soap, sizeof(_ns1__remove11 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove11 *)soap_instantiate__ns1__remove11(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove11 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove11, sizeof(_ns1__remove11), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnUserVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnUserVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnUserVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnUserVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnUserVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnUserVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnUserVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnUserVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnUserVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnUserVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnUserVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVOResponse, sizeof(_ns1__findBySQLQueryReturnUserVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnUserVO(struct soap *soap, _ns1__findBySQLQueryReturnUserVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnUserVO(struct soap *soap, _ns1__findBySQLQueryReturnUserVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnUserVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnUserVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnUserVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnUserVO(struct soap *soap, _ns1__findBySQLQueryReturnUserVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnUserVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnUserVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnUserVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnUserVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnUserVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnUserVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnUserVO *)soap_instantiate__ns1__findBySQLQueryReturnUserVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnUserVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnUserVO, sizeof(_ns1__findBySQLQueryReturnUserVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEntityVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEntityVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnEntityVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEntityVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnEntityVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEntityVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnEntityVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnEntityVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnEntityVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnEntityVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEntityVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVOResponse, sizeof(_ns1__findBySQLQueryReturnEntityVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnEntityVO(struct soap *soap, _ns1__findBySQLQueryReturnEntityVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnEntityVO(struct soap *soap, _ns1__findBySQLQueryReturnEntityVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEntityVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnEntityVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnEntityVO(struct soap *soap, _ns1__findBySQLQueryReturnEntityVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnEntityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEntityVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnEntityVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEntityVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnEntityVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnEntityVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnEntityVO *)soap_instantiate__ns1__findBySQLQueryReturnEntityVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEntityVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnEntityVO, sizeof(_ns1__findBySQLQueryReturnEntityVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createResponse(struct soap *soap, _ns1__createResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createResponse(struct soap *soap, _ns1__createResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createResponse);
	if (soap_out_PointerTo_ns1__createResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createResponse(struct soap *soap, const char *tag, int id, _ns1__createResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__createResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__createResponse(struct soap *soap, _ns1__createResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__createResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__createResponse(struct soap *soap, const char *tag, _ns1__createResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__createResponse **)soap_malloc(soap, sizeof(_ns1__createResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__createResponse *)soap_instantiate__ns1__createResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__createResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createResponse, sizeof(_ns1__createResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create(struct soap *soap, _ns1__create *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create(struct soap *soap, _ns1__create *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create);
	if (soap_out_PointerTo_ns1__create(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create(struct soap *soap, const char *tag, int id, _ns1__create *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create ** SOAP_FMAC4 soap_get_PointerTo_ns1__create(struct soap *soap, _ns1__create **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create ** SOAP_FMAC4 soap_in_PointerTo_ns1__create(struct soap *soap, const char *tag, _ns1__create **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create **)soap_malloc(soap, sizeof(_ns1__create *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create *)soap_instantiate__ns1__create(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create, sizeof(_ns1__create), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove1Response(struct soap *soap, _ns1__remove1Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove1Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove1Response(struct soap *soap, _ns1__remove1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove1Response);
	if (soap_out_PointerTo_ns1__remove1Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove1Response(struct soap *soap, const char *tag, int id, _ns1__remove1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove1Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove1Response(struct soap *soap, _ns1__remove1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove1Response(struct soap *soap, const char *tag, _ns1__remove1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove1Response **)soap_malloc(soap, sizeof(_ns1__remove1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove1Response *)soap_instantiate__ns1__remove1Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove1Response, sizeof(_ns1__remove1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove1(struct soap *soap, _ns1__remove1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove1(struct soap *soap, _ns1__remove1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove1);
	if (soap_out_PointerTo_ns1__remove1(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove1(struct soap *soap, const char *tag, int id, _ns1__remove1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove1(struct soap *soap, _ns1__remove1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove1(struct soap *soap, const char *tag, _ns1__remove1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove1 **)soap_malloc(soap, sizeof(_ns1__remove1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove1 *)soap_instantiate__ns1__remove1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove1, sizeof(_ns1__remove1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK7Response(struct soap *soap, _ns1__findByPK7Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK7Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK7Response(struct soap *soap, _ns1__findByPK7Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK7Response);
	if (soap_out_PointerTo_ns1__findByPK7Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK7Response(struct soap *soap, const char *tag, int id, _ns1__findByPK7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK7Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK7Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK7Response(struct soap *soap, _ns1__findByPK7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK7Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK7Response(struct soap *soap, const char *tag, _ns1__findByPK7Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK7Response **)soap_malloc(soap, sizeof(_ns1__findByPK7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK7Response *)soap_instantiate__ns1__findByPK7Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK7Response, sizeof(_ns1__findByPK7Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK7(struct soap *soap, _ns1__findByPK7 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK7))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK7(struct soap *soap, _ns1__findByPK7 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK7);
	if (soap_out_PointerTo_ns1__findByPK7(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK7(struct soap *soap, const char *tag, int id, _ns1__findByPK7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK7);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK7 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK7(struct soap *soap, _ns1__findByPK7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK7 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK7(struct soap *soap, const char *tag, _ns1__findByPK7 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK7 **)soap_malloc(soap, sizeof(_ns1__findByPK7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK7 *)soap_instantiate__ns1__findByPK7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK7, sizeof(_ns1__findByPK7), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__echoStringResponse(struct soap *soap, _ns1__echoStringResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__echoStringResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__echoStringResponse(struct soap *soap, _ns1__echoStringResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__echoStringResponse);
	if (soap_out_PointerTo_ns1__echoStringResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__echoStringResponse(struct soap *soap, const char *tag, int id, _ns1__echoStringResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__echoStringResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__echoStringResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__echoStringResponse(struct soap *soap, _ns1__echoStringResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__echoStringResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__echoStringResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__echoStringResponse(struct soap *soap, const char *tag, _ns1__echoStringResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__echoStringResponse **)soap_malloc(soap, sizeof(_ns1__echoStringResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__echoStringResponse *)soap_instantiate__ns1__echoStringResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__echoStringResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__echoStringResponse, sizeof(_ns1__echoStringResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__echoString(struct soap *soap, _ns1__echoString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__echoString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__echoString(struct soap *soap, _ns1__echoString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__echoString);
	if (soap_out_PointerTo_ns1__echoString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__echoString(struct soap *soap, const char *tag, int id, _ns1__echoString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__echoString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__echoString ** SOAP_FMAC4 soap_get_PointerTo_ns1__echoString(struct soap *soap, _ns1__echoString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__echoString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__echoString ** SOAP_FMAC4 soap_in_PointerTo_ns1__echoString(struct soap *soap, const char *tag, _ns1__echoString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__echoString **)soap_malloc(soap, sizeof(_ns1__echoString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__echoString *)soap_instantiate__ns1__echoString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__echoString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__echoString, sizeof(_ns1__echoString), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create2Response(struct soap *soap, _ns1__create2Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create2Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create2Response(struct soap *soap, _ns1__create2Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create2Response);
	if (soap_out_PointerTo_ns1__create2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create2Response(struct soap *soap, const char *tag, int id, _ns1__create2Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create2Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create2Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create2Response(struct soap *soap, _ns1__create2Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create2Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create2Response(struct soap *soap, const char *tag, _ns1__create2Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create2Response **)soap_malloc(soap, sizeof(_ns1__create2Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create2Response *)soap_instantiate__ns1__create2Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create2Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create2Response, sizeof(_ns1__create2Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create2(struct soap *soap, _ns1__create2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create2(struct soap *soap, _ns1__create2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create2);
	if (soap_out_PointerTo_ns1__create2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create2(struct soap *soap, const char *tag, int id, _ns1__create2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create2(struct soap *soap, _ns1__create2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create2(struct soap *soap, const char *tag, _ns1__create2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create2 **)soap_malloc(soap, sizeof(_ns1__create2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create2 *)soap_instantiate__ns1__create2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create2, sizeof(_ns1__create2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK6Response(struct soap *soap, _ns1__findByPK6Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK6Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK6Response(struct soap *soap, _ns1__findByPK6Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK6Response);
	if (soap_out_PointerTo_ns1__findByPK6Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK6Response(struct soap *soap, const char *tag, int id, _ns1__findByPK6Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK6Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK6Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK6Response(struct soap *soap, _ns1__findByPK6Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK6Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK6Response(struct soap *soap, const char *tag, _ns1__findByPK6Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK6Response **)soap_malloc(soap, sizeof(_ns1__findByPK6Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK6Response *)soap_instantiate__ns1__findByPK6Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK6Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK6Response, sizeof(_ns1__findByPK6Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK6(struct soap *soap, _ns1__findByPK6 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK6))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK6(struct soap *soap, _ns1__findByPK6 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK6);
	if (soap_out_PointerTo_ns1__findByPK6(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK6(struct soap *soap, const char *tag, int id, _ns1__findByPK6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK6);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK6 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK6(struct soap *soap, _ns1__findByPK6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK6 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK6(struct soap *soap, const char *tag, _ns1__findByPK6 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK6 **)soap_malloc(soap, sizeof(_ns1__findByPK6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK6 *)soap_instantiate__ns1__findByPK6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK6, sizeof(_ns1__findByPK6), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateResponse(struct soap *soap, _ns1__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateResponse(struct soap *soap, _ns1__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateResponse);
	if (soap_out_PointerTo_ns1__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateResponse(struct soap *soap, const char *tag, int id, _ns1__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__updateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateResponse(struct soap *soap, _ns1__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__updateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateResponse(struct soap *soap, const char *tag, _ns1__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__updateResponse **)soap_malloc(soap, sizeof(_ns1__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__updateResponse *)soap_instantiate__ns1__updateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateResponse, sizeof(_ns1__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update(struct soap *soap, _ns1__update *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update(struct soap *soap, _ns1__update *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update);
	if (soap_out_PointerTo_ns1__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update(struct soap *soap, const char *tag, int id, _ns1__update *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update ** SOAP_FMAC4 soap_get_PointerTo_ns1__update(struct soap *soap, _ns1__update **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update ** SOAP_FMAC4 soap_in_PointerTo_ns1__update(struct soap *soap, const char *tag, _ns1__update **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update **)soap_malloc(soap, sizeof(_ns1__update *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update *)soap_instantiate__ns1__update(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update, sizeof(_ns1__update), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove10Response(struct soap *soap, _ns1__remove10Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove10Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove10Response(struct soap *soap, _ns1__remove10Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove10Response);
	if (soap_out_PointerTo_ns1__remove10Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove10Response(struct soap *soap, const char *tag, int id, _ns1__remove10Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove10Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove10Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove10Response(struct soap *soap, _ns1__remove10Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove10Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove10Response(struct soap *soap, const char *tag, _ns1__remove10Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove10Response **)soap_malloc(soap, sizeof(_ns1__remove10Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove10Response *)soap_instantiate__ns1__remove10Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove10Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove10Response, sizeof(_ns1__remove10Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove10(struct soap *soap, _ns1__remove10 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove10))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove10(struct soap *soap, _ns1__remove10 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove10);
	if (soap_out_PointerTo_ns1__remove10(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove10(struct soap *soap, const char *tag, int id, _ns1__remove10 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove10);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove10 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove10(struct soap *soap, _ns1__remove10 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove10 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove10(struct soap *soap, const char *tag, _ns1__remove10 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove10 **)soap_malloc(soap, sizeof(_ns1__remove10 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove10 *)soap_instantiate__ns1__remove10(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove10 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove10, sizeof(_ns1__remove10), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create3Response(struct soap *soap, _ns1__create3Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create3Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create3Response(struct soap *soap, _ns1__create3Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create3Response);
	if (soap_out_PointerTo_ns1__create3Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create3Response(struct soap *soap, const char *tag, int id, _ns1__create3Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create3Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create3Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create3Response(struct soap *soap, _ns1__create3Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create3Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create3Response(struct soap *soap, const char *tag, _ns1__create3Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create3Response **)soap_malloc(soap, sizeof(_ns1__create3Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create3Response *)soap_instantiate__ns1__create3Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create3Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create3Response, sizeof(_ns1__create3Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create3(struct soap *soap, _ns1__create3 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create3))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create3(struct soap *soap, _ns1__create3 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create3);
	if (soap_out_PointerTo_ns1__create3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create3(struct soap *soap, const char *tag, int id, _ns1__create3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create3);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create3 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create3(struct soap *soap, _ns1__create3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create3 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create3(struct soap *soap, const char *tag, _ns1__create3 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create3 **)soap_malloc(soap, sizeof(_ns1__create3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create3 *)soap_instantiate__ns1__create3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create3, sizeof(_ns1__create3), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPKResponse(struct soap *soap, _ns1__findByPKResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPKResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPKResponse(struct soap *soap, _ns1__findByPKResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPKResponse);
	if (soap_out_PointerTo_ns1__findByPKResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPKResponse(struct soap *soap, const char *tag, int id, _ns1__findByPKResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPKResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPKResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPKResponse(struct soap *soap, _ns1__findByPKResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPKResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPKResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPKResponse(struct soap *soap, const char *tag, _ns1__findByPKResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPKResponse **)soap_malloc(soap, sizeof(_ns1__findByPKResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPKResponse *)soap_instantiate__ns1__findByPKResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPKResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPKResponse, sizeof(_ns1__findByPKResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK(struct soap *soap, _ns1__findByPK *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK(struct soap *soap, _ns1__findByPK *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK);
	if (soap_out_PointerTo_ns1__findByPK(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK(struct soap *soap, const char *tag, int id, _ns1__findByPK *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK(struct soap *soap, _ns1__findByPK **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK(struct soap *soap, const char *tag, _ns1__findByPK **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK **)soap_malloc(soap, sizeof(_ns1__findByPK *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK *)soap_instantiate__ns1__findByPK(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK, sizeof(_ns1__findByPK), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update6Response(struct soap *soap, _ns1__update6Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update6Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update6Response(struct soap *soap, _ns1__update6Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update6Response);
	if (soap_out_PointerTo_ns1__update6Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update6Response(struct soap *soap, const char *tag, int id, _ns1__update6Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update6Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update6Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update6Response(struct soap *soap, _ns1__update6Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update6Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update6Response(struct soap *soap, const char *tag, _ns1__update6Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update6Response **)soap_malloc(soap, sizeof(_ns1__update6Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update6Response *)soap_instantiate__ns1__update6Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update6Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update6Response, sizeof(_ns1__update6Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update6(struct soap *soap, _ns1__update6 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update6))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update6(struct soap *soap, _ns1__update6 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update6);
	if (soap_out_PointerTo_ns1__update6(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update6(struct soap *soap, const char *tag, int id, _ns1__update6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update6);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update6 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update6(struct soap *soap, _ns1__update6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update6 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update6(struct soap *soap, const char *tag, _ns1__update6 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update6 **)soap_malloc(soap, sizeof(_ns1__update6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update6 *)soap_instantiate__ns1__update6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update6, sizeof(_ns1__update6), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update9Response(struct soap *soap, _ns1__update9Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update9Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update9Response(struct soap *soap, _ns1__update9Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update9Response);
	if (soap_out_PointerTo_ns1__update9Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update9Response(struct soap *soap, const char *tag, int id, _ns1__update9Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update9Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update9Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update9Response(struct soap *soap, _ns1__update9Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update9Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update9Response(struct soap *soap, const char *tag, _ns1__update9Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update9Response **)soap_malloc(soap, sizeof(_ns1__update9Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update9Response *)soap_instantiate__ns1__update9Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update9Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update9Response, sizeof(_ns1__update9Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update9(struct soap *soap, _ns1__update9 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update9))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update9(struct soap *soap, _ns1__update9 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update9);
	if (soap_out_PointerTo_ns1__update9(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update9(struct soap *soap, const char *tag, int id, _ns1__update9 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update9);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update9 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update9(struct soap *soap, _ns1__update9 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update9 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update9(struct soap *soap, const char *tag, _ns1__update9 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update9 **)soap_malloc(soap, sizeof(_ns1__update9 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update9 *)soap_instantiate__ns1__update9(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update9 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update9, sizeof(_ns1__update9), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update11Response(struct soap *soap, _ns1__update11Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update11Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update11Response(struct soap *soap, _ns1__update11Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update11Response);
	if (soap_out_PointerTo_ns1__update11Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update11Response(struct soap *soap, const char *tag, int id, _ns1__update11Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update11Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update11Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update11Response(struct soap *soap, _ns1__update11Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update11Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update11Response(struct soap *soap, const char *tag, _ns1__update11Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update11Response **)soap_malloc(soap, sizeof(_ns1__update11Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update11Response *)soap_instantiate__ns1__update11Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update11Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update11Response, sizeof(_ns1__update11Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update11(struct soap *soap, _ns1__update11 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update11))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update11(struct soap *soap, _ns1__update11 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update11);
	if (soap_out_PointerTo_ns1__update11(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update11(struct soap *soap, const char *tag, int id, _ns1__update11 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update11);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update11 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update11(struct soap *soap, _ns1__update11 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update11 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update11(struct soap *soap, const char *tag, _ns1__update11 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update11 **)soap_malloc(soap, sizeof(_ns1__update11 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update11 *)soap_instantiate__ns1__update11(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update11 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update11, sizeof(_ns1__update11), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove7Response(struct soap *soap, _ns1__remove7Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove7Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove7Response(struct soap *soap, _ns1__remove7Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove7Response);
	if (soap_out_PointerTo_ns1__remove7Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove7Response(struct soap *soap, const char *tag, int id, _ns1__remove7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove7Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove7Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove7Response(struct soap *soap, _ns1__remove7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove7Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove7Response(struct soap *soap, const char *tag, _ns1__remove7Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove7Response **)soap_malloc(soap, sizeof(_ns1__remove7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove7Response *)soap_instantiate__ns1__remove7Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove7Response, sizeof(_ns1__remove7Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove7(struct soap *soap, _ns1__remove7 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove7))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove7(struct soap *soap, _ns1__remove7 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove7);
	if (soap_out_PointerTo_ns1__remove7(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove7(struct soap *soap, const char *tag, int id, _ns1__remove7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove7);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove7 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove7(struct soap *soap, _ns1__remove7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove7 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove7(struct soap *soap, const char *tag, _ns1__remove7 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove7 **)soap_malloc(soap, sizeof(_ns1__remove7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove7 *)soap_instantiate__ns1__remove7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove7, sizeof(_ns1__remove7), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnDictionaryVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnDictionaryVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnDictionaryVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnDictionaryVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnDictionaryVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnDictionaryVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnDictionaryVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnDictionaryVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVOResponse, sizeof(_ns1__findBySQLQueryReturnDictionaryVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnDictionaryVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnDictionaryVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, _ns1__findBySQLQueryReturnDictionaryVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnDictionaryVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnDictionaryVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnDictionaryVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnDictionaryVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnDictionaryVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnDictionaryVO *)soap_instantiate__ns1__findBySQLQueryReturnDictionaryVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnDictionaryVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnDictionaryVO, sizeof(_ns1__findBySQLQueryReturnDictionaryVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnERelationVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnERelationVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnERelationVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnERelationVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnERelationVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnERelationVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnERelationVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnERelationVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnERelationVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnERelationVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnERelationVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVOResponse, sizeof(_ns1__findBySQLQueryReturnERelationVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnERelationVO(struct soap *soap, _ns1__findBySQLQueryReturnERelationVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnERelationVO(struct soap *soap, _ns1__findBySQLQueryReturnERelationVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnERelationVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnERelationVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnERelationVO(struct soap *soap, _ns1__findBySQLQueryReturnERelationVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnERelationVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnERelationVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnERelationVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnERelationVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnERelationVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnERelationVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnERelationVO *)soap_instantiate__ns1__findBySQLQueryReturnERelationVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnERelationVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnERelationVO, sizeof(_ns1__findBySQLQueryReturnERelationVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK4Response(struct soap *soap, _ns1__findByPK4Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK4Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK4Response(struct soap *soap, _ns1__findByPK4Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK4Response);
	if (soap_out_PointerTo_ns1__findByPK4Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK4Response(struct soap *soap, const char *tag, int id, _ns1__findByPK4Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK4Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK4Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK4Response(struct soap *soap, _ns1__findByPK4Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK4Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK4Response(struct soap *soap, const char *tag, _ns1__findByPK4Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK4Response **)soap_malloc(soap, sizeof(_ns1__findByPK4Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK4Response *)soap_instantiate__ns1__findByPK4Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK4Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK4Response, sizeof(_ns1__findByPK4Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK4(struct soap *soap, _ns1__findByPK4 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK4))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK4(struct soap *soap, _ns1__findByPK4 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK4);
	if (soap_out_PointerTo_ns1__findByPK4(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK4(struct soap *soap, const char *tag, int id, _ns1__findByPK4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK4);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK4 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK4(struct soap *soap, _ns1__findByPK4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK4 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK4(struct soap *soap, const char *tag, _ns1__findByPK4 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK4 **)soap_malloc(soap, sizeof(_ns1__findByPK4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK4 *)soap_instantiate__ns1__findByPK4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK4, sizeof(_ns1__findByPK4), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK9Response(struct soap *soap, _ns1__findByPK9Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK9Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK9Response(struct soap *soap, _ns1__findByPK9Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK9Response);
	if (soap_out_PointerTo_ns1__findByPK9Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK9Response(struct soap *soap, const char *tag, int id, _ns1__findByPK9Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK9Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK9Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK9Response(struct soap *soap, _ns1__findByPK9Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK9Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK9Response(struct soap *soap, const char *tag, _ns1__findByPK9Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK9Response **)soap_malloc(soap, sizeof(_ns1__findByPK9Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK9Response *)soap_instantiate__ns1__findByPK9Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK9Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK9Response, sizeof(_ns1__findByPK9Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK9(struct soap *soap, _ns1__findByPK9 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK9))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK9(struct soap *soap, _ns1__findByPK9 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK9);
	if (soap_out_PointerTo_ns1__findByPK9(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK9(struct soap *soap, const char *tag, int id, _ns1__findByPK9 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK9);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK9 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK9(struct soap *soap, _ns1__findByPK9 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK9 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK9(struct soap *soap, const char *tag, _ns1__findByPK9 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK9 **)soap_malloc(soap, sizeof(_ns1__findByPK9 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK9 *)soap_instantiate__ns1__findByPK9(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK9 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK9, sizeof(_ns1__findByPK9), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update10Response(struct soap *soap, _ns1__update10Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update10Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update10Response(struct soap *soap, _ns1__update10Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update10Response);
	if (soap_out_PointerTo_ns1__update10Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update10Response(struct soap *soap, const char *tag, int id, _ns1__update10Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update10Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update10Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update10Response(struct soap *soap, _ns1__update10Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update10Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update10Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update10Response(struct soap *soap, const char *tag, _ns1__update10Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update10Response **)soap_malloc(soap, sizeof(_ns1__update10Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update10Response *)soap_instantiate__ns1__update10Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update10Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update10Response, sizeof(_ns1__update10Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update10(struct soap *soap, _ns1__update10 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update10))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update10(struct soap *soap, _ns1__update10 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update10);
	if (soap_out_PointerTo_ns1__update10(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update10(struct soap *soap, const char *tag, int id, _ns1__update10 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update10);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update10 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update10(struct soap *soap, _ns1__update10 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update10(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update10 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update10(struct soap *soap, const char *tag, _ns1__update10 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update10 **)soap_malloc(soap, sizeof(_ns1__update10 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update10 *)soap_instantiate__ns1__update10(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update10 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update10, sizeof(_ns1__update10), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update8Response(struct soap *soap, _ns1__update8Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update8Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update8Response(struct soap *soap, _ns1__update8Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update8Response);
	if (soap_out_PointerTo_ns1__update8Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update8Response(struct soap *soap, const char *tag, int id, _ns1__update8Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update8Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update8Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update8Response(struct soap *soap, _ns1__update8Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update8Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update8Response(struct soap *soap, const char *tag, _ns1__update8Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update8Response **)soap_malloc(soap, sizeof(_ns1__update8Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update8Response *)soap_instantiate__ns1__update8Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update8Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update8Response, sizeof(_ns1__update8Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update8(struct soap *soap, _ns1__update8 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update8))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update8(struct soap *soap, _ns1__update8 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update8);
	if (soap_out_PointerTo_ns1__update8(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update8(struct soap *soap, const char *tag, int id, _ns1__update8 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update8);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update8 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update8(struct soap *soap, _ns1__update8 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update8 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update8(struct soap *soap, const char *tag, _ns1__update8 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update8 **)soap_malloc(soap, sizeof(_ns1__update8 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update8 *)soap_instantiate__ns1__update8(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update8 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update8, sizeof(_ns1__update8), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create1Response(struct soap *soap, _ns1__create1Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create1Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create1Response(struct soap *soap, _ns1__create1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create1Response);
	if (soap_out_PointerTo_ns1__create1Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create1Response(struct soap *soap, const char *tag, int id, _ns1__create1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create1Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create1Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create1Response(struct soap *soap, _ns1__create1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create1Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create1Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create1Response(struct soap *soap, const char *tag, _ns1__create1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create1Response **)soap_malloc(soap, sizeof(_ns1__create1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create1Response *)soap_instantiate__ns1__create1Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create1Response, sizeof(_ns1__create1Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create1(struct soap *soap, _ns1__create1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create1(struct soap *soap, _ns1__create1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create1);
	if (soap_out_PointerTo_ns1__create1(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create1(struct soap *soap, const char *tag, int id, _ns1__create1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create1(struct soap *soap, _ns1__create1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create1(struct soap *soap, const char *tag, _ns1__create1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create1 **)soap_malloc(soap, sizeof(_ns1__create1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create1 *)soap_instantiate__ns1__create1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create1, sizeof(_ns1__create1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove8Response(struct soap *soap, _ns1__remove8Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove8Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove8Response(struct soap *soap, _ns1__remove8Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove8Response);
	if (soap_out_PointerTo_ns1__remove8Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove8Response(struct soap *soap, const char *tag, int id, _ns1__remove8Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove8Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove8Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove8Response(struct soap *soap, _ns1__remove8Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove8Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove8Response(struct soap *soap, const char *tag, _ns1__remove8Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove8Response **)soap_malloc(soap, sizeof(_ns1__remove8Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove8Response *)soap_instantiate__ns1__remove8Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove8Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove8Response, sizeof(_ns1__remove8Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove8(struct soap *soap, _ns1__remove8 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove8))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove8(struct soap *soap, _ns1__remove8 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove8);
	if (soap_out_PointerTo_ns1__remove8(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove8(struct soap *soap, const char *tag, int id, _ns1__remove8 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove8);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove8 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove8(struct soap *soap, _ns1__remove8 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove8 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove8(struct soap *soap, const char *tag, _ns1__remove8 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove8 **)soap_malloc(soap, sizeof(_ns1__remove8 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove8 *)soap_instantiate__ns1__remove8(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove8 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove8, sizeof(_ns1__remove8), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update7Response(struct soap *soap, _ns1__update7Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update7Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update7Response(struct soap *soap, _ns1__update7Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update7Response);
	if (soap_out_PointerTo_ns1__update7Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update7Response(struct soap *soap, const char *tag, int id, _ns1__update7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update7Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update7Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update7Response(struct soap *soap, _ns1__update7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update7Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update7Response(struct soap *soap, const char *tag, _ns1__update7Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update7Response **)soap_malloc(soap, sizeof(_ns1__update7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update7Response *)soap_instantiate__ns1__update7Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update7Response, sizeof(_ns1__update7Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update7(struct soap *soap, _ns1__update7 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update7))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update7(struct soap *soap, _ns1__update7 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update7);
	if (soap_out_PointerTo_ns1__update7(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update7(struct soap *soap, const char *tag, int id, _ns1__update7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update7);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update7 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update7(struct soap *soap, _ns1__update7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update7 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update7(struct soap *soap, const char *tag, _ns1__update7 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update7 **)soap_malloc(soap, sizeof(_ns1__update7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update7 *)soap_instantiate__ns1__update7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update7, sizeof(_ns1__update7), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove5Response(struct soap *soap, _ns1__remove5Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove5Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove5Response(struct soap *soap, _ns1__remove5Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove5Response);
	if (soap_out_PointerTo_ns1__remove5Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove5Response(struct soap *soap, const char *tag, int id, _ns1__remove5Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove5Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove5Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove5Response(struct soap *soap, _ns1__remove5Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove5Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove5Response(struct soap *soap, const char *tag, _ns1__remove5Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove5Response **)soap_malloc(soap, sizeof(_ns1__remove5Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove5Response *)soap_instantiate__ns1__remove5Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove5Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove5Response, sizeof(_ns1__remove5Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove5(struct soap *soap, _ns1__remove5 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove5))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove5(struct soap *soap, _ns1__remove5 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove5);
	if (soap_out_PointerTo_ns1__remove5(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove5(struct soap *soap, const char *tag, int id, _ns1__remove5 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove5);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove5 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove5(struct soap *soap, _ns1__remove5 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove5 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove5(struct soap *soap, const char *tag, _ns1__remove5 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove5 **)soap_malloc(soap, sizeof(_ns1__remove5 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove5 *)soap_instantiate__ns1__remove5(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove5 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove5, sizeof(_ns1__remove5), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove4Response(struct soap *soap, _ns1__remove4Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove4Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove4Response(struct soap *soap, _ns1__remove4Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove4Response);
	if (soap_out_PointerTo_ns1__remove4Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove4Response(struct soap *soap, const char *tag, int id, _ns1__remove4Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove4Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove4Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove4Response(struct soap *soap, _ns1__remove4Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove4Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove4Response(struct soap *soap, const char *tag, _ns1__remove4Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove4Response **)soap_malloc(soap, sizeof(_ns1__remove4Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove4Response *)soap_instantiate__ns1__remove4Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove4Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove4Response, sizeof(_ns1__remove4Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove4(struct soap *soap, _ns1__remove4 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove4))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove4(struct soap *soap, _ns1__remove4 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove4);
	if (soap_out_PointerTo_ns1__remove4(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove4(struct soap *soap, const char *tag, int id, _ns1__remove4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove4);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove4 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove4(struct soap *soap, _ns1__remove4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove4 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove4(struct soap *soap, const char *tag, _ns1__remove4 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove4 **)soap_malloc(soap, sizeof(_ns1__remove4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove4 *)soap_instantiate__ns1__remove4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove4, sizeof(_ns1__remove4), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create7Response(struct soap *soap, _ns1__create7Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create7Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create7Response(struct soap *soap, _ns1__create7Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create7Response);
	if (soap_out_PointerTo_ns1__create7Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create7Response(struct soap *soap, const char *tag, int id, _ns1__create7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create7Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create7Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create7Response(struct soap *soap, _ns1__create7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create7Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create7Response(struct soap *soap, const char *tag, _ns1__create7Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create7Response **)soap_malloc(soap, sizeof(_ns1__create7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create7Response *)soap_instantiate__ns1__create7Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create7Response, sizeof(_ns1__create7Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create7(struct soap *soap, _ns1__create7 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create7))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create7(struct soap *soap, _ns1__create7 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create7);
	if (soap_out_PointerTo_ns1__create7(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create7(struct soap *soap, const char *tag, int id, _ns1__create7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create7);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create7 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create7(struct soap *soap, _ns1__create7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create7 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create7(struct soap *soap, const char *tag, _ns1__create7 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create7 **)soap_malloc(soap, sizeof(_ns1__create7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create7 *)soap_instantiate__ns1__create7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create7, sizeof(_ns1__create7), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK2Response(struct soap *soap, _ns1__findByPK2Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK2Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK2Response(struct soap *soap, _ns1__findByPK2Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK2Response);
	if (soap_out_PointerTo_ns1__findByPK2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK2Response(struct soap *soap, const char *tag, int id, _ns1__findByPK2Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK2Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK2Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK2Response(struct soap *soap, _ns1__findByPK2Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK2Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK2Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK2Response(struct soap *soap, const char *tag, _ns1__findByPK2Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK2Response **)soap_malloc(soap, sizeof(_ns1__findByPK2Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK2Response *)soap_instantiate__ns1__findByPK2Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK2Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK2Response, sizeof(_ns1__findByPK2Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK2(struct soap *soap, _ns1__findByPK2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK2(struct soap *soap, _ns1__findByPK2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK2);
	if (soap_out_PointerTo_ns1__findByPK2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK2(struct soap *soap, const char *tag, int id, _ns1__findByPK2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK2(struct soap *soap, _ns1__findByPK2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK2(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK2(struct soap *soap, const char *tag, _ns1__findByPK2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK2 **)soap_malloc(soap, sizeof(_ns1__findByPK2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK2 *)soap_instantiate__ns1__findByPK2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK2, sizeof(_ns1__findByPK2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__generateSQLQueryResponse(struct soap *soap, _ns1__generateSQLQueryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__generateSQLQueryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__generateSQLQueryResponse(struct soap *soap, _ns1__generateSQLQueryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__generateSQLQueryResponse);
	if (soap_out_PointerTo_ns1__generateSQLQueryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__generateSQLQueryResponse(struct soap *soap, const char *tag, int id, _ns1__generateSQLQueryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__generateSQLQueryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__generateSQLQueryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__generateSQLQueryResponse(struct soap *soap, _ns1__generateSQLQueryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__generateSQLQueryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__generateSQLQueryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__generateSQLQueryResponse(struct soap *soap, const char *tag, _ns1__generateSQLQueryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__generateSQLQueryResponse **)soap_malloc(soap, sizeof(_ns1__generateSQLQueryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__generateSQLQueryResponse *)soap_instantiate__ns1__generateSQLQueryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__generateSQLQueryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__generateSQLQueryResponse, sizeof(_ns1__generateSQLQueryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__generateSQLQuery(struct soap *soap, _ns1__generateSQLQuery *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__generateSQLQuery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__generateSQLQuery(struct soap *soap, _ns1__generateSQLQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__generateSQLQuery);
	if (soap_out_PointerTo_ns1__generateSQLQuery(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__generateSQLQuery(struct soap *soap, const char *tag, int id, _ns1__generateSQLQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__generateSQLQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__generateSQLQuery ** SOAP_FMAC4 soap_get_PointerTo_ns1__generateSQLQuery(struct soap *soap, _ns1__generateSQLQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__generateSQLQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__generateSQLQuery ** SOAP_FMAC4 soap_in_PointerTo_ns1__generateSQLQuery(struct soap *soap, const char *tag, _ns1__generateSQLQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__generateSQLQuery **)soap_malloc(soap, sizeof(_ns1__generateSQLQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__generateSQLQuery *)soap_instantiate__ns1__generateSQLQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__generateSQLQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__generateSQLQuery, sizeof(_ns1__generateSQLQuery), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnPPTVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnPPTVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnPPTVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnPPTVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnPPTVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnPPTVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVOResponse, sizeof(_ns1__findBySQLQueryReturnPPTVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnPPTVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnPPTVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnPPTVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnPPTVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnPPTVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnPPTVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnPPTVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnPPTVO *)soap_instantiate__ns1__findBySQLQueryReturnPPTVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTVO, sizeof(_ns1__findBySQLQueryReturnPPTVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnContainerVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnContainerVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnContainerVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnContainerVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnContainerVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnContainerVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnContainerVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnContainerVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnContainerVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnContainerVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnContainerVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVOResponse, sizeof(_ns1__findBySQLQueryReturnContainerVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnContainerVO(struct soap *soap, _ns1__findBySQLQueryReturnContainerVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnContainerVO(struct soap *soap, _ns1__findBySQLQueryReturnContainerVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnContainerVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnContainerVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnContainerVO(struct soap *soap, _ns1__findBySQLQueryReturnContainerVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnContainerVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnContainerVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnContainerVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnContainerVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnContainerVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnContainerVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnContainerVO *)soap_instantiate__ns1__findBySQLQueryReturnContainerVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnContainerVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnContainerVO, sizeof(_ns1__findBySQLQueryReturnContainerVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create6Response(struct soap *soap, _ns1__create6Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create6Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create6Response(struct soap *soap, _ns1__create6Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create6Response);
	if (soap_out_PointerTo_ns1__create6Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create6Response(struct soap *soap, const char *tag, int id, _ns1__create6Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create6Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create6Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create6Response(struct soap *soap, _ns1__create6Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create6Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create6Response(struct soap *soap, const char *tag, _ns1__create6Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create6Response **)soap_malloc(soap, sizeof(_ns1__create6Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create6Response *)soap_instantiate__ns1__create6Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create6Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create6Response, sizeof(_ns1__create6Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create6(struct soap *soap, _ns1__create6 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create6))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create6(struct soap *soap, _ns1__create6 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create6);
	if (soap_out_PointerTo_ns1__create6(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create6(struct soap *soap, const char *tag, int id, _ns1__create6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create6);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create6 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create6(struct soap *soap, _ns1__create6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create6 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create6(struct soap *soap, const char *tag, _ns1__create6 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create6 **)soap_malloc(soap, sizeof(_ns1__create6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create6 *)soap_instantiate__ns1__create6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create6, sizeof(_ns1__create6), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK5Response(struct soap *soap, _ns1__findByPK5Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK5Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK5Response(struct soap *soap, _ns1__findByPK5Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK5Response);
	if (soap_out_PointerTo_ns1__findByPK5Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK5Response(struct soap *soap, const char *tag, int id, _ns1__findByPK5Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK5Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK5Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK5Response(struct soap *soap, _ns1__findByPK5Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK5Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK5Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK5Response(struct soap *soap, const char *tag, _ns1__findByPK5Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK5Response **)soap_malloc(soap, sizeof(_ns1__findByPK5Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK5Response *)soap_instantiate__ns1__findByPK5Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK5Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK5Response, sizeof(_ns1__findByPK5Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK5(struct soap *soap, _ns1__findByPK5 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK5))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK5(struct soap *soap, _ns1__findByPK5 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK5);
	if (soap_out_PointerTo_ns1__findByPK5(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK5(struct soap *soap, const char *tag, int id, _ns1__findByPK5 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK5);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK5 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK5(struct soap *soap, _ns1__findByPK5 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK5(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK5 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK5(struct soap *soap, const char *tag, _ns1__findByPK5 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK5 **)soap_malloc(soap, sizeof(_ns1__findByPK5 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK5 *)soap_instantiate__ns1__findByPK5(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK5 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK5, sizeof(_ns1__findByPK5), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnPPTSlideVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnPPTSlideVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTSlideVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnPPTSlideVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnPPTSlideVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnPPTSlideVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTSlideVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVOResponse, sizeof(_ns1__findBySQLQueryReturnPPTSlideVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnPPTSlideVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, _ns1__findBySQLQueryReturnPPTSlideVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnPPTSlideVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnPPTSlideVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnPPTSlideVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnPPTSlideVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnPPTSlideVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnPPTSlideVO *)soap_instantiate__ns1__findBySQLQueryReturnPPTSlideVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnPPTSlideVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnPPTSlideVO, sizeof(_ns1__findBySQLQueryReturnPPTSlideVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update4Response(struct soap *soap, _ns1__update4Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update4Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update4Response(struct soap *soap, _ns1__update4Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update4Response);
	if (soap_out_PointerTo_ns1__update4Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update4Response(struct soap *soap, const char *tag, int id, _ns1__update4Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update4Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update4Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update4Response(struct soap *soap, _ns1__update4Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update4Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update4Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update4Response(struct soap *soap, const char *tag, _ns1__update4Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update4Response **)soap_malloc(soap, sizeof(_ns1__update4Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update4Response *)soap_instantiate__ns1__update4Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update4Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update4Response, sizeof(_ns1__update4Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update4(struct soap *soap, _ns1__update4 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update4))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update4(struct soap *soap, _ns1__update4 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update4);
	if (soap_out_PointerTo_ns1__update4(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update4(struct soap *soap, const char *tag, int id, _ns1__update4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update4);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update4 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update4(struct soap *soap, _ns1__update4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update4(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update4 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update4(struct soap *soap, const char *tag, _ns1__update4 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update4 **)soap_malloc(soap, sizeof(_ns1__update4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update4 *)soap_instantiate__ns1__update4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update4, sizeof(_ns1__update4), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create8Response(struct soap *soap, _ns1__create8Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create8Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create8Response(struct soap *soap, _ns1__create8Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create8Response);
	if (soap_out_PointerTo_ns1__create8Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create8Response(struct soap *soap, const char *tag, int id, _ns1__create8Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create8Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create8Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create8Response(struct soap *soap, _ns1__create8Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create8Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create8Response(struct soap *soap, const char *tag, _ns1__create8Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create8Response **)soap_malloc(soap, sizeof(_ns1__create8Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create8Response *)soap_instantiate__ns1__create8Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create8Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create8Response, sizeof(_ns1__create8Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create8(struct soap *soap, _ns1__create8 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create8))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create8(struct soap *soap, _ns1__create8 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create8);
	if (soap_out_PointerTo_ns1__create8(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create8(struct soap *soap, const char *tag, int id, _ns1__create8 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create8);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create8 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create8(struct soap *soap, _ns1__create8 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create8 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create8(struct soap *soap, const char *tag, _ns1__create8 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create8 **)soap_malloc(soap, sizeof(_ns1__create8 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create8 *)soap_instantiate__ns1__create8(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create8 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create8, sizeof(_ns1__create8), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK8Response(struct soap *soap, _ns1__findByPK8Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK8Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK8Response(struct soap *soap, _ns1__findByPK8Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK8Response);
	if (soap_out_PointerTo_ns1__findByPK8Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK8Response(struct soap *soap, const char *tag, int id, _ns1__findByPK8Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK8Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK8Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK8Response(struct soap *soap, _ns1__findByPK8Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK8Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK8Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK8Response(struct soap *soap, const char *tag, _ns1__findByPK8Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK8Response **)soap_malloc(soap, sizeof(_ns1__findByPK8Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK8Response *)soap_instantiate__ns1__findByPK8Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK8Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK8Response, sizeof(_ns1__findByPK8Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findByPK8(struct soap *soap, _ns1__findByPK8 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findByPK8))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findByPK8(struct soap *soap, _ns1__findByPK8 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findByPK8);
	if (soap_out_PointerTo_ns1__findByPK8(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findByPK8(struct soap *soap, const char *tag, int id, _ns1__findByPK8 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findByPK8);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findByPK8 ** SOAP_FMAC4 soap_get_PointerTo_ns1__findByPK8(struct soap *soap, _ns1__findByPK8 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findByPK8(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findByPK8 ** SOAP_FMAC4 soap_in_PointerTo_ns1__findByPK8(struct soap *soap, const char *tag, _ns1__findByPK8 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findByPK8 **)soap_malloc(soap, sizeof(_ns1__findByPK8 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findByPK8 *)soap_instantiate__ns1__findByPK8(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findByPK8 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findByPK8, sizeof(_ns1__findByPK8), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnEActivityVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnEActivityVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEActivityVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnEActivityVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnEActivityVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnEActivityVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnEActivityVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEActivityVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVOResponse, sizeof(_ns1__findBySQLQueryReturnEActivityVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnEActivityVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnEActivityVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, _ns1__findBySQLQueryReturnEActivityVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnEActivityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnEActivityVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnEActivityVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnEActivityVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnEActivityVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnEActivityVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnEActivityVO *)soap_instantiate__ns1__findBySQLQueryReturnEActivityVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnEActivityVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnEActivityVO, sizeof(_ns1__findBySQLQueryReturnEActivityVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove9Response(struct soap *soap, _ns1__remove9Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove9Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove9Response(struct soap *soap, _ns1__remove9Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove9Response);
	if (soap_out_PointerTo_ns1__remove9Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove9Response(struct soap *soap, const char *tag, int id, _ns1__remove9Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove9Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove9Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove9Response(struct soap *soap, _ns1__remove9Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove9Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove9Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove9Response(struct soap *soap, const char *tag, _ns1__remove9Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove9Response **)soap_malloc(soap, sizeof(_ns1__remove9Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove9Response *)soap_instantiate__ns1__remove9Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove9Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove9Response, sizeof(_ns1__remove9Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove9(struct soap *soap, _ns1__remove9 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove9))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove9(struct soap *soap, _ns1__remove9 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove9);
	if (soap_out_PointerTo_ns1__remove9(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove9(struct soap *soap, const char *tag, int id, _ns1__remove9 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove9);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove9 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove9(struct soap *soap, _ns1__remove9 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove9(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove9 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove9(struct soap *soap, const char *tag, _ns1__remove9 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove9 **)soap_malloc(soap, sizeof(_ns1__remove9 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove9 *)soap_instantiate__ns1__remove9(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove9 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove9, sizeof(_ns1__remove9), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create11Response(struct soap *soap, _ns1__create11Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create11Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create11Response(struct soap *soap, _ns1__create11Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create11Response);
	if (soap_out_PointerTo_ns1__create11Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create11Response(struct soap *soap, const char *tag, int id, _ns1__create11Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create11Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create11Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__create11Response(struct soap *soap, _ns1__create11Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create11Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create11Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__create11Response(struct soap *soap, const char *tag, _ns1__create11Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create11Response **)soap_malloc(soap, sizeof(_ns1__create11Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create11Response *)soap_instantiate__ns1__create11Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create11Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create11Response, sizeof(_ns1__create11Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__create11(struct soap *soap, _ns1__create11 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__create11))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__create11(struct soap *soap, _ns1__create11 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__create11);
	if (soap_out_PointerTo_ns1__create11(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__create11(struct soap *soap, const char *tag, int id, _ns1__create11 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__create11);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__create11 ** SOAP_FMAC4 soap_get_PointerTo_ns1__create11(struct soap *soap, _ns1__create11 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__create11(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__create11 ** SOAP_FMAC4 soap_in_PointerTo_ns1__create11(struct soap *soap, const char *tag, _ns1__create11 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__create11 **)soap_malloc(soap, sizeof(_ns1__create11 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__create11 *)soap_instantiate__ns1__create11(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__create11 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__create11, sizeof(_ns1__create11), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update3Response(struct soap *soap, _ns1__update3Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update3Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update3Response(struct soap *soap, _ns1__update3Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update3Response);
	if (soap_out_PointerTo_ns1__update3Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update3Response(struct soap *soap, const char *tag, int id, _ns1__update3Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update3Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update3Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__update3Response(struct soap *soap, _ns1__update3Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update3Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__update3Response(struct soap *soap, const char *tag, _ns1__update3Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update3Response **)soap_malloc(soap, sizeof(_ns1__update3Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update3Response *)soap_instantiate__ns1__update3Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update3Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update3Response, sizeof(_ns1__update3Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__update3(struct soap *soap, _ns1__update3 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__update3))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__update3(struct soap *soap, _ns1__update3 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__update3);
	if (soap_out_PointerTo_ns1__update3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__update3(struct soap *soap, const char *tag, int id, _ns1__update3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__update3);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__update3 ** SOAP_FMAC4 soap_get_PointerTo_ns1__update3(struct soap *soap, _ns1__update3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__update3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__update3 ** SOAP_FMAC4 soap_in_PointerTo_ns1__update3(struct soap *soap, const char *tag, _ns1__update3 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__update3 **)soap_malloc(soap, sizeof(_ns1__update3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__update3 *)soap_instantiate__ns1__update3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__update3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__update3, sizeof(_ns1__update3), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove6Response(struct soap *soap, _ns1__remove6Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove6Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove6Response(struct soap *soap, _ns1__remove6Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove6Response);
	if (soap_out_PointerTo_ns1__remove6Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove6Response(struct soap *soap, const char *tag, int id, _ns1__remove6Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove6Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove6Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove6Response(struct soap *soap, _ns1__remove6Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove6Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove6Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove6Response(struct soap *soap, const char *tag, _ns1__remove6Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove6Response **)soap_malloc(soap, sizeof(_ns1__remove6Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove6Response *)soap_instantiate__ns1__remove6Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove6Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove6Response, sizeof(_ns1__remove6Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove6(struct soap *soap, _ns1__remove6 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove6))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove6(struct soap *soap, _ns1__remove6 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove6);
	if (soap_out_PointerTo_ns1__remove6(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove6(struct soap *soap, const char *tag, int id, _ns1__remove6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove6);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove6 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove6(struct soap *soap, _ns1__remove6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove6(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove6 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove6(struct soap *soap, const char *tag, _ns1__remove6 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove6 **)soap_malloc(soap, sizeof(_ns1__remove6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove6 *)soap_instantiate__ns1__remove6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove6, sizeof(_ns1__remove6), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove3Response(struct soap *soap, _ns1__remove3Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove3Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove3Response(struct soap *soap, _ns1__remove3Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove3Response);
	if (soap_out_PointerTo_ns1__remove3Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove3Response(struct soap *soap, const char *tag, int id, _ns1__remove3Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove3Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove3Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove3Response(struct soap *soap, _ns1__remove3Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove3Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove3Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove3Response(struct soap *soap, const char *tag, _ns1__remove3Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove3Response **)soap_malloc(soap, sizeof(_ns1__remove3Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove3Response *)soap_instantiate__ns1__remove3Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove3Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove3Response, sizeof(_ns1__remove3Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__remove3(struct soap *soap, _ns1__remove3 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__remove3))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__remove3(struct soap *soap, _ns1__remove3 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__remove3);
	if (soap_out_PointerTo_ns1__remove3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__remove3(struct soap *soap, const char *tag, int id, _ns1__remove3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__remove3);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__remove3 ** SOAP_FMAC4 soap_get_PointerTo_ns1__remove3(struct soap *soap, _ns1__remove3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__remove3(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__remove3 ** SOAP_FMAC4 soap_in_PointerTo_ns1__remove3(struct soap *soap, const char *tag, _ns1__remove3 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__remove3 **)soap_malloc(soap, sizeof(_ns1__remove3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__remove3 *)soap_instantiate__ns1__remove3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__remove3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__remove3, sizeof(_ns1__remove3), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnFeedbackVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnFeedbackVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnFeedbackVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnFeedbackVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnFeedbackVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnFeedbackVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnFeedbackVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnFeedbackVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVOResponse, sizeof(_ns1__findBySQLQueryReturnFeedbackVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnFeedbackVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnFeedbackVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, _ns1__findBySQLQueryReturnFeedbackVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnFeedbackVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnFeedbackVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnFeedbackVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnFeedbackVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnFeedbackVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnFeedbackVO *)soap_instantiate__ns1__findBySQLQueryReturnFeedbackVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnFeedbackVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnFeedbackVO, sizeof(_ns1__findBySQLQueryReturnFeedbackVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnESignatureVOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVOResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVOResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnESignatureVOResponse(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnESignatureVOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnESignatureVOResponse **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnESignatureVOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnESignatureVOResponse *)soap_instantiate__ns1__findBySQLQueryReturnESignatureVOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnESignatureVOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVOResponse, sizeof(_ns1__findBySQLQueryReturnESignatureVOResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__findBySQLQueryReturnESignatureVO);
	if (soap_out_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const char *tag, int id, _ns1__findBySQLQueryReturnESignatureVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVO ** SOAP_FMAC4 soap_get_PointerTo_ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, _ns1__findBySQLQueryReturnESignatureVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findBySQLQueryReturnESignatureVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__findBySQLQueryReturnESignatureVO ** SOAP_FMAC4 soap_in_PointerTo_ns1__findBySQLQueryReturnESignatureVO(struct soap *soap, const char *tag, _ns1__findBySQLQueryReturnESignatureVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findBySQLQueryReturnESignatureVO **)soap_malloc(soap, sizeof(_ns1__findBySQLQueryReturnESignatureVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findBySQLQueryReturnESignatureVO *)soap_instantiate__ns1__findBySQLQueryReturnESignatureVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__findBySQLQueryReturnESignatureVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findBySQLQueryReturnESignatureVO, sizeof(_ns1__findBySQLQueryReturnESignatureVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SKSWSException(struct soap *soap, ns5__SKSWSException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SKSWSException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SKSWSException(struct soap *soap, ns5__SKSWSException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__SKSWSException);
	if (soap_out_PointerTons5__SKSWSException(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SKSWSException(struct soap *soap, const char *tag, int id, ns5__SKSWSException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SKSWSException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__SKSWSException ** SOAP_FMAC4 soap_get_PointerTons5__SKSWSException(struct soap *soap, ns5__SKSWSException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SKSWSException(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__SKSWSException ** SOAP_FMAC4 soap_in_PointerTons5__SKSWSException(struct soap *soap, const char *tag, ns5__SKSWSException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SKSWSException **)soap_malloc(soap, sizeof(ns5__SKSWSException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SKSWSException *)soap_instantiate_ns5__SKSWSException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__SKSWSException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SKSWSException, sizeof(ns5__SKSWSException), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__decimal);
	if (soap_out_PointerToxsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfCommentVO(struct soap *soap, ns4__ArrayOfCommentVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfCommentVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfCommentVO(struct soap *soap, ns4__ArrayOfCommentVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfCommentVO);
	if (soap_out_PointerTons4__ArrayOfCommentVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfCommentVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfCommentVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfCommentVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfCommentVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfCommentVO(struct soap *soap, ns4__ArrayOfCommentVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfCommentVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfCommentVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfCommentVO(struct soap *soap, const char *tag, ns4__ArrayOfCommentVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfCommentVO **)soap_malloc(soap, sizeof(ns4__ArrayOfCommentVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfCommentVO *)soap_instantiate_ns4__ArrayOfCommentVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfCommentVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfCommentVO, sizeof(ns4__ArrayOfCommentVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfImageVO(struct soap *soap, ns4__ArrayOfImageVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfImageVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfImageVO(struct soap *soap, ns4__ArrayOfImageVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfImageVO);
	if (soap_out_PointerTons4__ArrayOfImageVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfImageVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfImageVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfImageVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfImageVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfImageVO(struct soap *soap, ns4__ArrayOfImageVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfImageVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfImageVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfImageVO(struct soap *soap, const char *tag, ns4__ArrayOfImageVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfImageVO **)soap_malloc(soap, sizeof(ns4__ArrayOfImageVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfImageVO *)soap_instantiate_ns4__ArrayOfImageVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfImageVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfImageVO, sizeof(ns4__ArrayOfImageVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfUserVO(struct soap *soap, ns4__ArrayOfUserVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfUserVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfUserVO(struct soap *soap, ns4__ArrayOfUserVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfUserVO);
	if (soap_out_PointerTons4__ArrayOfUserVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfUserVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfUserVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfUserVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfUserVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfUserVO(struct soap *soap, ns4__ArrayOfUserVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfUserVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfUserVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfUserVO(struct soap *soap, const char *tag, ns4__ArrayOfUserVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfUserVO **)soap_malloc(soap, sizeof(ns4__ArrayOfUserVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfUserVO *)soap_instantiate_ns4__ArrayOfUserVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfUserVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfUserVO, sizeof(ns4__ArrayOfUserVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfEntityVO(struct soap *soap, ns4__ArrayOfEntityVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfEntityVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfEntityVO(struct soap *soap, ns4__ArrayOfEntityVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfEntityVO);
	if (soap_out_PointerTons4__ArrayOfEntityVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfEntityVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfEntityVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfEntityVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfEntityVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfEntityVO(struct soap *soap, ns4__ArrayOfEntityVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfEntityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfEntityVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfEntityVO(struct soap *soap, const char *tag, ns4__ArrayOfEntityVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfEntityVO **)soap_malloc(soap, sizeof(ns4__ArrayOfEntityVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfEntityVO *)soap_instantiate_ns4__ArrayOfEntityVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfEntityVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfEntityVO, sizeof(ns4__ArrayOfEntityVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CommentVO(struct soap *soap, ns4__CommentVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CommentVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CommentVO(struct soap *soap, ns4__CommentVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CommentVO);
	if (soap_out_PointerTons4__CommentVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CommentVO(struct soap *soap, const char *tag, int id, ns4__CommentVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CommentVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__CommentVO ** SOAP_FMAC4 soap_get_PointerTons4__CommentVO(struct soap *soap, ns4__CommentVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CommentVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__CommentVO ** SOAP_FMAC4 soap_in_PointerTons4__CommentVO(struct soap *soap, const char *tag, ns4__CommentVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__CommentVO **)soap_malloc(soap, sizeof(ns4__CommentVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__CommentVO *)soap_instantiate_ns4__CommentVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__CommentVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CommentVO, sizeof(ns4__CommentVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfDictionaryVO(struct soap *soap, ns4__ArrayOfDictionaryVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfDictionaryVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfDictionaryVO(struct soap *soap, ns4__ArrayOfDictionaryVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfDictionaryVO);
	if (soap_out_PointerTons4__ArrayOfDictionaryVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfDictionaryVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfDictionaryVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfDictionaryVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfDictionaryVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfDictionaryVO(struct soap *soap, ns4__ArrayOfDictionaryVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfDictionaryVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfDictionaryVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfDictionaryVO(struct soap *soap, const char *tag, ns4__ArrayOfDictionaryVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfDictionaryVO **)soap_malloc(soap, sizeof(ns4__ArrayOfDictionaryVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfDictionaryVO *)soap_instantiate_ns4__ArrayOfDictionaryVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfDictionaryVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfDictionaryVO, sizeof(ns4__ArrayOfDictionaryVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfERelationVO(struct soap *soap, ns4__ArrayOfERelationVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfERelationVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfERelationVO(struct soap *soap, ns4__ArrayOfERelationVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfERelationVO);
	if (soap_out_PointerTons4__ArrayOfERelationVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfERelationVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfERelationVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfERelationVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfERelationVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfERelationVO(struct soap *soap, ns4__ArrayOfERelationVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfERelationVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfERelationVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfERelationVO(struct soap *soap, const char *tag, ns4__ArrayOfERelationVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfERelationVO **)soap_malloc(soap, sizeof(ns4__ArrayOfERelationVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfERelationVO *)soap_instantiate_ns4__ArrayOfERelationVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfERelationVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfERelationVO, sizeof(ns4__ArrayOfERelationVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__PPTVO(struct soap *soap, ns4__PPTVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__PPTVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__PPTVO(struct soap *soap, ns4__PPTVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__PPTVO);
	if (soap_out_PointerTons4__PPTVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__PPTVO(struct soap *soap, const char *tag, int id, ns4__PPTVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__PPTVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__PPTVO ** SOAP_FMAC4 soap_get_PointerTons4__PPTVO(struct soap *soap, ns4__PPTVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__PPTVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__PPTVO ** SOAP_FMAC4 soap_in_PointerTons4__PPTVO(struct soap *soap, const char *tag, ns4__PPTVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PPTVO **)soap_malloc(soap, sizeof(ns4__PPTVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__PPTVO *)soap_instantiate_ns4__PPTVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__PPTVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__PPTVO, sizeof(ns4__PPTVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ContainerVO(struct soap *soap, ns4__ContainerVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ContainerVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ContainerVO(struct soap *soap, ns4__ContainerVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ContainerVO);
	if (soap_out_PointerTons4__ContainerVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ContainerVO(struct soap *soap, const char *tag, int id, ns4__ContainerVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ContainerVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ContainerVO ** SOAP_FMAC4 soap_get_PointerTons4__ContainerVO(struct soap *soap, ns4__ContainerVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ContainerVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ContainerVO ** SOAP_FMAC4 soap_in_PointerTons4__ContainerVO(struct soap *soap, const char *tag, ns4__ContainerVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ContainerVO **)soap_malloc(soap, sizeof(ns4__ContainerVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ContainerVO *)soap_instantiate_ns4__ContainerVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ContainerVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ContainerVO, sizeof(ns4__ContainerVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__FeedbackVO(struct soap *soap, ns4__FeedbackVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__FeedbackVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__FeedbackVO(struct soap *soap, ns4__FeedbackVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__FeedbackVO);
	if (soap_out_PointerTons4__FeedbackVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__FeedbackVO(struct soap *soap, const char *tag, int id, ns4__FeedbackVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__FeedbackVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__FeedbackVO ** SOAP_FMAC4 soap_get_PointerTons4__FeedbackVO(struct soap *soap, ns4__FeedbackVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__FeedbackVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__FeedbackVO ** SOAP_FMAC4 soap_in_PointerTons4__FeedbackVO(struct soap *soap, const char *tag, ns4__FeedbackVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__FeedbackVO **)soap_malloc(soap, sizeof(ns4__FeedbackVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__FeedbackVO *)soap_instantiate_ns4__FeedbackVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__FeedbackVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FeedbackVO, sizeof(ns4__FeedbackVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DictionaryVO(struct soap *soap, ns4__DictionaryVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__DictionaryVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DictionaryVO(struct soap *soap, ns4__DictionaryVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__DictionaryVO);
	if (soap_out_PointerTons4__DictionaryVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DictionaryVO(struct soap *soap, const char *tag, int id, ns4__DictionaryVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__DictionaryVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__DictionaryVO ** SOAP_FMAC4 soap_get_PointerTons4__DictionaryVO(struct soap *soap, ns4__DictionaryVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DictionaryVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__DictionaryVO ** SOAP_FMAC4 soap_in_PointerTons4__DictionaryVO(struct soap *soap, const char *tag, ns4__DictionaryVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__DictionaryVO **)soap_malloc(soap, sizeof(ns4__DictionaryVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__DictionaryVO *)soap_instantiate_ns4__DictionaryVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__DictionaryVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DictionaryVO, sizeof(ns4__DictionaryVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfPPTVO(struct soap *soap, ns4__ArrayOfPPTVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfPPTVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfPPTVO(struct soap *soap, ns4__ArrayOfPPTVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfPPTVO);
	if (soap_out_PointerTons4__ArrayOfPPTVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfPPTVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfPPTVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfPPTVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfPPTVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfPPTVO(struct soap *soap, ns4__ArrayOfPPTVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfPPTVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfPPTVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfPPTVO(struct soap *soap, const char *tag, ns4__ArrayOfPPTVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfPPTVO **)soap_malloc(soap, sizeof(ns4__ArrayOfPPTVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfPPTVO *)soap_instantiate_ns4__ArrayOfPPTVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfPPTVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfPPTVO, sizeof(ns4__ArrayOfPPTVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfContainerVO(struct soap *soap, ns4__ArrayOfContainerVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfContainerVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfContainerVO(struct soap *soap, ns4__ArrayOfContainerVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfContainerVO);
	if (soap_out_PointerTons4__ArrayOfContainerVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfContainerVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfContainerVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfContainerVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfContainerVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfContainerVO(struct soap *soap, ns4__ArrayOfContainerVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfContainerVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfContainerVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfContainerVO(struct soap *soap, const char *tag, ns4__ArrayOfContainerVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfContainerVO **)soap_malloc(soap, sizeof(ns4__ArrayOfContainerVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfContainerVO *)soap_instantiate_ns4__ArrayOfContainerVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfContainerVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfContainerVO, sizeof(ns4__ArrayOfContainerVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ESignatureVO(struct soap *soap, ns4__ESignatureVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ESignatureVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ESignatureVO(struct soap *soap, ns4__ESignatureVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ESignatureVO);
	if (soap_out_PointerTons4__ESignatureVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ESignatureVO(struct soap *soap, const char *tag, int id, ns4__ESignatureVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ESignatureVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ESignatureVO ** SOAP_FMAC4 soap_get_PointerTons4__ESignatureVO(struct soap *soap, ns4__ESignatureVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ESignatureVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ESignatureVO ** SOAP_FMAC4 soap_in_PointerTons4__ESignatureVO(struct soap *soap, const char *tag, ns4__ESignatureVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ESignatureVO **)soap_malloc(soap, sizeof(ns4__ESignatureVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ESignatureVO *)soap_instantiate_ns4__ESignatureVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ESignatureVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ESignatureVO, sizeof(ns4__ESignatureVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfPPTSlideVO(struct soap *soap, ns4__ArrayOfPPTSlideVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfPPTSlideVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfPPTSlideVO(struct soap *soap, ns4__ArrayOfPPTSlideVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfPPTSlideVO);
	if (soap_out_PointerTons4__ArrayOfPPTSlideVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfPPTSlideVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfPPTSlideVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfPPTSlideVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfPPTSlideVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfPPTSlideVO(struct soap *soap, ns4__ArrayOfPPTSlideVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfPPTSlideVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfPPTSlideVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfPPTSlideVO(struct soap *soap, const char *tag, ns4__ArrayOfPPTSlideVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfPPTSlideVO **)soap_malloc(soap, sizeof(ns4__ArrayOfPPTSlideVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfPPTSlideVO *)soap_instantiate_ns4__ArrayOfPPTSlideVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfPPTSlideVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfPPTSlideVO, sizeof(ns4__ArrayOfPPTSlideVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ERelationVO(struct soap *soap, ns4__ERelationVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ERelationVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ERelationVO(struct soap *soap, ns4__ERelationVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ERelationVO);
	if (soap_out_PointerTons4__ERelationVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ERelationVO(struct soap *soap, const char *tag, int id, ns4__ERelationVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ERelationVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ERelationVO ** SOAP_FMAC4 soap_get_PointerTons4__ERelationVO(struct soap *soap, ns4__ERelationVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ERelationVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ERelationVO ** SOAP_FMAC4 soap_in_PointerTons4__ERelationVO(struct soap *soap, const char *tag, ns4__ERelationVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ERelationVO **)soap_malloc(soap, sizeof(ns4__ERelationVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ERelationVO *)soap_instantiate_ns4__ERelationVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ERelationVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ERelationVO, sizeof(ns4__ERelationVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ImageVO(struct soap *soap, ns4__ImageVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ImageVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ImageVO(struct soap *soap, ns4__ImageVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ImageVO);
	if (soap_out_PointerTons4__ImageVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ImageVO(struct soap *soap, const char *tag, int id, ns4__ImageVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ImageVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ImageVO ** SOAP_FMAC4 soap_get_PointerTons4__ImageVO(struct soap *soap, ns4__ImageVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ImageVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ImageVO ** SOAP_FMAC4 soap_in_PointerTons4__ImageVO(struct soap *soap, const char *tag, ns4__ImageVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ImageVO **)soap_malloc(soap, sizeof(ns4__ImageVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ImageVO *)soap_instantiate_ns4__ImageVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ImageVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ImageVO, sizeof(ns4__ImageVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfEActivityVO(struct soap *soap, ns4__ArrayOfEActivityVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfEActivityVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfEActivityVO(struct soap *soap, ns4__ArrayOfEActivityVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfEActivityVO);
	if (soap_out_PointerTons4__ArrayOfEActivityVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfEActivityVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfEActivityVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfEActivityVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfEActivityVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfEActivityVO(struct soap *soap, ns4__ArrayOfEActivityVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfEActivityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfEActivityVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfEActivityVO(struct soap *soap, const char *tag, ns4__ArrayOfEActivityVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfEActivityVO **)soap_malloc(soap, sizeof(ns4__ArrayOfEActivityVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfEActivityVO *)soap_instantiate_ns4__ArrayOfEActivityVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfEActivityVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfEActivityVO, sizeof(ns4__ArrayOfEActivityVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__PPTSlideVO(struct soap *soap, ns4__PPTSlideVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__PPTSlideVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__PPTSlideVO(struct soap *soap, ns4__PPTSlideVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__PPTSlideVO);
	if (soap_out_PointerTons4__PPTSlideVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__PPTSlideVO(struct soap *soap, const char *tag, int id, ns4__PPTSlideVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__PPTSlideVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__PPTSlideVO ** SOAP_FMAC4 soap_get_PointerTons4__PPTSlideVO(struct soap *soap, ns4__PPTSlideVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__PPTSlideVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__PPTSlideVO ** SOAP_FMAC4 soap_in_PointerTons4__PPTSlideVO(struct soap *soap, const char *tag, ns4__PPTSlideVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PPTSlideVO **)soap_malloc(soap, sizeof(ns4__PPTSlideVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__PPTSlideVO *)soap_instantiate_ns4__PPTSlideVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__PPTSlideVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__PPTSlideVO, sizeof(ns4__PPTSlideVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UserVO(struct soap *soap, ns4__UserVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__UserVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UserVO(struct soap *soap, ns4__UserVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UserVO);
	if (soap_out_PointerTons4__UserVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UserVO(struct soap *soap, const char *tag, int id, ns4__UserVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UserVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__UserVO ** SOAP_FMAC4 soap_get_PointerTons4__UserVO(struct soap *soap, ns4__UserVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UserVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__UserVO ** SOAP_FMAC4 soap_in_PointerTons4__UserVO(struct soap *soap, const char *tag, ns4__UserVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__UserVO **)soap_malloc(soap, sizeof(ns4__UserVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__UserVO *)soap_instantiate_ns4__UserVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__UserVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UserVO, sizeof(ns4__UserVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__EntityVO(struct soap *soap, ns4__EntityVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__EntityVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__EntityVO(struct soap *soap, ns4__EntityVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__EntityVO);
	if (soap_out_PointerTons4__EntityVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__EntityVO(struct soap *soap, const char *tag, int id, ns4__EntityVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__EntityVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__EntityVO ** SOAP_FMAC4 soap_get_PointerTons4__EntityVO(struct soap *soap, ns4__EntityVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__EntityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__EntityVO ** SOAP_FMAC4 soap_in_PointerTons4__EntityVO(struct soap *soap, const char *tag, ns4__EntityVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__EntityVO **)soap_malloc(soap, sizeof(ns4__EntityVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__EntityVO *)soap_instantiate_ns4__EntityVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__EntityVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__EntityVO, sizeof(ns4__EntityVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__EActivityVO(struct soap *soap, ns4__EActivityVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__EActivityVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__EActivityVO(struct soap *soap, ns4__EActivityVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__EActivityVO);
	if (soap_out_PointerTons4__EActivityVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__EActivityVO(struct soap *soap, const char *tag, int id, ns4__EActivityVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__EActivityVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__EActivityVO ** SOAP_FMAC4 soap_get_PointerTons4__EActivityVO(struct soap *soap, ns4__EActivityVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__EActivityVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__EActivityVO ** SOAP_FMAC4 soap_in_PointerTons4__EActivityVO(struct soap *soap, const char *tag, ns4__EActivityVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__EActivityVO **)soap_malloc(soap, sizeof(ns4__EActivityVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__EActivityVO *)soap_instantiate_ns4__EActivityVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__EActivityVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__EActivityVO, sizeof(ns4__EActivityVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfFeedbackVO(struct soap *soap, ns4__ArrayOfFeedbackVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfFeedbackVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfFeedbackVO(struct soap *soap, ns4__ArrayOfFeedbackVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfFeedbackVO);
	if (soap_out_PointerTons4__ArrayOfFeedbackVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfFeedbackVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfFeedbackVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfFeedbackVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfFeedbackVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfFeedbackVO(struct soap *soap, ns4__ArrayOfFeedbackVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfFeedbackVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfFeedbackVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfFeedbackVO(struct soap *soap, const char *tag, ns4__ArrayOfFeedbackVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfFeedbackVO **)soap_malloc(soap, sizeof(ns4__ArrayOfFeedbackVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfFeedbackVO *)soap_instantiate_ns4__ArrayOfFeedbackVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfFeedbackVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfFeedbackVO, sizeof(ns4__ArrayOfFeedbackVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfESignatureVO(struct soap *soap, ns4__ArrayOfESignatureVO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfESignatureVO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfESignatureVO(struct soap *soap, ns4__ArrayOfESignatureVO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfESignatureVO);
	if (soap_out_PointerTons4__ArrayOfESignatureVO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfESignatureVO(struct soap *soap, const char *tag, int id, ns4__ArrayOfESignatureVO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfESignatureVO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfESignatureVO ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfESignatureVO(struct soap *soap, ns4__ArrayOfESignatureVO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfESignatureVO(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__ArrayOfESignatureVO ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfESignatureVO(struct soap *soap, const char *tag, ns4__ArrayOfESignatureVO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfESignatureVO **)soap_malloc(soap, sizeof(ns4__ArrayOfESignatureVO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfESignatureVO *)soap_instantiate_ns4__ArrayOfESignatureVO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfESignatureVO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfESignatureVO, sizeof(ns4__ArrayOfESignatureVO), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SKSQuery(struct soap *soap, ns2__SKSQuery *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SKSQuery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SKSQuery(struct soap *soap, ns2__SKSQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SKSQuery);
	if (soap_out_PointerTons2__SKSQuery(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SKSQuery(struct soap *soap, const char *tag, int id, ns2__SKSQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SKSQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SKSQuery ** SOAP_FMAC4 soap_get_PointerTons2__SKSQuery(struct soap *soap, ns2__SKSQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SKSQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__SKSQuery ** SOAP_FMAC4 soap_in_PointerTons2__SKSQuery(struct soap *soap, const char *tag, ns2__SKSQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SKSQuery **)soap_malloc(soap, sizeof(ns2__SKSQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SKSQuery *)soap_instantiate_ns2__SKSQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__SKSQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SKSQuery, sizeof(ns2__SKSQuery), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__anyType2anyTypeMap_entry(struct soap *soap, struct _ns1__anyType2anyTypeMap_entry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__anyType2anyTypeMap_entry))
		soap_serialize__ns1__anyType2anyTypeMap_entry(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__anyType2anyTypeMap_entry(struct soap *soap, struct _ns1__anyType2anyTypeMap_entry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__anyType2anyTypeMap_entry);
	if (soap_out_PointerTo_ns1__anyType2anyTypeMap_entry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__anyType2anyTypeMap_entry(struct soap *soap, const char *tag, int id, struct _ns1__anyType2anyTypeMap_entry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__anyType2anyTypeMap_entry);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__anyType2anyTypeMap_entry(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__anyType2anyTypeMap_entry ** SOAP_FMAC4 soap_get_PointerTo_ns1__anyType2anyTypeMap_entry(struct soap *soap, struct _ns1__anyType2anyTypeMap_entry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__anyType2anyTypeMap_entry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _ns1__anyType2anyTypeMap_entry ** SOAP_FMAC4 soap_in_PointerTo_ns1__anyType2anyTypeMap_entry(struct soap *soap, const char *tag, struct _ns1__anyType2anyTypeMap_entry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__anyType2anyTypeMap_entry **)soap_malloc(soap, sizeof(struct _ns1__anyType2anyTypeMap_entry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__anyType2anyTypeMap_entry(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__anyType2anyTypeMap_entry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__anyType2anyTypeMap_entry, sizeof(struct _ns1__anyType2anyTypeMap_entry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__anyType2anyTypeMap(struct soap *soap, ns1__anyType2anyTypeMap *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__anyType2anyTypeMap))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__anyType2anyTypeMap(struct soap *soap, ns1__anyType2anyTypeMap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__anyType2anyTypeMap);
	if (soap_out_PointerTons1__anyType2anyTypeMap(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__anyType2anyTypeMap(struct soap *soap, const char *tag, int id, ns1__anyType2anyTypeMap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__anyType2anyTypeMap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__anyType2anyTypeMap ** SOAP_FMAC4 soap_get_PointerTons1__anyType2anyTypeMap(struct soap *soap, ns1__anyType2anyTypeMap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__anyType2anyTypeMap(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__anyType2anyTypeMap ** SOAP_FMAC4 soap_in_PointerTons1__anyType2anyTypeMap(struct soap *soap, const char *tag, ns1__anyType2anyTypeMap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__anyType2anyTypeMap **)soap_malloc(soap, sizeof(ns1__anyType2anyTypeMap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__anyType2anyTypeMap *)soap_instantiate_ns1__anyType2anyTypeMap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__anyType2anyTypeMap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__anyType2anyTypeMap, sizeof(ns1__anyType2anyTypeMap), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDateTime(struct soap *soap, ns1__ArrayOfDateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDateTime))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDateTime(struct soap *soap, ns1__ArrayOfDateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDateTime);
	if (soap_out_PointerTons1__ArrayOfDateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDateTime(struct soap *soap, const char *tag, int id, ns1__ArrayOfDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDateTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfDateTime ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDateTime(struct soap *soap, ns1__ArrayOfDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ArrayOfDateTime ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDateTime(struct soap *soap, const char *tag, ns1__ArrayOfDateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDateTime **)soap_malloc(soap, sizeof(ns1__ArrayOfDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDateTime *)soap_instantiate_ns1__ArrayOfDateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDateTime, sizeof(ns1__ArrayOfDateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfString);
	if (soap_out_PointerTons1__ArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfString **)soap_malloc(soap, sizeof(ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfString *)soap_instantiate_ns1__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__OperatorIntf(struct soap *soap, ns3__OperatorIntf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__OperatorIntf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__OperatorIntf(struct soap *soap, ns3__OperatorIntf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__OperatorIntf);
	if (soap_out_PointerTons3__OperatorIntf(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__OperatorIntf(struct soap *soap, const char *tag, int id, ns3__OperatorIntf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__OperatorIntf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__OperatorIntf ** SOAP_FMAC4 soap_get_PointerTons3__OperatorIntf(struct soap *soap, ns3__OperatorIntf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__OperatorIntf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__OperatorIntf ** SOAP_FMAC4 soap_in_PointerTons3__OperatorIntf(struct soap *soap, const char *tag, ns3__OperatorIntf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__OperatorIntf **)soap_malloc(soap, sizeof(ns3__OperatorIntf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__OperatorIntf *)soap_instantiate_ns3__OperatorIntf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__OperatorIntf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__OperatorIntf, sizeof(ns3__OperatorIntf), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfLong(struct soap *soap, ns1__ArrayOfLong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfLong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfLong(struct soap *soap, ns1__ArrayOfLong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfLong);
	if (soap_out_PointerTons1__ArrayOfLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfLong(struct soap *soap, const char *tag, int id, ns1__ArrayOfLong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfLong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfLong ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfLong(struct soap *soap, ns1__ArrayOfLong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ArrayOfLong ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfLong(struct soap *soap, const char *tag, ns1__ArrayOfLong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfLong **)soap_malloc(soap, sizeof(ns1__ArrayOfLong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfLong *)soap_instantiate_ns1__ArrayOfLong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfLong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfLong, sizeof(ns1__ArrayOfLong), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__QueryColumn(struct soap *soap, ns2__QueryColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__QueryColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__QueryColumn(struct soap *soap, ns2__QueryColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__QueryColumn);
	if (soap_out_PointerTons2__QueryColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__QueryColumn(struct soap *soap, const char *tag, int id, ns2__QueryColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__QueryColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__QueryColumn ** SOAP_FMAC4 soap_get_PointerTons2__QueryColumn(struct soap *soap, ns2__QueryColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__QueryColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__QueryColumn ** SOAP_FMAC4 soap_in_PointerTons2__QueryColumn(struct soap *soap, const char *tag, ns2__QueryColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__QueryColumn **)soap_malloc(soap, sizeof(ns2__QueryColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__QueryColumn *)soap_instantiate_ns2__QueryColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__QueryColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__QueryColumn, sizeof(ns2__QueryColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ColumnOperatorIntf(struct soap *soap, ns3__ColumnOperatorIntf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ColumnOperatorIntf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ColumnOperatorIntf(struct soap *soap, ns3__ColumnOperatorIntf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ColumnOperatorIntf);
	if (soap_out_PointerTons3__ColumnOperatorIntf(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ColumnOperatorIntf(struct soap *soap, const char *tag, int id, ns3__ColumnOperatorIntf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ColumnOperatorIntf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ColumnOperatorIntf ** SOAP_FMAC4 soap_get_PointerTons3__ColumnOperatorIntf(struct soap *soap, ns3__ColumnOperatorIntf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ColumnOperatorIntf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__ColumnOperatorIntf ** SOAP_FMAC4 soap_in_PointerTons3__ColumnOperatorIntf(struct soap *soap, const char *tag, ns3__ColumnOperatorIntf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ColumnOperatorIntf **)soap_malloc(soap, sizeof(ns3__ColumnOperatorIntf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ColumnOperatorIntf *)soap_instantiate_ns3__ColumnOperatorIntf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__ColumnOperatorIntf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ColumnOperatorIntf, sizeof(ns3__ColumnOperatorIntf), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ScalarIntf(struct soap *soap, ns3__ScalarIntf *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ScalarIntf))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ScalarIntf(struct soap *soap, ns3__ScalarIntf *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ScalarIntf);
	if (soap_out_PointerTons3__ScalarIntf(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ScalarIntf(struct soap *soap, const char *tag, int id, ns3__ScalarIntf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ScalarIntf);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ScalarIntf ** SOAP_FMAC4 soap_get_PointerTons3__ScalarIntf(struct soap *soap, ns3__ScalarIntf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ScalarIntf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__ScalarIntf ** SOAP_FMAC4 soap_in_PointerTons3__ScalarIntf(struct soap *soap, const char *tag, ns3__ScalarIntf **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ScalarIntf **)soap_malloc(soap, sizeof(ns3__ScalarIntf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ScalarIntf *)soap_instantiate_ns3__ScalarIntf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__ScalarIntf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ScalarIntf, sizeof(ns3__ScalarIntf), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReturnColumn(struct soap *soap, ns2__ReturnColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReturnColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReturnColumn(struct soap *soap, ns2__ReturnColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReturnColumn);
	if (soap_out_PointerTons2__ReturnColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReturnColumn(struct soap *soap, const char *tag, int id, ns2__ReturnColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReturnColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReturnColumn ** SOAP_FMAC4 soap_get_PointerTons2__ReturnColumn(struct soap *soap, ns2__ReturnColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReturnColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__ReturnColumn ** SOAP_FMAC4 soap_in_PointerTons2__ReturnColumn(struct soap *soap, const char *tag, ns2__ReturnColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReturnColumn **)soap_malloc(soap, sizeof(ns2__ReturnColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReturnColumn *)soap_instantiate_ns2__ReturnColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__ReturnColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReturnColumn, sizeof(ns2__ReturnColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Order(struct soap *soap, enum ns2__Order *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__Order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Order(struct soap *soap, enum ns2__Order *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Order);
	if (soap_out_PointerTons2__Order(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Order(struct soap *soap, const char *tag, int id, enum ns2__Order *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Order);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Order(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__Order ** SOAP_FMAC4 soap_get_PointerTons2__Order(struct soap *soap, enum ns2__Order **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Order(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ns2__Order ** SOAP_FMAC4 soap_in_PointerTons2__Order(struct soap *soap, const char *tag, enum ns2__Order **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__Order **)soap_malloc(soap, sizeof(enum ns2__Order *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Order(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__Order **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Order, sizeof(enum ns2__Order), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DBColumn(struct soap *soap, ns3__DBColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__DBColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DBColumn(struct soap *soap, ns3__DBColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__DBColumn);
	if (soap_out_PointerTons3__DBColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DBColumn(struct soap *soap, const char *tag, int id, ns3__DBColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__DBColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__DBColumn ** SOAP_FMAC4 soap_get_PointerTons3__DBColumn(struct soap *soap, ns3__DBColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DBColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__DBColumn ** SOAP_FMAC4 soap_in_PointerTons3__DBColumn(struct soap *soap, const char *tag, ns3__DBColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DBColumn **)soap_malloc(soap, sizeof(ns3__DBColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DBColumn *)soap_instantiate_ns3__DBColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__DBColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__DBColumn, sizeof(ns3__DBColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OrderColumn(struct soap *soap, ns2__OrderColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OrderColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OrderColumn(struct soap *soap, ns2__OrderColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OrderColumn);
	if (soap_out_PointerTons2__OrderColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OrderColumn(struct soap *soap, const char *tag, int id, ns2__OrderColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OrderColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OrderColumn ** SOAP_FMAC4 soap_get_PointerTons2__OrderColumn(struct soap *soap, ns2__OrderColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OrderColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__OrderColumn ** SOAP_FMAC4 soap_in_PointerTons2__OrderColumn(struct soap *soap, const char *tag, ns2__OrderColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OrderColumn **)soap_malloc(soap, sizeof(ns2__OrderColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OrderColumn *)soap_instantiate_ns2__OrderColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__OrderColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OrderColumn, sizeof(ns2__OrderColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ArrayOfReturnColumn(struct soap *soap, ns2__ArrayOfReturnColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ArrayOfReturnColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ArrayOfReturnColumn(struct soap *soap, ns2__ArrayOfReturnColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ArrayOfReturnColumn);
	if (soap_out_PointerTons2__ArrayOfReturnColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ArrayOfReturnColumn(struct soap *soap, const char *tag, int id, ns2__ArrayOfReturnColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ArrayOfReturnColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ArrayOfReturnColumn ** SOAP_FMAC4 soap_get_PointerTons2__ArrayOfReturnColumn(struct soap *soap, ns2__ArrayOfReturnColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ArrayOfReturnColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__ArrayOfReturnColumn ** SOAP_FMAC4 soap_in_PointerTons2__ArrayOfReturnColumn(struct soap *soap, const char *tag, ns2__ArrayOfReturnColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ArrayOfReturnColumn **)soap_malloc(soap, sizeof(ns2__ArrayOfReturnColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ArrayOfReturnColumn *)soap_instantiate_ns2__ArrayOfReturnColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfReturnColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ArrayOfReturnColumn, sizeof(ns2__ArrayOfReturnColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SKSObject(struct soap *soap, ns3__SKSObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__SKSObject))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SKSObject(struct soap *soap, ns3__SKSObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__SKSObject);
	if (soap_out_PointerTons3__SKSObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SKSObject(struct soap *soap, const char *tag, int id, ns3__SKSObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__SKSObject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__SKSObject ** SOAP_FMAC4 soap_get_PointerTons3__SKSObject(struct soap *soap, ns3__SKSObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__SKSObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__SKSObject ** SOAP_FMAC4 soap_in_PointerTons3__SKSObject(struct soap *soap, const char *tag, ns3__SKSObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__SKSObject **)soap_malloc(soap, sizeof(ns3__SKSObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__SKSObject *)soap_instantiate_ns3__SKSObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__SKSObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SKSObject, sizeof(ns3__SKSObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ArrayOfQueryColumn(struct soap *soap, ns2__ArrayOfQueryColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ArrayOfQueryColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ArrayOfQueryColumn(struct soap *soap, ns2__ArrayOfQueryColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ArrayOfQueryColumn);
	if (soap_out_PointerTons2__ArrayOfQueryColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ArrayOfQueryColumn(struct soap *soap, const char *tag, int id, ns2__ArrayOfQueryColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ArrayOfQueryColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ArrayOfQueryColumn ** SOAP_FMAC4 soap_get_PointerTons2__ArrayOfQueryColumn(struct soap *soap, ns2__ArrayOfQueryColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ArrayOfQueryColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__ArrayOfQueryColumn ** SOAP_FMAC4 soap_in_PointerTons2__ArrayOfQueryColumn(struct soap *soap, const char *tag, ns2__ArrayOfQueryColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ArrayOfQueryColumn **)soap_malloc(soap, sizeof(ns2__ArrayOfQueryColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ArrayOfQueryColumn *)soap_instantiate_ns2__ArrayOfQueryColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfQueryColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ArrayOfQueryColumn, sizeof(ns2__ArrayOfQueryColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ArrayOfOrderColumn(struct soap *soap, ns2__ArrayOfOrderColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ArrayOfOrderColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ArrayOfOrderColumn(struct soap *soap, ns2__ArrayOfOrderColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ArrayOfOrderColumn);
	if (soap_out_PointerTons2__ArrayOfOrderColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ArrayOfOrderColumn(struct soap *soap, const char *tag, int id, ns2__ArrayOfOrderColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ArrayOfOrderColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ArrayOfOrderColumn ** SOAP_FMAC4 soap_get_PointerTons2__ArrayOfOrderColumn(struct soap *soap, ns2__ArrayOfOrderColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ArrayOfOrderColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__ArrayOfOrderColumn ** SOAP_FMAC4 soap_in_PointerTons2__ArrayOfOrderColumn(struct soap *soap, const char *tag, ns2__ArrayOfOrderColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ArrayOfOrderColumn **)soap_malloc(soap, sizeof(ns2__ArrayOfOrderColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ArrayOfOrderColumn *)soap_instantiate_ns2__ArrayOfOrderColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfOrderColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ArrayOfOrderColumn, sizeof(ns2__ArrayOfOrderColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LimitOffset(struct soap *soap, ns2__LimitOffset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LimitOffset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LimitOffset(struct soap *soap, ns2__LimitOffset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LimitOffset);
	if (soap_out_PointerTons2__LimitOffset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LimitOffset(struct soap *soap, const char *tag, int id, ns2__LimitOffset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LimitOffset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LimitOffset ** SOAP_FMAC4 soap_get_PointerTons2__LimitOffset(struct soap *soap, ns2__LimitOffset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LimitOffset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__LimitOffset ** SOAP_FMAC4 soap_in_PointerTons2__LimitOffset(struct soap *soap, const char *tag, ns2__LimitOffset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LimitOffset **)soap_malloc(soap, sizeof(ns2__LimitOffset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LimitOffset *)soap_instantiate_ns2__LimitOffset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__LimitOffset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LimitOffset, sizeof(ns2__LimitOffset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfDBColumn(struct soap *soap, ns3__ArrayOfDBColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfDBColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfDBColumn(struct soap *soap, ns3__ArrayOfDBColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfDBColumn);
	if (soap_out_PointerTons3__ArrayOfDBColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfDBColumn(struct soap *soap, const char *tag, int id, ns3__ArrayOfDBColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfDBColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfDBColumn ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfDBColumn(struct soap *soap, ns3__ArrayOfDBColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfDBColumn(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__ArrayOfDBColumn ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfDBColumn(struct soap *soap, const char *tag, ns3__ArrayOfDBColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfDBColumn **)soap_malloc(soap, sizeof(ns3__ArrayOfDBColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfDBColumn *)soap_instantiate_ns3__ArrayOfDBColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfDBColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfDBColumn, sizeof(ns3__ArrayOfDBColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfSKSObject(struct soap *soap, ns3__ArrayOfSKSObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfSKSObject))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfSKSObject(struct soap *soap, ns3__ArrayOfSKSObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfSKSObject);
	if (soap_out_PointerTons3__ArrayOfSKSObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfSKSObject(struct soap *soap, const char *tag, int id, ns3__ArrayOfSKSObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfSKSObject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfSKSObject ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfSKSObject(struct soap *soap, ns3__ArrayOfSKSObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfSKSObject(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__ArrayOfSKSObject ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfSKSObject(struct soap *soap, const char *tag, ns3__ArrayOfSKSObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfSKSObject **)soap_malloc(soap, sizeof(ns3__ArrayOfSKSObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfSKSObject *)soap_instantiate_ns3__ArrayOfSKSObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfSKSObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfSKSObject, sizeof(ns3__ArrayOfSKSObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, const std::vector<ns4__CommentVO * >*a)
{
	for (std::vector<ns4__CommentVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__CommentVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, std::vector<ns4__CommentVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__CommentVO * >*a, const char *type)
{
	for (std::vector<ns4__CommentVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__CommentVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__CommentVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, const char *tag, std::vector<ns4__CommentVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__CommentVO(soap, -1)))
		return NULL;
	ns4__CommentVO *n;
	ns4__CommentVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__CommentVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__CommentVO, sizeof(ns4__CommentVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__CommentVO(soap, tag, NULL, "ns4:CommentVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__CommentVO(soap, tag, &n, "ns4:CommentVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__CommentVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__CommentVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, std::vector<ns4__CommentVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__CommentVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__CommentVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__CommentVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__CommentVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__CommentVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__CommentVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__CommentVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__CommentVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__CommentVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__CommentVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__CommentVO * >*)p = *(std::vector<ns4__CommentVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, const std::vector<ns4__ImageVO * >*a)
{
	for (std::vector<ns4__ImageVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__ImageVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, std::vector<ns4__ImageVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__ImageVO * >*a, const char *type)
{
	for (std::vector<ns4__ImageVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__ImageVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__ImageVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, const char *tag, std::vector<ns4__ImageVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__ImageVO(soap, -1)))
		return NULL;
	ns4__ImageVO *n;
	ns4__ImageVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__ImageVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ImageVO, sizeof(ns4__ImageVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__ImageVO(soap, tag, NULL, "ns4:ImageVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__ImageVO(soap, tag, &n, "ns4:ImageVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__ImageVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__ImageVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, std::vector<ns4__ImageVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__ImageVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__ImageVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ImageVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__ImageVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__ImageVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__ImageVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__ImageVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__ImageVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__ImageVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__ImageVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__ImageVO * >*)p = *(std::vector<ns4__ImageVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, const std::vector<ns4__UserVO * >*a)
{
	for (std::vector<ns4__UserVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__UserVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, std::vector<ns4__UserVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__UserVO * >*a, const char *type)
{
	for (std::vector<ns4__UserVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__UserVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__UserVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, const char *tag, std::vector<ns4__UserVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__UserVO(soap, -1)))
		return NULL;
	ns4__UserVO *n;
	ns4__UserVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__UserVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__UserVO, sizeof(ns4__UserVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__UserVO(soap, tag, NULL, "ns4:UserVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__UserVO(soap, tag, &n, "ns4:UserVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__UserVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__UserVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, std::vector<ns4__UserVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__UserVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__UserVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__UserVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__UserVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__UserVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__UserVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__UserVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__UserVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__UserVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__UserVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__UserVO * >*)p = *(std::vector<ns4__UserVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, const std::vector<ns4__EntityVO * >*a)
{
	for (std::vector<ns4__EntityVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__EntityVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, std::vector<ns4__EntityVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__EntityVO * >*a, const char *type)
{
	for (std::vector<ns4__EntityVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__EntityVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__EntityVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, const char *tag, std::vector<ns4__EntityVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__EntityVO(soap, -1)))
		return NULL;
	ns4__EntityVO *n;
	ns4__EntityVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__EntityVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__EntityVO, sizeof(ns4__EntityVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__EntityVO(soap, tag, NULL, "ns4:EntityVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__EntityVO(soap, tag, &n, "ns4:EntityVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__EntityVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__EntityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, std::vector<ns4__EntityVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__EntityVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__EntityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__EntityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__EntityVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__EntityVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__EntityVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__EntityVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__EntityVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__EntityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__EntityVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__EntityVO * >*)p = *(std::vector<ns4__EntityVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, const std::vector<ns4__DictionaryVO * >*a)
{
	for (std::vector<ns4__DictionaryVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__DictionaryVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, std::vector<ns4__DictionaryVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__DictionaryVO * >*a, const char *type)
{
	for (std::vector<ns4__DictionaryVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__DictionaryVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__DictionaryVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, const char *tag, std::vector<ns4__DictionaryVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__DictionaryVO(soap, -1)))
		return NULL;
	ns4__DictionaryVO *n;
	ns4__DictionaryVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__DictionaryVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__DictionaryVO, sizeof(ns4__DictionaryVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__DictionaryVO(soap, tag, NULL, "ns4:DictionaryVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__DictionaryVO(soap, tag, &n, "ns4:DictionaryVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__DictionaryVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__DictionaryVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, std::vector<ns4__DictionaryVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__DictionaryVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__DictionaryVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__DictionaryVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__DictionaryVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__DictionaryVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__DictionaryVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__DictionaryVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__DictionaryVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__DictionaryVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__DictionaryVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__DictionaryVO * >*)p = *(std::vector<ns4__DictionaryVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, const std::vector<ns4__ERelationVO * >*a)
{
	for (std::vector<ns4__ERelationVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__ERelationVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, std::vector<ns4__ERelationVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__ERelationVO * >*a, const char *type)
{
	for (std::vector<ns4__ERelationVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__ERelationVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__ERelationVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, const char *tag, std::vector<ns4__ERelationVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__ERelationVO(soap, -1)))
		return NULL;
	ns4__ERelationVO *n;
	ns4__ERelationVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__ERelationVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ERelationVO, sizeof(ns4__ERelationVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__ERelationVO(soap, tag, NULL, "ns4:ERelationVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__ERelationVO(soap, tag, &n, "ns4:ERelationVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__ERelationVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__ERelationVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, std::vector<ns4__ERelationVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__ERelationVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__ERelationVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ERelationVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__ERelationVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__ERelationVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__ERelationVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__ERelationVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__ERelationVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__ERelationVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__ERelationVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__ERelationVO * >*)p = *(std::vector<ns4__ERelationVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, const std::vector<ns4__PPTVO * >*a)
{
	for (std::vector<ns4__PPTVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__PPTVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, std::vector<ns4__PPTVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__PPTVO * >*a, const char *type)
{
	for (std::vector<ns4__PPTVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__PPTVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__PPTVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, const char *tag, std::vector<ns4__PPTVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__PPTVO(soap, -1)))
		return NULL;
	ns4__PPTVO *n;
	ns4__PPTVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__PPTVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTVO, sizeof(ns4__PPTVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__PPTVO(soap, tag, NULL, "ns4:PPTVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__PPTVO(soap, tag, &n, "ns4:PPTVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__PPTVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__PPTVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, std::vector<ns4__PPTVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__PPTVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__PPTVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__PPTVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__PPTVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__PPTVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__PPTVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__PPTVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__PPTVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__PPTVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__PPTVO * >*)p = *(std::vector<ns4__PPTVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, const std::vector<ns4__ContainerVO * >*a)
{
	for (std::vector<ns4__ContainerVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__ContainerVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, std::vector<ns4__ContainerVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__ContainerVO * >*a, const char *type)
{
	for (std::vector<ns4__ContainerVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__ContainerVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__ContainerVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, const char *tag, std::vector<ns4__ContainerVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__ContainerVO(soap, -1)))
		return NULL;
	ns4__ContainerVO *n;
	ns4__ContainerVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__ContainerVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ContainerVO, sizeof(ns4__ContainerVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__ContainerVO(soap, tag, NULL, "ns4:ContainerVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__ContainerVO(soap, tag, &n, "ns4:ContainerVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__ContainerVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__ContainerVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, std::vector<ns4__ContainerVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__ContainerVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__ContainerVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ContainerVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__ContainerVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__ContainerVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__ContainerVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__ContainerVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__ContainerVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__ContainerVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__ContainerVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__ContainerVO * >*)p = *(std::vector<ns4__ContainerVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, const std::vector<ns4__PPTSlideVO * >*a)
{
	for (std::vector<ns4__PPTSlideVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__PPTSlideVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, std::vector<ns4__PPTSlideVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__PPTSlideVO * >*a, const char *type)
{
	for (std::vector<ns4__PPTSlideVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__PPTSlideVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__PPTSlideVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, const char *tag, std::vector<ns4__PPTSlideVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__PPTSlideVO(soap, -1)))
		return NULL;
	ns4__PPTSlideVO *n;
	ns4__PPTSlideVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__PPTSlideVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTSlideVO, sizeof(ns4__PPTSlideVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__PPTSlideVO(soap, tag, NULL, "ns4:PPTSlideVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__PPTSlideVO(soap, tag, &n, "ns4:PPTSlideVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__PPTSlideVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__PPTSlideVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, std::vector<ns4__PPTSlideVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__PPTSlideVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__PPTSlideVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__PPTSlideVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__PPTSlideVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__PPTSlideVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__PPTSlideVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__PPTSlideVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__PPTSlideVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__PPTSlideVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__PPTSlideVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__PPTSlideVO * >*)p = *(std::vector<ns4__PPTSlideVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, const std::vector<ns4__EActivityVO * >*a)
{
	for (std::vector<ns4__EActivityVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__EActivityVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, std::vector<ns4__EActivityVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__EActivityVO * >*a, const char *type)
{
	for (std::vector<ns4__EActivityVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__EActivityVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__EActivityVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, const char *tag, std::vector<ns4__EActivityVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__EActivityVO(soap, -1)))
		return NULL;
	ns4__EActivityVO *n;
	ns4__EActivityVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__EActivityVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__EActivityVO, sizeof(ns4__EActivityVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__EActivityVO(soap, tag, NULL, "ns4:EActivityVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__EActivityVO(soap, tag, &n, "ns4:EActivityVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__EActivityVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__EActivityVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, std::vector<ns4__EActivityVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__EActivityVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__EActivityVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__EActivityVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__EActivityVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__EActivityVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__EActivityVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__EActivityVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__EActivityVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__EActivityVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__EActivityVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__EActivityVO * >*)p = *(std::vector<ns4__EActivityVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, const std::vector<ns4__FeedbackVO * >*a)
{
	for (std::vector<ns4__FeedbackVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__FeedbackVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, std::vector<ns4__FeedbackVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__FeedbackVO * >*a, const char *type)
{
	for (std::vector<ns4__FeedbackVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__FeedbackVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__FeedbackVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, const char *tag, std::vector<ns4__FeedbackVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__FeedbackVO(soap, -1)))
		return NULL;
	ns4__FeedbackVO *n;
	ns4__FeedbackVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__FeedbackVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__FeedbackVO, sizeof(ns4__FeedbackVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__FeedbackVO(soap, tag, NULL, "ns4:FeedbackVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__FeedbackVO(soap, tag, &n, "ns4:FeedbackVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__FeedbackVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__FeedbackVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, std::vector<ns4__FeedbackVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__FeedbackVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__FeedbackVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__FeedbackVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__FeedbackVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__FeedbackVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__FeedbackVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__FeedbackVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__FeedbackVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__FeedbackVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__FeedbackVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__FeedbackVO * >*)p = *(std::vector<ns4__FeedbackVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, const std::vector<ns4__ESignatureVO * >*a)
{
	for (std::vector<ns4__ESignatureVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__ESignatureVO(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, std::vector<ns4__ESignatureVO * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, const char *tag, int id, const std::vector<ns4__ESignatureVO * >*a, const char *type)
{
	for (std::vector<ns4__ESignatureVO * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__ESignatureVO(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__ESignatureVO * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, const char *tag, std::vector<ns4__ESignatureVO * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__ESignatureVO(soap, -1)))
		return NULL;
	ns4__ESignatureVO *n;
	ns4__ESignatureVO **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__ESignatureVO, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ESignatureVO, sizeof(ns4__ESignatureVO), 1))
				break;
			if (!(p = soap_in_PointerTons4__ESignatureVO(soap, tag, NULL, "ns4:ESignatureVO")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__ESignatureVO(soap, tag, &n, "ns4:ESignatureVO"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__ESignatureVO * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__ESignatureVO(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, std::vector<ns4__ESignatureVO * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__ESignatureVO * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__ESignatureVO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__ESignatureVO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__ESignatureVO * >;
		if (size)
			*size = sizeof(std::vector<ns4__ESignatureVO * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__ESignatureVO * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__ESignatureVO * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__ESignatureVO * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__ESignatureVO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__ESignatureVO * > %p -> %p\n", q, p));
	*(std::vector<ns4__ESignatureVO * >*)p = *(std::vector<ns4__ESignatureVO * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfLONG64(struct soap *soap, const std::vector<LONG64 >*a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64 >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, int id, const std::vector<LONG64 >*a, const char *type)
{
	for (std::vector<LONG64 >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_LONG64(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<LONG64 >* SOAP_FMAC4 soap_in_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, std::vector<LONG64 >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfLONG64(soap, -1)))
		return NULL;
	LONG64 n;
	LONG64 *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_LONG64, SOAP_TYPE_std__vectorTemplateOfLONG64, sizeof(LONG64), 0))
				break;
			if (!(p = soap_in_LONG64(soap, tag, NULL, "xsd:long")))
				break;
		}
		else
		{	soap_default_LONG64(soap, &n);
			if (!soap_in_LONG64(soap, tag, &n, "xsd:long"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<LONG64 > * SOAP_FMAC6 soap_new_std__vectorTemplateOfLONG64(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfLONG64(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64 >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<LONG64 > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfLONG64(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfLONG64(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfLONG64, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<LONG64 >;
		if (size)
			*size = sizeof(std::vector<LONG64 >);
	}
	else
	{	cp->ptr = (void*)new std::vector<LONG64 >[n];
		if (size)
			*size = n * sizeof(std::vector<LONG64 >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<LONG64 >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfLONG64(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<LONG64 > %p -> %p\n", q, p));
	*(std::vector<LONG64 >*)p = *(std::vector<LONG64 >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftime(struct soap *soap, const std::vector<time_t >*a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftime(struct soap *soap, std::vector<time_t >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftime(struct soap *soap, const char *tag, int id, const std::vector<time_t >*a, const char *type)
{
	for (std::vector<time_t >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_time(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<time_t >* SOAP_FMAC4 soap_in_std__vectorTemplateOftime(struct soap *soap, const char *tag, std::vector<time_t >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftime(soap, -1)))
		return NULL;
	time_t n;
	time_t *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_time, SOAP_TYPE_std__vectorTemplateOftime, sizeof(time_t), 0))
				break;
			if (!(p = soap_in_time(soap, tag, NULL, "xsd:dateTime")))
				break;
		}
		else
		{	soap_default_time(soap, &n);
			if (!soap_in_time(soap, tag, &n, "xsd:dateTime"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<time_t > * SOAP_FMAC6 soap_new_std__vectorTemplateOftime(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOftime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOftime(struct soap *soap, std::vector<time_t >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<time_t > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOftime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<time_t >;
		if (size)
			*size = sizeof(std::vector<time_t >);
	}
	else
	{	cp->ptr = (void*)new std::vector<time_t >[n];
		if (size)
			*size = n * sizeof(std::vector<time_t >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<time_t >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<time_t > %p -> %p\n", q, p));
	*(std::vector<time_t >*)p = *(std::vector<time_t >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_std__string(soap, tag, NULL, "xsd:string")))
				break;
		}
		else
		{	soap_default_std__string(soap, &n);
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, const std::vector<ns3__DBColumn * >*a)
{
	for (std::vector<ns3__DBColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__DBColumn(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, std::vector<ns3__DBColumn * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, const char *tag, int id, const std::vector<ns3__DBColumn * >*a, const char *type)
{
	for (std::vector<ns3__DBColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__DBColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__DBColumn * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, const char *tag, std::vector<ns3__DBColumn * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__DBColumn(soap, -1)))
		return NULL;
	ns3__DBColumn *n;
	ns3__DBColumn **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__DBColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DBColumn, sizeof(ns3__DBColumn), 1))
				break;
			if (!(p = soap_in_PointerTons3__DBColumn(soap, tag, NULL, "ns3:DBColumn")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons3__DBColumn(soap, tag, &n, "ns3:DBColumn"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns3__DBColumn * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons3__DBColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, std::vector<ns3__DBColumn * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns3__DBColumn * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__DBColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DBColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns3__DBColumn * >;
		if (size)
			*size = sizeof(std::vector<ns3__DBColumn * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns3__DBColumn * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns3__DBColumn * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__DBColumn * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__DBColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__DBColumn * > %p -> %p\n", q, p));
	*(std::vector<ns3__DBColumn * >*)p = *(std::vector<ns3__DBColumn * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, const std::vector<ns3__SKSObject * >*a)
{
	for (std::vector<ns3__SKSObject * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__SKSObject(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, std::vector<ns3__SKSObject * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, const char *tag, int id, const std::vector<ns3__SKSObject * >*a, const char *type)
{
	for (std::vector<ns3__SKSObject * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__SKSObject(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__SKSObject * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, const char *tag, std::vector<ns3__SKSObject * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__SKSObject(soap, -1)))
		return NULL;
	ns3__SKSObject *n;
	ns3__SKSObject **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__SKSObject, SOAP_TYPE_std__vectorTemplateOfPointerTons3__SKSObject, sizeof(ns3__SKSObject), 1))
				break;
			if (!(p = soap_in_PointerTons3__SKSObject(soap, tag, NULL, "ns3:SKSObject")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons3__SKSObject(soap, tag, &n, "ns3:SKSObject"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns3__SKSObject * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons3__SKSObject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, std::vector<ns3__SKSObject * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns3__SKSObject * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__SKSObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__SKSObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns3__SKSObject * >;
		if (size)
			*size = sizeof(std::vector<ns3__SKSObject * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns3__SKSObject * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns3__SKSObject * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__SKSObject * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__SKSObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__SKSObject * > %p -> %p\n", q, p));
	*(std::vector<ns3__SKSObject * >*)p = *(std::vector<ns3__SKSObject * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, const std::vector<ns2__QueryColumn * >*a)
{
	for (std::vector<ns2__QueryColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__QueryColumn(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, std::vector<ns2__QueryColumn * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, const char *tag, int id, const std::vector<ns2__QueryColumn * >*a, const char *type)
{
	for (std::vector<ns2__QueryColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__QueryColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__QueryColumn * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, const char *tag, std::vector<ns2__QueryColumn * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__QueryColumn(soap, -1)))
		return NULL;
	ns2__QueryColumn *n;
	ns2__QueryColumn **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__QueryColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons2__QueryColumn, sizeof(ns2__QueryColumn), 1))
				break;
			if (!(p = soap_in_PointerTons2__QueryColumn(soap, tag, NULL, "ns2:QueryColumn")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons2__QueryColumn(soap, tag, &n, "ns2:QueryColumn"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns2__QueryColumn * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons2__QueryColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, std::vector<ns2__QueryColumn * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns2__QueryColumn * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__QueryColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__QueryColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns2__QueryColumn * >;
		if (size)
			*size = sizeof(std::vector<ns2__QueryColumn * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns2__QueryColumn * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns2__QueryColumn * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__QueryColumn * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__QueryColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__QueryColumn * > %p -> %p\n", q, p));
	*(std::vector<ns2__QueryColumn * >*)p = *(std::vector<ns2__QueryColumn * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, const std::vector<ns2__ReturnColumn * >*a)
{
	for (std::vector<ns2__ReturnColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ReturnColumn(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, std::vector<ns2__ReturnColumn * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, const char *tag, int id, const std::vector<ns2__ReturnColumn * >*a, const char *type)
{
	for (std::vector<ns2__ReturnColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ReturnColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ReturnColumn * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, const char *tag, std::vector<ns2__ReturnColumn * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ReturnColumn(soap, -1)))
		return NULL;
	ns2__ReturnColumn *n;
	ns2__ReturnColumn **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ReturnColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ReturnColumn, sizeof(ns2__ReturnColumn), 1))
				break;
			if (!(p = soap_in_PointerTons2__ReturnColumn(soap, tag, NULL, "ns2:ReturnColumn")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons2__ReturnColumn(soap, tag, &n, "ns2:ReturnColumn"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns2__ReturnColumn * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons2__ReturnColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, std::vector<ns2__ReturnColumn * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns2__ReturnColumn * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ReturnColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ReturnColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns2__ReturnColumn * >;
		if (size)
			*size = sizeof(std::vector<ns2__ReturnColumn * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns2__ReturnColumn * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns2__ReturnColumn * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ReturnColumn * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ReturnColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ReturnColumn * > %p -> %p\n", q, p));
	*(std::vector<ns2__ReturnColumn * >*)p = *(std::vector<ns2__ReturnColumn * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, const std::vector<ns2__OrderColumn * >*a)
{
	for (std::vector<ns2__OrderColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__OrderColumn(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, std::vector<ns2__OrderColumn * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, const char *tag, int id, const std::vector<ns2__OrderColumn * >*a, const char *type)
{
	for (std::vector<ns2__OrderColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__OrderColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__OrderColumn * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, const char *tag, std::vector<ns2__OrderColumn * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__OrderColumn(soap, -1)))
		return NULL;
	ns2__OrderColumn *n;
	ns2__OrderColumn **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__OrderColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OrderColumn, sizeof(ns2__OrderColumn), 1))
				break;
			if (!(p = soap_in_PointerTons2__OrderColumn(soap, tag, NULL, "ns2:OrderColumn")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons2__OrderColumn(soap, tag, &n, "ns2:OrderColumn"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns2__OrderColumn * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons2__OrderColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, std::vector<ns2__OrderColumn * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns2__OrderColumn * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__OrderColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OrderColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns2__OrderColumn * >;
		if (size)
			*size = sizeof(std::vector<ns2__OrderColumn * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns2__OrderColumn * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns2__OrderColumn * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__OrderColumn * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__OrderColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__OrderColumn * > %p -> %p\n", q, p));
	*(std::vector<ns2__OrderColumn * >*)p = *(std::vector<ns2__OrderColumn * >*)q;
}

/* End of soapC.cpp */
